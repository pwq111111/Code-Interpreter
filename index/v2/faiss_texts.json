[
    "Field List > Methods > adjusted_mutual_information: Paramters: clustering: NodeClustering object\nReturn: [AMI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)]\nReferences: [Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854.]\nDescription: Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won’t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\nSection_id: NodeClustering",
    "Field List > Methods > adjusted_rand_index: Paramters: clustering: NodeClustering object\nReturn: [ARI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)]\nReferences: [Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218.]\nDescription: Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then “adjusted for chance” into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\nSection_id: NodeClustering",
    "Field List > Methods > average_internal_degree: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()]\nReferences: []\nDescription: The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\nSection_id: NodeClustering",
    "Field List > Methods > avg_distance: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\nSection_id: NodeClustering",
    "Field List > Methods > avg_embeddedness: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\nSection_id: NodeClustering",
    "Field List > Methods > avg_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()]\nReferences: []\nDescription: Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\nSection_id: NodeClustering",
    "Field List > Methods > avg_transitivity: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\nSection_id: NodeClustering",
    "Field List > Methods > conductance: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()]\nReferences: []\nDescription: Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\nSection_id: NodeClustering",
    "Field List > Methods > cut_ratio: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()]\nReferences: []\nDescription: Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n − n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\nSection_id: NodeClustering",
    "Field List > Methods > edges_inside: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()]\nReferences: []\nDescription: Number of edges internal to the algorithms.\nSection_id: NodeClustering",
    "Field List > Methods > erdos_renyi_modularity: Paramters: \nReturn: [the Erdos-Renyi modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()]\nReferences: []\nDescription: Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S − \\frac{mn_S(n_S −1)}{n(n−1)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\nSection_id: NodeClustering",
    "Field List > Methods > expansion: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()]\nReferences: []\nDescription: Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\nSection_id: NodeClustering",
    "Field List > Methods > f1: Paramters: clustering: NodeClustering object\nReturn: [F1 score (harmonic mean of precision and recall)]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)]\nReferences: [Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham.]\nDescription: Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\nSection_id: NodeClustering",
    "Field List > Methods > flake_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()]\nReferences: []\nDescription: Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\nSection_id: NodeClustering",
    "Field List > Methods > fraction_over_median_degree: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()]\nReferences: []\nDescription: Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\nSection_id: NodeClustering",
    "Field List > Methods > get_description: Paramters: parameters_to_display: parameters to display. By default, all float parameters.\nprecision: precision used to plot parameters. default: 3\nReturn: [a string description of the method.\n]\nExample: []\nReferences: []\nDescription: Return a description of the clustering, with the name of the method and its numeric parameters.\nSection_id: NodeClustering",
    "Field List > Methods > hub_dominance: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\nSection_id: NodeClustering",
    "Field List > Methods > internal_edge_density: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()]\nReferences: []\nDescription: The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S−1)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\nSection_id: NodeClustering",
    "Field List > Methods > link_modularity: Paramters: \nReturn: [the link modularity score]\nExample: [from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()]\nReferences: []\nDescription: Quality function designed for directed graphs with overlapping communities.\nSection_id: NodeClustering",
    "Field List > Methods > max_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()]\nReferences: []\nDescription: Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\nSection_id: NodeClustering",
    "Field List > Methods > modularity_density: Paramters: \nReturn: [the modularity density score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()]\nReferences: []\nDescription: The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} − d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\nSection_id: NodeClustering",
    "Field List > Methods > modularity_overlap: Paramters: weight: label identifying the edge weight parameter name (if present), default None\nReturn: [FitnessResult object]\nExample: []\nReferences: [\nLazar, D. Abel and T. Vicsek, “Modularity measure of networks with overlapping communities”  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n, Lazar, D. Abel and T. Vicsek, “Modularity measure of networks with overlapping communities”  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001]\nDescription: Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\nSection_id: NodeClustering",
    "Field List > Methods > newman_girvan_modularity: Paramters: \nReturn: [the Newman-Girvan modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()]\nReferences: []\nDescription: Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\nSection_id: NodeClustering",
    "Field List > Methods > nf1: Paramters: clustering: NodeClustering object\nReturn: [MatchingResult instance]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)]\nReferences: [Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth., Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912.]\nDescription: Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\nSection_id: NodeClustering",
    "Field List > Methods > normalized_cut: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()]\nReferences: []\nDescription: Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m−m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\nSection_id: NodeClustering",
    "Field List > Methods > normalized_mutual_information: Paramters: clustering: NodeClustering object\nReturn: [normalized mutual information score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)]\nReferences: []\nDescription: Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\nSection_id: NodeClustering",
    "Field List > Methods > omega: Paramters: clustering: NodeClustering object\nReturn: [omega index]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)]\nReferences: [Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18.]\nDescription: Index of resemblance for overlapping, complete coverage, network clusterings.\nSection_id: NodeClustering",
    "Field List > Methods > overlapping_normalized_mutual_information_LFK: Paramters: clustering: NodeClustering object\nReturn: [onmi score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)]\nReferences: [Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015.]\nDescription: Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\nSection_id: NodeClustering",
    "Field List > Methods > overlapping_normalized_mutual_information_MGH: Paramters: clustering: NodeClustering object\nnormalization: one of “max” or “LFK”. Default “max” (corresponds to the main method described in the article)\nReturn: [onmi score\n]\nExample: [from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)]\nReferences: [McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago]\nDescription: Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\nSection_id: NodeClustering",
    "Field List > Methods > scaled_density: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\nSection_id: NodeClustering",
    "Field List > Methods > significance: Paramters: \nReturn: [the significance score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()]\nReferences: []\nDescription: Significance estimates how likely a partition of dense communities appear in a random graph.\nSection_id: NodeClustering",
    "Field List > Methods > size: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: []\nReferences: []\nDescription: Size is the number of nodes in the community\nSection_id: NodeClustering",
    "Field List > Methods > surprise: Paramters: \nReturn: [the surprise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()]\nReferences: []\nDescription: Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\nSection_id: NodeClustering",
    "Field List > Methods > to_json: Paramters: \nReturn: [a JSON formatted string representing the object]\nExample: []\nReferences: []\nDescription: Generate a JSON representation of the algorithms object\nSection_id: NodeClustering",
    "Field List > Methods > to_node_community_map: Paramters: \nReturn: [dict of the form <node, list(communities)>]\nExample: []\nReferences: []\nDescription: Generate a <node, list(communities)> representation of the current clustering\nSection_id: NodeClustering",
    "Field List > Methods > triangle_participation_ratio: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()]\nReferences: []\nDescription: Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\nSection_id: NodeClustering",
    "Field List > Methods > variation_of_information: Paramters: clustering: NodeClustering object\nReturn: [VI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)]\nReferences: [Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013]\nDescription: Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\nSection_id: NodeClustering",
    "Field List > Methods > z_modularity: Paramters: \nReturn: [the z-modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()]\nReferences: []\nDescription: Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\nSection_id: NodeClustering",
    "Field List > Methods > adjusted_mutual_information: Paramters: clustering: NodeClustering object\nReturn: [AMI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)]\nReferences: [Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854.]\nDescription: Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won’t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > adjusted_rand_index: Paramters: clustering: NodeClustering object\nReturn: [ARI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)]\nReferences: [Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218.]\nDescription: Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then “adjusted for chance” into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > average_internal_degree: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()]\nReferences: []\nDescription: The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > avg_distance: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > avg_embeddedness: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > avg_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()]\nReferences: []\nDescription: Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > avg_transitivity: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > conductance: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()]\nReferences: []\nDescription: Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > cut_ratio: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()]\nReferences: []\nDescription: Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n − n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > edges_inside: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()]\nReferences: []\nDescription: Number of edges internal to the algorithms.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > erdos_renyi_modularity: Paramters: \nReturn: [the Erdos-Renyi modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()]\nReferences: []\nDescription: Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S − \\frac{mn_S(n_S −1)}{n(n−1)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > expansion: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()]\nReferences: []\nDescription: Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > f1: Paramters: clustering: NodeClustering object\nReturn: [F1 score (harmonic mean of precision and recall)]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)]\nReferences: [Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham.]\nDescription: Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > flake_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()]\nReferences: []\nDescription: Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > fraction_over_median_degree: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()]\nReferences: []\nDescription: Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > get_description: Paramters: parameters_to_display: parameters to display. By default, all float parameters.\nprecision: precision used to plot parameters. default: 3\nReturn: [a string description of the method.\n]\nExample: []\nReferences: []\nDescription: Return a description of the clustering, with the name of the method and its numeric parameters.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > hub_dominance: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > internal_edge_density: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()]\nReferences: []\nDescription: The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S−1)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > link_modularity: Paramters: \nReturn: [the link modularity score]\nExample: [from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()]\nReferences: []\nDescription: Quality function designed for directed graphs with overlapping communities.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > max_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()]\nReferences: []\nDescription: Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > modularity_density: Paramters: \nReturn: [the modularity density score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()]\nReferences: []\nDescription: The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} − d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > modularity_overlap: Paramters: weight: label identifying the edge weight parameter name (if present), default None\nReturn: [FitnessResult object]\nExample: []\nReferences: [\nLazar, D. Abel and T. Vicsek, “Modularity measure of networks with overlapping communities”  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n, Lazar, D. Abel and T. Vicsek, “Modularity measure of networks with overlapping communities”  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001]\nDescription: Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > newman_girvan_modularity: Paramters: \nReturn: [the Newman-Girvan modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()]\nReferences: []\nDescription: Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > nf1: Paramters: clustering: NodeClustering object\nReturn: [MatchingResult instance]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)]\nReferences: [Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth., Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912.]\nDescription: Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > normalized_cut: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()]\nReferences: []\nDescription: Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m−m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > normalized_mutual_information: Paramters: clustering: NodeClustering object\nReturn: [normalized mutual information score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)]\nReferences: []\nDescription: Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > omega: Paramters: clustering: NodeClustering object\nReturn: [omega index]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)]\nReferences: [Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18.]\nDescription: Index of resemblance for overlapping, complete coverage, network clusterings.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > overlapping_normalized_mutual_information_LFK: Paramters: clustering: NodeClustering object\nReturn: [onmi score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)]\nReferences: [Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015.]\nDescription: Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > overlapping_normalized_mutual_information_MGH: Paramters: clustering: NodeClustering object\nnormalization: one of “max” or “LFK”. Default “max” (corresponds to the main method described in the article)\nReturn: [onmi score\n]\nExample: [from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)]\nReferences: [McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago]\nDescription: Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > scaled_density: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > significance: Paramters: \nReturn: [the significance score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()]\nReferences: []\nDescription: Significance estimates how likely a partition of dense communities appear in a random graph.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > size: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: []\nReferences: []\nDescription: Size is the number of nodes in the community\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > surprise: Paramters: \nReturn: [the surprise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()]\nReferences: []\nDescription: Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > to_json: Paramters: \nReturn: [a JSON formatted string representing the object]\nExample: []\nReferences: []\nDescription: Generate a JSON representation of the algorithms object\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > to_node_community_map: Paramters: \nReturn: [dict of the form <node, list(communities)>]\nExample: []\nReferences: []\nDescription: Generate a <node, list(communities)> representation of the current clustering\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > triangle_participation_ratio: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()]\nReferences: []\nDescription: Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > variation_of_information: Paramters: clustering: NodeClustering object\nReturn: [VI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)]\nReferences: [Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013]\nDescription: Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > z_modularity: Paramters: \nReturn: [the z-modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()]\nReferences: []\nDescription: Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\nSection_id: FuzzyNodeClustering",
    "Field List > Methods > adjusted_mutual_information: Paramters: clustering: NodeClustering object\nReturn: [AMI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)]\nReferences: [Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854.]\nDescription: Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won’t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\nSection_id: AttrNodeClustering",
    "Field List > Methods > adjusted_rand_index: Paramters: clustering: NodeClustering object\nReturn: [ARI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)]\nReferences: [Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218.]\nDescription: Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then “adjusted for chance” into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\nSection_id: AttrNodeClustering",
    "Field List > Methods > average_internal_degree: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()]\nReferences: []\nDescription: The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\nSection_id: AttrNodeClustering",
    "Field List > Methods > avg_distance: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\nSection_id: AttrNodeClustering",
    "Field List > Methods > avg_embeddedness: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\nSection_id: AttrNodeClustering",
    "Field List > Methods > avg_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()]\nReferences: []\nDescription: Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\nSection_id: AttrNodeClustering",
    "Field List > Methods > avg_transitivity: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\nSection_id: AttrNodeClustering",
    "Field List > Methods > conductance: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()]\nReferences: []\nDescription: Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\nSection_id: AttrNodeClustering",
    "Field List > Methods > cut_ratio: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()]\nReferences: []\nDescription: Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n − n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\nSection_id: AttrNodeClustering",
    "Field List > Methods > edges_inside: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()]\nReferences: []\nDescription: Number of edges internal to the algorithms.\nSection_id: AttrNodeClustering",
    "Field List > Methods > erdos_renyi_modularity: Paramters: \nReturn: [the Erdos-Renyi modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()]\nReferences: []\nDescription: Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S − \\frac{mn_S(n_S −1)}{n(n−1)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\nSection_id: AttrNodeClustering",
    "Field List > Methods > expansion: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()]\nReferences: []\nDescription: Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\nSection_id: AttrNodeClustering",
    "Field List > Methods > f1: Paramters: clustering: NodeClustering object\nReturn: [F1 score (harmonic mean of precision and recall)]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)]\nReferences: [Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham.]\nDescription: Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\nSection_id: AttrNodeClustering",
    "Field List > Methods > flake_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()]\nReferences: []\nDescription: Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\nSection_id: AttrNodeClustering",
    "Field List > Methods > fraction_over_median_degree: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()]\nReferences: []\nDescription: Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\nSection_id: AttrNodeClustering",
    "Field List > Methods > get_description: Paramters: parameters_to_display: parameters to display. By default, all float parameters.\nprecision: precision used to plot parameters. default: 3\nReturn: [a string description of the method.\n]\nExample: []\nReferences: []\nDescription: Return a description of the clustering, with the name of the method and its numeric parameters.\nSection_id: AttrNodeClustering",
    "Field List > Methods > hub_dominance: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\nSection_id: AttrNodeClustering",
    "Field List > Methods > internal_edge_density: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()]\nReferences: []\nDescription: The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S−1)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\nSection_id: AttrNodeClustering",
    "Field List > Methods > link_modularity: Paramters: \nReturn: [the link modularity score]\nExample: [from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()]\nReferences: []\nDescription: Quality function designed for directed graphs with overlapping communities.\nSection_id: AttrNodeClustering",
    "Field List > Methods > max_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()]\nReferences: []\nDescription: Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\nSection_id: AttrNodeClustering",
    "Field List > Methods > modularity_density: Paramters: \nReturn: [the modularity density score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()]\nReferences: []\nDescription: The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} − d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\nSection_id: AttrNodeClustering",
    "Field List > Methods > modularity_overlap: Paramters: weight: label identifying the edge weight parameter name (if present), default None\nReturn: [FitnessResult object]\nExample: []\nReferences: [\nLazar, D. Abel and T. Vicsek, “Modularity measure of networks with overlapping communities”  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n, Lazar, D. Abel and T. Vicsek, “Modularity measure of networks with overlapping communities”  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001]\nDescription: Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\nSection_id: AttrNodeClustering",
    "Field List > Methods > newman_girvan_modularity: Paramters: \nReturn: [the Newman-Girvan modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()]\nReferences: []\nDescription: Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\nSection_id: AttrNodeClustering",
    "Field List > Methods > nf1: Paramters: clustering: NodeClustering object\nReturn: [MatchingResult instance]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)]\nReferences: [Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth., Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912.]\nDescription: Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\nSection_id: AttrNodeClustering",
    "Field List > Methods > normalized_cut: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()]\nReferences: []\nDescription: Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m−m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\nSection_id: AttrNodeClustering",
    "Field List > Methods > normalized_mutual_information: Paramters: clustering: NodeClustering object\nReturn: [normalized mutual information score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)]\nReferences: []\nDescription: Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\nSection_id: AttrNodeClustering",
    "Field List > Methods > omega: Paramters: clustering: NodeClustering object\nReturn: [omega index]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)]\nReferences: [Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18.]\nDescription: Index of resemblance for overlapping, complete coverage, network clusterings.\nSection_id: AttrNodeClustering",
    "Field List > Methods > overlapping_normalized_mutual_information_LFK: Paramters: clustering: NodeClustering object\nReturn: [onmi score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)]\nReferences: [Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015.]\nDescription: Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\nSection_id: AttrNodeClustering",
    "Field List > Methods > overlapping_normalized_mutual_information_MGH: Paramters: clustering: NodeClustering object\nnormalization: one of “max” or “LFK”. Default “max” (corresponds to the main method described in the article)\nReturn: [onmi score\n]\nExample: [from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)]\nReferences: [McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago]\nDescription: Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\nSection_id: AttrNodeClustering",
    "Field List > Methods > scaled_density: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\nSection_id: AttrNodeClustering",
    "Field List > Methods > significance: Paramters: \nReturn: [the significance score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()]\nReferences: []\nDescription: Significance estimates how likely a partition of dense communities appear in a random graph.\nSection_id: AttrNodeClustering",
    "Field List > Methods > size: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: []\nReferences: []\nDescription: Size is the number of nodes in the community\nSection_id: AttrNodeClustering",
    "Field List > Methods > surprise: Paramters: \nReturn: [the surprise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()]\nReferences: []\nDescription: Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\nSection_id: AttrNodeClustering",
    "Field List > Methods > to_json: Paramters: \nReturn: [a JSON formatted string representing the object]\nExample: []\nReferences: []\nDescription: Generate a JSON representation of the algorithms object\nSection_id: AttrNodeClustering",
    "Field List > Methods > to_node_community_map: Paramters: \nReturn: [dict of the form <node, list(communities)>]\nExample: []\nReferences: []\nDescription: Generate a <node, list(communities)> representation of the current clustering\nSection_id: AttrNodeClustering",
    "Field List > Methods > triangle_participation_ratio: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()]\nReferences: []\nDescription: Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\nSection_id: AttrNodeClustering",
    "Field List > Methods > variation_of_information: Paramters: clustering: NodeClustering object\nReturn: [VI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)]\nReferences: [Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013]\nDescription: Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\nSection_id: AttrNodeClustering",
    "Field List > Methods > z_modularity: Paramters: \nReturn: [the z-modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()]\nReferences: []\nDescription: Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\nSection_id: AttrNodeClustering",
    "Field List > Methods > get_description: Paramters: parameters_to_display: parameters to display. By default, all float parameters.\nprecision: precision used to plot parameters. default: 3\nReturn: [a string description of the method.\n]\nExample: []\nReferences: []\nDescription: Return a description of the clustering, with the name of the method and its numeric parameters.\nSection_id: EdgeClustering",
    "Field List > Methods > to_edge_community_map: Paramters: \nReturn: [dict of the form <edge, list(communities)>]\nExample: []\nReferences: []\nDescription: Generate a <edge, list(communities)> representation of the current clustering\nSection_id: EdgeClustering",
    "Field List > Methods > to_json: Paramters: \nReturn: [a JSON formatted string representing the object]\nExample: []\nReferences: []\nDescription: Generate a JSON representation of the algorithms object\nSection_id: EdgeClustering",
    "Field List > Methods > adjusted_mutual_information: Paramters: clustering: NodeClustering object\nReturn: [AMI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)]\nReferences: [Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854.]\nDescription: Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won’t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\nSection_id: BiNodeClustering",
    "Field List > Methods > adjusted_rand_index: Paramters: clustering: NodeClustering object\nReturn: [ARI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)]\nReferences: [Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218.]\nDescription: Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then “adjusted for chance” into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\nSection_id: BiNodeClustering",
    "Field List > Methods > average_internal_degree: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()]\nReferences: []\nDescription: The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\nSection_id: BiNodeClustering",
    "Field List > Methods > avg_distance: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\nSection_id: BiNodeClustering",
    "Field List > Methods > avg_embeddedness: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\nSection_id: BiNodeClustering",
    "Field List > Methods > avg_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()]\nReferences: []\nDescription: Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\nSection_id: BiNodeClustering",
    "Field List > Methods > avg_transitivity: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\nSection_id: BiNodeClustering",
    "Field List > Methods > conductance: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()]\nReferences: []\nDescription: Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\nSection_id: BiNodeClustering",
    "Field List > Methods > cut_ratio: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()]\nReferences: []\nDescription: Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n − n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\nSection_id: BiNodeClustering",
    "Field List > Methods > edges_inside: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()]\nReferences: []\nDescription: Number of edges internal to the algorithms.\nSection_id: BiNodeClustering",
    "Field List > Methods > erdos_renyi_modularity: Paramters: \nReturn: [the Erdos-Renyi modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()]\nReferences: []\nDescription: Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S − \\frac{mn_S(n_S −1)}{n(n−1)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\nSection_id: BiNodeClustering",
    "Field List > Methods > expansion: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()]\nReferences: []\nDescription: Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\nSection_id: BiNodeClustering",
    "Field List > Methods > f1: Paramters: clustering: NodeClustering object\nReturn: [F1 score (harmonic mean of precision and recall)]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)]\nReferences: [Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham.]\nDescription: Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\nSection_id: BiNodeClustering",
    "Field List > Methods > flake_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()]\nReferences: []\nDescription: Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\nSection_id: BiNodeClustering",
    "Field List > Methods > fraction_over_median_degree: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()]\nReferences: []\nDescription: Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\nSection_id: BiNodeClustering",
    "Field List > Methods > get_description: Paramters: parameters_to_display: parameters to display. By default, all float parameters.\nprecision: precision used to plot parameters. default: 3\nReturn: [a string description of the method.\n]\nExample: []\nReferences: []\nDescription: Return a description of the clustering, with the name of the method and its numeric parameters.\nSection_id: BiNodeClustering",
    "Field List > Methods > hub_dominance: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\nSection_id: BiNodeClustering",
    "Field List > Methods > internal_edge_density: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()]\nReferences: []\nDescription: The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S−1)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\nSection_id: BiNodeClustering",
    "Field List > Methods > link_modularity: Paramters: \nReturn: [the link modularity score]\nExample: [from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()]\nReferences: []\nDescription: Quality function designed for directed graphs with overlapping communities.\nSection_id: BiNodeClustering",
    "Field List > Methods > max_odf: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()]\nReferences: []\nDescription: Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\nSection_id: BiNodeClustering",
    "Field List > Methods > modularity_density: Paramters: \nReturn: [the modularity density score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()]\nReferences: []\nDescription: The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} − d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\nSection_id: BiNodeClustering",
    "Field List > Methods > modularity_overlap: Paramters: weight: label identifying the edge weight parameter name (if present), default None\nReturn: [FitnessResult object]\nExample: []\nReferences: [\nLazar, D. Abel and T. Vicsek, “Modularity measure of networks with overlapping communities”  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n, Lazar, D. Abel and T. Vicsek, “Modularity measure of networks with overlapping communities”  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001]\nDescription: Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\nSection_id: BiNodeClustering",
    "Field List > Methods > newman_girvan_modularity: Paramters: \nReturn: [the Newman-Girvan modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()]\nReferences: []\nDescription: Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\nSection_id: BiNodeClustering",
    "Field List > Methods > nf1: Paramters: clustering: NodeClustering object\nReturn: [MatchingResult instance]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)]\nReferences: [Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth., Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912.]\nDescription: Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\nSection_id: BiNodeClustering",
    "Field List > Methods > normalized_cut: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()]\nReferences: []\nDescription: Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m−m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\nSection_id: BiNodeClustering",
    "Field List > Methods > normalized_mutual_information: Paramters: clustering: NodeClustering object\nReturn: [normalized mutual information score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)]\nReferences: []\nDescription: Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\nSection_id: BiNodeClustering",
    "Field List > Methods > omega: Paramters: clustering: NodeClustering object\nReturn: [omega index]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)]\nReferences: [Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18.]\nDescription: Index of resemblance for overlapping, complete coverage, network clusterings.\nSection_id: BiNodeClustering",
    "Field List > Methods > overlapping_normalized_mutual_information_LFK: Paramters: clustering: NodeClustering object\nReturn: [onmi score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)]\nReferences: [Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015.]\nDescription: Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\nSection_id: BiNodeClustering",
    "Field List > Methods > overlapping_normalized_mutual_information_MGH: Paramters: clustering: NodeClustering object\nnormalization: one of “max” or “LFK”. Default “max” (corresponds to the main method described in the article)\nReturn: [onmi score\n]\nExample: [from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)]\nReferences: [McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago]\nDescription: Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\nSection_id: BiNodeClustering",
    "Field List > Methods > scaled_density: Paramters: summary: boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue.\nReturn: [If summary==True a FitnessResult object, otherwise a list of floats.]\nExample: []\nReferences: []\nDescription: Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\nSection_id: BiNodeClustering",
    "Field List > Methods > significance: Paramters: \nReturn: [the significance score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()]\nReferences: []\nDescription: Significance estimates how likely a partition of dense communities appear in a random graph.\nSection_id: BiNodeClustering",
    "Field List > Methods > size: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: []\nReferences: []\nDescription: Size is the number of nodes in the community\nSection_id: BiNodeClustering",
    "Field List > Methods > surprise: Paramters: \nReturn: [the surprise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()]\nReferences: []\nDescription: Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\nSection_id: BiNodeClustering",
    "Field List > Methods > to_json: Paramters: \nReturn: [a JSON formatted string representing the object]\nExample: []\nReferences: []\nDescription: Generate a JSON representation of the algorithms object\nSection_id: BiNodeClustering",
    "Field List > Methods > to_node_community_map: Paramters: \nReturn: [dict of the form <node, list(communities)>]\nExample: []\nReferences: []\nDescription: Generate a <node, list(communities)> representation of the current clustering\nSection_id: BiNodeClustering",
    "Field List > Methods > triangle_participation_ratio: Paramters: summary: (optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score\nReturn: [a FitnessResult object/a list of community-wise score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()]\nReferences: []\nDescription: Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\nSection_id: BiNodeClustering",
    "Field List > Methods > variation_of_information: Paramters: clustering: NodeClustering object\nReturn: [VI score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)]\nReferences: [Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013]\nDescription: Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\nSection_id: BiNodeClustering",
    "Field List > Methods > z_modularity: Paramters: \nReturn: [the z-modularity score]\nExample: [from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()]\nReferences: []\nDescription: Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\nSection_id: BiNodeClustering",
    "Field List > Methods > add_clustering: Paramters: clustering: a Clustering object\ntime: time of observation\nReturn: []\nExample: []\nReferences: []\nDescription: Add to the Temporal Clustering the communities observed at a given time\nSection_id: TemporalClustering",
    "Field List > Methods > add_matching: Paramters: matching: a list of tuples [(Ti_Ca, Tj_Cb, score), … ].\nCommunity names needs to satisfy the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object.\nReturn: []\nExample: []\nReferences: []\nDescription: Add a precomputed matching of the communities.\nSection_id: TemporalClustering",
    "Field List > Methods > clustering_stability_trend: Paramters: method: a comparison score taking as input two Clustering objects (e.g., NMI, NF1, ARI…)\nReturn: [a list of floats]\nExample: []\nReferences: []\nDescription: Returns the trend for community stability.\nThe stability index is computed for temporally adjacent clustering pairs.\nSection_id: TemporalClustering",
    "Field List > Methods > community_matching: Paramters: method: a set similarity function with co-domain in [0,1] (e.g., Jaccard)\ntwo_sided: boolean.\nWhether the match has to be applied only from the past to the future (False, default)\nor even from the future to the past (True)\nReturn: [a list of tuples [(Ti_Ca, Tj_Cb, score), … ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object.\n]\nExample: []\nReferences: []\nDescription: Reconstruct community matches across adjacent observations using a provided similarity function.\nSection_id: TemporalClustering",
    "Field List > Methods > get_clustering_at: Paramters: time: the time of observation\nReturn: [a Clustering object]\nExample: []\nReferences: []\nDescription: Returns the clustering observed at a given time\nSection_id: TemporalClustering",
    "Field List > Methods > get_community: Paramters: cid: community id of the form {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object.\nReturn: [list of nodes within cid]\nExample: []\nReferences: []\nDescription: Returns the nodes within a given temporal community\nSection_id: TemporalClustering",
    "Field List > Methods > get_explicit_community_match: Paramters: \nReturn: [a list of tuple [(Ti_Ca, Tj_Cb, score), … ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object.]\nExample: []\nReferences: []\nDescription: Return an explicit matching of computed communities (if it exists)\nSection_id: TemporalClustering",
    "Field List > Methods > has_explicit_match: Paramters: \nReturn: [a list of tuple [(Ti_Ca, Tj_Cb, score), … ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object.]\nExample: []\nReferences: []\nDescription: Checks if the algorithm provided an explicit match of temporal communities\nSection_id: TemporalClustering",
    "Field List > Methods > lifecycle_polytree: Paramters: method: a set similarity function with co-domain in [0,1] (e.g., Jaccard)\ntwo_sided: boolean.\nWhether the match has to be applied only from the past to the future (False, default)\nor even from the future to the past (True)\nReturn: [a networkx DiGraph object.\nNodes represent communities, their ids are assigned following the pattern {tid}_{cid},\nwhere tid is the time of observation and\ncid is the position of the community within the Clustering object.\n]\nExample: []\nReferences: []\nDescription: Reconstruct the poly-tree representing communities lifecycles using a provided similarity function.\nSection_id: TemporalClustering",
    "Field List > Methods > to_json: Paramters: \nReturn: [a JSON formatted string representing the object]\nExample: []\nReferences: []\nDescription: Generate a JSON representation of the TemporalClustering object\nSection_id: TemporalClustering",
    "Field List > Methods > fit: Description: Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second.\nIn sign flips, Q_ is an diagonal orthogonal matrices (i.e. a matrix with 1 or -1 in each entry on diagonal and 0 everywhere else) picked such that all dimensions of X @ Q_ and Y are in the same orthant using some critera (median or max magnitude).\nParameters: X: np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have same number of dimensions (axis 1) as Y.\nY: np.ndarray, shape (m, d)\nTarget dataset, must have same number of dimensions (axis 1) as X.\nReturns: self: returns an instance of self\nSection_id: SignFlips",
    "Field List > Methods > fit_transform: Description: Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.\nParameters: X: np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have same number of dimensions (axis 1) as Y.\nY: np.ndarray, shape (m, d)\nTarget dataset, must have same number of dimensions (axis 1) as X.\nReturns: X_prime: np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_.\nSection_id: SignFlips",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: SignFlips",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: SignFlips",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: SignFlips",
    "Field List > Methods > transform: Description: Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.\nParameters: X: np.ndarray, shape(m, d)\nDataset to be transformed, must have same number of dimensions (axis 1) as X and Y that were passed to fit.\nReturns: X_prime: np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_.\nSection_id: SignFlips",
    "Field List > Methods > fit: Description: Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second.\nParameters: X: np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have the same shape as Y.\nY: np.ndarray, shape (m, d)\nTarget dataset, must have the same shape as X.\nReturns: self: returns an instance of self\nSection_id: OrthogonalProcrustes",
    "Field List > Methods > fit_transform: Description: Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.\nParameters: X: np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have the same shape as Y.\nY: np.ndarray, shape (m, d)\nTarget dataset, must have the same shape as X.\nReturns: X_prime: np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_.\nSection_id: OrthogonalProcrustes",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: OrthogonalProcrustes",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: OrthogonalProcrustes",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: OrthogonalProcrustes",
    "Field List > Methods > transform: Description: Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.\nParameters: X: np.ndarray, shape(m, d)\nDataset to be transformed, must have same number of dimensions (axis 1) as X and Y that were passed to fit.\nReturns: X_prime: np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_.\nSection_id: OrthogonalProcrustes",
    "Field List > Methods > fit: Description: Uses the two datasets to learn the matrix self.Q_ that aligns the first dataset with the second.\nParameters: X: np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have same number of dimensions (axis 1) as Y.\nY: np.ndarray, shape (m, d)\nTarget dataset, must have same number of dimensions (axis 1) as X.\nReturns: self: returns an instance of self\nSection_id: SeedlessProcrustes",
    "Field List > Methods > fit_transform: Description: Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.\nParameters: X: np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have same number of dimensions (axis 1) as Y.\nY: np.ndarray, shape (m, d)\nTarget dataset, must have same number of dimensions (axis 1) as X.\nReturns: X_prime: np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_.\nSection_id: SeedlessProcrustes",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: SeedlessProcrustes",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: SeedlessProcrustes",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: SeedlessProcrustes",
    "Field List > Methods > transform: Description: Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.\nParameters: X: np.ndarray, shape(m, d)\nDataset to be transformed, must have same number of dimensions (axis 1) as X and Y that were passed to fit.\nReturns: X_prime: np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_.\nSection_id: SeedlessProcrustes",
    "Field List > Methods > fit: Description: Fits kmeans model to the data.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: self: returns an instance of self\nSection_id: KMeansCluster",
    "Field List > Methods > fit_predict: Description: Fit the models and predict clusters based on best model.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples, ), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: labels: array, shape (n_samples,)\nComponent labels.\nSection_id: KMeansCluster",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: KMeansCluster",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: KMeansCluster",
    "Field List > Methods > predict: Description: Predict clusters based on best model.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples, ), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: labels: array, shape (n_samples,)\nComponent labels.\nSection_id: KMeansCluster",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: KMeansCluster",
    "Field List > Methods > fit: Description: Fits gaussian mixure model to the data. Estimate model parameters with the EM algorithm.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: self: self\nSection_id: GaussianCluster",
    "Field List > Methods > fit_predict: Description: Fit the models and predict clusters based on best model.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: labels: array, shape (n_samples,)\nComponent labels.\nSection_id: GaussianCluster",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: GaussianCluster",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: GaussianCluster",
    "Field List > Methods > predict: Description: Predict clusters based on best model.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: labels: array, shape (n_samples,)\nComponent labels.\nSection_id: GaussianCluster",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nReturns: self: estimator instance\nSection_id: GaussianCluster",
    "Field List > Methods > fit: Description: Fits gaussian mixture model to the data. Initialize with agglomerative clustering then estimate model parameters with EM algorithm.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: self: object\nReturns an instance of self.\nSection_id: AutoGMMCluster",
    "Field List > Methods > fit_predict: Description: Fit the models and predict clusters based on best model.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples, ), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: labels: array, shape (n_samples,)\nComponent labels.\nSection_id: AutoGMMCluster",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: AutoGMMCluster",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: AutoGMMCluster",
    "Field List > Methods > predict: Description: Predict clusters based on best model.\nParameters: X: array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.\ny: array-like, shape (n_samples, ), optional (default=None)\nList of labels for X if available. Used to compute ARI scores.\nReturns: labels: array, shape (n_samples,)\nComponent labels.\nSection_id: AutoGMMCluster",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: AutoGMMCluster",
    "Field List > Methods > fit: Description: Fits clustering models to the data as well as resulting clusters\nParameters: X: array-like, shape (n_samples, n_features)\nReturns: self: object\nReturns an instance of self.\nSection_id: DivisiveCluster",
    "Field List > Methods > fit_predict: Description: Fits clustering models to the data as well as resulting clusters and using fitted models to predict a hierarchy of labels\nParameters: X: array-like, shape (n_samples, n_features)\n\nfcluster: bool, default=False\nif True, returned labels will be re-numbered so that each column of labels represents a flat clustering at current level, and each label corresponds to a cluster indexed the same as the corresponding node in the overall clustering dendrogram\nlevel: int, optional (default=None)\nthe level of a single flat clustering to generate only available if fcluster is True\nReturns: labels: array_label,shape (n_samples, n_levels)\nif no level specified; otherwise, shape (n_samples,)\nSection_id: DivisiveCluster",
    "Field List > Methods > predict: Description: Predicts a hierarchy of labels based on fitted models\nParameters: X: array-like, shape (n_samples, n_features)\n\nfcluster: bool, default=False\nif True, returned labels will be re-numbered so that each column of labels represents a flat clustering at current level, and each label corresponds to a cluster indexed the same as the corresponding node in the overall clustering dendrogram\nlevel: int, optional (default=None)\nthe level of a single flat clustering to generate only available if fcluster is True\nReturns: labels: array-like, shape (n_samples, n_levels)\nif no level specified; otherwise, shape (n_samples,)\nSection_id: DivisiveCluster",
    "Field List > Methods > set_predict_request: Description: Request metadata passed to the predict method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to the predict method.\nFalse: metadata is not requested, and not passed to the predict.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\nParameters: fcluster: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for fcluster parameter in predict.\nlevel: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for level parameter in predict.\nSection_id: DivisiveCluster",
    "Field List > Methods > fit: Description: Fit ASE model to input graph\nParameters: graph: array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graph to embed.\ny: Ignored\nReturns: self: object\nReturns an instance of self.\nSection_id: AdjacencySpectralEmbed",
    "Field List > Methods > fit_transform: Description: Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.\nParameters: graph: array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graph to embed.\nReturns: out: np.ndarray OR length 2 tuple of np.ndarray.\nIf undirected then returns single np.ndarray of latent position, shape(n_vertices, n_components). If directed, concat is True then concatenate latent matrices on axis 1, shape(n_vertices, 2*n_components). If directed, concat is False then tuple of the latent matrices. Each of shape (n_vertices, n_components).\nSection_id: AdjacencySpectralEmbed",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: AdjacencySpectralEmbed",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: AdjacencySpectralEmbed",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: AdjacencySpectralEmbed",
    "Field List > Methods > fit: Description: Fit LSE model to input graph\nParameters: graph: array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graph to embed.\nReturns: self: object\nReturns an instance of self.\nSection_id: LaplacianSpectralEmbed",
    "Field List > Methods > fit_transform: Description: Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.\nParameters: graph: array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graph to embed.\nReturns: out: np.ndarray OR length 2 tuple of np.ndarray.\nIf undirected then returns single np.ndarray of latent position, shape(n_vertices, n_components). If directed, concat is True then concatenate latent matrices on axis 1, shape(n_vertices, 2*n_components). If directed, concat is False then tuple of the latent matrices. Each of shape (n_vertices, n_components).\nSection_id: LaplacianSpectralEmbed",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: LaplacianSpectralEmbed",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: LaplacianSpectralEmbed",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: LaplacianSpectralEmbed",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: LaplacianSpectralEmbed",
    "Field List > Methods > transform: Description: Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].\nParameters: X: array-like or tuple, original shape or (n_oos_vertices, n_vertices).\nThe original fitted matrix ('graph' in fit) or new out-of-sample data. If X is the original fitted matrix, returns a matrix close to self.fit_transform(X).\n\nIf X is an out-of-sample matrix, n_oos_vertices is the number of new vertices, and n_vertices is the number of vertices in the original graph. If tuple, graph is directed and X[0] contains edges from out-of-sample vertices to in-sample vertices.\nReturns: out: np.ndarray OR length 2 tuple of np.ndarray\nArray of latent positions, shape (n_oos_vertices, n_components) or (n_vertices, n_components). Transforms the fitted matrix if it was passed in.\n\nIf X is an array or tuple containing adjacency vectors corresponding to new nodes, returns the estimated latent positions for the new out-of-sample adjacency vectors. If undirected, returns array. If directed, returns (X_out, X_in), where X_out contains latent positions corresponding to nodes with edges from out-of-sample vertices to in-sample vertices.\nSection_id: LaplacianSpectralEmbed",
    "Field List > Methods > fit: Description: Fit Omnibus model to input graphs\nParameters: graphs: list of array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graphs to embed.\ny: Ignored\nReturns: self: object\nReturns an instance of self.\nSection_id: OmnibusEmbed",
    "Field List > Methods > fit_transform: Description: Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.\nParameters: graphs: list of array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graphs to embed.\nReturns: out: np.ndarray OR length 2 tuple of np.ndarray.\nIf undirected then returns single np.ndarray of latent position, shape(n_vertices, n_components). If directed, concat is True then concatenate latent matrices on axis 1, shape(n_vertices, 2*n_components). If directed, concat is False then tuple of the latent matrices. Each of shape (n_vertices, n_components).\nSection_id: OmnibusEmbed",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: OmnibusEmbed",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: OmnibusEmbed",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\nParameters: graphs: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graphs parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: OmnibusEmbed",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: OmnibusEmbed",
    "Field List > Methods > transform: Description: Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].\nParameters: X: array-like or tuple, original shape or (n_oos_vertices, n_vertices).\nThe original fitted matrix ('graph' in fit) or new out-of-sample data.\nReturns: out: np.ndarray OR length 2 tuple of np.ndarray\nArray of latent positions, shape (n_oos_vertices, n_components) or (n_vertices, n_components). Transforms the fitted matrix if it was passed in.\n\nIf X is an array or tuple containing adjacency vectors corresponding to new nodes, returns the estimated latent positions for the new out-of-sample adjacency vectors. If undirected, returns array. If directed, returns (X_out, X_in), where X_out contains latent positions corresponding to nodes with edges from out-of-sample vertices to in-sample vertices.\nSection_id: OmnibusEmbed",
    "Field List > Methods > fit: Description: Fit MASE model to input graphs\nParameters: graphs: list of nx.Graph, ndarray or scipy.sparse.csr_array\nIf list of nx.Graph, each Graph must contain same number of nodes. If list of ndarray or csr_array, each array must have shape (n_vertices, n_vertices). If ndarray, then array must have shape (n_graphs, n_vertices, n_vertices).\ny: Ignored\nReturns: self: object\nReturns an instance of self.\nSection_id: MultipleASE",
    "Field List > Methods > fit_transform: Description: Fit the model with graphs and apply the embedding on graphs. n_components is either automatically determined or based on user input.\nParameters: graphs: list of nx.Graph, ndarray or scipy.sparse.csr_array\nIf list of nx.Graph, each Graph must contain same number of nodes. If list of ndarray or csr_array, each array must have shape (n_vertices, n_vertices). If ndarray, then array must have shape (n_graphs, n_vertices, n_vertices).\nReturns: out: np.ndarray or length 2 tuple of np.ndarray.\nIf input graphs were symmetric shape (n_vertices, n_components). If graphs were directed and concat is False, returns tuple of two arrays (same shape as above). The first corresponds to the left latent positions, and the second to the right latent positions. When concat is True left and right (out and in\nSection_id: MultipleASE",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: MultipleASE",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: MultipleASE",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\nParameters: graphs: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graphs parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: MultipleASE",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: MultipleASE",
    "Field List > Methods > transform: Description: Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].\nParameters: X: array-like or tuple, original shape or (n_oos_vertices, n_vertices).\nThe original fitted matrix ('graph' in fit) or new out-of-sample data. If X is the original fitted matrix, returns a matrix close to self.fit_transform(X).\n\nIf X is an out-of-sample matrix, n_oos_vertices is the number of new vertices, and n_vertices is the number of vertices in the original graph. If tuple, graph is directed and X[0] contains edges from out-of-sample vertices to in-sample vertices.\nReturns: out: np.ndarray OR length 2 tuple of np.ndarray\nArray of latent positions, shape (n_oos_vertices, n_components) or (n_vertices, n_components). Transforms the fitted matrix if it was passed in.\n\nIf X is an array or tuple containing adjacency vectors corresponding to new nodes, returns the estimated latent positions for the new out-of-sample adjacency vectors. If undirected, returns array. If directed, returns (X_out, X_in), where X_out contains latent positions corresponding to nodes with edges from out-of-sample vertices to in-sample vertices.\nSection_id: MultipleASE",
    "Field List > Methods > fit: Description: Computes a vector for each graph.\nParameters: graphs: list of nx.Graph or ndarray, or ndarray\nIf list of nx.Graph, each Graph must contain same number of nodes. If list of ndarray, each array must have shape (n_vertices, n_vertices). If ndarray, then array must have shape (n_graphs, n_vertices, n_vertices).\ny: Ignored\nReturns: self: mug2vec\nReturns an instance of self.\nSection_id: mug2vec",
    "Field List > Methods > fit_transform: Description: Computes a vector for each graph.\nParameters: graphs: list of nx.Graph or ndarray, or ndarray\nIf list of nx.Graph, each Graph must contain same number of nodes. If list of ndarray, each array must have shape (n_vertices, n_vertices). If ndarray, then array must have shape (n_graphs, n_vertices, n_vertices).\ny: Ignored\nReturns: embedding: ndarray\nembeddings generated by fit.\nSection_id: mug2vec",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: mug2vec",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: mug2vec",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested\nParameters: graphs: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graphs parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: mug2vec",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: mug2vec",
    "Field List > Methods > fit: Description: Fit the model with X.\nParameters: X: array_like\nIf dissimilarity=='precomputed', the input should be the dissimilarity matrix with shape (n_samples, n_samples). If dissimilarity=='euclidean', then the input should be 2d-array with shape (n_samples, n_features) or a 3d-array with shape (n_samples, n_features_1, n_features_2).\nReturns: self: object\nReturns an instance of self.\nSection_id: ClassicalMDS",
    "Field List > Methods > fit_transform: Description: Fit the data from X, and returns the embedded coordinates.\nParameters: X: nd-array\nIf dissimilarity=='precomputed', the input should be the dissimilarity matrix with shape (n_samples, n_samples). If dissimilarity=='euclidean', then the input should be array with shape (n_samples, n_features) or a nd-array with shape (n_samples, n_features_1, n_features_2, ..., n_features_d). First axis of nd-array must be n_samples.\nReturns: X_new: array-like, shape (n_samples, n_components)\nEmbedded input.\nSection_id: ClassicalMDS",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: ClassicalMDS",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: ClassicalMDS",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: ClassicalMDS",
    "Field List > Methods > static__new__: Description: Create new instance of NodePosition(node_id, x, y, size, community)\nParameters: node_id: str\nx: float\ny: float\nsize: float\ncommunity: int\nSection_id: NodePosition",
    "Field List > Methods > count: Description: Return number of occurrences of value.\nSection_id: NodePosition",
    "Field List > Methods > index: Description: Return first index of value.\nSection_id: NodePosition",
    "Field List > Methods > bic: Description: Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph\nReturns: float: The lower the better\nSection_id: EREstimator",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: EREstimator",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: EREstimator",
    "Field List > Methods > mse: Description: Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph\nReturns: float: Mean square error for the model's fit P matrix\nSection_id: EREstimator",
    "Field List > Methods > sample: Description: Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit\nParameters: n_samples: int (default 1), optional\nThe number of graphs to sample\nReturns: graphs: np.array (n_samples, n_verts, n_verts)\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts) adjacency matrices for the sampled graphs.\n\nNote that if only one sample is drawn, a (1, n_verts, n_verts) array will still be returned.\nSection_id: EREstimator",
    "Field List > Methods > score: Description: Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nReturns: float: sum of log-loglikelihoods for each potential edge in input graph\nSection_id: EREstimator",
    "Field List > Methods > score_samples: Description: Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nclip: scalar or None, optional (default=None)\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model.\nReturns: sample_scores: np.ndarray (size of graph)\nlog-likelihood per potential edge in the graph\nSection_id: EREstimator",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: EREstimator",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: EREstimator",
    "Field List > Methods > set_score_request: Description: Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score.\nReturns: self: object\nThe updated object.\nSection_id: EREstimator",
    "Field List > Methods > fit: Description: Fit the DCSBM to a graph, optionally with known block labels.\nIf y is None, the block assignments for each vertex will first be estimated.\nParameters: graph: array-like or array_like or networkx.Graph\nInput graph to fit\ny: array-like, length graph.shape[0], optional\nCategorical labels for the block assignments of the graph\nReturns: self: DCEREstimator\nFitted instance of self\nSection_id: DCEREstimator",
    "Field List > Methods > bic: Description: Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph\nReturns: float: The lower the better\nSection_id: DCEREstimator",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: DCEREstimator",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: DCEREstimator",
    "Field List > Methods > mse: Description: Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph\nReturns: float: Mean square error for the model's fit P matrix\nSection_id: DCEREstimator",
    "Field List > Methods > sample: Description: Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit\nParameters: n_samples: int\nThe number of graphs to sample\nReturns: graphs: np.array\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts) adjacency matrices for the sampled graphs.\nSection_id: DCEREstimator",
    "Field List > Methods > score: Description: Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nReturns: float: sum of log-loglikelihoods for each potential edge in input graph\nSection_id: DCEREstimator",
    "Field List > Methods > score_samples: Description: Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nclip: float or None\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model.\nReturns: sample_scores: np.ndarray\nlog-likelihood per potential edge in the graph\nSection_id: DCEREstimator",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: DCEREstimator",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: DCEREstimator",
    "Field List > Methods > set_score_request: Description: Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score.\nReturns: self: object\nThe updated object.\nSection_id: DCEREstimator",
    "Field List > Methods > fit: Description: Fit the SBM to a graph, optionally with known block labels\n\nIf y is None, the block assignments for each vertex will first be estimated.\nParameters: graph: ndarray | csr_array | Graph\ny: Any | None\nReturns: SBMEstimator: SBMEstimator\nSection_id: SBMEstimator",
    "Field List > Methods > bic: Description: Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: ndarray\nInput graph\nReturns: float: The lower the better\nSection_id: SBMEstimator",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: SBMEstimator",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: SBMEstimator",
    "Field List > Methods > mse: Description: Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: ndarray\nInput graph\nReturns: float: Mean square error for the model's fit P matrix\nSection_id: SBMEstimator",
    "Field List > Methods > sample: Description: Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit\nParameters: n_samples: int (default 1), optional\nThe number of graphs to sample\nReturns: graphs: np.array (n_samples, n_verts, n_verts)\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts)\nSection_id: SBMEstimator",
    "Field List > Methods > score: Description: Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nReturns: float: sum of log-loglikelihoods for each potential edge in input graph\nSection_id: SBMEstimator",
    "Field List > Methods > score_samples: Description: Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nclip: scalar or None, optional (default=None)\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model.\nReturns: sample_scores: np.ndarray (size of graph)\nlog-likelihood per potential edge in the graph\nSection_id: SBMEstimator",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: SBMEstimator",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: SBMEstimator",
    "Field List > Methods > set_score_request: Description: Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score.\nReturns: self: object\nThe updated object.\nSection_id: SBMEstimator",
    "Field List > Methods > fit: Description: Fit the DCSBM to a graph, optionally with known block labels\n\nIf y is None, the block assignments for each vertex will first be estimated.\nParameters: graph: array_like or networkx.Graph\nInput graph to fit\ny: array_like, length graph.shape[0], optional\nCategorical labels for the block assignments of the graph\nReturns: self: DCSBMEstimator object\nFitted instance of self\nSection_id: DCSBMEstimator",
    "Field List > Methods > bic: Description: Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph\nReturns: float: The lower the better\nSection_id: DCSBMEstimator",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: DCSBMEstimator",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: DCSBMEstimator",
    "Field List > Methods > mse: Description: Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph\nReturns: float: Mean square error for the model's fit P matrix\nSection_id: DCSBMEstimator",
    "Field List > Methods > sample: Description: Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit\nParameters: n_samples: int\nThe number of graphs to sample\nReturns: graphs: np.array\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts) adjacency matrices for the sampled graphs.\nSection_id: DCSBMEstimator",
    "Field List > Methods > score: Description: Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nReturns: float: sum of log-loglikelihoods for each potential edge in input graph\nSection_id: DCSBMEstimator",
    "Field List > Methods > score_samples: Description: Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nclip: scalar or None, optional (default=None)\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model.\nReturns: sample_scores: np.ndarray (size of graph)\nlog-likelihood per potential edge in the graph\nSection_id: DCSBMEstimator",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: DCSBMEstimator",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: DCSBMEstimator",
    "Field List > Methods > set_score_request: Description: Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score.\nReturns: self: object\nThe updated object.\nSection_id: DCSBMEstimator",
    "Field List > Methods > fit: Description: Calculate the parameters for the given graph model\nParameters: graph: ndarray | csr_array | Graph\ny: Any | None\nReturns: RDPGEstimator: RDPGEstimator\nSection_id: RDPGEstimator",
    "Field List > Methods > bic: Description: Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: ndarray\nReturns: bic: float\nThe lower the better\nSection_id: RDPGEstimator",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: RDPGEstimator",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: RDPGEstimator",
    "Field List > Methods > mse: Description: Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: ndarray\nInput graph\nReturns: mse: float\nMean square error for the model's fit P matrix\nSection_id: RDPGEstimator",
    "Field List > Methods > sample: Description: Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit\nParameters: n_samples: int\nThe number of graphs to sample\nReturns: graphs: np.array\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts) adjacency matrices for the sampled graphs.\nSection_id: RDPGEstimator",
    "Field List > Methods > score: Description: Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nReturns: float: sum of log-loglikelihoods for each potential edge in input graph\nSection_id: RDPGEstimator",
    "Field List > Methods > score_samples: Description: Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.\nParameters: graph: np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute\nclip: scalar or None, optional (default=None)\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model.\nReturns: sample_scores: np.ndarray (size of graph)\nlog-likelihood per potential edge in the graph\nSection_id: RDPGEstimator",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: RDPGEstimator",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: RDPGEstimator",
    "Field List > Methods > set_score_request: Description: Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.\nParameters: graph: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score.\nReturns: self: object\nThe updated object.\nSection_id: RDPGEstimator",
    "Field List > Methods > swap_edges: Description: Performs a number of edge swaps on the graph\nParameters: n_swaps: int(default 1), optional\nThe number of edge swaps to be performed\nReturns: adjacency: np.ndarray OR csr.matrix, shape (n_verts, n_verts)\nThe adjancency matrix after a number of edge swaps are performed on the graph\nedge_list: np.ndarray (n_verts, 2)\nThe edge_list after a number of edge swaps are perfomed on the graph\nSection_id: EdgeSwapper",
    "Field List > Methods > fit: Description: Constructs the embedding if not provided, then calculates the pairwise distance from each seed to each vertex in graph\nParameters: X: ndarray\nIf input_graph is True\nExpects a graph as an adjacency matrix, i.e. an ndarray of shape (n, n). Will be embedded using the specified embedder.\n\nIf input_graph is False\nExpects an embedding of the graph, i.e. a ndarray of size (n, d).\ny: NoneType\nIncluded by sklearn convention.\nReturns: self: object\nReturns an instance of self.\nSection_id: SpectralVertexNomination",
    "Field List > Methods > predict: Description: Nominates vertices for each seed vertex. Methodology is distance based ranking\nParameters: y: np.ndarray\nThe indices of the seed vertices. Should be a dim 1 array with length less than .\nReturns: Tuple[ndarray, ndarray]: Nomination Listnp.ndarray\nShape is (number_vertices, number_vertices_in_seed) . Each column is a seed vertex, and the rows of each column are a list of vertex indexes from the original adjacency matrix in order degree of match.\n\nDistance Matrixnp.ndarray\nThe matrix of distances associated with each element of the nomination list.\nSection_id: SpectralVertexNomination",
    "Field List > Methods > fit_predict: Description: Calls this class' fit and then predict methods\nParameters: X: ndarray\nIf input_graph is True\nExpects a graph as an adjacency matrix, i.e. an ndarray of shape (n, n). Will be embedded using the specified embedder.\n\nIf input_graph is False\nExpects an embedding of the graph, i.e. a ndarray of size (n, d).\ny: ndarray.\nList of unattributed seed vertex indices.\nReturns: Tuple[ndarray, ndarray]: Nomination Listnp.ndarray\nShape is (number_vertices, number_vertices_in_seed) . Each column is a seed vertex, and the rows of each column are a list of vertex indexes from the original adjacency matrix in order degree of match.\n\nDistance Matrixnp.ndarray\nThe matrix of distances associated with each element of the nomination list.\nSection_id: SpectralVertexNomination",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: SpectralVertexNomination",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: SpectralVertexNomination",
    "Field List > Methods > set_params: Description: Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.\nParameters: **params: dict\nEstimator parameters.\nReturns: self: estimator instance\nEstimator instance.\nSection_id: SpectralVertexNomination",
    "Field List > Methods > fit: Description: Fits the model to two graphs.\nParameters: A: 2d-array, square\nAdjacency matrix, the graph where voi is known\nB: 2d-array, square\nAdjacency matrix, the graph where voi is not known\nvoi: int\nVertex of interest\nseeds: list, 2d-array\nList of length two, of form [seedsA, seedsB]. The elements of seedsA and seedsB are vertex indices from A and B, respectively, which are known to be matched; that is, vertex seedsA[i] is matched to vertex seedsB[i]. Note: len(seedsA)==len(seedsB).\nReturns: self: An instance of self\nSection_id: VNviaSGM",
    "Field List > Methods > fit_predict: Description: Fits model to two adjacency matrices and returns\nParameters: A: 2d-array, square\nAdjacency matrix, the graph where voi is known\nB: 2d-array, square\nAdjacency matrix, the graph where voi is not known\nvoi: int\nVertex of interest\nseeds: list, 2d-array\nList of length two, of form [seedsA, seedsB]. The elements of seedsA and seedsB are vertex indices from A and B, respectively, which are known to be matched; that is, vertex seedsA[i] is matched to vertex seedsB[i]. Note: len(seedsA)==len(seedsB).\nReturns: nomination_list_: 2d-array\nThe nomination list.\nSection_id: VNviaSGM",
    "Field List > Methods > get_metadata_routing: Description: Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.\nReturns: routing: MetadataRequest\nA MetadataRequest encapsulating routing information.\nSection_id: VNviaSGM",
    "Field List > Methods > get_params: Description: Get parameters for this estimator.\nParameters: deep: bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\nReturns: params: dict\nParameter names mapped to their values.\nSection_id: VNviaSGM",
    "Field List > Methods > set_fit_request: Description: Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\nParameters: A: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for A parameter in fit.\nB: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for B parameter in fit.\nseeds: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for seeds parameter in fit.\nvoi: str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for voi parameter in fit.\nReturns: self: object\nThe updated object.\nSection_id: VNviaSGM",
    "Field List > Methods > add_edge: Description: Adds a weighted edge between the provided source and target. The source and target id are converted to a unique int.\nParameters: source: Any\nsource node id\ntarget: Any\ntarget node id\nweight: Union[int, float] (default=1.0)\nThe weight for the edge. If none is provided, the weight is defaulted to 1.\nsum_weight: bool(default=True)\nIf an edge between the source and target already exist, should we sum the edge weights or overwrite the edge weight with the provided weight value.\nattributes: kwargs\nThe attributes kwargs are presumed to be attributes that should be added to the edge dictionary for source and target.\nReturns: None: None\nSection_id: GraphBuilder",
    "Field List > Methods > fit: Description: Fit the signal-subgraph estimator according to the constraints given.\nParameters: graphs: array-like, shape (n_vertices, n_vertices, s_samples)\nA series of labeled (n_vertices, n_vertices) unweighted graph samples. If undirected, the upper or lower triangle matrices should be used.\nlabels: vector, length (s_samples)\nA vector of class labels. There must be a maximum of two classes.\nconstraints: int or vector\nThe constraints that will be imposed onto the estimated signal-subgraph.\n\nIf constraints is an int, constraints is the number of edges in the signal-subgraph. If constraints is a vector, the first element of constraints is the number of edges in the signal-subgraph, and the second element of constraints is the number of vertices that the signal-subgraph must be incident to.\nReturns: self: returns an instance of self\nSection_id: SignalSubgraph",
    "Field List > Methods > fit_transform: Description: A function to return the indices of the signal-subgraph. If return_mask is True, also returns a mask for the signal-subgraph.\nParameters: graphs: array-like, shape (n_vertices, n_vertices, s_samples)\nA series of labeled (n_vertices, n_vertices) unweighted graph samples. If undirected, the upper or lower triangle matrices should be used.\nlabels: vector, length (s_samples)\nA vector of class labels. There must be a maximum of two classes.\nconstraints: int or vector\nThe constraints that will be imposed onto the estimated signal-subgraph.\n\nIf constraints is an int, constraints is the number of edges in the signal-subgraph. If constraints is a vector, the first element of constraints is the number of edges in the signal-subgraph, and the second element of constraints is the number of vertices that the signal-subgraph must be incident to.\nReturns: sigsub: tuple\nContains an array of row indices and an array of column indices.\nSection_id: SignalSubgraph",
    "Field List > Methods > draw_path: Description: overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a rectangle-shaped path on the Cairo context without stroking or filling it.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.draw_path\nexample: []\nSection_id: RectangleDrawer",
    "Field List > Methods > intersection_point: Description: overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the rectangle centered at (center_x, center_y) having the given width and height intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.intersection_point\nexample: []\nSection_id: RectangleDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.colors.Palette.__init__\nCreates a rainbow palette.\nParamters: n: the umber of colors i the palette.\ns: the aturation of the color in the palette.\nv: the alue component of the colors in the palette.\nstart: the hue at which the rainbow begins (between 0 and 1).\nend: the hue at which the rainbow s (between 0 and 1).\nalpha: the  component of the colors in the palette.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RainbowPalette",
    "Field List > Methods > __len__: Description: Inherited from Palette:Returns the number of colors in this palette\nSection_id: RainbowPalette",
    "Field List > Methods > __plot__: Description: Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes\nSection_id: RainbowPalette",
    "Field List > Methods > __repr__: Description: Inherited from Palette:Undocumented\nSection_id: RainbowPalette",
    "Field List > Methods > clear_cache: Description: Inherited from Palette:Clears the result cache.\nSection_id: RainbowPalette",
    "Field List > Methods > get: Description: Inherited from Palette:Returns the given color from the palette.\nSection_id: RainbowPalette",
    "Field List > Methods > get_many: Description: Inherited from Palette:Returns multiple colors from the palette.\nSection_id: RainbowPalette",
    "Field List > Methods > __call__: Description: Shorthand notation to select()\nThis method simply passes all its arguments to EdgeSeq.select().\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeSeq",
    "Field List > Methods > attributes: Description: Returns the list of all the edge attributes in the graph associated to this edge sequence.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeSeq",
    "Field List > Methods > find: Description: overrides igraph._igraph.EdgeSeq.find\nReturns the first edge of the edge sequence that matches some criteria.\nThe selection criteria are equal to the ones allowed by VertexSeq.select. See VertexSeq.select for more details.\nFor instance, to find the first edge with weight larger than 5 in graph g:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [For instance, to find the first edge with weight larger than 5 in graph g:\n>>> g.es.find(weight_gt=5)           #doctest:+SKIP]\nSection_id: EdgeSeq",
    "Field List > Methods > select: Description: overrides igraph._igraph.EdgeSeq.select\nSelects a subset of the edge sequence based on some criteria\nThe selection criteria can be specified by the positional and the keyword arguments. Positional arguments are always processed before keyword arguments.If the first positional argument is None, an empty sequence is returned.If the first positional argument is a callable object, the object will be called for every edge in the sequence. If it returns True, the edge will be included, otherwise it will be excluded.If the first positional argument is an iterable, it must return integers and they will be considered as indices of the current edge set (NOT the whole edge set of the graph -- the difference matters when one filters an edge set that has already been filtered by a previous invocation of EdgeSeq.select(). In this case, the indices do not refer directly to the edges of the graph but to the elements of the filtered edge sequence.If the first positional argument is an integer, all remaining arguments are expected to be integers. They are considered as indices of the current edge set again.\nKeyword arguments can be used to filter the edges based on their attributes and properties. The name of the keyword specifies the name of the attribute and the filtering operator, they should be concatenated by an underscore (_) character. Attribute names can also contain underscores, but operator names don't, so the operator is always the largest trailing substring of the keyword name that does not contain an underscore. Possible operators are:eq: equal tone: not equal tolt: less thangt: greater thanle: less than or equal toge: greater than or equal toin: checks if the value of an attribute is in a given listnotin: checks if the value of an attribute is not in a given list\nFor instance, if you want to filter edges with a numeric weight property larger than 50, you have to write:\nParamters: \nReturn: [the new, filtered edge sequence]\nReferences: []\nRasises: \nSee Also: \nexample: [For instance, if you want to filter edges with a numeric weight property larger than 50, you have to write:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP, Similarly, to filter edges whose type is in a list of predefined types:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP, If the operator is omitted, it defaults to eq. For instance, the following selector selects edges whose type property is intracluster:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP, For instance, if you want to exclude edges with a betweenness centrality less than 2:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP, To select edges originating from vertices 2 and 4:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP, To select edges lying entirely within the subgraph spanned by vertices 2, 3, 4 and 7:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP, To select edges with one endpoint in the vertex set containing vertices 2, 3, 4 and 7 and the other endpoint in the vertex set containing vertices 8 and 9:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP, For properties that take a long time to be computed (e.g., betweenness centrality for large graphs), it is advised to calculate the values in advance and store it in a graph attribute. The same applies when you are selecting based on the same property more than once in the same select() call to avoid calculating it twice unnecessarily. For instance, the following would calculate betweenness centralities twice:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP, It is advised to use this instead:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP]\nSection_id: EdgeSeq",
    "Field List > Methods > attribute_names: Description: Inherited from EdgeSeq:Returns the attribute name list of the graph's edges\nSection_id: EdgeSeq",
    "Field List > Methods > get_attribute_values: Description: Inherited from EdgeSeq:Returns the value of a given edge attribute for all edges.\nSection_id: EdgeSeq",
    "Field List > Methods > is_all: Description: Inherited from EdgeSeq:Returns whether the edge sequence contains all the edges exactly once, in the order of their edge IDs.\nSection_id: EdgeSeq",
    "Field List > Methods > set_attribute_values: Description: Inherited from EdgeSeq:Sets the value of a given edge attribute for all vertices\nSection_id: EdgeSeq",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AttributeSpecification",
    "Field List > Methods > __init__: Description: Constructs the drawer and associates it to the given Axes.\nParamters: ax: the Axes on which we will draw\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibDendrogramDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Dendrogram in a matplotlib Axes.\nOther keyword arguments are passed to mpl.patches.Polygon.\nParamters: dendro: the igraph.Dendrogram to plot.\norientation: the direction of the plot. Accepted values are \"lr\" (root on the right), \"rl\" (root on the left), \"tb\" (root at the bottom), and \"bt\" (root at the top). A few aliases are available (see utils.str_to_).\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibDendrogramDrawer",
    "Field List > Methods > resolve: Description: Given a shape name, returns the corresponding shape drawer class\nParamters: cls: the class to resolve\nobj: an instance of the ect to plot\nbackend: the name of the\nReturn: [the corresponding shape drawer class]\nReferences: []\nRasises: ValueError: if no drawer is available for this backend/object\nSee Also: \nexample: []\nSection_id: DrawerDirectory",
    "Field List > Methods > __getitem__: Description: Returns the collected attributes of the vertex/edge with the given index.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AttributeCollectorBase",
    "Field List > Methods > __init__: Description: Constructs a new attribute collector that uses the given vertex/edge sequence and the given dict as data sources.\nParamters: seq: an igraph.VertexSeq or igraph.EdgeSeq class that will be used as a data source for attributes.\nkwds: a Python dict that will be used to override the attributes collected from seq if necessary.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AttributeCollectorBase",
    "Field List > Methods > __len__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AttributeCollectorBase",
    "Field List > Methods > __init__: Description: Constructs the drawer and associates it to the given Axes.\nParamters: ax: the Axes on which we will draw\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibHistogramDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.\nParamters: matrix: the igraph.Histogram to plot.\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibHistogramDrawer",
    "Field List > Methods > __getattr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: TriadCensus",
    "Field List > Methods > __getitem__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: TriadCensus",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: TriadCensus",
    "Field List > Methods > __str__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: TriadCensus",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.colors.PrecalculatedPalette.__init__\nCreates the palette backed by the given list. The list must contain RGBA quadruplets or color names, which will be resolved first by color_name_to_rgba(). Anything that is understood by color_name_to_rgba() is OK here.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ClusterColoringPalette",
    "Field List > Methods > draw_path: Description: overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws nothing.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: NullDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs a new instance that will draw the given text on the given Cairo context.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoTextDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the text in the current bounding box of the drawer.\nSince the class itself is an instance of AbstractCairoDrawer, it has an attribute named bbox which will be used as a bounding box.\nParamters: wrap: whether to allow re-ping of the text if it does not fit within the bounding box horizontally.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoTextDrawer",
    "Field List > Methods > draw_at: Description: Draws the text by setting up an appropriate path on the Cairo context and filling it. x and y denote the coordinates where the drawing should start. If they are both None, the current position of the context will be used.\nVertical alignment settings are not taken into account in this method as the text is not drawn within a box.\nParamters: x: The X coordinate of the reference point where the layout should start.\ny: The Y coordinate of the reference point where the laout should start.\nwidth: The  of the box in which the text will be fitted. It matters only when the text is right-aligned or centered. The text will overflow the box if any of the lines is longer than the box  and wrap is False.\nwrap: whether to allow re-ping of the text if it does not fit within the given width.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoTextDrawer",
    "Field List > Methods > get_text_layout: Description: Calculates the layout of the current text. x and y denote the coordinates where the drawing should start. If they are both None, the current position of the context will be used.\nVertical alignment settings are not taken into account in this method as the text is not drawn within a box.\nParamters: x: The X coordinate of the reference point where the layout should start.\ny: The Y coordinate of the reference point where the laout should start.\nwidth: The  of the box in which the text will be fitted. It matters only when the text is right-aligned or centered. The text will overflow the box if any of the lines is longer than the box  and wrap is False.\nwrap: whether to allow re-ping of the text if it does not fit within the given width.\nReturn: [a list consisting of (x, y, line) tuples where x and y refer to reference points on the Cairo canvas and line refers to the corresponding text that should be plotted there.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoTextDrawer",
    "Field List > Methods > text: Description: Sets the text that will be drawn.\nIf text is None, it will be mapped to an empty string; otherwise, it will be converted to a string.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoTextDrawer",
    "Field List > Methods > text_extents: Description: Returns the X-bearing, Y-bearing, width, height, X-advance and Y-advance of the text.\nFor multi-line text, the X-bearing and Y-bearing correspond to the first line, while the X-advance is extracted from the last line. and the Y-advance is the sum of all the Y-advances. The width and height correspond to the entire bounding box of the text.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoTextDrawer",
    "Field List > Methods > bbox.setter: Description: Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.\nSection_id: CairoTextDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given Cairo context and the given BoundingBox.\nParamters: context: the  on which we will draw\nbbox: the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).\npalette: the  that can be used to map integer color indices to colors when drawing vertices\nlayout: the  of the vertices in the graph being drawn\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractCairoVertexDrawer",
    "Field List > Methods > draw: Description: Inherited from AbstractVertexDrawer:Draws the given vertex.\nSection_id: AbstractCairoVertexDrawer",
    "Field List > Methods > __new__: Description: Create and return a new object.  See help(type) for accurate signature.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > add_edges: Description: overridden in igraph.Graph\nAdds edges to the graph.\nParamters: es: the list of edg to be added. Every edge is reprented with a tuple, containing the vertex IDs of the two endpoints. Vertic are enumerated from zero.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > add_vertices: Description: overridden in igraph.Graph\nAdds vertices to the graph.\nParamters: n: the umber of vertices to be added\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Adjacency: Description: overridden in igraph.Graph\nGenerates a graph from its adjacency matrix.\nParamters: matrix: the adjacency \nmode: the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The input matrix must be symmetric.\"max\"   - undirected graph will be created and the number of edges between vertex i and j is max(A(i, j), A(j, i))\"min\"   - like \"max\", but with min(A(i, j), A(j, i))\"plus\"  - like \"max\", but with A(i, j) + A(j, i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)\nloops: specifies how the diagonal of the matrix should be handled:\"ignore\" - ignore loop edges in the diagonal\"once\" - treat the diagonal entries as loop edge counts\"twice\" - treat the diagonal entries as twice the number of loop edges\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > all_minimal_st_separators: Description: Returns a list containing all the minimal s-t separators of a graph.\nA minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.\nReference: Anne Berry, Jean-Paul Bordat and Olivier Cogis: Generating all the minimal separators of a graph. In: Peter Widmayer, Gabriele Neyer and Stephan Eidenbenz (eds.): Graph-theoretic concepts in computer science, 1665, 167-172, 1999. Springer.\nParamters: \nReturn: [a list where each item lists the vertex indices of a given minimal s-t separator.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > all_st_cuts: Description: overridden in igraph.Graph\nReturns all the cuts between the source and target vertices in a directed graph.\nThis function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.\nParamters: source: the  vertex ID\ntarget: the  vertex ID\nReturn: [a tuple where the first element is a list of lists of edge IDs representing a cut and the second element is a list of lists of vertex IDs representing the sets of vertices that were separated by the cuts.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > all_st_mincuts: Description: overridden in igraph.Graph\nReturns all minimum cuts between the source and target vertices in a directed graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.\nParamters: source: the  vertex ID\ntarget: the  vertex ID\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > are_connected: Description: Decides whether two given vertices are directly connected.\nParamters: v1: the ID or name of the first vertex\nv2: the ID or name of the second vertex\nReturn: [True if there exists an edge from v1 to v2, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > articulation_points: Description: Returns the list of articulation points in the graph.\nA vertex is an articulation point if its removal increases the number of connected components in the graph.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > assortativity: Description: Returns the assortativity of the graph based on numeric properties of the vertices.\nThis coefficient is basically the correlation between the actual connectivity patterns of the vertices and the pattern expected from the distribution of the vertex types.\nSee equation (21) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition. The actual calculation is performed using equation (26) in the same paper for directed graphs, and equation (4) in Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701 (2002) for undirected graphs.\n\nParamters: types1: vertex types in a list or the name of a vertex attribute holding vertex types. Types are ideally denoted by numeric values.\ntypes2: in directed assortativity calculations, each vertex can have an out-type and an in-type. In this case, types1 contains the out-types and this parameter contains the in-types in a list or the name of a vertex attribute. If None, it is assumed to be equal to types1.\ndirected: whether to consider edge directions or not.\nnormalized: whether to compute the  covariance, i.e. Pearson correlation. Supply True here to compute the standard assortativity.\nReturn: [the assortativity coefficient]\nReferences: [Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701, 2002.]\nRasises: \nSee Also: assortativity_degree() when the types are the vertex degrees\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > assortativity_degree: Description: Returns the assortativity of a graph based on vertex degrees.\nSee assortativity() for the details. assortativity_degree() simply calls assortativity() with the vertex degrees as types.\nParamters: directed: whether to consider edge directions for  graphs or not. This argument is ignored for un graphs.\nReturn: [the assortativity coefficient]\nReferences: []\nRasises: \nSee Also: assortativity()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > assortativity_nominal: Description: Returns the assortativity of the graph based on vertex categories.\nAssuming that the vertices belong to different categories, this function calculates the assortativity coefficient, which specifies the extent to which the connections stay within categories. The assortativity coefficient is one if all the connections stay within categories and minus one if all the connections join vertices of different categories. For a randomly connected network, it is asymptotically zero.\nSee equation (2) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition.\nReference: Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.\nParamters: types: vertex  in a list or the name of a vertex attribute holding vertex . Types should be denoted by numeric values.\ndirected: whether to consider edge directions or not.\nnormalized: whether to compute the (usual)  assortativity. The un version is identical to modularity. Supply True here to compute the standard assortativity.\nReturn: [the assortativity coefficient]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Asymmetric_Preference: Description: Generates a graph based on asymmetric vertex types and connection probabilities.\nThis is the asymmetric variant of Preference(). A given number of vertices are generated. Every vertex is assigned to an \"incoming\" and an \"outgoing\" vertex type according to the given joint type probabilities. Finally, every vertex pair is evaluated and a directed edge is created between them with a probability depending on the \"outgoing\" type of the source vertex and the \"incoming\" type of the target vertex.\nParamters: n: the umber of vertices i the graph\ntype_dist_matrix: matrix giving the joint distribution of vertex types\npref_matrix: matrix giving the connection probabilities for different vertex types.\nattribute: the vertex  name used to store the vertex types. If None, vertex types are not stored.\nloops: whether loop edges are allowed.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Atlas: Description: Generates a graph from the Graph Atlas.\nReference: Ronald C. Read and Robin J. Wilson: An Atlas of Graphs. Oxford University Press, 1998.\nParamters: idx: The index of the graph to be generated. Indices start from zero, graphs are listed:in increasing order of number of vertices;for a fixed number of vertices, in increasing order of the number of edges;for fixed numbers of vertices and edges, in increasing order of the degree sequence, for example 111223 < 112222;for fixed degree sequence, in increasing number of automorphisms.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > attributes: Description: \nParamters: \nReturn: [the attribute name list of the graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > authority_score: Description: Calculates Kleinberg's authority score for the vertices of the graph\nParamters: weights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nscale: whether to normalize the scores so that the largest one is 1.\narpack_options: an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.\nreturn_eigenvalue: whether to return the largest eigenvalue\nReturn: [the authority scores in a list and optionally the largest eigenvalue as a second member of a tuple]\nReferences: []\nRasises: \nSee Also: hub_score()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > automorphism_group: Description: Calculates the generators of the automorphism group of a graph using the BLISS isomorphism algorithm.\nThe generator set may not be minimal and may depend on the splitting heuristics. The generators are permutations represented using zero-based indexing.\nParamters: sh: splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell\ncolor: optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same .\nReturn: [a list of integer vectors, each vector representing an automorphism group of the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > average_path_length: Description: Calculates the average path length in a graph.\nParamters: directed: whether to consider  paths in case of a  graph. Ignored for un graphs.\nunconn: what to do when the graph is ected. If True, the average of the geodesic lengths in the components is calculated. Otherwise for all ected vertex pairs, a path length equal to the number of vertices is used.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nReturn: [the average path length in the graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Barabasi: Description: Generates a graph based on the Barabási-Albert model.\nReference: Barabási, A-L and Albert, R. 1999. Emergence of scaling in random networks. Science, 286 509-512.\nParamters: n: the umber of vertices\nm: either the nuber of outgoing edges generated for each vertex or a list containing the nuber of outgoing edges for each vertex explicitly.\noutpref: True if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to False.\ndirected: True if the generated graph should be  (default: False).\npower: the  constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used.\nzero_appeal: the attractivity of vertices with degree zero.\nimplementation: the algorithm to use to generate the network. Possible values are:\"bag\": the algorithm that was the default in igraph before 0.6. It works by putting the ids of the vertices into a bag (multiset) exactly as many times as their in-degree, plus once more. The required number of cited vertices are then drawn from the bag with replacement. It works only for power=1 and zero_appeal=1.\"psumtree\": this algorithm uses a partial prefix-sum tree to generate the graph. It does not generate multiple edges and it works for any values of power and zero_appeal.\"psumtree_multiple\": similar to \"psumtree\", but it will generate multiple edges as well. igraph before 0.6 used this algorithm for powers other than 1.\nstart_from: if given and not None, this must be another GraphBase object. igraph will use this graph as a starting point for the preferential attachment model.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > betweenness: Description: Calculates or estimates the betweenness of vertices in a graph.\nAlso supports calculating betweenness with shortest path length cutoffs or considering shortest paths only from certain source vertices or to certain target vertices.\nKeyword arguments:\nParamters: vertices: the  for which the betweennesses must be returned. If None, assumes all of the  in the graph.\ndirected: whether to consider  paths.\ncutoff: if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness for the given vertices. If None, the exact betweenness is returned.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nsources: the set of source vertices to consider when calculating shortest paths.\ntargets: the set of target vertices to consider when calculating shortest paths.\nReturn: [the (possibly cutoff-limited) betweenness of the given vertices in a list]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > bfs: Description: Conducts a breadth first search (BFS) on the graph.\nParamters: vid: the root vertex ID\nmode: either \"in\" or \"out\" or \"all\", ignored for undirected graphs.\nReturn: [a tuple with the following items:\n\nThe vertex IDs visited (in order)\nThe start indices of the layers in the vertex list\nThe parent of every vertex in the BFS\n\n]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > bfsiter: Description: Constructs a breadth first search (BFS) iterator of the graph.\nParamters: vid: the root vertex ID\nmode: either \"in\" or \"out\" or \"all\".\nadvanced: if False, the iterator returns the next vertex in BFS order in every step. If True, the iterator returns the distance of the vertex from the root and the parent of the vertex in the BFS tree as well.\nReturn: [the BFS iterator as an igraph.BFSIter object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > bibcoupling: Description: Calculates bibliographic coupling scores for given vertices in a graph.\nParamters: vertices: the  to be analysed. If None, all  will be considered.\nReturn: [bibliographic coupling scores for all given vertices in a matrix.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > biconnected_components: Description: overridden in igraph.Graph\nCalculates the biconnected components of the graph.\nComponents containing a single vertex only are not considered as being biconnected.\nParamters: return_articulation_points: whether to return the articulation points as well\nReturn: [a list of lists containing edge indices making up spanning trees of the biconnected components (one spanning tree for each component) and optionally the list of articulation points]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > bipartite_projection: Description: overridden in igraph.Graph\nInternal function, undocumented.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.bipartite_projection()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > bipartite_projection_size: Description: overridden in igraph.Graph\nInternal function, undocumented.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.bipartite_projection_size()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > bridges: Description: Returns the list of bridges in the graph.\nAn edge is a bridge if its removal increases the number of (weakly) connected components in the graph.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > canonical_permutation: Description: Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.\nPassing the permutation returned here to permute_vertices() will transform the graph into its canonical form.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm and canonical permutations.\nParamters: sh: splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell\ncolor: optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same .\nReturn: [a permutation vector containing vertex IDs. Vertex 0 in the original graph will be mapped to an ID contained in the first element of this vector; vertex 1 will be mapped to the second and so on.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > chordal_completion: Description: Returns the list of edges needed to be added to the graph to make it chordal.\nA graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.\nThe chordal completion of a graph is the list of edges that needed to be added to the graph to make it chordal. It is an empty list if the graph is already chordal.\nNote that at the moment igraph does not guarantee that the returned chordal completion is minimal; there may exist a subset of the returned chordal completion that is still a valid chordal completion.\nParamters: alpha: the  vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the  vector; simply passing None here will make igraph calculate the  vector on its own.\nalpham1: the inverse alpha vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the inverse alpha vector; simply passing None here will make igraph calculate the inverse alpha vector on its own.\nReturn: [the list of edges to add to the graph; each item in the list is a source-target pair of vertex indices.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > clique_number: Description: Returns the clique number of the graph.\nThe clique number of the graph is the size of the largest clique.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: largest_cliques() for the largest cliques.\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > cliques: Description: Returns some or all cliques of the graph as a list of tuples.\nA clique is a complete subgraph -- a set of vertices where an edge is present between any two of them (excluding loops)\nParamters: min: the imum size of cliques to be returned. If zero or negative, no lower bound will be used.\nmax: the imum size of cliques to be returned. If zero or negative, no upper bound will be used.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > closeness: Description: Calculates the closeness centralities of given vertices in a graph.\nThe closeness centrality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the number of vertices minus one divided by the sum of the lengths of all geodesics from/to the given vertex.\nIf the graph is not connected, and there is no path between two vertices, the number of vertices is used instead the length of the geodesic. This is always longer than the longest possible geodesic.\nParamters: vertices: the  for which the closenesses must be returned. If None, uses all of the  in the graph.\nmode: must be one of \"in\", \"out\" and \"all\". \"in\" means that the length of the incoming paths, \"out\" means that the length of the outgoing paths must be calculated. \"all\" means that both of them must be calculated.\ncutoff: if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the closeness for the given vertices (which is always an underestimation of the real closeness, since some vertex pairs will appear as disconnected even though they are connected).. If None, the exact closeness is returned.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nnormalized: Whether to normalize the raw closeness scores by multiplying by the number of vertices minus one.\nReturn: [the calculated closenesses in a list]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > cocitation: Description: Calculates cocitation scores for given vertices in a graph.\nParamters: vertices: the  to be analysed. If None, all  will be considered.\nReturn: [cocitation scores for all given vertices in a matrix.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > cohesive_blocks: Description: overridden in igraph.Graph\nCalculates the cohesive block structure of the graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a CohesiveBlocks object. It is advised to use that.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_edge_betweenness: Description: overridden in igraph.Graph\nCommunity structure detection based on the betweenness of the edges in the network. This algorithm was invented by M Girvan and MEJ Newman, see: M Girvan and MEJ Newman: Community structure in social and biological networks, Proc. Nat. Acad. Sci. USA 99, 7821-7826 (2002).\nThe idea is that the betweenness of the edges connecting two communities is typically high. So we gradually remove the edge with the highest betweenness from the network and recalculate edge betweenness after every removal, as long as all edges are removed.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nParamters: directed: whether to take into account the ness of the edges when we calculate the betweenness values.\nweights: name of an edge attribute or a list containing edge .\nReturn: [a tuple with the merge matrix that describes the dendrogram and the modularity scores before each merge. The modularity scores use the weights if the original graph was weighted.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_fastgreedy: Description: overridden in igraph.Graph\nFinds the community structure of the graph according to the algorithm of Clauset et al based on the greedy optimization of modularity.\nThis is a bottom-up algorithm: initially every vertex belongs to a separate community, and communities are merged one by one. In every step, the two communities being merged are the ones which result in the maximal increase in modularity.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: A. Clauset, M. E. J. Newman and C. Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).\nParamters: weights: name of an edge attribute or a list containing edge\nReturn: [a tuple with the following elements:\n\nThe list of merges\nThe modularity scores before each merge\n\n]\nReferences: []\nRasises: \nSee Also: modularity()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_infomap: Description: overridden in igraph.Graph\nFinds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.\nSee http://www.mapequation.org for a visualization of the algorithm or one of the references provided below. \nParamters: edge_weights: name of an edge attribute or a list containing edge weights.\nvertex_weights: name of an vertex attribute or a list containing vertex weights.\ntrials: the number of attempts to partition the network.\nReturn: [the calculated membership vector and the corresponding codelength in a tuple.]\nReferences: [M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks. PNAS 105, 1118 (2008). http://arxiv.org/abs/0707.0609M. Rosvall, D. Axelsson and C. T. Bergstrom: The map equation. Eur Phys J Special Topics 178, 13 (2009). http://arxiv.org/abs/0906.1405]\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_label_propagation: Description: overridden in igraph.Graph\nFinds the community structure of the graph according to the label propagation method of Raghavan et al.\nInitially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.\nNote that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.\nReference: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938.\nParamters: weights: name of an edge attribute or a list containing edge \ninitial: name of a vertex attribute or a list containing the  vertex labels. Labels are identified by integers from zero to n − 1 where n is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.\nfixed: a list of booleans for each vertex. True corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be . Note that vertex attribute names are not accepted here.\nReturn: [the resulting membership vector]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_leading_eigenvector: Description: overridden in igraph.Graph\nA proper implementation of Newman's eigenvector community structure detection. Each split is done by maximizing the modularity regarding the original network. See the reference for details.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087\nParamters: n: the desired umber of commuities. If egative, the algorithm tries to do as may splits as possible. Note that the algorithm wo't split a commuity further if the sigs of the leadig eigevector are all the same.\narpack_options: an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.\nweights: name of an edge attribute or a list containing edge\nReturn: [a tuple where the first element is the membership vector of the clustering and the second element is the merge matrix.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_leiden: Description: overridden in igraph.Graph\nFinds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman.\nParamters: edge_weights: edge weights to be used. Can be a sequence or iterable or even an edge attribute name.\nnode_weights: the node weights used in the Leiden algorithm.\nresolution: the  parameter to use. Higher s lead to more smaller communities, while lower s lead to fewer larger communities.\nnormalize_resolution: if set to true, the resolution parameter will be divided by the sum of the node weights. If this is not supplied, it will default to the node degree, or weighted degree in case edge_weights are supplied.\nbeta: parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.\ninitial_membership: if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.\nn_iterations: the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. You can also set this parameter to a negative number, which means that the algorithm will be iterated until an iteration does not change the current membership vector any more.\nReturn: [the community membership vector.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_multilevel: Description: overridden in igraph.Graph\nFinds the community structure of the graph according to the multilevel algorithm of Blondel et al. This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.\nReference: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks. J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nParamters: weights: name of an edge attribute or a list containing edge \nreturn_levels: if True, returns the multilevel result. If False, only the best level (corresponding to the best modularity) is returned.\nresolution: the  parameter to use in the modularity measure. Smaller values result in a smaller number of larger clusters, while higher values yield a large number of small clusters. The classical modularity measure assumes a  parameter of 1.\nReturn: [either a single list describing the community membership of each vertex (if return_levels is False), or a list of community membership vectors, one corresponding to each level and a list of corresponding modularities (if return_levels is True).]\nReferences: []\nRasises: \nSee Also: modularity()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_optimal_modularity: Description: overridden in igraph.Graph\nCalculates the optimal modularity score of the graph and the corresponding community structure.\nThis function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.\nParamters: weights: name of an edge attribute or a list containing edge .\nReturn: [the calculated membership vector and the corresponding modularity in a tuple.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_spinglass: Description: overridden in igraph.Graph\nFinds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt.\nParamters: weights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nspins: integer, the number of  to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.\nparupdate: whether to update the spins of the vertices in parallel (synchronously) or not\nstart_temp: the starting temperature\nstop_temp: the stop temperature\ncool_fact: cooling factor for the simulated annealing\nupdate_rule: specifies the null model of the simulation. Possible values are \"config\" (a random graph with the same vertex degrees as the input graph) or \"simple\" (a random graph with the same number of edges)\ngamma: the  argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.\nimplementation: currently igraph contains two s for the spinglass community detection algorithm. The faster original  is the default. The other  is able to take into account negative weights, this can be chosen by setting  to \"neg\".\nlambda_: the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used.\nReturn: [the community membership vector.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > community_walktrap: Description: overridden in igraph.Graph\nFinds the community structure of the graph according to the random walk method of Latapy & Pons.\nThe basic idea of the algorithm is that short random walks tend to stay in the same community. The method provides a dendrogram.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106.\nParamters: weights: name of an edge attribute or a list containing edge \nsteps: Undocumented\nReturn: [a tuple with the list of merges and the modularity scores corresponding to each merge]\nReferences: []\nRasises: \nSee Also: modularity()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > complementer: Description: Returns the complementer of the graph\nParamters: loops: whether to include loop edges in the complementer.\nReturn: [the complementer of the graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > compose: Description: Returns the composition of two graphs.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > connected_components: Description: overridden in igraph.Graph\nCalculates the (strong or weak) connected components for a given graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a VertexClustering object. It is advised to use that.\nParamters: mode: must be either \"strong\" or \"weak\", depending on the clusters being sought. Optional, defaults to \"strong\".\nReturn: [the component index for every node in the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > constraint: Description: Calculates Burt's constraint scores for given vertices in a graph.\nBurt's constraint is higher if ego has less, or mutually stronger related (i.e. more redundant) contacts. Burt's measure of constraint, C[i], of vertex i's ego network V[i], is defined for directed and valued graphs as follows:\nC[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in V[], j != i)\nfor a graph of order (ie. number od vertices) N, where proportional tie strengths are defined as follows:\np[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i), a[i,j] are elements of A and the latter being the graph adjacency matrix.\nFor isolated vertices, constraint is undefined.\nParamters: vertices: the  to be analysed or None for all .\nweights:  associated to the edges. Can be an attribute name as well. If None, every edge will have the same weight.\nReturn: [constraint scores for all given vertices in a matrix.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > contract_vertices: Description: Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.\nParamters: mapping: numeric vector which gives the  between old and new vertex IDs. Vertices having the same new vertex ID in this vector will be remapped into a single new vertex. It is safe to pass the membership vector of a VertexClustering object here.\ncombine_attrs: specifies how to combine the attributes of the vertices being collapsed into a single one. If it is None, all the attributes will be lost. If it is a function, the attributes of the vertices will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed vertex. It can also be one of the following string constants which define built-in collapsing functions: sum, prod, mean, median, max, min, first, last, random. You can also specify different combination functions for different attributes by passing a dict here which maps attribute names to functions. See simplify() for more details.\nReturn: [None.]\nReferences: []\nRasises: \nSee Also: simplify()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > convergence_degree: Description: Undocumented (yet).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > convergence_field_size: Description: Undocumented (yet).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > copy: Description: Creates a copy of the graph.\nAttributes are copied by reference; in other words, if you use mutable Python objects as attribute values, these objects will still be shared between the old and new graph. You can use `deepcopy()` from the `copy` module if you need a truly deep copy of the graph.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > coreness: Description: Finds the coreness (shell index) of the vertices of the network.\nThe k-core of a graph is a maximal subgraph in which each vertex has at least degree k. (Degree here means the degree in the subgraph of course). The coreness of a vertex is k if it is a member of the k-core but not a member of the k + 1-core.\nReference: Vladimir Batagelj, Matjaz Zaversnik: An O(m) Algorithm for Core Decomposition of Networks.\nParamters: mode: whether to compute the in-corenesses (\"in\"), the out-corenesses (\"out\") or the undirected corenesses (\"all\"). Ignored and assumed to be \"all\" for undirected graphs.\nReturn: [the corenesses for each vertex.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > count_automorphisms: Description: Calculates the number of automorphisms of a graph using the BLISS isomorphism algorithm.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm and canonical permutations.\nParamters: sh: splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell\ncolor: optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same .\nReturn: [the number of automorphisms of the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > count_isomorphisms_vf2: Description: Determines the number of isomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.\nParamters: other: the  graph. If None, the number of automorphisms will be returned.\ncolor1: optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.\ncolor2: optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.\nedge_color1: optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.\nedge_color2: optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.\nnode_compat_fn: a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.\nedge_compat_fn: a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node.\nReturn: [the number of isomorphisms between the two given graphs (or the number of automorphisms if other is None.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > count_multiple: Description: Counts the multiplicities of the given edges.\nParamters: edges: edge indices for which we want to count their multiplicity. If None, all  are counted.\nReturn: [the multiplicities of the given edges as a list.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > count_subisomorphisms_vf2: Description: Determines the number of subisomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.\nParamters: other: the  graph.\ncolor1: optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.\ncolor2: optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.\nedge_color1: optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.\nedge_color2: optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.\nnode_compat_fn: a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.\nedge_compat_fn: a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node.\nReturn: [the number of subisomorphisms between the two given graphs]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > De_Bruijn: Description: Generates a de Bruijn graph with parameters (m, n)\nA de Bruijn graph represents relationships between strings. An alphabet of m letters are used and strings of length n are considered. A vertex corresponds to every possible string and there is a directed edge from vertex v to vertex w if the string of v can be transformed into the string of w by removing its first letter and appending a letter to it.\nPlease note that the graph will have mn vertices and even more edges, so probably you don't want to supply too big numbers for m and n.\nParamters: m: the size of the alphabet\nn: the legth of the strigs\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > decompose: Description: Decomposes the graph into subgraphs.\nParamters: mode: must be either \"strong\" or \"weak\", depending on the clusters being sought. Optional, defaults to \"strong\".\nmaxcompno: maximum number of components to return. None means all possible components.\nminelements: minimum number of vertices in a component. By setting this to 2, isolated vertices are not returned as separate components.\nReturn: [a list of the subgraphs. Every returned subgraph is a copy of the original.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > degree: Description: Returns some vertex degrees from the graph.\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).\nParamters: vertices: a single vertex ID or a list of vertex IDs\nmode: the type of degree to be returned (\"out\" for out-degrees, \"in\" for in-degrees or \"all\" for the sum of them).\nloops: whether self- should be counted.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Degree_Sequence: Description: Generates a graph with a given degree sequence.\nParamters: out: the -degree sequence for a directed graph. If the in-degree sequence is omitted, the generated graph will be undirected, so this will be the in-degree sequence as well\nin_: the in-degree sequence for a directed graph. If omitted, the generated graph will be undirected.\nmethod: the generation  to be used. One of the following:\"configuration\" -- simple generator that implements the stub-matching configuration model. It may generate self-loops and multiple edges. This  does not sample multigraphs uniformly, but it can be used to implement uniform sampling for simple graphs by rejecting any result that is non-simple (i.e. contains loops or multi-edges).\"fast_heur_simple\" -- similar to \"configuration\" but avoids the generation of multiple and loop edges at the expense of increased time complexity. The  will re-start the generation every time it gets stuck in a configuration where it is not possible to insert any more edges without creating loops or multiple edges, and there is no upper bound on the number of iterations, but it will succeed eventually if the input degree sequence is graphical and throw an exception if the input degree sequence is not graphical. This  does not sample simple graphs uniformly.\"configuration_simple\" -- similar to \"configuration\" but rejects generated graphs if they are not simple. This  samples simple graphs uniformly.\"edge_switching_simple\" -- an MCMC sampler based on degree-preserving edge switches. It generates simple undirected or directed graphs. The algorithm uses Graph.Realize_Degree_Sequence() to construct an initial graph, then rewires it using Graph.rewire().\"vl\" -- a more sophisticated generator that can sample undirected, connected simple graphs approximately uniformly. It uses edge-switching Monte-Carlo s to randomize the graphs. This generator should be favoured if undirected and connected graphs are to be generated and execution time is not a concern. igraph uses the original implementation of Fabien Viger; see the following URL and the paper cited on it for the details of the algorithm: https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > delete_edges: Description: overridden in igraph.Graph\nRemoves edges from the graph.\nAll vertices will be kept, even if they lose all their edges. Nonexistent edges will be silently ignored.\nParamters: es: the list of edg to be removed. Edg are identifed by edge IDs. EdgeSeq objects are also accepted here. No argument delet all edg.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > delete_vertices: Description: Deletes vertices and all its edges from the graph.\nParamters: vs: a single vertex ID or the list of vertex IDs to be deleted. No argument deletes all vertices.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > density: Description: Calculates the density of the graph.\nParamters: loops: whether to take  into consideration. If True, the algorithm assumes that there might be some  in the graph and calculates the density accordingly. If False, the algorithm assumes that there can't be any .\nReturn: [the density of the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > dfsiter: Description: Constructs a depth first search (DFS) iterator of the graph.\nParamters: vid: the root vertex ID\nmode: either \"in\" or \"out\" or \"all\".\nadvanced: if False, the iterator returns the next vertex in DFS order in every step. If True, the iterator returns the distance of the vertex from the root and the parent of the vertex in the DFS tree as well.\nReturn: [the DFS iterator as an igraph.DFSIter object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > diameter: Description: Calculates the diameter of the graph.\nParamters: directed: whether to consider  paths.\nunconn: if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result is the number of vertices if there are no weights or infinity if there are weights.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nReturn: [the diameter]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > difference: Description: Subtracts the given graph from the original\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > distances: Description: Calculates shortest path lengths for given vertices in a graph.\nThe algorithm used for the calculations is selected automatically: a simple BFS is used for unweighted graphs, Dijkstra's algorithm is used when all the weights are non-negative. Otherwise, the Bellman-Ford algorithm is used if the number of requested source vertices is smaller than 100 and Johnson's algorithm is used otherwise.\nParamters: source: a list containing the  vertex IDs which should be included in the result. If None, all vertices will be considered.\ntarget: a list containing the  vertex IDs which should be included in the result. If None, all vertices will be considered.\nweights: a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight).\nmode: the type of shortest paths to be used for the calculation in directed graphs. \"out\" means only outgoing, \"in\" means only incoming paths. \"all\" means to consider the directed graph as an undirected one.\nalgorithm: the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . \"johnson\" uses Johnson's . Ignored for unweighted graphs.\nReturn: [the shortest path lengths for given vertices in a matrix]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > diversity: Description: Calculates the structural diversity index of the vertices.\nThe structural diversity index of a vertex is simply the (normalized) Shannon entropy of the weights of the edges incident on the vertex.\nThe measure is defined for undirected graphs only; edge directions are ignored.\nReference: Eagle N, Macy M and Claxton R: Network diversity and economic development, Science 328, 1029-1031, 2010.\nParamters: vertices: the  for which the diversity indices must be returned. If None, uses all of the  in the graph.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nReturn: [the calculated diversity indices in a list, or a single number if a single vertex was supplied.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > dominator: Description: Returns the dominator tree from the given root node\nParamters: vid: the root vertex ID\nmode: either \"in\" or \"out\"\nReturn: [a list containing the dominator tree for the current graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > dyad_census: Description: overridden in igraph.Graph\nDyad census, as defined by Holland and Leinhardt\nDyad census means classifying each pair of vertices of a directed graph into three categories: mutual, there is an edge from a to b and also from b to a; asymmetric, there is an edge either from a to b or from b to a but not the other way and null, no edges between a and b.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a DyadCensus object. It is advised to use that.\nParamters: \nReturn: [the number of mutual, asymmetric and null connections in a 3-tuple.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > eccentricity: Description: Calculates the eccentricities of given vertices in a graph.\nThe eccentricity of a vertex is calculated by measuring the shortest distance from (or to) the vertex, to (or from) all other vertices in the graph, and taking the maximum.\nParamters: vertices: the  for which the eccentricity scores must be returned. If None, uses all of the  in the graph.\nmode: must be one of \"in\", \"out\" and \"all\". \"in\" means that edge directions are followed; \"out\" means that edge directions are followed the opposite direction; \"all\" means that directions are ignored. The argument has no effect for undirected graphs.\nweights: a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight).\nReturn: [the calculated eccentricities in a list, or a single number if a single vertex was supplied.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > ecount: Description: Counts the number of edges.\nParamters: \nReturn: [integerthe number of edges in the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > edge_attributes: Description: \nParamters: \nReturn: [the attribute name list of the edges of the graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > edge_betweenness: Description: Calculates or estimates the edge betweennesses in a graph.\nAlso supports calculating edge betweenness with shortest path length cutoffs or considering shortest paths only from certain source vertices or to certain target vertices.\nParamters: directed: whether to consider  paths.\ncutoff: if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness values. If None, the exact betweennesses are returned.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nsources: the set of source vertices to consider when calculating shortest paths.\ntargets: the set of target vertices to consider when calculating shortest paths.\nReturn: [a list with the (exact or estimated) edge betweennesses of all edges.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > edge_connectivity: Description: Calculates the edge connectivity of the graph or between some vertices.\nThe edge connectivity between two given vertices is the number of edges that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of edge disjoint directed paths between the vertices. The edge connectivity of the graph is the minimal edge connectivity over all vertex pairs.\nThis method calculates the edge connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall edge connectivity is returned.\nParamters: source: the  vertex involved in the calculation.\ntarget: the  vertex involved in the calculation.\nchecks: if the whole graph connectivity is calculated and this is True, igraph performs some basic  before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple  are much faster than checking the entire graph, therefore it is advised to set this to True. The parameter is ignored if the connectivity between two given vertices is computed.\nReturn: [the edge connectivity]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > eigen_adjacency: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > eigenvector_centrality: Description: Calculates the eigenvector centralities of the vertices in a graph.\nEigenvector centrality is a measure of the importance of a node in a network. It assigns relative scores to all nodes in the network based on the principle that connections from high-scoring nodes contribute more to the score of the node in question than equal connections from low-scoring nodes. In practice, the centralities are determined by calculating eigenvector corresponding to the largest positive eigenvalue of the adjacency matrix. In the undirected case, this function considers the diagonal entries of the adjacency matrix to be twice the number of self-loops on the corresponding vertex.\nIn the directed case, the left eigenvector of the adjacency matrix is calculated. In other words, the centrality of a vertex is proportional to the sum of centralities of vertices pointing to it.\nEigenvector centrality is meaningful only for connected graphs. Graphs that are not connected should be decomposed into connected components, and the eigenvector centrality calculated for each separately.\nParamters: directed: whether to consider edge directions in a  graph. Ignored for un graphs.\nscale: whether to normalize the centralities so the largest one will always be 1.\nweights: edge  given as a list or an edge attribute. If None, all edges have equal weight.\nreturn_eigenvalue: whether to return the actual largest eigenvalue along with the centralities\narpack_options: an ARPACKOptions object that can be used to fine-tune the calculation. If it is omitted, the module-level variable called  is used.\nReturn: [the eigenvector centralities in a list and optionally the largest eigenvalue (as a second member of a tuple)]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Erdos_Renyi: Description: Generates a graph based on the Erdős-Rényi model.\nParamters: n: the umber of vertices.\np: the robability of edges. If given, m must be missing.\nm: the nuber of edges. If given, p ust be issing.\ndirected: whether to generate a  graph.\nloops: whether self- are allowed.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Establishment: Description: Generates a graph based on a simple growing model with vertex types.\nA single vertex is added at each time step. This new vertex tries to connect to k vertices in the graph. The probability that such a connection is realized depends on the types of the vertices involved.\nParamters: n: the umber of vertices i the graph\nk: the number of connections tried in each step\ntype_dist: list giving the distribution of vertex types\npref_matrix: matrix (list of lists) giving the connection probabilities for different vertex types\ndirected: whether to generate a  graph.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Famous: Description: Generates a famous graph based on its name.\nSeveral famous graphs are known to igraph including (but not limited to) the Chvatal graph, the Petersen graph or the Tutte graph. This method generates one of them based on its name (case insensitive). See the documentation of the C interface of igraph for the names available: https://igraph.org/c/doc.\nParamters: name: the  of the graph to be generated.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > farthest_points: Description: Returns two vertex IDs whose distance equals the actual diameter of the graph.\nIf there are many shortest paths with the length of the diameter, it returns the first one it found.\nParamters: directed: whether to consider  paths.\nunconn: if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result contains the number of vertices if there are no weights or infinity if there are weights.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nReturn: [a triplet containing the two vertex IDs and their distance. The IDs are None if the graph is unconnected and unconn is False.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > feedback_arc_set: Description: Calculates an approximately or exactly minimal feedback arc set.\nA feedback arc set is a set of edges whose removal makes the graph acyclic. Since this is always possible by removing all the edges, we are in general interested in removing the smallest possible number of edges, or an edge set with as small total weight as possible. This method calculates one such edge set. Note that the task is trivial for an undirected graph as it is enough to find a spanning tree and then remove all the edges not in the spanning tree. Of course it is more complicated for directed graphs.\nReference: Eades P, Lin X and Smyth WF: A fast and effective heuristic for the feedback arc set problem. In: Proc Inf Process Lett 319-323, 1993.\nParamters: weights: edge  to be used. Can be a sequence or iterable or even an edge attribute name. When given, the algorithm will strive to remove lightweight edges in order to minimize the total weight of the feedback arc set.\nmethod: the algorithm to use. \"eades\" uses the greedy cycle breaking heuristic of Eades, Lin and Smyth, which is linear in the number of edges but not necessarily optimal; however, it guarantees that the number of edges to be removed is smaller than |E|/2 - |V|/6. \"ip\" uses an integer programming formulation which is guaranteed to yield an optimal result, but is too slow for large graphs.\nReturn: [the IDs of the edges to be removed, in a list.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Forest_Fire: Description: Generates a graph based on the forest fire model\nThe forest fire model is a growing graph model. In every time step, a new vertex is added to the graph. The new vertex chooses an ambassador (or more than one if ambs > 1) and starts a simulated forest fire at its ambassador(s). The fire spreads through the edges. The spreading probability along an edge is given by fwprob. The fire may also spread backwards on an edge by probability fwprob*bwfactor. When the fire ended, the newly added vertex connects to the vertices ``burned'' in the previous fire.\nParamters: n: the umber of vertices i the graph\nfw_prob: forward burning probability\nbw_factor: ratio of backward and forward burning probability\nambs: number of ambassadors chosen in each step\ndirected: whether the graph will be\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Full: Description: Generates a full graph (directed or undirected, with or without loops).\nParamters: n: the umber of vertices.\ndirected: whether to generate a  graph.\nloops: whether self- are allowed.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Full_Citation: Description: Generates a full citation graph\nA full citation graph is a graph where the vertices are indexed from 0 to n − 1 and vertex i has a directed edge towards all vertices with an index less than i.\nParamters: n: the umber of vertices.\ndirected: whether to generate a  graph.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > fundamental_cycles: Description: Finds a single fundamental cycle basis of the graph\nParamters: start_vid: when None or negative, a complete fundamental cycle basis is returned. When it is a vertex or a vertex ID, the fundamental cycles associated with the BFS tree rooted in that vertex will be returned, only for the weakly connected component containing that vertex\ncutoff: when None or negative, a complete cycle basis is returned. Otherwise the BFS is stopped after this many steps, so the result will effectively include cycles of length 2* + 1 or shorter only.\nReturn: [the cycle basis as a list of tuples containing edge IDs]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_adjacency: Description: overridden in igraph.Graph\nReturns the adjacency matrix of a graph.\nParamters: type: one of \"lower\" (uses the lower triangle of the matrix), \"upper\" (uses the upper triangle) or \"both\" (uses both parts). Ignored for directed graphs.\nloops: specifies how loop edges should be handled. False or \"ignore\" ignores loop edges. \"once\" counts each loop edge once in the diagonal. \"twice\" counts each loop edge twice (i.e. it counts the endpoints of the loop edges, not the edges themselves).\nReturn: [the adjacency matrix.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_all_shortest_paths: Description: Calculates all of the shortest paths from/to a given node in a graph.\nParamters: v: the source for the calculated paths\nto: a vertex selecr describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.\nweights: edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.\nmode: the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones.\nReturn: [all of the shortest path from the given node to every other reachable node in the graph in a list. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_biadjacency: Description: overridden in igraph.Graph\nInternal function, undocumented.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.get_biadjacency()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_diameter: Description: Returns a path with the actual diameter of the graph.\nIf there are many shortest paths with the length of the diameter, it returns the first one it founds.\nParamters: directed: whether to consider  paths.\nunconn: if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result is the number of vertices if there are no weights or infinity if there are weights.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nReturn: [the vertices in the path in order.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_edgelist: Description: Returns the edge list of a graph.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_eid: Description: Returns the edge ID of an arbitrary edge between vertices v1 and v2\nParamters: v1: the ID or name of the first vertex\nv2: the ID or name of the second vertex\ndirected: whether edge directions should be considered in  graphs. The default is True. Ignored for un graphs.\nerror: if True, an exception will be raised when the given edge does not exist. If False, -1 will be returned in that case.\nReturn: [the edge ID of an arbitrary edge between vertices v1 and v2]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_eids: Description: Returns the edge IDs of some edges between some vertices.\nThe method does not consider multiple edges; if there are multiple edges between a pair of vertices, only the ID of one of the edges is returned.\nParamters: pairs: a list of integer . Each integer pair is considered as a source-target vertex pair; the corresponding edge is looked up in the graph and the edge ID is returned for each pair.\ndirected: whether edge directions should be considered in  graphs. The default is True. Ignored for un graphs.\nerror: if True, an exception will be raised if a given edge does not exist. If False, -1 will be returned in that case.\nReturn: [the edge IDs in a list]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_isomorphisms_vf2: Description: Returns all isomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.\nParamters: other: the  graph. If None, the automorphisms will be returned.\ncolor1: optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.\ncolor2: optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.\nedge_color1: optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.\nedge_color2: optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.\nnode_compat_fn: a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.\nedge_compat_fn: a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node.\nReturn: [a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_k_shortest_paths: Description: Calculates the k shortest paths from/to a given node in a graph.\nParamters: v: the ID or name of the ertex from which the paths are calculated.\nto: the ID or name of the vertex  which the paths are calculated.\nk: the desired number of shortest path\nweights: edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.\nmode: the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones.\noutput: determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned, one path for each target vertex. For unconnected graphs, some of the list elements may be empty. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order. If =\"epath\", edge IDs are returned instead of vertex IDs.\nReturn: [the k shortest paths from the given source node to the given target node in a list of vertex or edge IDs (depending on the value of the output argument). Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_shortest_path: Description: Calculates the shortest path from a source vertex to a target vertex in a graph.\nParamters: v: the source ertex of the path\nto: the target vertex of the path\nweights: edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.\nmode: the directionality of the paths. \"out\" means to calculate paths from source to target, following edges according to their natural direction. \"in\" means to calculate paths from target to source, flipping the direction of each edge on-the-fly. \"all\" means to ignore edge directions.\noutput: determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned. If this is \"epath\", edge IDs are returned instead of vertex IDs.\nalgorithm: the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . Ignored for unweighted graphs.\nReturn: [see the documentation of the output parameter.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_shortest_path_astar: Description: Calculates the shortest path from a source vertex to a target vertex in a graph using the A-Star algorithm and a heuristic function.\nParamters: v: the source ertex of the path\nto: the target vertex of the path\nheuristics: a function that will be called with the graph and two vertices, and must return an estimate of the cost of the path from the first vertex to the second vertex. The A-Star algorithm is guaranteed to return an optimal solution if the heuristic is admissible, i.e. if it does never overestimate the cost of the shortest path from the given source vertex to the given target vertex.\nweights: edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.\nmode: the directionality of the paths. \"out\" means to calculate paths from source to target, following edges according to their natural direction. \"in\" means to calculate paths from target to source, flipping the direction of each edge on-the-fly. \"all\" means to ignore edge directions.\noutput: determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned. If this is \"epath\", edge IDs are returned instead of vertex IDs.\nReturn: [see the documentation of the output parameter.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_shortest_paths: Description: Calculates the shortest paths from/to a given node in a graph.\nParamters: v: the source/destination for the calculated paths\nto: a vertex selecr describing the destination/source for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.\nweights: edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.\nmode: the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones.\noutput: determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned, one path for each target vertex. For unconnected graphs, some of the list elements may be empty. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order. If =\"epath\", edge IDs are returned instead of vertex IDs.\nalgorithm: the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . Ignored for unweighted graphs.\nReturn: [see the documentation of the output parameter.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_subisomorphisms_lad: Description: Returns all subisomorphisms between the graph and another one using the LAD algorithm.\nThe optional domains argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.\nParamters: other: the pattern graph we are looking for in the graph.\ndomains: a list of lists, one sublist belonging to each vertex in the template graph. Sublist i contains the indices of the vertices in the original graph that may match vertex i in the template graph. None means that every vertex may match every other vertex.\ninduced: whether to consider  subgraphs only.\ntime_limit: an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception.\nReturn: [a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > get_subisomorphisms_vf2: Description: Returns all subisomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.\nParamters: other: the  graph.\ncolor1: optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.\ncolor2: optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.\nedge_color1: optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.\nedge_color2: optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.\nnode_compat_fn: a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.\nedge_compat_fn: a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node.\nReturn: [a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > girth: Description: Returns the girth of the graph.\nThe girth of a graph is the length of the shortest circle in it.\nParamters: return_shortest_circle: whether to return one of the shortest circles found in the graph.\nReturn: [the length of the shortest circle or (if return_shortest_circle) is true, the shortest circle itself as a list]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > gomory_hu_tree: Description: overridden in igraph.Graph\nInternal function, undocumented.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.gomory_hu_tree()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Growing_Random: Description: Generates a growing random graph.\nParamters: n: The umber of vertices i the graph\nm: The nuber of edges to add in each step (after adding a new vertex)\ndirected: whether the graph should be .\ncitation: whether the new edges should originate from the most recently added vertex.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > harmonic_centrality: Description: Calculates the harmonic centralities of given vertices in a graph.\nThe harmonic centrality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the mean inverse distance to all other vertices.\nIf the graph is not connected, and there is no path between two vertices, the inverse distance is taken to be zero.\nParamters: vertices: the  for which the harmonic centrality must be returned. If None, uses all of the  in the graph.\nmode: must be one of \"in\", \"out\" and \"all\". \"in\" means that the length of the incoming paths, \"out\" means that the length of the outgoing paths must be calculated. \"all\" means that both of them must be calculated.\ncutoff: if it is not None, only paths less than or equal to this length are considered.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nnormalized: Whether to normalize the result. If True, the result is the mean inverse path length to other vertices, i.e. it is  by the number of vertices minus one. If False, the result is the sum of inverse path lengths to other vertices.\nReturn: [the calculated harmonic centralities in a list]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > has_multiple: Description: Checks whether the graph has multiple edges.\nParamters: \nReturn: [booleanTrue if the graph has at least one multiple edge, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Hexagonal_Lattice: Description: Generates a regular hexagonal lattice.\nParamters: dim: list with the ensions of the lattice\ndirected: whether to create a  graph.\nmutual: whether to create all connections as  in case of a directed graph.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > hub_score: Description: Calculates Kleinberg's hub score for the vertices of the graph\nParamters: weights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nscale: whether to normalize the scores so that the largest one is 1.\narpack_options: an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.\nreturn_eigenvalue: whether to return the largest eigenvalue\nReturn: [the hub scores in a list and optionally the largest eigenvalue as a second member of a tuple]\nReferences: []\nRasises: \nSee Also: authority_score()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > incident: Description: Returns the edges a given vertex is incident on.\nParamters: vertex: a  ID\nmode: whether to return only successors (\"out\"), predecessors (\"in\") or both (\"all\"). Ignored for undirected graphs.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > independence_number: Description: Returns the independence number of the graph.\nThe independence number of the graph is the size of the largest independent vertex set.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: largest_independent_vertex_sets() for the largest independent vertex sets\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > independent_vertex_sets: Description: Returns some or all independent vertex sets of the graph as a list of tuples.\nTwo vertices are independent if there is no edge between them. Members of an independent vertex set are mutually independent.\nParamters: min: the imum size of sets to be returned. If zero or negative, no lower bound will be used.\nmax: the imum size of sets to be returned. If zero or negative, no upper bound will be used.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > induced_subgraph: Description: Returns a subgraph spanned by the given vertices.\nParamters: vertices: a list containing the vertex IDs which should be included in the result.\nimplementation: the  to use when constructing the new subgraph. igraph includes two s at the moment. \"copy_and_delete\" copies the original graph and removes those vertices that are not in the given set. This is more efficient if the size of the subgraph is comparable to the original graph. The other  (\"create_from_scratch\") constructs the result graph from scratch and then copies the attributes accordingly. This is a better solution if the subgraph is relatively small, compared to the original graph. \"auto\" selects between the two s automatically, based on the ratio of the size of the subgraph and the size of the original graph.\nReturn: [the subgraph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_acyclic: Description: Returns whether the graph is acyclic (i.e. contains no cycles).\nParamters: \nReturn: [booleanTrue if the graph is acyclic, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_biconnected: Description: Decides whether the graph is biconnected.\nA graph is biconnected if it stays connected after the removal of any single vertex.\nNote that there are different conventions in use about whether to consider a graph consisting of two connected vertices to be biconnected. igraph does consider it biconnected.\nParamters: \nReturn: [booleanTrue if it is biconnected, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_bipartite: Description: Decides whether the graph is bipartite or not.\nVertices of a bipartite graph can be partitioned into two groups A and B in a way that all edges go between the two groups.\nParamters: return_types: if False, the method will simply return True or False depending on whether the graph is bipartite or not. If True, the actual group assignments are also returned as a list of boolean values. (Note that the group assignment is not unique, especially if the graph consists of multiple components, since the assignments of components are independent from each other).\nReturn: [True if the graph is bipartite, False if not. If return_types is True, the group assignment is also returned.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_chordal: Description: Returns whether the graph is chordal or not.\nA graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.\nParamters: alpha: the  vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the  vector; simply passing None here will make igraph calculate the  vector on its own.\nalpham1: the inverse alpha vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the inverse alpha vector; simply passing None here will make igraph calculate the inverse alpha vector on its own.\nReturn: [True if the graph is chordal, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_connected: Description: Decides whether the graph is connected.\nParamters: mode: whether we should calculate strong or weak connectivity.\nReturn: [True if the graph is connected, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_dag: Description: Checks whether the graph is a DAG (directed acyclic graph).\nA DAG is a directed graph with no directed cycles.\nParamters: \nReturn: [booleanTrue if it is a DAG, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_directed: Description: Checks whether the graph is directed.\nParamters: \nReturn: [booleanTrue if it is directed, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_loop: Description: Checks whether a specific set of edges contain loop edges\nParamters: edges: edge indices which we want to check. If None, all  are checked.\nReturn: [a list of booleans, one for every edge given]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_minimal_separator: Description: Decides whether the given vertex set is a minimal separator.\nA minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.\nParamters: vertices: a single vertex ID or a list of vertex IDs\nReturn: [True is the given vertex set is a minimal separator, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_multiple: Description: Checks whether an edge is a multiple edge.\nAlso works for a set of edges -- in this case, every edge is checked one by one. Note that if there are multiple edges going between a pair of vertices, there is always one of them that is not reported as multiple (only the others). This allows one to easily detect the edges that have to be deleted in order to make the graph free of multiple edges.\nParamters: edges: edge indices which we want to check. If None, all  are checked.\nReturn: [a list of booleans, one for every edge given]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_mutual: Description: Checks whether an edge has an opposite pair.\nAlso works for a set of edges -- in this case, every edge is checked one by one. The result will be a list of booleans (or a single boolean if only an edge index is supplied), every boolean corresponding to an edge in the edge set supplied. True is returned for a given edge a --> b if there exists another edge b --> a in the original graph (not the given edge set!). All edges in an undirected graph are mutual. In case there are multiple edges between a and b, it is enough to have at least one edge in either direction to report all edges between them as mutual, so the multiplicity of edges do not matter.\nParamters: edges: edge indices which we want to check. If None, all  are checked.\nloops: specifies whether loop edges should be treated as mutual in a directed graph.\nReturn: [a list of booleans, one for every edge given]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_separator: Description: Decides whether the removal of the given vertices disconnects the graph.\nParamters: vertices: a single vertex ID or a list of vertex IDs\nReturn: [True is the given vertex set is a separator, False if not.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_simple: Description: Checks whether the graph is simple (no loop or multiple edges).\nParamters: \nReturn: [booleanTrue if it is simple, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > is_tree: Description: Checks whether the graph is a (directed or undirected) tree graph.\nFor directed trees, the function may require that the edges are oriented outwards from the root or inwards to the root, depending on the value of the mode argument.\nParamters: mode: for directed graphs, specifies how the edge directions should be taken into account. \"all\" means that the edge directions must be ignored, \"out\" means that the edges must be oriented away from the root, \"in\" means that the edges must be oriented towards the root. Ignored for undirected graphs.\nReturn: [booleanTrue if the graph is a tree, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Isoclass: Description: Generates a graph with a given isomorphism class.\nCurrently we support directed graphs of size 3 and 4, and undirected graphs of size 3, 4, 5 or 6. Use the isoclass() instance method to find the isomorphism class of a given graph.\nParamters: n: the umber of vertices i the graph\ncls: the isomorphism class\ndirected: whether the graph should be .\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > isoclass: Description: Returns the isomorphism class of the graph or its subgraph.\nIsomorphism class calculations are implemented only for directed graphs with 3 or 4 vertices, or undirected graphs with 3, 4, 5 or 6 vertices..\nParamters: vertices: a list of  if we want to calculate the isomorphism class for only a subset of . None means to use the full graph.\nReturn: [the isomorphism class of the (sub)graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > isomorphic: Description: Checks whether the graph is isomorphic to another graph.\nThe algorithm being used is selected using a simple heuristic:If one graph is directed and the other undirected, an exception is thrown.If the two graphs does not have the same number of vertices and edges, it returns with FalseIf the graphs have three or four vertices, then an O(1) algorithm is used with precomputed data.Otherwise if the graphs are directed, then the VF2 isomorphism algorithm is used (see isomorphic_vf2).Otherwise the BLISS isomorphism algorithm is used, see isomorphic_bliss.\nParamters: \nReturn: [True if the graphs are isomorphic, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > isomorphic_bliss: Description: Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm.\nParamters: other: the  graph with which we want to compare the graph.\nreturn_mapping_12: if True, calculates the mapping which maps the vertices of the first graph to the second.\nreturn_mapping_21: if True, calculates the mapping which maps the vertices of the second graph to the first.\nsh1: splitting heuristics for the first graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell\nsh2: splitting heuristics to be used for the second graph. This must be the same as sh1; alternatively, it can be None, in which case it will automatically use the same value as sh1. Currently it is present for backwards compatibility only.\ncolor1: optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.\ncolor2: optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.\nReturn: [if no mapping is calculated, the result is True if the graphs are isomorphic, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > isomorphic_vf2: Description: Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.\nParamters: other: the  graph with which we want to compare the graph. If None, the automorphjisms of the graph will be tested.\ncolor1: optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.\ncolor2: optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.\nedge_color1: optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.\nedge_color2: optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.\nreturn_mapping_12: if True, calculates the mapping which maps the vertices of the first graph to the second.\nreturn_mapping_21: if True, calculates the mapping which maps the vertices of the second graph to the first.\nnode_compat_fn: a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.\nedge_compat_fn: a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node.\ncallback: if not None, the isomorphism search will not stop at the first match; it will call this  function instead for every isomorphism found. The  function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return True if the search should continue or False otherwise.\nReturn: [if no mapping is calculated, the result is True if the graphs are isomorphic, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > K_Regular: Description: Generates a k-regular random graph\nA k-regular random graph is a random graph where each vertex has degree k. If the graph is directed, both the in-degree and the out-degree of each vertex will be k.\nParamters: n: The umber of vertices i the graph\nk: The degree of each vertex if the graph is undirected, or the in-degree and out-degree of each vertex if the graph is directed\ndirected: whether the graph should be .\nmultiple: whether it is allowed to create  edges.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Kautz: Description: Generates a Kautz graph with parameters (m, n)\nA Kautz graph is a labeled graph, vertices are labeled by strings of length n + 1 above an alphabet with m + 1 letters, with the restriction that every two consecutive letters in the string must be different. There is a directed edge from a vertex v to another vertex w if it is possible to transform the string of v into the string of w by removing the first letter and appending a letter to it.\nParamters: m: the size of the alphabet inus one\nn: the legth of the strigs mius oe\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > knn: Description: Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.\nParamters: vids: the vertices for which the calculation is performed. None means all vertices.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name. If this is given, the vertex strength will be used instead of the vertex degree in the calculations, but the \"ordinary\" vertex degree will be used for the second (degree- dependent) list in the result.\nReturn: [two lists in a tuple. The first list contains the average degree of neighbors for each vertex, the second contains the average degree of neighbors as a function of vertex degree. The zeroth element of this list corresponds to vertices of degree 1.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > laplacian: Description: Returns the Laplacian matrix of a graph.\nThe Laplacian matrix is similar to the adjacency matrix, but the edges are denoted with -1 and the diagonal contains the node degrees.\nSymmetric normalized Laplacian matrices have 1 or 0 in their diagonals (0 for vertices with no edges), edges are denoted by 1 / sqrt(d_i * d_j) where d_i is the degree of node i.\nLeft-normalized and right-normalized Laplacian matrices are derived from the unnormalized Laplacian by scaling the row or the column sums to be equal to 1.\nParamters: weights: edge  to be used. Can be a sequence or iterable or even an edge attribute name. When edge  are used, the degree of a node is considered to be the sum of the  of its incident edges.\nnormalized: whether to return the  Laplacian matrix. False or \"un\" returns the un Laplacian matrix. True or \"symmetric\" returns the symmetric normalization of the Laplacian matrix. \"left\" returns the left-, \"right\" returns the right- Laplacian matrix.\nmode: for directed graphs, specifies whether to use out- or in-degrees in the Laplacian matrix. \"all\" means that the edge directions must be ignored, \"out\" means that the out-degrees should be used, \"in\" means that the in-degrees should be used. Ignored for undirected graphs.\nReturn: [the Laplacian matrix.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > largest_cliques: Description: Returns the largest cliques of the graph as a list of tuples.\nQuite intuitively a clique is considered largest if there is no clique with more vertices in the whole graph. All largest cliques are maximal (i.e. nonextendable) but not all maximal cliques are largest.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: clique_number() for the size of the largest cliques or maximal_cliques() for the maximal cliques\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > largest_independent_vertex_sets: Description: Returns the largest independent vertex sets of the graph as a list of tuples.\nQuite intuitively an independent vertex set is considered largest if there is no other set with more vertices in the whole graph. All largest sets are maximal (i.e. nonextendable) but not all maximal sets are largest.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: independence_number() for the size of the largest independent vertex sets or maximal_independent_vertex_sets() for the maximal (nonextendable) independent vertex sets\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Lattice: Description: Generates a regular square lattice.\nParamters: dim: list with the ensions of the lattice\nnei: value giving the distance (number of steps) within which two vertices will be connected.\ndirected: whether to create a  graph.\nmutual: whether to create all connections as  in case of a directed graph.\ncircular: whether the generated lattice is periodic. May also be an iterable; in this case, the iterator is assumed to yield booleans that specify whether the lattice is periodic along each dimension.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_bipartite: Description: Place the vertices of a bipartite graph in two layers.\nThe layout is created by placing the vertices in two rows, according to their types. The positions of the vertices within the rows are then optimized to minimize the number of edge crossings using the heuristic used by the Sugiyama layout algorithm.\nParamters: types: an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.\nhgap: minimum horizontal gap between vertices in the same layer.\nvgap: vertical gap between the two layers.\nmaxiter: maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_circle: Description: Places the vertices of the graph uniformly on a circle or a sphere.\nParamters: dim: the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.\norder: the  in which the vertices are placed along the circle. Not supported when dim is not equal to 2.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_davidson_harel: Description: Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.\nThe algorithm uses simulated annealing and a sophisticated energy function, which is unfortunately hard to parameterize for different graphs. The original publication did not disclose any parameter values, and the ones below were determined by experimentation.\nThe algorithm consists of two phases: an annealing phase and a fine-tuning phase. There is no simulated annealing in the second phase.\nParamters: seed: if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.\nmaxiter: Number of iterations to perform in the annealing phase.\nfineiter: Number of iterations to perform in the fine-tuning phase. Negative numbers set up a reasonable default from the base-2 logarithm of the vertex count, bounded by 10 from above.\ncool_fact: Cooling factor of the simulated annealing phase.\nweight_node_dist: Weight for the node-node distances in the energy function.\nweight_border: Weight for the distance from the border component of the energy function. Zero means that vertices are allowed to sit on the border of the area designated for the layout.\nweight_edge_lengths: Weight for the edge length component of the energy function. Negative numbers are replaced by the density of the graph divided by 10.\nweight_edge_crossings: Weight for the edge crossing component of the energy function. Negative numbers are replaced by one minus the square root of the density of the graph.\nweight_node_edge_dist: Weight for the node-edge distance component of the energy function. Negative numbers are replaced by 0.2 minus 0.2 times the density of the graph.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_drl: Description: Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.\nThis is an algorithm suitable for quite large graphs, but it can be surprisingly slow for small ones (where the simpler force-based layouts like layout_kamada_kawai() or layout_fruchterman_reingold() are more useful.\nParamters: weights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nfixed: ignored. We used to assume that the DrL layout supports  nodes, but later it turned out that the argument has no effect in the original DrL code. We kept the argument for sake of backwards compatibility, but it will have no effect on the final layout.\nseed: if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.\noptions: if you give a string argument here, you can select from five default preset parameterisations: default, coarsen for a coarser layout, coarsest for an even coarser layout, refine for refining an existing layout and final for finalizing a layout. If you supply an object that is not a string, the DrL layout parameters are retrieved from the respective keys of the object (so it should be a dict or something else that supports the mapping protocol). The following keys can be used:edge_cut: edge cutting is done in the late stages of the algorithm in order to achieve less dense layouts. Edges are cut if there is a lot of stress on them (a large value in the objective function sum). The edge cutting parameter is a value between 0 and 1 with 0 representing no edge cutting and 1 representing maximal edge cutting.init_iterations: number of iterations in the initialization phaseinit_temperature: start temperature during initializationinit_attraction: attraction during initializationinit_damping_mult: damping multiplier during initializationliquid_iterations, liquid_temperature, liquid_attraction, liquid_damping_mult: same parameters for the liquid phaseexpansion_iterations, expansion_temperature, expansion_attraction, expansion_damping_mult: parameters for the expansion phasecooldown_...: parameters for the cooldown phasecrunch_...: parameters for the crunch phasesimmer_...: parameters for the simmer phaseInstead of a mapping, you can also use an arbitrary Python object here: if the object does not support the mapping protocol, an attribute of the object with the same name is looked up instead. If a parameter cannot be found either as a key or an attribute, the default from the default preset will be used.\ndim: the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_fruchterman_reingold: Description: Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.\nThis is a force directed layout, see Fruchterman, T. M. J. and Reingold, E. M.: Graph Drawing by Force-directed Placement. Software -- Practice and Experience, 21/11, 1129--1164, 1991\nParamters: weights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nniter: the number of iterations to perform. The default is 500.\nseed: if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.\nstart_temp: Real scalar, the start temperature. This is the maximum amount of movement alloved along one axis, within one step, for a vertex. Currently it is decreased linearly to zero during the iteration. The default is the square root of the number of vertices divided by 10.\nminx: if not None, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.\nmaxx: similar to minx, but with maximum constraints\nminy: similar to minx, but with the Y coordinates\nmaxy: similar to maxx, but with the Y coordinates\nminz: similar to minx, but with the Z coordinates. Use only for 3D layouts (dim=3).\nmaxz: similar to maxx, but with the Z coordinates. Use only for 3D layouts (dim=3).\ngrid: whether to use a faster, but less accurate -based implementation of the algorithm. \"auto\" decides based on the number of vertices in the graph; a  will be used if there are at least 1000 vertices. \"\" is equivalent to True, \"no\" is equivalent to False.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_graphopt: Description: This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.\ngraphopt uses physical analogies for defining attracting and repelling forces among the vertices and then the physical system is simulated until it reaches an equilibrium or the maximal number of iterations is reached.\nSee http://www.schmuhl.org/graphopt/ for the original graphopt.\nParamters: niter: the number of iterations to perform. Should be a couple of hundred in general.\nnode_charge: the charge of the vertices, used to calculate electric repulsion.\nnode_mass: the mass of the vertices, used for the spring forces\nspring_length: the length of the springs\nspring_constant: the spring constant\nmax_sa_movement: the maximum amount of movement allowed in a single step along a single axis.\nseed: a matrix containing a  layout from which the algorithm will be started. If None, a random layout will be used.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_grid: Description: Places the vertices of a graph in a 2D or 3D grid.\nParamters: width: the number of vertices in a single row of the layout. Zero or negative numbers mean that the  should be determined automatically.\nheight: the number of vertices in a single column of the layout. Zero or negative numbers mean that the  should be determined automatically. It must not be given if the number of dimensions is 2.\ndim: the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_kamada_kawai: Description: Places the vertices on a plane according to the Kamada-Kawai algorithm.\nThis is a force directed layout, see Kamada, T. and Kawai, S.: An Algorithm for Drawing General Undirected Graphs. Information Processing Letters, 31/1, 7--15, 1989.\nParamters: maxiter: the maximum number of iterations to perform. None selects a reasonable default based on the number of vertices.\nepsilon: quit if the energy of the system changes less than . See the original paper for details.\nkkconst: the Kamada-Kawai vertex attraction constant. None means the number of vertices.\nseed: when None, uses a circular layout as a starting point for the algorithm when no bounds are given, or a random layout when bounds are specified for the coordinated. When the argument is a matrix (list of lists), it uses the given matrix as the initial layout.\nminx: if not None, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.\nmaxx: similar to minx, but with maximum constraints\nminy: similar to minx, but with the Y coordinates\nmaxy: similar to maxx, but with the Y coordinates\nminz: similar to minx, but with the Z coordinates. Use only for 3D layouts (dim=3).\nmaxz: similar to maxx, but with the Z coordinates. Use only for 3D layouts (dim=3).\ndim: the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_lgl: Description: Places the vertices on a 2D plane according to the Large Graph Layout.\nParamters: maxiter: the number of iterations to perform.\nmaxdelta: the maximum distance to move a vertex in an iteration. If negative, defaults to the number of vertices.\narea: the  of the square on which the vertices will be placed. If negative, defaults to the number of vertices squared.\ncoolexp: the cooling exponent of the simulated annealing.\nrepulserad: determines the radius at which vertex-vertex repulsion cancels out attraction of adjacent vertices. If negative, defaults to area times the number of vertices.\ncellsize: the size of the grid cells. When calculating the repulsion forces, only vertices in the same or neighboring grid cells are taken into account. Defaults to the fourth root of area.\nroot: the  vertex, this is placed first, its neighbors in the first iteration, second neighbors in the second, etc. None means that a random vertex will be chosen.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_mds: Description: Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.\nThis layout requires a distance matrix, where the intersection of row i and column j specifies the desired distance between vertex i and vertex j. The algorithm will try to place the vertices in a way that approximates the distance relations prescribed in the distance matrix. igraph uses the classical multidimensional scaling by Torgerson (see reference below).\nFor unconnected graphs, the method will decompose the graph into weakly connected components and then lay out the components individually using the appropriate parts of the distance matrix.\nReference: Cox & Cox: Multidimensional Scaling (1994), Chapman and Hall, London.\nParamters: dist: the ance matrix. It must be symmetric and the symmetry is not checked -- results are unspecified when a non-symmetric ance matrix is used. If this parameter is None, the shortest path lengths will be used as ances. Directed graphs are treated as undirected when calculating the shortest path lengths to ensure symmetry.\ndim: the number of ensions. For 2D layouts, supply 2 here; for 3D layouts, supply 3.\narpack_options: an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_random: Description: Places the vertices of the graph randomly.\nParamters: dim: the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.\nReturn: [the coordinate pairs in a list.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_reingold_tilford: Description: Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.\nThis is a tree layout. If the given graph is not a tree, a breadth-first search is executed first to obtain a possible spanning tree.\nReference: EM Reingold, JS Tilford: Tidier Drawings of Trees. IEEE Transactions on Software Engineering 7:22, 223-228, 1981.\nParamters: mode: specifies which edges to consider when builing the tree. If it is OUT then only the outgoing, if it is IN then only the incoming edges of a parent are considered. If it is ALL then all edges are used (this was the behaviour in igraph 0.5 and before). This parameter also influences how the root vertices are calculated if they are not given. See the root parameter.\nroot: the index of the  vertex or  vertices. If this is a non-empty vector then the supplied vertex IDs are used as the s of the trees (or a single tree if the graph is connected). If this is None or an empty list, the  vertices are automatically calculated in such a way so that all other vertices would be reachable from them. Currently, automatic  selection prefers low eccentricity vertices in small graphs (fewer than 500 vertices) and high degree vertices in large graphs. This heuristic may change in future versions. Specify s manually for a consistent output.\nrootlevel: this argument is useful when drawing forests which are not trees. It specifies the level of the root vertices for every tree in the forest.\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: layout_reingold_tilford_circular\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_reingold_tilford_circular: Description: Circular Reingold-Tilford layout for trees.\nThis layout is similar to the Reingold-Tilford layout, but the vertices are placed in a circular way, with the root vertex in the center.\nSee layout_reingold_tilford for the explanation of the parameters.\nReference: EM Reingold, JS Tilford: Tidier Drawings of Trees. IEEE Transactions on Software Engineering 7:22, 223-228, 1981.\nParamters: \nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: layout_reingold_tilford\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_star: Description: Calculates a star-like layout for the graph.\nParamters: center: the ID of the vertex to put in the \norder: a numeric vector giving the  of the vertices (including the center vertex!). If it is None, the vertices will be placed in increasing vertex ID .\nReturn: [the calculated layout.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > layout_umap: Description: Uniform Manifold Approximation and Projection (UMAP).\nThis layout is a probabilistic algorithm that places vertices that are connected and have a short distance close by in the embedded space.\nReference: L McInnes, J Healy, J Melville: UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. arXiv:1802.03426.\nParamters: dist: ances associated with the graph edges. If None, all edges will be assumed to convey the same ance between the vertices. Either this argument of the weights argument can be set, but not both. It is fine to set neither.\nweights: precomputed edge  if you have them, as an alternative to setting the dist argument. Zero  will be ignored if this argument is set, e.g. if you computed the  via igraph.umap_compute_().\ndim: the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.\nseed: if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.\nmin_dist: the minimal distance in the embedded space beyond which the probability of being located closeby decreases.\nepochs: the number of  (iterations) the algorithm will iterate over. Accuracy increases with more , at the cost of longer runtimes. Values between 50 and 1000 are typical. Notice that UMAP does not technically converge for symmetry reasons, but a larger number of  should generally give an equivalent or better layout.\nReturn: [the calculated layout.\nPlease note that if distances are set, the graph is usually directed, whereas if weights are precomputed, the graph will be treated as undirected. A special case is when the graph is directed but the precomputed weights are symmetrized in a way only one of each pair of opposite edges has nonzero weight, e.g. as computed by igraph.umap_compute_weights(). For example: weights = igraph.umap_compute_weights(graph, dist) layout = graph.layout_umap(weights=weights)\n]\nReferences: []\nRasises: \nSee Also: igraph.umap_compute_weights()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > LCF: Description: Generates a graph from LCF notation.\nLCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for 3-regular Hamiltonian graphs. It consists of three parameters, the number of vertices in the graph, a list of shifts giving additional edges to a cycle backbone and another integer giving how many times the shifts should be performed. See http://mathworld.wolfram.com/LCFNotation.html for details.\nParamters: n: the umber of vertices\nshifts: the  in a list or tuple\nrepeats: the number of\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > linegraph: Description: Returns the line graph of the graph.\nThe line graph L(G) of an undirected graph is defined as follows: L(G) has one vertex for each edge in G and two vertices in L(G) are connected iff their corresponding edges in the original graph share an end point.\nThe line graph of a directed graph is slightly different: two vertices are connected by a directed edge iff the target of the first vertex's corresponding edge is the same as the source of the second vertex's corresponding edge.\nEdge i in the original graph will map to vertex i of the line graph.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > list_triangles: Description: Lists the triangles of the graph\nParamters: \nReturn: [the list of triangles in the graph; each triangle is represented by a tuple of length 3, containing the corresponding vertex IDs.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > maxdegree: Description: Returns the maximum degree of a vertex set in the graph.\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).\nParamters: vertices: a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.\nmode: the type of degree to be returned (\"out\" for out-degrees, \"in\" IN for in-degrees or \"all\" for the sum of them).\nloops: whether self- should be counted.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > maxflow: Description: overridden in igraph.Graph\nReturns the maximum flow between the source and target vertices.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a Flow object. It is advised to use that.\nParamters: source: the  vertex ID\ntarget: the  vertex ID\ncapacity: the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same .\nReturn: [a tuple containing the following: the value of the maximum flow between the given vertices, the flow value on all the edges, the edge IDs that are part of the corresponding minimum cut, and the vertex IDs on one side of the cut. For directed graphs, the flow value vector gives the flow value on each edge. For undirected graphs, the flow value is positive if the flow goes from the smaller vertex ID to the bigger one and negative if the flow goes from the bigger vertex ID to the smaller.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > maxflow_value: Description: Returns the value of the maximum flow between the source and target vertices.\nParamters: source: the  vertex ID\ntarget: the  vertex ID\ncapacity: the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same .\nReturn: [the value of the maximum flow between the given vertices]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > maximal_cliques: Description: Returns the maximal cliques of the graph as a list of tuples.\nA maximal clique is a clique which can't be extended by adding any other vertex to it. A maximal clique is not necessarily one of the largest cliques in the graph.\nParamters: min: the imum size of maximal cliques to be returned. If zero or negative, no lower bound will be used.\nmax: the imum size of imal cliques to be returned. If zero or negative, no upper bound will be used. If nonzero, the size of every imal clique found will be compared to this value and a clique will be returned only if its size is smaller than this limit.\nfile: a  object or the name of the  to write the results to. When this argument is None, the maximal cliques will be returned as a list of lists.\nReturn: [the maximal cliques of the graph as a list of lists, or None if the file argument was given.@see: largest_cliques() for the largest cliques.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > maximal_independent_vertex_sets: Description: Returns the maximal independent vertex sets of the graph as a list of tuples.\nA maximal independent vertex set is an independent vertex set which can't be extended by adding any other vertex to it. A maximal independent vertex set is not necessarily one of the largest independent vertex sets in the graph.\nReference: S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka: A new algorithm for generating all the maximal independent sets. SIAM J Computing, 6:505-517, 1977.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: largest_independent_vertex_sets() for the largest independent vertex sets\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > maximum_cardinality_search: Description: Conducts a maximum cardinality search on the graph. The function computes a rank alpha for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.\nMaximum cardinality search is useful in deciding the chordality of a graph: a graph is chordal if and only if any two neighbors of a vertex that are higher in rank than the original vertex are connected to each other.\nThe result of this function can be passed to is_chordal() to speed up the chordality computation if you also need the result of the maximum cardinality search for other purposes.\nParamters: \nReturn: [a tuple consisting of the rank vector and its inverse.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > mincut: Description: overridden in igraph.Graph\nCalculates the minimum cut between the source and target vertices or within the whole graph.\nThe minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if the source and target are not given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated. For undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a Cut object. It is advised to use that.\n\nParamters: source: the  vertex ID. If None, target must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).\ntarget: the  vertex ID. If None, source must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).\ncapacity: the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same .\nReturn: [the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple]\nReferences: [M. Stoer, F. Wagner: A simple min-cut algorithm. Journal of the ACM 44(4):585-591, 1997.A. V. Goldberg, R. E. Tarjan: A new approach to the maximum-flow problem. Journal of the ACM 35(4):921-940, 1988.]\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > mincut_value: Description: Returns the minimum cut between the source and target vertices or within the whole graph.\nParamters: source: the  vertex ID. If negative, the calculation is done for every vertex except the target and the minimum is returned.\ntarget: the  vertex ID. If negative, the calculation is done for every vertex except the source and the minimum is returned.\ncapacity: the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same .\nReturn: [the value of the minimum cut between the given vertices]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > minimum_cycle_basis: Description: Computes a minimum cycle basis of the graph\nParamters: cutoff: when None or negative, a complete minimum cycle basis is returned. Otherwise only those cycles in the result will be part of some minimum cycle basis that are of length 2* + 1 or shorter. Cycles longer than this limit may not be of the smallest possible size. This parameter effectively limits the depth of the BFS tree when computing candidate cycles and may speed up the computation substantially.\ncomplete: used only when a cutoff is specified, and in this case it specifies whether a  basis is returned (True) or the result will be limited to cycles of length 2*cutoff + 1 or shorter only. This limits computation time, but the result may not span the entire cycle space.\nuse_cycle_order: if True, every cycle is returned in natural order: the edge IDs will appear ordered along the cycle. If False, no guarantees are given about the ordering of edge IDs within cycles.\nReturn: [the cycle basis as a list of tuples containing edge IDs]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > minimum_size_separators: Description: Returns a list containing all separator vertex sets of minimum size.\nA vertex set is a separator if its removal disconnects the graph. This method lists all the separators for which no smaller separator set exists in the given graph.\nReference: Arkady Kanevsky: Finding all minimum-size separating vertex sets in a graph. Networks 23:533-541, 1993.\nParamters: \nReturn: [a list where each item lists the vertex indices of a given separator of minimum size.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > modularity: Description: overridden in igraph.Graph\nCalculates the modularity of the graph with respect to some vertex types.\nThe modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It is defined as Q = 1 ⁄ (2m)*sum(Aij − gamma*ki*kj ⁄ (2m)delta(ci, cj), i, j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, Ci and cj are the types of the two vertices (i and j), and gamma is a resolution parameter that defaults to 1 for the classical definition of modularity. delta(x, y) is one iff x = y, 0 otherwise.\nIf edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges incident on vertex i, kj is the total weight of edges incident on vertex j and m is the total edge weight in the graph.\nAttention: method overridden in Graph to allow VertexClustering objects as a parameter. This method is not strictly necessary, since the VertexClustering class provides a variable called modularity.\nReference: MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.\nParamters: membership: the  vector, e.g. the vertex type index for each vertex.\nweights: optional edge  or None if all edges are weighed equally.\nresolution: the  parameter gamma in the formula above. The classical definition of modularity is retrieved when the  parameter is set to 1.\ndirected: whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un.\nReturn: [the modularity score.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > modularity_matrix: Description: Calculates the modularity matrix of the graph.\nParamters: weights: optional edge  or None if all edges are weighed equally.\nresolution: the  parameter gamma of the modularity formula. The classical definition of modularity is retrieved when the  parameter is set to 1.\ndirected: whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un.\nReturn: [the modularity matrix as a list of lists.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > motifs_randesu: Description: Counts the number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. It is argued that the motif profile (ie. the number of different motifs in the graph) is characteristic for different types of networks and network function is related to the motifs in the graph.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nIn a big network the total number of motifs can be very large, so it takes a lot of time to find all of them. In such cases, a sampling method can be used. This function is capable of doing sampling via the cut_prob argument. This argument gives the probability that a branch of the motif search tree will not be explored.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.\nParamters: size: the  of the motifs\ncut_prob: the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs.\ncallback: None or a callable that will be called for every motif found in the graph. The callable must accept three parameters: the graph itself, the list of vertices in the motif and the isomorphism class of the motif (see isoclass()). The search will stop when the  returns an object with a non-zero truth value or raises an exception.\nReturn: [the list of motifs if callback is None, or None otherwise]\nReferences: []\nRasises: \nSee Also: Graph.motifs_randesu_no()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > motifs_randesu_estimate: Description: Counts the total number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. This function estimates the total number of motifs in a graph without assigning isomorphism classes to them by extrapolating from a random sample of vertices.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.\nParamters: size: the  of the motifs\ncut_prob: the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs.\nsample: the size of the  or the vertex IDs of the vertices to be used for sampling.\nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.motifs_randesu()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > motifs_randesu_no: Description: Counts the total number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. This function counts the total number of motifs in a graph without assigning isomorphism classes to them.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.\nParamters: size: the  of the motifs\ncut_prob: the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs.\nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.motifs_randesu()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > neighborhood: Description: For each vertex specified by vertices, returns the vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.\nParamters: vertices: a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.\norder: the  of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.\nmode: specifies how to take into account the direction of the edges if a directed graph is analyzed. \"out\" means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most order steps are counted. \"in\" means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most order steps are counted. \"all\" treats directed edges as undirected.\nmindist: the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not included. If this is two, the direct neighbors of the seed vertex are not included either, and so on.\nReturn: [a single list specifying the neighborhood if vertices was an integer specifying a single vertex index, or a list of lists if vertices was a list or None.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > neighborhood_size: Description: For each vertex specified by vertices, returns the number of vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.\nParamters: vertices: a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.\norder: the  of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.\nmode: specifies how to take into account the direction of the edges if a directed graph is analyzed. \"out\" means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most order steps are counted. \"in\" means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most order steps are counted. \"all\" treats directed edges as undirected.\nmindist: the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not counted. If this is two, the direct neighbors of the seed vertex are not counted either, and so on.\nReturn: [a single number specifying the neighborhood size if vertices was an integer specifying a single vertex index, or a list of sizes if vertices was a list or None.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > neighbors: Description: Returns adjacent vertices to a given vertex.\nParamters: vertex: a  ID\nmode: whether to return only successors (\"out\"), predecessors (\"in\") or both (\"all\"). Ignored for undirected graphs.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > path_length_hist: Description: overridden in igraph.Graph\nCalculates the path length histogram of the graph Attention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nParamters: directed: whether to consider  paths\nReturn: [a tuple. The first item of the tuple is a list of path lengths, the ith element of the list contains the number of paths with length i + 1. The second item contains the number of unconnected vertex pairs as a float (since it might not fit into an integer)]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > permute_vertices: Description: Permutes the vertices of the graph according to the given permutation and returns the new graph.\nVertex k of the original graph will become vertex permutation[k] in the new graph. No validity checks are performed on the permutation vector.\nParamters: \nReturn: [the new graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > personalized_pagerank: Description: Calculates the personalized PageRank values of a graph.\nThe personalized PageRank calculation is similar to the PageRank calculation, but the random walk is reset to a non-uniform distribution over the vertices in every step with probability 1 − damping instead of a uniform distribution.\nParamters: vertices: the indices of the  being queried. None means all of the .\ndirected: whether to consider  paths.\ndamping: the  factor.\nreset: the distribution over the vertices to be used when ting the random walk. Can be a sequence, an iterable or a vertex attribute name as long as they return a list of floats whose length is equal to the number of vertices. If None, a uniform distribution is assumed, which makes the method equivalent to the original PageRank algorithm.\nreset_vertices: an alternative way to specify the distribution over the vertices to be used when resetting the random walk. Simply supply a list of vertex IDs here, or a VertexSeq or a Vertex. Resetting will take place using a uniform distribution over the specified vertices.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\narpack_options: an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used. This argument is ignored if not the ARPACK implementation is used, see the implementation argument.\nimplementation: which  to use to solve the PageRank eigenproblem. Possible values are:\"prpack\": use the PRPACK library. This is a new  in igraph 0.7\"arpack\": use the ARPACK library. This  was used from version 0.5, until version 0.7.\nReturn: [a list with the personalized PageRank values of the specified vertices.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > predecessors: Description: Returns the predecessors of a given vertex.\nEquivalent to calling the neighbors() method with type=\"in\".\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Preference: Description: Generates a graph based on vertex types and connection probabilities.\nThis is practically the non-growing variant of Establishment. A given number of vertices are generated. Every vertex is assigned to a vertex type according to the given type probabilities. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved.\nParamters: n: the umber of vertices i the graph\ntype_dist: list giving the distribution of vertex types\npref_matrix: matrix giving the connection probabilities for different vertex types.\nattribute: the vertex  name used to store the vertex types. If None, vertex types are not stored.\ndirected: whether to generate a  graph.\nloops: whether loop edges are allowed.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Prufer: Description: Generates a tree from its Prüfer sequence.\nA Prüfer sequence is a unique sequence of integers associated with a labelled tree. A tree on n vertices can be represented by a sequence of n − 2 integers, each between 0 and n − 1 (inclusive).\nParamters: seq: the Prüfer uence as an iterable of integers\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > radius: Description: Calculates the radius of the graph.\nThe radius of a graph is defined as the minimum eccentricity of its vertices (see eccentricity()).\nParamters: mode: what kind of paths to consider for the calculation in case of directed graphs. OUT considers paths that follow edge directions, IN considers paths that follow the opposite edge directions, ALL ignores edge directions. The argument is ignored for undirected graphs.\nweights: a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight).\nReturn: [the radius]\nReferences: []\nRasises: \nSee Also: eccentricity()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > random_walk: Description: Performs a random walk of a given length from a given node.\nParamters: start: the ing vertex of the walk\nsteps: the number of  that the random walk should take\nmode: whether to follow outbound edges only (\"out\"), inbound edges only (\"in\") or both (\"all\"). Ignored for undirected graphs.@param stuck: what to do when the random walk gets stuck. \"return\" returns a partial random walk; \"error\" throws an exception.\nstuck: Undocumented\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nreturn_type: what to return. It can be \"vertices\" (default), then the function returns a list of the vertex ids visited; \"edges\", then the function returns a list of edge ids visited; or \"both\", then the function return a dictionary with keys \"vertices\" and \"edges\".\nReturn: [a random walk that starts from the given vertex and has at most the given length (shorter if the random walk got stuck).]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_DIMACS: Description: overridden in igraph.Graph\nReads a graph from a file conforming to the DIMACS minimum-cost flow file format.\nFor the exact description of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm\nRestrictions compared to the official description of the format:igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.Node indices start from 1. Only a single source and target node is allowed.\nParamters: f: the name o the ile or a Python ile handle\ndirected: whether the generated graph should be .\nReturn: [the generated graph, the source and the target of the flow and the edge capacities in a tuple]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_DL: Description: Reads an UCINET DL file and creates a graph based on it.\nParamters: f: the name o the ile or a Python ile handle\ndirected: whether the generated graph should be .\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_Edgelist: Description: Reads an edge list from a file and creates a graph based on it.\nPlease note that the vertex indices are zero-based. A vertex of zero degree will be created for every integer that is in range but does not appear in the edgelist.\nParamters: f: the name o the ile or a Python ile handle\ndirected: whether the generated graph should be .\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_GML: Description: Reads a GML file and creates a graph based on it.\nParamters: f: the name o the ile or a Python ile handle\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_GraphDB: Description: Reads a GraphDB format file and creates a graph based on it.\nGraphDB is a binary format, used in the graph database for isomorphism testing (see http://amalfi.dis.unina.it/graph/).\nParamters: f: the name o the ile or a Python ile handle\ndirected: whether the generated graph should be .\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_GraphML: Description: Reads a GraphML format file and creates a graph based on it.\nParamters: f: the name o the ile or a Python ile handle\nindex: if the GraphML file contains multiple graphs, specifies the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_Lgl: Description: Reads an .lgl file used by LGL.\nIt is also useful for creating graphs from \"named\" (and optionally weighted) edge lists.\nThis format is used by the Large Graph Layout program. See the documentation of LGL regarding the exact format description.\nLGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.\nParamters: f: the name o the ile or a Python ile handle\nnames: If True, the vertex  are added as a vertex attribute called 'name'.\nweights: If True, the edge  are added as an edge attribute called 'weight', even if there are no  in the file. If False, the edge  are never added, even if they are present. \"auto\" or \"if_present\" means that  are added if there is at least one weighted edge in the input file, but they are not added otherwise.\ndirected: whether the graph being created should be\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_Ncol: Description: Reads an .ncol file used by LGL.\nIt is also useful for creating graphs from \"named\" (and optionally weighted) edge lists.\nThis format is used by the Large Graph Layout program. See the repository of LGL for more information.\nLGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.\nParamters: f: the name o the ile or a Python ile handle\nnames: If True, the vertex  are added as a vertex attribute called 'name'.\nweights: If True, the edge  are added as an edge attribute called 'weight', even if there are no  in the file. If False, the edge  are never added, even if they are present. \"auto\" or \"if_present\" means that  are added if there is at least one weighted edge in the input file, but they are not added otherwise.\ndirected: whether the graph being created should be\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Read_Pajek: Description: Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj).\nParamters: f: the name o the ile or a Python ile handle\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Realize_Bipartite_Degree_Sequence: Description: Generates a bipartite graph from the degree sequences of its partitions.\nThis method implements a Havel-Hakimi style graph construction for biparite graphs. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the method parameter. The allowed edge types (i.e. whether multi-edges are allowed) are specified in the allowed_edge_types parameter. Self-loops are never created, since a graph with self-loops is not bipartite.\nParamters: degrees1: the degrees of the first partition.\ndegrees2: the degrees of the second partition.\nallowed_edge_types: controls whether multi-edges are allowed during the generation process. Possible values are:\"simple\": simple graphs (no multi-edges)\"multi\": multi-edges allowed\nmethod: controls how the vertices are selected during the generation process. Possible values are:smallest: The vertex with smallest remaining degree first.largest: The vertex with the largest remaining degree first.index: The vertices are selected in order of their index.The smallest smallest  is guaranteed to produce a connected graph, if one exists.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Realize_Degree_Sequence: Description: Generates a graph from a degree sequence.\nThis method implements a Havel-Hakimi style graph construction from a given degree sequence. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the method parameter. The allowed edge types (i.e. whether multiple or loop edges are allowed) are specified in the allowed_edge_types parameter.\n\nParamters: out: the degree sequence of an undirected graph (if in_=None), or the -degree sequence of a directed graph.\nin_: None to generate an undirected graph, the in-degree sequence to generate a directed graph.\nallowed_edge_types: controls whether loops or multi-edges are allowed during the generation process. Note that not all combinations are supported for all types of graphs; an exception will be raised for unsupported combinations. Possible values are:\"simple\": simple graphs (no self-loops, no multi-edges)\"loops\": single self-loops allowed, but not multi-edges\"multi\": multi-edges allowed, but not self-loops\"all\": multi-edges and self-loops allowed\nmethod: controls how the vertices are selected during the generation process. Possible values are:smallest: The vertex with smallest remaining degree first.largest: The vertex with the largest remaining degree first.index: The vertices are selected in order of their index.In the undirected case, smallest is guaranteed to produce a connected graph. See Horvát and Modes (2021) for details.\nReturn: []\nReferences: [V. Havel, Poznámka o existenci konečných grafů (A remark on the existence of finite graphs), Časopis pro pěstování matematiky 80, 477-480 (1955). http://eudml.org/doc/19050S. L. Hakimi, On Realizability of a Set of Integers as Degrees of the Vertices of a Linear Graph, Journal of the SIAM 10, 3 (1962). https://www.jstor.org/stable/2098770D. J. Kleitman and D. L. Wang, Algorithms for Constructing Graphs and Digraphs with Given Valences and Factors, Discrete Mathematics 6, 1 (1973). https://doi.org/10.1016/0012-365X%2873%2990037-XSz. Horvát and C. D. Modes, Connectedness matters: construction and exact random sampling of connected networks (2021). https://doi.org/10.1088/2632-072X/abced5]\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Recent_Degree: Description: Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.\nParamters: n: the umber of vertices\nm: either the nuber of outgoing edges generated for each vertex or a list containing the nuber of outgoing edges for each vertex explicitly.\nwindow: size of the  in time steps\noutpref: True if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to False.\ndirected: True if the generated graph should be  (default: False).\npower: the  constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > reciprocity: Description: Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph. This measure is calculated if mode is \"default\".\nPrior to igraph 0.6, another measure was implemented, defined as the probability of mutual connection between a vertex pair if we know that there is a (possibly non-mutual) connection between them. In other words, (unordered) vertex pairs are classified into three groups: (1) disconnected, (2) non-reciprocally connected and (3) reciprocally connected. The result is the size of group (3), divided by the sum of sizes of groups (2) and (3). This measure is calculated if mode is \"ratio\".\nParamters: ignore_loops: whether loop edges should be ignored.\nmode: the algorithm to use to calculate the reciprocity; see above for more details.\nReturn: [the reciprocity of the graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > reverse_edges: Description: Reverses the direction of some edges in the graph.\nThis function is a no-op for undirected graphs.\nParamters: es: the list of edg to be reversed. Edg are identifed by edge IDs. EdgeSeq objects are also accepted here. When omitted, all edg will be reversed.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > rewire: Description: Randomly rewires the graph while preserving the degree distribution.\nPlease note that the rewiring is done \"in-place\", so the original graph will be modified. If you want to preserve the original graph, use the copy method before.\nParamters: n: the umber of rewirig trials.\nmode: the rewiring algorithm to use. It can either be \"simple\" or \"loops\"; the former does not create or destroy loop edges while the latter does.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > rewire_edges: Description: Rewires the edges of a graph with constant probability.\nEach endpoint of each edge of the graph will be rewired with a constant probability, given in the first argument.\nPlease note that the rewiring is done \"in-place\", so the original graph will be modified. If you want to preserve the original graph, use the copy method before.\nParamters: prob: rewiring ability\nloops: whether the algorithm is allowed to create loop edges\nmultiple: whether the algorithm is allowed to create  edges.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Ring: Description: Generates a ring graph.\nParamters: n: the umber of vertices i the rig\ndirected: whether to create a  ring.\nmutual: whether to create  edges in a directed ring.\ncircular: whether to create a closed ring.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > SBM: Description: Generates a graph based on a stochastic block model.\nA given number of vertices are generated. Every vertex is assigned to a vertex type according to the given block sizes. Vertices of the same type will be assigned consecutive vertex IDs. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved. The probabilities are taken from the preference matrix.\nParamters: n: the umber of vertices i the graph\npref_matrix: matrix giving the connection probabilities for different vertex types.\nblock_sizes: list giving the number of vertices in each block; must sum up to n.\ndirected: whether to generate a  graph.\nloops: whether loop edges are allowed.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > similarity_dice: Description: Dice similarity coefficient of vertices.\nThe Dice similarity coefficient of two vertices is twice the number of their common neighbors divided by the sum of their degrees. This coefficient is very similar to the Jaccard coefficient, but usually gives higher similarities than its counterpart.\nParamters: vertices: the  to be analysed. If None and pairs is also None, all  will be considered.\npairs: the vertex  to be analysed. If this is given, vertices must be None, and the similarity values will be calculated only for the given . Vertex  must be specified as tuples of vertex IDs.\nmode: which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs.\nloops: whether vertices should be considered adjacent to themselves. Setting this to True assumes a loop edge for all vertices even if none is present in the graph. Setting this to False may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get.\nReturn: [the pairwise similarity coefficients for the vertices specified, in the form of a matrix if pairs is None or in the form of a list if pairs is not None.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > similarity_inverse_log_weighted: Description: Inverse log-weighted similarity coefficient of vertices.\nEach vertex is assigned a weight which is 1 / log(degree). The log-weighted similarity of two vertices is the sum of the weights of their common neighbors.\nNote that the presence of loop edges may yield counter-intuitive results. A node with a loop edge is considered to be a neighbor of itself twice (because there are two edge stems incident on the node). Adding a loop edge to a node may decrease its similarity to other nodes, but it may also increase it. For instance, if nodes A and B are connected but share no common neighbors, their similarity is zero. However, if a loop edge is added to B, then B itself becomes a common neighbor of A and B and thus the similarity of A and B will be increased. Consider removing loop edges explicitly before invoking this function using Graph.simplify().\nParamters: vertices: the  to be analysed. If None, all  will be considered.\nmode: which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs. \"in\" means that the weights are determined by the out-degrees, \"out\" means that the weights are determined by the in-degrees.\nReturn: [the pairwise similarity coefficients for the vertices specified, in the form of a matrix (list of lists).]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > similarity_jaccard: Description: Jaccard similarity coefficient of vertices.\nThe Jaccard similarity coefficient of two vertices is the number of their common neighbors divided by the number of vertices that are adjacent to at least one of them.\nParamters: vertices: the  to be analysed. If None and pairs is also None, all  will be considered.\npairs: the vertex  to be analysed. If this is given, vertices must be None, and the similarity values will be calculated only for the given . Vertex  must be specified as tuples of vertex IDs.\nmode: which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs.\nloops: whether vertices should be considered adjacent to themselves. Setting this to True assumes a loop edge for all vertices even if none is present in the graph. Setting this to False may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get.\nReturn: [the pairwise similarity coefficients for the vertices specified, in the form of a matrix if pairs is None or in the form of a list if pairs is not None.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > simplify: Description: Simplifies a graph by removing self-loops and/or multiple edges.\nFor example, suppose you have a graph with an edge attribute named weight. graph.simplify(combine_edges=max) will take the maximum of the weights of multiple edges and assign that weight to the collapsed edge. graph.simplify(combine_edges=sum) will take the sum of the weights. You can also write graph.simplify(combine_edges=dict(weight=\"sum\")) or graph.simplify(combine_edges=dict(weight=sum)), since sum is recognised both as a Python built-in function and as a string constant.\nParamters: multiple: whether to remove  edges.\nloops: whether to remove .\ncombine_edges: specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. If it is None, only one of the edges will be kept and all the attributes will be lost. If it is a function, the attributes of multiple edges will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed edge. It can also be one of the following string constants:\"ignore\": all the edge attributes will be ignored.\"sum\": the sum of the edge attribute values will be used for the new edge.\"product\": the product of the edge attribute values will be used for the new edge.\"mean\": the mean of the edge attribute values will be used for the new edge.\"median\": the median of the edge attribute values will be used for the new edge.\"min\": the minimum of the edge attribute values will be used for the new edge.\"max\": the maximum of the edge attribute values will be used for the new edge.\"first\": the attribute value of the first edge in the collapsed set will be used for the new edge.\"last\": the attribute value of the last edge in the collapsed set will be used for the new edge.\"random\": a randomly selected value will be used for the new edge\"concat\": the attribute values will be concatenated for the new edge.You can also use a dict mapping edge attribute names to functions or the above string constants if you want to make the behaviour of the simplification process depend on the name of the attribute. None is a special key in this dict, its value will be used for all the attributes not specified explicitly in the dictionary.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > st_mincut: Description: overridden in igraph.Graph\nCalculates the minimum cut between the source and target vertices in a graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.\nParamters: source: the  vertex ID\ntarget: the  vertex ID\ncapacity: the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same .\nReturn: [the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Star: Description: Generates a star graph.\nParamters: n: the umber of vertices i the graph\nmode: Gives the type of the star graph to create. Should be either \"in\", \"out\", \"mutual\" or \"undirected\"\ncenter: Vertex ID for the central vertex in the star.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Static_Fitness: Description: Generates a non-growing graph with edge probabilities proportional to node fitnesses.\nThe algorithm randomly selects vertex pairs and connects them until the given number of edges are created. Each vertex is selected with a probability proportional to its fitness; for directed graphs, a vertex is selected as a source proportional to its out-fitness and as a target proportional to its in-fitness.\nParamters: m: the nuber of edges in the graph\nfitness_out: a numeric vector with non-negative entries, one for each vertex. These values represent the fitness scores (out-fitness scores for directed graphs). fitness is an alias of this keyword argument.\nfitness_in: a numeric vector with non-negative entries, one for each vertex. These values represent the in-fitness scores for directed graphs. For undirected graphs, this argument must be None.\nloops: whether loop edges are allowed.\nmultiple: whether  edges are allowed.\nReturn: [a directed or undirected graph with the prescribed power-law degree distributions.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Static_Power_Law: Description: Generates a non-growing graph with prescribed power-law degree distributions.\n\nParamters: n: the umber of vertices i the graph\nm: the nuber of edges in the graph\nexponent_out: the exponent of the out-degree distribution, which must be between 2 and infinity (inclusive). When exponent_in is not given or negative, the graph will be undirected and this parameter specifies the degree distribution. exponent is an alias to this keyword argument.\nexponent_in: the exponent of the in-degree distribution, which must be between 2 and infinity (inclusive) It can also be negative, in which case an undirected graph will be generated.\nloops: whether loop edges are allowed.\nmultiple: whether  edges are allowed.\nfinite_size_correction: whether to apply a finite-size correction to the generated fitness values for exponents less than 3. See the paper of Cho et al for more details.\nReturn: [a directed or undirected graph with the prescribed power-law degree distributions.]\nReferences: [Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.]\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > strength: Description: Returns the strength (weighted degree) of some vertices from the graph\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the strength (that is, the sum of the weights of all incident edges) of the given vertices (in the form of a single integer or a list, depending on the input parameter).\nParamters: vertices: a single vertex ID or a list of vertex IDs\nmode: the type of degree to be returned (\"out\" for out-degrees, \"in\" for in-degrees or \"all\" for the sum of them).\nloops: whether self- should be counted.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name. ``None`` means to treat the graph as unweighted, falling back to ordinary degree calculations.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > subcomponent: Description: Determines the indices of vertices which are in the same component as a given vertex.\nParamters: v: the index of the ertex used as the source/destination\nmode: if equals to \"in\", returns the vertex IDs from where the given vertex can be reached. If equals to \"out\", returns the vertex IDs which are reachable from the given vertex. If equals to \"all\", returns all vertices within the same component as the given vertex, ignoring edge directions. Note that this is not equal to calculating the union of the results of \"in\" and \"out\".\nReturn: [the indices of vertices which are in the same component as a given vertex.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > subgraph_edges: Description: Returns a subgraph spanned by the given edges.\nParamters: edges: a list containing the edge IDs which should be included in the result.\ndelete_vertices: if True, vertices not incident on any of the specified edges will be deleted from the result. If False, all vertices will be kept.\nReturn: [the subgraph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > subisomorphic_lad: Description: Checks whether a subgraph of the graph is isomorphic to another graph.\nThe optional domains argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.\nParamters: other: the pattern graph we are looking for in the graph.\ndomains: a list of lists, one sublist belonging to each vertex in the template graph. Sublist i contains the indices of the vertices in the original graph that may match vertex i in the template graph. None means that every vertex may match every other vertex.\ninduced: whether to consider  subgraphs only.\ntime_limit: an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception.\nreturn_mapping: when True, the function will return a tuple, where the first element is a boolean denoting whether a subisomorphism has been found or not, and the second element describes the mapping of the vertices from the template graph to the original graph. When False, only the boolean is returned.\nReturn: [if no mapping is calculated, the result is True if the graph contains a subgraph that is isomorphic to the given template, False otherwise. If the mapping is calculated, the result is a tuple, the first element being the above mentioned boolean, and the second element being the mapping from the target to the original graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > subisomorphic_vf2: Description: Checks whether a subgraph of the graph is isomorphic to another graph.\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.\nParamters: other: the  graph with which we want to compare the graph.\ncolor1: optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.\ncolor2: optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.\nedge_color1: optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.\nedge_color2: optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.\nreturn_mapping_12: if True, calculates the mapping which maps the vertices of the first graph to the second. The mapping can contain -1 if a given node is not mapped.\nreturn_mapping_21: if True, calculates the mapping which maps the vertices of the second graph to the first. The mapping can contain -1 if a given node is not mapped.\ncallback: if not None, the subisomorphism search will not stop at the first match; it will call this  function instead for every subisomorphism found. The  function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return True if the search should continue or False otherwise.\nnode_compat_fn: a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.\nedge_compat_fn: a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node.\nReturn: [if no mapping is calculated, the result is True if the graph contains a subgraph that's isomorphic to the given one, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > successors: Description: Returns the successors of a given vertex.\nEquivalent to calling the neighbors() method with type=\"out\".\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > to_directed: Description: Converts an undirected graph to directed.\nParamters: mode: specifies how to convert undirected edges into directed ones. True or \"mutual\" creates a mutual edge pair for each undirected edge. False or \"arbitrary\" picks an arbitrary (but deterministic) edge direction for each edge. \"random\" picks a random direction for each edge. \"acyclic\" picks the edge directions in a way that the resulting graph will be acyclic if there were no self-loops in the original graph.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > to_prufer: Description: Converts a tree graph into a Prüfer sequence.\nParamters: \nReturn: [the Prüfer sequence as a list]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > to_undirected: Description: Converts a directed graph to undirected.\nParamters: mode: specifies what to do with multiple directed edges going between the same vertex pair. True or \"collapse\" means that only a single edge should be created from multiple directed edges. False or \"each\" means that every edge will be kept (with the arrowheads removed). \"mutual\" creates one undirected edge for each mutual directed edge pair.\ncombine_edges: specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. See simplify() for more details.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > topological_sorting: Description: Calculates a possible topological sorting of the graph.\nReturns a partial sorting and issues a warning if the graph is not a directed acyclic graph.\nParamters: mode: if \"out\", vertices are returned according to the forward topological order -- all vertices come before their successors. If \"in\", all vertices come before their ancestors.\nReturn: [a possible topological ordering as a list]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > transitivity_avglocal_undirected: Description: overridden in igraph.Graph\nCalculates the average of the vertex transitivities of the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter.\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it simply takes the average local transitivity across the whole network.\nReference: D. J. Watts and S. Strogatz: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.\nParamters: mode: defines how to treat vertices with degree less than two. If TRANSITIVITT_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will be excluded from the average.\nReturn: []\nReferences: []\nRasises: \nSee Also: transitivity_undirected(), transitivity_local_undirected()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > transitivity_local_undirected: Description: Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. In case of the local transitivity, this probability is calculated separately for each vertex.\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it calculates a transitivity value for each vertex individually.\nThe traditional local transitivity measure applies for unweighted graphs only. When the weights argument is given, this function calculates the weighted local transitivity proposed by Barrat et al (see references).\n\nParamters: vertices: a list containing the vertex IDs which should be included in the result. None means all of the .\nmode: defines how to treat vertices with degree less than two. If TRANSITIVITT_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will have NaN (not a number) as their transitivity.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nReturn: [the transitivities for the given vertices in a list]\nReferences: [:D. J. Watts and S. Strogatz: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: The architecture of complex weighted networks. PNAS 101, 3747 (2004). http://arxiv.org/abs/cond-mat/0311416.]\nRasises: \nSee Also: transitivity_undirected(), transitivity_avglocal_undirected()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > transitivity_undirected: Description: Calculates the global transitivity (clustering coefficient) of the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. More precisely, this is the ratio of the triangles and connected triplets in the graph. The result is a single real number. Directed graphs are considered as undirected ones.\nNote that this measure is different from the local transitivity measure (see transitivity_local_undirected()) as it calculates a single value for the whole graph.\nReference: S. Wasserman and K. Faust: Social Network Analysis: Methods and Applications. Cambridge: Cambridge University Press, 1994.\nParamters: mode: if TRANSITIVITY_ZERO or \"zero\", the result will be zero if the graph does not have any triplets. If \"nan\" or TRANSITIVITY_NAN, the result will be NaN (not a number).\nReturn: [the transitivity]\nReferences: []\nRasises: \nSee Also: transitivity_local_undirected(), transitivity_avglocal_undirected()\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Tree: Description: Generates a tree in which almost all vertices have the same number of children.\nParamters: n: the umber of vertices i the graph\nchildren: the number of  of a vertex in the graph\nmode: determines whether the tree should be directed, and if this is the case, also its orientation. Must be one of \"in\", \"out\" and \"undirected\".\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Tree_Game: Description: Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.\nParamters: n: the umber of vertices i the tree\ndirected: whether the graph should be \nmethod: the generation  to be used. One of the following:\"prufer\" -- samples Prüfer sequences uniformly, then converts them to trees\"lerw\" -- performs a loop-erased random walk on the complete graph to uniformly sample its spanning trees (Wilson's algorithm). This is the default choice as it supports both directed and undirected graphs.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > triad_census: Description: overridden in igraph.Graph\nTriad census, as defined by Davis and Leinhardt\nCalculating the triad census means classifying every triplets of vertices in a directed graph. A triplet can be in one of 16 states, these are listed in the documentation of the C interface of igraph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a TriadCensus object. It is advised to use that. The name of the triplet classes are also documented there.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Triangular_Lattice: Description: Generates a regular triangular lattice.\nParamters: dim: list with the ensions of the lattice\ndirected: whether to create a  graph.\nmutual: whether to create all connections as  in case of a directed graph.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > unfold_tree: Description: Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.\nParamters: sources: the source vertices to start the unfolding from. It should be a list of vertex indices, preferably one vertex from each connected component. You can use topological_sorting() to determine a suitable set. A single vertex index is also accepted.\nmode: which edges to follow during the BFS. OUT follows outgoing edges, IN follows incoming edges, ALL follows both. Ignored for undirected graphs.\nReturn: [the unfolded tree graph and a mapping from the new vertex indices to the old ones.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > vcount: Description: Counts the number of vertices.\nParamters: \nReturn: [integerthe number of vertices in the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > vertex_attributes: Description: \nParamters: \nReturn: [the attribute name list of the vertices of the graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > vertex_coloring_greedy: Description: Calculates a greedy vertex coloring for the graph based on some heuristics.\nParamters: method: the heuristics to use. colored_neighbors always picks the vertex with the largest number of colored neighbors as the next vertex to pick a color for. dsatur picks the vertex with the largest number of unique colors in its neighborhood; this is also known as the DSatur heuristics (hence the name).\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > vertex_connectivity: Description: Calculates the vertex connectivity of the graph or between some vertices.\nThe vertex connectivity between two given vertices is the number of vertices that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of vertex disjoint directed paths between the vertices (apart from the source and target vertices of course). The vertex connectivity of the graph is the minimal vertex connectivity over all vertex pairs.\nThis method calculates the vertex connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall vertex connectivity is returned.\nParamters: source: the  vertex involved in the calculation.\ntarget: the  vertex involved in the calculation.\nchecks: if the whole graph connectivity is calculated and this is True, igraph performs some basic  before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple  are much faster than checking the entire graph, therefore it is advised to set this to True. The parameter is ignored if the connectivity between two given vertices is computed.\nneighbors: tells igraph what to do when the two vertices are connected. \"error\" raises an exception, \"negative\" returns a negative value, \"number_of_nodes\" or \"nodes\" returns the number of nodes, or \"ignore\" ignores the edge.\nReturn: [the vertex connectivity]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > Watts_Strogatz: Description: This function generates networks with the small-world property based on a variant of the Watts-Strogatz model. The network is obtained by first creating a periodic undirected lattice, then rewiring both endpoints of each edge with probability p, while avoiding the creation of multi-edges.\nThis process differs from the original model of Watts and Strogatz (see reference) in that it rewires both endpoints of edges. Thus in the limit of p=1, we obtain a G(n,m) random graph with the same number of vertices and edges as the original lattice. In comparison, the original Watts-Strogatz model only rewires a single endpoint of each edge, thus the network does not become fully random even for <code>p=1</code>.\nFor appropriate choices of p, both models exhibit the property of simultaneously having short path lengths and high clustering.\nReference: Duncan J Watts and Steven H Strogatz: Collective dynamics of small world networks, Nature 393, 440-442, 1998\nParamters: dim: the ension of the lattice\nsize: the  of the lattice along all dimensions\nnei: value giving the distance (number of steps) within which two vertices will be connected.\np: rewiring robability\nloops: specifies whether loop edges are allowed\nmultiple: specifies whether  edges are allowed\nReturn: []\nReferences: []\nRasises: \nSee Also: Lattice(), rewire(), rewire_edges() if more flexibility is needed\nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_dimacs: Description: overridden in igraph.Graph\nWrites the graph in DIMACS format to the given file.\nParamters: f: the name o the ile to be written or a Python ile handle\nsource: the  vertex ID\ntarget: the  vertex ID\ncapacity: the capacities of the edges in a list. If it is not a list, the corresponding edge attribute will be used to retrieve capacities.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_dot: Description: Writes the graph in DOT format to the given file.\nDOT is the format used by the GraphViz software package.\nParamters: f: the name o the ile to be written or a Python ile handle\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_edgelist: Description: Writes the edge list of a graph to a file.\nDirected edges are written in (from, to) order.\nParamters: f: the name o the ile to be written or a Python ile handle\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_gml: Description: Writes the graph in GML format to the given file.\nParamters: f: the name o the ile to be written or a Python ile handle\ncreator: optional  information to be written to the file. If None, the current date and time is added.\nids: optional numeric vertex IDs to use in the file. This must be a list of integers or None. If None, the id attribute of the vertices are used, or if they don't exist, numeric vertex IDs will be generated automatically.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_graphml: Description: Writes the graph to a GraphML file.\nParamters: f: the name o the ile to be written or a Python ile handle\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_leda: Description: Writes the graph to a file in LEDA native format.\nThe LEDA format supports at most one attribute per vertex and edge. You can specify which vertex and edge attribute you want to use. Note that the name of the attribute is not saved in the LEDA file.\nParamters: f: the name o the ile to be written or a Python ile handle\nnames: the name of the vertex attribute to be stored along with the vertices. It is usually used to store the vertex  (hence the name of the keyword argument), but you may also use a numeric attribute. If you don't want to store any vertex attributes, supply None here.\nweights: the name of the edge attribute to be stored along with the edges. It is usually used to store the edge  (hence the name of the keyword argument), but you may also use a string attribute. If you don't want to store any edge attributes, supply None here.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_lgl: Description: Writes the edge list of a graph to a file in .lgl format.\nNote that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call simplify() before saving.\nParamters: f: the name o the ile to be written or a Python ile handle\nnames: the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex , supply None here.\nweights: the name of the edge attribute containing the weight of the vertices. If you don't want to store , supply None here.\nisolates: whether to include isolated vertices in the output.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_ncol: Description: Writes the edge list of a graph to a file in .ncol format.\nNote that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call simplify() before saving.\nParamters: f: the name o the ile to be written or a Python ile handle\nnames: the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex , supply None here.\nweights: the name of the edge attribute containing the weight of the vertices. If you don't want to store , supply None here.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > write_pajek: Description: Writes the graph in Pajek format to the given file.\nParamters: f: the name o the ile to be written or a Python ile handle\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphBase",
    "Field List > Methods > setboolean: Description: Sets a boolean value in the given configuration object.\nParamters: obj: a configuration ect\nsection: the  of the value to be set\nkey: the  of the value to be set\nvalue: the  itself. 0, false, no and off means false, 1, true, yes and on means true, everything else results in a ValueError being thrown. Values are case-insensitive\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Types",
    "Field List > Methods > setfloat: Description: Sets a float value in the given configuration object.\nNote that float values are converted to strings in the configuration object, which may lead to some precision loss.\nParamters: obj: a configuration ect\nsection: the  of the value to be set\nkey: the  of the value to be set\nvalue: the  itself.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Types",
    "Field List > Methods > setint: Description: Sets an integer value in the given configuration object.\nParamters: obj: a configuration ect\nsection: the  of the value to be set\nkey: the  of the value to be set\nvalue: the  itself.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Types",
    "Field List > Methods > __init__: Description: Constructs the edge drawer.\nParamters: context: a plotly Figure object on which the edges will be drawn.\npalette: the  that can be used to map integer color indices to colors when drawing edges\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyEdgeDrawer",
    "Field List > Methods > draw_directed_edge: Description: overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are defined by the attributes of this object.\ndest_vertex: the source vertex. Visual properties are defined by the attributes of this object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyEdgeDrawer",
    "Field List > Methods > draw_loop_edge: Description: Draws a loop edge.\nThe default implementation draws a small circle.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nvertex: the  to which the edge is attached. Visual properties are given again as attributes.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyEdgeDrawer",
    "Field List > Methods > draw_undirected_edge: Description: overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nThe default implementation of this method draws undirected edges as straight lines. Loop edges are drawn as small circles.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are given again as attributes.\ndest_vertex: the target vertex. Visual properties are given again as attributes.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyEdgeDrawer",
    "Field List > Methods > get_label_position: Description: Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.\nSection_id: PlotlyEdgeDrawer",
    "Field List > Methods > get_label_rotation: Description: Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge.\nSection_id: PlotlyEdgeDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.\nParamters: ax: Undocumented\npalette: the  that can be used to map integer color indices to colors when drawing vertices\nlayout: the  of the vertices in the graph being drawn\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibVertexDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nBuild the Artist for a vertex and return it.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibVertexDrawer",
    "Field List > Methods > draw_path: Description: overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a triangle on the Cairo context without stroking or filling it.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.draw_path\nexample: []\nSection_id: DownTriangleDrawer",
    "Field List > Methods > intersection_point: Description: overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the triangle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.intersection_point\nexample: []\nSection_id: DownTriangleDrawer",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FakeWrapper",
    "Field List > Methods > fill: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FakeWrapper",
    "Field List > Methods > wrap: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FakeWrapper",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.colors.Palette.__init__\nCreates an advanced gradient palette\nParamters: colors: the  in the gradient.\nindices: the color  belonging to the given colors. If None, the colors are distributed equidistantly\nn: the total umber of colors i the palette\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AdvancedGradientPalette",
    "Field List > Methods > __len__: Description: Inherited from Palette:Returns the number of colors in this palette\nSection_id: AdvancedGradientPalette",
    "Field List > Methods > __plot__: Description: Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes\nSection_id: AdvancedGradientPalette",
    "Field List > Methods > __repr__: Description: Inherited from Palette:Undocumented\nSection_id: AdvancedGradientPalette",
    "Field List > Methods > clear_cache: Description: Inherited from Palette:Clears the result cache.\nSection_id: AdvancedGradientPalette",
    "Field List > Methods > get: Description: Inherited from Palette:Returns the given color from the palette.\nSection_id: AdvancedGradientPalette",
    "Field List > Methods > get_many: Description: Inherited from Palette:Returns multiple colors from the palette.\nSection_id: AdvancedGradientPalette",
    "Field List > Methods > __init__: Description: overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem, igraph.drawing.cairo.dendrogram.CairoDendrogramDrawer, igraph.drawing.cairo.graph.AbstractCairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer, igraph.drawing.cairo.polygon.CairoPolygonDrawer, igraph.drawing.cairo.text.CairoTextDrawer, igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer\nConstructs the drawer and associates it to the given Cairo context and the given BoundingBox.\nParamters: context: the  on which we will draw\nbbox: :BoundingBox or Nonethe bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractCairoDrawer",
    "Field List > Methods > bbox: Description: overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem\nSets the bounding box of the drawing area where this drawer will draw.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractCairoDrawer",
    "Field List > Methods > draw: Description: Inherited from AbstractDrawer:Abstract method, must be implemented in derived classes.\nSection_id: AbstractCairoDrawer",
    "Field List > Methods > __init__: Description: Initializes the histogram with the given data set.\nParamters: bin_width: the bin width of the histogram.\ndata: the  set to be used. Must contain real numbers.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Histogram",
    "Field List > Methods > __plot__: Description: Plotting support\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Histogram",
    "Field List > Methods > __str__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Histogram",
    "Field List > Methods > add: Description: Adds a single number to the histogram.\nParamters: num: the ber to be added\nrepeat: number of ed additions\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Histogram",
    "Field List > Methods > add_many: Description: Adds a single number or the elements of an iterable to the histogram.\nParamters: data: the  to be added\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Histogram",
    "Field List > Methods > bins: Description: Generator returning the bins of the histogram in increasing order\nParamters: \nReturn: [a tuple with the following elements: left bound, right bound, number of elements in the bin]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Histogram",
    "Field List > Methods > clear: Description: Clears the collected data\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Histogram",
    "Field List > Methods > to_string: Description: Returns the string representation of the histogram.\nParamters: max_width: the maximal width of each line of the string This value may not be obeyed if it is too small.\nshow_bars: specify whether the histogram bars should be shown\nshow_counts: specify whether the histogram counts should be shown. If both show_bars and  are False, only a general descriptive statistics (number of elements, mean and standard deviation) is shown.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Histogram",
    "Field List > Methods > __getitem__: Description: Returns the cluster with the given index.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > __init__: Description: overridden in igraph.VertexCover\nConstructs a cover with the given clusters.\nParamters: clusters: the  in this cover, as a list or iterable. Each cluster is specified by a list or tuple that contains the IDs of the items in this cluster. IDs start from zero.\nn: the total umber of elemets i the set that is covered by this cover. If it is less tha the umber of uique elemets foud i all the clusters, we will simply use the umber of uique elemets, so it is safe to leave this at zero. You oly have to specify this parameter if there are some elemets that are covered by oe of the clusters.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > __iter__: Description: Iterates over the clusters in this cover.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > __len__: Description: Returns the number of clusters in this cover.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > __str__: Description: Returns a string representation of the cover.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > size: Description: Returns the size of a given cluster.\nParamters: idx: the cluster in which we are interested.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > size_histogram: Description: Returns the histogram of cluster sizes.\nParamters: bin_width: the bin width of the histogram\nReturn: [a Histogram object]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > sizes: Description: Returns the size of given clusters.\nThe indices are given as positional arguments. If there are no positional arguments, the function will return the sizes of all clusters.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > summary: Description: Returns the summary of the cover.\nThe summary includes the number of items and clusters, and also the list of members for each of the clusters if the verbosity is nonzero.\nParamters: verbosity: determines whether the cluster members should be printed. Zero  prints the number of items and clusters only.\nwidth: Undocumented\nReturn: [the summary of the cover as a string.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cover",
    "Field List > Methods > __del__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiConnection",
    "Field List > Methods > __init__: Description: Constructs a connection to a Gephi master server.\nThe connection object can be constructed either by specifying theurl directly, or by specifying the host, port andworkspace arguments.  The latter three are evaluated only ifurl is None; otherwise the url will take precedence.\nThe url argument does not have to include the operation (e.g.,?operation=updateGraph); the connection will take care of it.E.g., if you wish to connect to workspace 2 in a local Gephi instanceon port 7341, the correct form to use for the url is as follows:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [The url argument does not have to include the operation (e.g.,\n?operation=updateGraph); the connection will take care of it.\nE.g., if you wish to connect to workspace 2 in a local Gephi instance\non port 7341, the correct form to use for the url is as follows:\nhttp://localhost:7341/workspace0\n]\nSection_id: GephiConnection",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiConnection",
    "Field List > Methods > close: Description: Flushes all the pending operations to the Gephi master server in asingle request.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiConnection",
    "Field List > Methods > flush: Description: Flushes all the pending operations to the Gephi master server in asingle request.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiConnection",
    "Field List > Methods > url: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiConnection",
    "Field List > Methods > write: Description: Sends the given raw data to the Gephi streaming master server in an HTTPPOST request.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiConnection",
    "Field List > Methods > draw_path: Description: overridden in igraph.drawing.shapes.CircleDrawer, igraph.drawing.shapes.DiamondDrawer, igraph.drawing.shapes.DownTriangleDrawer, igraph.drawing.shapes.NullDrawer, igraph.drawing.shapes.RectangleDrawer, igraph.drawing.shapes.UpTriangleDrawer\nDraws the path of the shape on the given Cairo context, without stroking or filling it.\nThis method must be overridden in derived classes implementing custom shapes and declared as a static method using staticmethod(...).\nParamters: ctx: the context to draw on\ncenter_x: the X coordinate of the center of the object\ncenter_y: the Y coordinate of the center of the object\nwidth: the  of the object\nheight: the  of the object. If None, equals to the width.\n**kwargs: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ShapeDrawer",
    "Field List > Methods > intersection_point: Description: overridden in igraph.drawing.shapes.CircleDrawer, igraph.drawing.shapes.DiamondDrawer, igraph.drawing.shapes.DownTriangleDrawer, igraph.drawing.shapes.RectangleDrawer, igraph.drawing.shapes.UpTriangleDrawer\nDetermines where the shape centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nCan be overridden in derived classes. Must always be defined as a static method using staticmethod(...)\nParamters: center_x: Undocumented\ncenter_y: Undocumented\nsource_x: Undocumented\nsource_y: Undocumented\nwidth: the  of the shape\nheight: the  of the shape. If None, defaults to the width\nReturn: [the intersection point (the closest to (source_x, source_y) if there are more than one) or (center_x, center_y) if there is no intersection]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ShapeDrawer",
    "Field List > Methods > __init__: Description: Constructs the drawer and associates it to the given Axes.\nParamters: ax: the Axes on which we will draw\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibMatrixDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.\nParamters: matrix: the igraph.Matrix to plot.Keyword arguments are passed to Axes.imshow.\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibMatrixDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the graph drawer and associates it to the given Cairo context and the given BoundingBox.\nParamters: context: the  on which we will draw\nbbox: the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractCairoGraphDrawer",
    "Field List > Methods > draw: Description: Inherited from AbstractGraphDrawer:Abstract method, must be implemented in derived classes.\nSection_id: AbstractCairoGraphDrawer",
    "Field List > Methods > __call__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FakeModule",
    "Field List > Methods > __getattr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FakeModule",
    "Field List > Methods > __init__: Description: Constructor.\nParamters: message:  to print in exceptions raised from this module\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FakeModule",
    "Field List > Methods > __setattr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FakeModule",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer.__init__\nConstructs the edge drawer.\nParamters: context: a Cairo  on which the edges will be drawn.\npalette: the  that can be used to map integer color indices to colors when drawing edges\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: LightToDarkEdgeDrawer",
    "Field List > Methods > draw_directed_edge: Description: Inherited from AlphaVaryingEdgeDrawer:Draws a directed edge.\nSection_id: LightToDarkEdgeDrawer",
    "Field List > Methods > __init__: Description: Constructs the drawer and associates it to the given Axes.\nParamters: ax: the Axes on which we will draw\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibPaletteDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.\nParamters: matrix: the igraph.Histogram to plot.\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibPaletteDrawer",
    "Field List > Methods > __call__: Description: overridden in igraph.app.shell.ClassicPythonShell, igraph.app.shell.IDLEShell, igraph.app.shell.IPythonShell\nUndocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Shell",
    "Field List > Methods > get_progress_handler: Description: Returns the progress handler (if exists) or None (if not).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Shell",
    "Field List > Methods > get_status_handler: Description: Returns the status handler (if exists) or None (if not).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Shell",
    "Field List > Methods > supports_progress_bar: Description: Checks whether the shell supports progress bars.\nThis is done by checking for the existence of an attribute called _progress_handler.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Shell",
    "Field List > Methods > supports_status_messages: Description: Checks whether the shell supports status messages.\nThis is done by checking for the existence of an attribute called _status_handler.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Shell",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.colors.Palette.__init__\nCreates a gradient palette.\nParamters: color1: the color where the gradient starts.\ncolor2: the color where the gradient ends.\nn: the umber of colors i the palette.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GradientPalette",
    "Field List > Methods > __len__: Description: Inherited from Palette:Returns the number of colors in this palette\nSection_id: GradientPalette",
    "Field List > Methods > __plot__: Description: Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes\nSection_id: GradientPalette",
    "Field List > Methods > __repr__: Description: Inherited from Palette:Undocumented\nSection_id: GradientPalette",
    "Field List > Methods > clear_cache: Description: Inherited from Palette:Clears the result cache.\nSection_id: GradientPalette",
    "Field List > Methods > get: Description: Inherited from Palette:Returns the given color from the palette.\nSection_id: GradientPalette",
    "Field List > Methods > get_many: Description: Inherited from Palette:Returns multiple colors from the palette.\nSection_id: GradientPalette",
    "Field List > Methods > __init__: Description: Create a TerminalController and initialize its attributes with appropriate values for the current terminal. term_stream is the stream that will be used for terminal output; if this stream is not a tty, then the terminal is assumed to be a dumb terminal (i.e., have no capabilities).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: TerminalController",
    "Field List > Methods > render: Description: Replace each $-substitutions in the given template string with the corresponding terminal control string (if it's defined) or '' (if it's not).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: TerminalController",
    "Field List > Methods > __complex__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > __float__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > __init__: Description: RunningMean(items=None, n=0.0, mean=0.0, sd=0.0)\nInitializes the running mean calculator.\nThere are two possible ways to initialize the calculator. First, one can provide an iterable of items; alternatively, one can specify the number of items, the mean and the standard deviation if we want to continue an interrupted calculation.\nParamters: items: the  that are used to initialize the running mean calcuator. If  is given, n, mean and sd must be zeros.\nn: the iitial umber of elemets already processed. If this is give, items must be Noe.\nmean: the initial . If this is given, items must be None.\nsd: the initial standard deviation. If this is given, items must be None.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > __int__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > __len__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > __str__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > add: Description: RunningMean.add(value, repeat=1)\nAdds the given value to the elements from which we calculate the mean and the standard deviation.\nParamters: value: the element to be added\nrepeat: number of ed additions\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > add_many: Description: RunningMean.add(values)\nAdds the values in the given iterable to the elements from which we calculate the mean. Can also accept a single number. The left shift (<<) operator is aliased to this function, so you can use it to add elements as well:\nParamters: values: :iterablethe element(s) to be added\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Adds the values in the given iterable to the elements from which we calculate the mean. Can also accept a single number. The left shift (<<) operator is aliased to this function, so you can use it to add elements as well:\n>>> rm=RunningMean()\n>>> rm << [1,2,3,4]\n>>> rm.result               # doctest:+ELLIPSIS\n(2.5, 1.290994...)\n]\nSection_id: RunningMean",
    "Field List > Methods > clear: Description: Resets the running mean calculator.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: RunningMean",
    "Field List > Methods > __init__: Description: overrides igraph.VertexClustering.__init__\nInitializes the cut.\nThis should not be called directly, everything is taken care of by the functions that return cuts.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cut",
    "Field List > Methods > __repr__: Description: overridden in igraph.Flow\nUndocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cut",
    "Field List > Methods > __str__: Description: overrides igraph.Clustering.__str__\nUndocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Cut",
    "Field List > Methods > __plot__: Description: Inherited from VertexClustering:Plots the clustering to the given Cairo context or matplotlib Axes.\nSection_id: Cut",
    "Field List > Methods > as_cover: Description: Inherited from VertexClustering:Returns a VertexCover that contains the same clusters as this clustering.\nSection_id: Cut",
    "Field List > Methods > cluster_graph: Description: Inherited from VertexClustering:Returns a graph where each cluster is contracted into a single vertex.\nSection_id: Cut",
    "Field List > Methods > crossing: Description: Inherited from VertexClustering:Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.\nSection_id: Cut",
    "Field List > Methods > giant: Description: Inherited from VertexClustering:Returns the largest cluster of the clustered graph.\nSection_id: Cut",
    "Field List > Methods > recalculate_modularity: Description: Inherited from VertexClustering:Recalculates the stored modularity value.\nSection_id: Cut",
    "Field List > Methods > subgraph: Description: Inherited from VertexClustering:Get the subgraph belonging to a given cluster.\nSection_id: Cut",
    "Field List > Methods > subgraphs: Description: Inherited from VertexClustering:Gets all the subgraphs belonging to each of the clusters.\nSection_id: Cut",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: HullCollection",
    "Field List > Methods > draw: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: HullCollection",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.graph.AbstractCairoGraphDrawer.__init__\nConstructs the graph drawer and associates it to the given Cairo context and the given BoundingBox.\nParamters: context: the  on which we will draw\nbbox: the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).\nvertex_drawer_factory: a factory method that returns an AbstractCairoVertexDrawer instance bound to a given Cairo context. The factory method must take four parameters: the Cairo context, the bounding box of the drawing area, the palette to be used for drawing colored vertices, and the graph layout. The default vertex drawer is CairoVertexDrawer.\nedge_drawer_factory: a factory method that returns an AbstractCairoEdgeDrawer instance bound to a given Cairo context. The factory method must take two parameters: the Cairo context and the palette to be used for drawing colored edges. You can use any of the actual AbstractEdgeDrawer implementations here to control the style of edges drawn by igraph. The default edge drawer is CairoArrowEdgeDrawer.\nlabel_drawer_factory: a factory method that returns a CairoTextDrawer instance bound to a given Cairo context. The method must take one parameter: the Cairo context. The default label drawer is CairoTextDrawer.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoGraphDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoGraphDrawer",
    "Field List > Methods > all_edges: Description: Proxy method to Graph.incident(..., mode=\"all\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"all\" as the mode argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.incident() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > attribute_names: Description: Returns the list of vertex attribute names\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Vertex",
    "Field List > Methods > attributes: Description: Returns a dict of attribute names and values for the vertex\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Vertex",
    "Field List > Methods > betweenness: Description: Proxy method to Graph.betweenness()\nThis method calls the betweenness() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.betweenness() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > closeness: Description: Proxy method to Graph.closeness()\nThis method calls the closeness() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.closeness() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > constraint: Description: Proxy method to Graph.constraint()\nThis method calls the constraint() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.constraint() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > degree: Description: Proxy method to Graph.degree()\nThis method calls the degree() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.degree() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > delete: Description: Proxy method to Graph.delete_vertices()\nThis method calls the delete_vertices method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.delete_vertices() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > distances: Description: Proxy method to Graph.distances()\nThis method calls the distances() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.distances() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > diversity: Description: Proxy method to Graph.diversity()\nThis method calls the diversity() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.diversity() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > eccentricity: Description: Proxy method to Graph.eccentricity()\nThis method calls the eccentricity() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.eccentricity() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > get_shortest_paths: Description: Proxy method to Graph.get_shortest_paths()\nThis method calls the get_shortest_paths() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.get_shortest_paths() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > in_edges: Description: Proxy method to Graph.incident(..., mode=\"in\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"in\" as the mode argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.incident() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > incident: Description: Proxy method to Graph.incident()\nThis method calls the incident() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.incident() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > indegree: Description: Proxy method to Graph.indegree()\nThis method calls the indegree() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.indegree() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > is_minimal_separator: Description: Proxy method to Graph.is_minimal_separator()\nThis method calls the is_minimal_separator() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.is_minimal_separator() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > is_separator: Description: Proxy method to Graph.is_separator()\nThis method calls the is_separator() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.is_separator() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > neighbors: Description: Proxy method to Graph.neighbors()\nThis method calls the neighbors() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.neighbors() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > out_edges: Description: Proxy method to Graph.incident(..., mode=\"out\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"out\" as the mode argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.incident() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > outdegree: Description: Proxy method to Graph.outdegree()\nThis method calls the outdegree() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.outdegree() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > pagerank: Description: Proxy method to Graph.pagerank()\nThis method calls the pagerank() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.pagerank() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > personalized_pagerank: Description: Proxy method to Graph.personalized_pagerank()\nThis method calls the personalized_pagerank() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.personalized_pagerank() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > predecessors: Description: Proxy method to Graph.predecessors()\nThis method calls the predecessors() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.predecessors() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > strength: Description: Proxy method to Graph.strength()\nThis method calls the strength() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.strength() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > successors: Description: Proxy method to Graph.successors()\nThis method calls the successors() method of the Graph class with this vertex as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.successors() for details.\nexample: []\nSection_id: Vertex",
    "Field List > Methods > update_attributes: Description: Updates the attributes of the vertex from dict/iterable E and F.\nIf E has a keys() method, it does: for k in E: self[k] = E[k]. If E lacks a keys() method, it does: for (k, v) in E: self[k] = v. In either case, this is followed by: for k in F: self[k] = F[k].\nThis method thus behaves similarly to the update() method of Python dictionaries.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Vertex",
    "Field List > Methods > __init__: Description: overridden in igraph.drawing.colors.AdvancedGradientPalette, igraph.drawing.colors.GradientPalette, igraph.drawing.colors.PrecalculatedPalette, igraph.drawing.colors.RainbowPalette\nUndocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Palette",
    "Field List > Methods > __len__: Description: Returns the number of colors in this palette\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Palette",
    "Field List > Methods > __plot__: Description: Plots the colors of the palette on the given Cairo context/mpl Axes\nSupported keywork arguments in both Cairo and matplotlib are:orientation: the orientation of the palette. Must be one of the following values: left-right, bottom-top, right-left or top-bottom. Possible aliases: horizontal = left-right, vertical = bottom-top, lr = left-right, rl = right-left, tb = top-bottom, bt = bottom-top. The default is left-right.\nAdditional supported keyword arguments in Cairo are:border_width: line width of the border shown around the palette. If zero or negative, the border is turned off. Default is 1.grid_width: line width of the grid that separates palette cells. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 0.  Fractional widths are also allowed.\nKeyword arguments in matplotlib are passes to Axes.imshow.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Palette",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Palette",
    "Field List > Methods > clear_cache: Description: Clears the result cache.\nThe return values of Palette.get are cached. Use this method to clear the cache.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Palette",
    "Field List > Methods > get: Description: Returns the given color from the palette.\nValues are cached: if the specific value given has already been looked up, its value will be returned from the cache instead of calculating it again. Use Palette.clear_cache to clear the cache if necessary.\nParamters: v: the color to be retrieed. If it is an integer, it is passed to Palette._get to be translated to an RGBA quadruplet. Otherwise it is passed to color_name_to_rgb() to determine the RGBA alues.\nReturn: [the color as an RGBA quadruplet, you shouldn't override this method in subclasses, override _get instead. If you override this method, lookups in the known_colors dict won't work, so you won't be able to refer to colors by names or RGBA quadruplets, only by integer indices. The caching functionality will disappear as well. However, feel free to override this method if this is exactly the behaviour you want.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Palette",
    "Field List > Methods > get_many: Description: Returns multiple colors from the palette.\nValues are cached: if the specific value given has already been looked upon, its value will be returned from the cache instead of calculating it again. Use Palette.clear_cache to clear the cache if necessary.\nParamters: colors: the list of  to be retrieved. The palette class tries to make an educated guess here: if it is not possible to interpret the value you passed here as a list of , the class will simply try to interpret it as a single color by forwarding the value to Palette.get.\nReturn: [the colors as a list of RGBA quadruplets. The result will be a list even if you passed a single color index or color name.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Palette",
    "Field List > Methods > attribute_names: Description: Returns the attribute name list of the graph's vertices\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexSeq",
    "Field List > Methods > find: Description: overridden in igraph.VertexSeq\nFor internal use only.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexSeq",
    "Field List > Methods > get_attribute_values: Description: Returns the value of a given vertex attribute for all vertices in a list.\nThe values stored in the list are exactly the same objects that are stored in the vertex attribute, meaning that in the case of mutable objects, the modification of the list element does affect the attribute stored in the vertex. In the case of immutable objects, modification of the list does not affect the attribute values.\nParamters: attrname: the name of the attribute\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexSeq",
    "Field List > Methods > select: Description: overridden in igraph.VertexSeq\nFor internal use only.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexSeq",
    "Field List > Methods > set_attribute_values: Description: Sets the value of a given vertex attribute for all vertices\nParamters: attrname: the name of the attribute\nvalues: the new attribute  in a list\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexSeq",
    "Field List > Methods > __init__: Description: overridden in igraph.VertexDendrogram\nCreates a hierarchical clustering.\nParamters: merges: the merge history either in matrix or tuple format\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Dendrogram",
    "Field List > Methods > __plot__: Description: overridden in igraph.VertexDendrogram\nDraws the dendrogram on the given Cairo context or matplotlib Axes.\nSupported keyword arguments are:orientation: the orientation of the dendrogram. Must be one of the following values: left-right, bottom-top, right-left or top-bottom. Individual elements are always placed at the former edge and merges are performed towards the latter edge. Possible aliases: horizontal = left-right, vertical = bottom-top, lr = left-right, rl = right-left, tb = top-bottom, bt = bottom-top. The default is left-right.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Dendrogram",
    "Field List > Methods > __str__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Dendrogram",
    "Field List > Methods > format: Description: Formats the dendrogram in a foreign format.\nCurrently only the Newick format is supported.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> d = Dendrogram([(2, 3), (0, 1), (4, 5)])\n>>> d.format()\n'((2,3)4,(0,1)5)6;'\n>>> d.names = list(\"ABCDEFG\")\n>>> d.format()\n'((C,D)E,(A,B)F)G;'\n]\nSection_id: Dendrogram",
    "Field List > Methods > names: Description: Sets the names of the nodes in the dendrogram\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Dendrogram",
    "Field List > Methods > summary: Description: Returns the summary of the dendrogram.\nThe summary includes the number of leafs and branches, and also an ASCII art representation of the dendrogram unless it is too large.\nParamters: verbosity: determines whether the ASCII representation of the dendrogram should be printed. Zero  prints only the number of leafs and branches.\nmax_leaf_count: the maximal number of leafs to print in the ASCII representation. If the dendrogram has more leafs than this limit, the ASCII representation will not be printed even if the verbosity is larger than or equal to 1.\nReturn: [the summary of the dendrogram as a string.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Dendrogram",
    "Field List > Methods > infer_cytoscape_type: Description: Returns a Cytoscape type that can be used to represent all the values in values and an appropriately converted copy of values that is suitable for an XML-RPC call.  Note that the string type in Cytoscape is used as a catch-all type; if no other type fits, attribute values will be converted to string and then posted to Cytoscape.\nNone entries are allowed in values, they will be ignored on the Cytoscape side.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CytoscapeGraphDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.baseclasses.AbstractXMLRPCDrawer.__init__\nConstructs a Cytoscape graph drawer using the XML-RPC interface of Cytoscape at the given URL.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CytoscapeGraphDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nSends the given graph to Cytoscape as a new network.\nParamters: graph: Undocumented\nname: the  of the network in Cytoscape.\ncreate_view: whether to create a view for the network in Cytoscape.The default is True.\n*args: Undocumented\nnode_ids: specifies the identifiers of the nodes to be used in Cytoscape. This must either be the name of a vertex attribute or a list specifying the identifiers, one for each node in the graph. The default is None, which simply uses the vertex index for each vertex.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CytoscapeGraphDrawer",
    "Field List > Methods > fetch: Description: Fetches the network with the given name from Cytoscape.\nWhen fetching networks from Cytoscape, the canonicalName attributes of vertices and edges are not converted by default. Use the keep_canonical_names parameter to retrieve these attributes as well.\nParamters: name: the  of the network in Cytoscape.\ndirected: whether the network is .\nkeep_canonical_names: whether to keep the canonicalName vertex/edge attributes that are added automatically by Cytoscape\nReturn: [an appropriately constructed igraph Graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CytoscapeGraphDrawer",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > contains: Description: Track 'contains' event for mouse interactions.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nDraw each of the children, with some buffering mechanism.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > get_children: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > get_datalim: Description: Get limits on x/y axes based on the graph layout data.\nThere is a small padding based on the size of the vertex marker to ensure it fits into the canvas.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > get_edge_labels: Description: Get list of edge label artists.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > get_edges: Description: Get EdgeCollection artist.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > get_groups: Description: Get HullCollection group/cluster/cover artists.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > get_vertex_labels: Description: Get list of vertex label artists.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > get_vertices: Description: Get VertexCollection artist.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > pick: Description: Track 'pick' event for mouse interactions.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > set: Description: Set multiple parameters at once.\nThe same options can be used as in the igraph.plot function.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphArtist",
    "Field List > Methods > FromAttribute: Description: Creates a vertex clustering based on the value of a vertex attribute.\nVertices having the same attribute will correspond to the same cluster.\nParamters: graph: the  on which we are working\nattribute: name of the  on which the clustering is based.\nintervals: for numeric attributes, you can either pass a single number or a list of numbers here. A single number means that the vertices will be put in bins of that width and vertices ending up in the same bin will be in the same cluster. A list of numbers specify the bin positions explicitly; e.g., [10, 20, 30] means that there will be four categories: vertices with the attribute value less than 10, between 10 and 20, between 20 and 30 and over 30. Intervals are closed from the left and open from the right.\nparams: additional parameters to be stored in this object.\nReturn: [a new VertexClustering object]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > __init__: Description: overrides igraph.Clustering.__init__\nCreates a clustering object for a given graph.\nParamters: graph: the  that will be associated to the clustering\nmembership: the  list. The length of the list must be equal to the number of vertices in the graph. If None, every vertex is assumed to belong to the same cluster.\nmodularity: the  score of the clustering. If None, it will be calculated when needed.\nparams: additional parameters to be stored in this object.\nmodularity_params: arguments that should be passed to Graph.modularity when the modularity is (re)calculated. If the original graph was weighted, you should pass a dictionary containing a weight key with the appropriate value here.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > __plot__: Description: Plots the clustering to the given Cairo context or matplotlib Axes.\nThis is done by calling Graph.__plot__() with the same arguments, but coloring the graph vertices according to the current clustering (unless overridden by the vertex_color argument explicitly).\nThis method understands all the positional and keyword arguments that are understood by Graph.__plot__(), only the differences will be highlighted here:mark_groups: whether to highlight some of the vertex groups by colored polygons. Besides the values accepted by Graph.__plot__ (i.e., a dict mapping colors to vertex indices, a list containing lists of vertex indices, or False), the following are also accepted:True: all the groups will be highlighted, the colors matching the corresponding color indices from the current palette (see the palette keyword argument of Graph.__plot__).A dict mapping cluster indices or tuples of vertex indices to color names.  The given clusters or vertex groups will be highlighted by the given colors.A list of cluster indices. This is equivalent to passing a dict mapping numeric color indices from the current palette to cluster indices; therefore, the cluster referred to by element i of the list will be highlighted by color i from the palette.The value of the plotting.mark_groups configuration key is also taken into account here; if that configuration key is True and mark_groups is not given explicitly, it will automatically be set to True.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.palette: the palette used to resolve numeric color indices to RGBA values. By default, this is an instance of ClusterColoringPalette.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.__plot__() for more supported keyword arguments.\nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > as_cover: Description: overrides igraph.Clustering.as_cover\nReturns a VertexCover that contains the same clusters as this clustering.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > cluster_graph: Description: Returns a graph where each cluster is contracted into a single vertex.\nIn the resulting graph, vertex i represents cluster i in this clustering. Vertex i and j will be connected if there was at least one connected vertex pair (a, b) in the original graph such that vertex a was in cluster i and vertex b was in cluster j.\nParamters: combine_vertices: specifies how to derive the attributes of the vertices in the new graph from the attributes of the old ones. See Graph.contract_vertices() for more details.\ncombine_edges: specifies how to derive the attributes of the edges in the new graph from the attributes of the old ones. See Graph.simplify() for more details. If you specify False here, edges will not be combined, and the number of edges between the vertices representing the original clusters will be equal to the number of edges between the members of those clusters in the original graph.\nReturn: [the new graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > crossing: Description: Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > giant: Description: Returns the largest cluster of the clustered graph.\nThe largest cluster is a cluster for which no larger cluster exists in the clustering. It may also be known as the giant community if the clustering represents the result of a community detection function.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.\nParamters: \nReturn: [a copy of the largest cluster., there can be multiple largest clusters, this method will return the copy of an arbitrary one if there are multiple largest clusters.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > recalculate_modularity: Description: Recalculates the stored modularity value.\nThis method must be called before querying the modularity score of the clustering through the class member modularity or q if the graph has been modified (edges have been added or removed) since the creation of the VertexClustering object.\nParamters: \nReturn: [the new modularity score]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > subgraph: Description: Get the subgraph belonging to a given cluster.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.\nParamters: idx: the cluster index\nReturn: [a copy of the subgraph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > subgraphs: Description: Gets all the subgraphs belonging to each of the clusters.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.\nParamters: \nReturn: [a list containing copies of the subgraphs]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexClustering",
    "Field List > Methods > __getitem__: Description: Inherited from Clustering:Returns the members of the specified cluster.\nSection_id: VertexClustering",
    "Field List > Methods > __iter__: Description: Inherited from Clustering:Iterates over the clusters in this clustering.\nSection_id: VertexClustering",
    "Field List > Methods > __len__: Description: Inherited from Clustering:Returns the number of clusters.\nSection_id: VertexClustering",
    "Field List > Methods > __str__: Description: Inherited from Clustering:Undocumented\nSection_id: VertexClustering",
    "Field List > Methods > compare_to: Description: Inherited from Clustering:Compares this clustering to another one using some similarity or distance metric.\nSection_id: VertexClustering",
    "Field List > Methods > size: Description: Inherited from Clustering:Returns the size of a given cluster.\nSection_id: VertexClustering",
    "Field List > Methods > size_histogram: Description: Inherited from Clustering:Returns the histogram of cluster sizes.\nSection_id: VertexClustering",
    "Field List > Methods > sizes: Description: Inherited from Clustering:Returns the size of given clusters.\nSection_id: VertexClustering",
    "Field List > Methods > summary: Description: Inherited from Clustering:Returns the summary of the clustering.\nSection_id: VertexClustering",
    "Field List > Methods > draw_path: Description: overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws an upright triangle on the Cairo context without stroking or filling it.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.draw_path\nexample: []\nSection_id: UpTriangleDrawer",
    "Field List > Methods > intersection_point: Description: overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the triangle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.intersection_point\nexample: []\nSection_id: UpTriangleDrawer",
    "Field List > Methods > __init__: Description: overridden in igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer, igraph.drawing.matplotlib.vertex.MatplotlibVertexDrawer, igraph.drawing.plotly.vertex.PlotlyVerticesDrawer\nConstructs the vertex drawer and associates it to the given palette.\nParamters: palette: the  that can be used to map integer color indices to colors when drawing vertices\nlayout: the  of the vertices in the graph being drawn\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractVertexDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given vertex.\nParamters: visual_vertex: object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.\nvertex: the raw igraph  being drawn\ncoords: the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractVertexDrawer",
    "Field List > Methods > __init__: Description: Creates a new plot.\nParamters: target: the  surface to write to. It can be one of the following types:None -- a Cairo surface will be created and the object will be plotted there.cairo.Surface -- the given Cairo surface will be used.string -- a file with the given name will be created and an appropriate Cairo surface will be attached to it.\nbbox: the bounding box of the surface. It is interpreted differently with different surfaces: PDF and PS surfaces will treat it as points (1 point = 1/72 inch). Image surfaces will treat it as pixels. SVG surfaces will treat it as an abstract unit, but it will mostly be interpreted as pixels when viewing the SVG file in Firefox.\npalette: the  primarily used on the plot if the added objects do not specify a private . Must be either an igraph.drawing.colors.Palette object or a string referring to a valid key of igraph.drawing.colors.s (see module igraph.drawing.colors) or None. In the latter case, the default  given by the configuration key plotting. is used.\nbackground: the  color. If None, the  will be transparent. You can use any color specification here that is understood by igraph.drawing.colors.color_name_to_rgba.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPlot",
    "Field List > Methods > add: Description: Adds an object to the plot.\nArguments not specified here are stored and passed to the object's plotting function when necessary. Since you are most likely interested in the arguments acceptable by graphs, see Graph.__plot__ for more details.\nParamters: obj: the ect to be added\nbbox: the bounding box of the object. If None, the object will fill the entire area of the plot.\npalette: the color  used for drawing the object. If the object tries to get a color assigned to a positive integer, it will use this . If None, defaults to the global  of the plot.\nopacity: the  of the object being plotted, in the range 0.0-1.0\n*args: Undocumented\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.__plot__\nexample: []\nSection_id: CairoPlot",
    "Field List > Methods > background: Description: Sets the background color of the plot. None means a transparent background. You can use any color specification here that is understood by the get method of the current palette or by igraph.drawing.colors.color_name_to_rgb.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPlot",
    "Field List > Methods > mark_dirty: Description: Marks the plot as dirty (should be redrawn)\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPlot",
    "Field List > Methods > redraw: Description: Redraws the plot\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPlot",
    "Field List > Methods > remove: Description: Removes an object from the plot.\nIf the object has been added multiple times and no bounding box was specified, it removes the instance which occurs idxth in the list of identical instances of the object.\nParamters: obj: the ect to be removed\nbbox: optional bounding box specification for the object. If given, only objects with exactly this bounding box will be considered.\nidx: if multiple objects match the specification given by obj and bbox, only the th occurrence will be removed.\nReturn: [True if the object has been removed successfully, False if the object was not on the plot at all or idx was larger than the count of occurrences]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPlot",
    "Field List > Methods > save: Description: Saves the plot.\nParamters: fname: the filename to save to. It is ignored if the surface of the plot is not an ImageSurface.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPlot",
    "Field List > Methods > __init__: Description: Constructs a summary representation of a graph.\nParamters: graph: Undocumented\nverbosity: the  of the summary. If zero, only the header line will be returned. If one, the header line and the list of edges will both be returned.\nwidth: the maximal  of each line in the summary. None means that no limit will be enforced.\nedge_list_format: format of the edge list in the summary. Supported formats are: compressed, adjlist, edgelist, auto, which selects automatically from the other three based on some simple criteria.\nmax_rows: the maximal number of rows to print in a single table (e.g., vertex attribute table or edge attribute table)\nprint_graph_attributes: whether to print graph attributes if there are any.\nprint_vertex_attributes: whether to print vertex attributes if there are any.\nprint_edge_attributes: whether to print edge attributes if there are any.\nfull: False has no effect; True turns on the attribute printing for graph, vertex and edge attributes with verbosity 1.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphSummary",
    "Field List > Methods > __str__: Description: Returns the summary representation as a string.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GraphSummary",
    "Field List > Methods > attribute_names: Description: Returns the attribute name list of the graph's edges\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeSeq",
    "Field List > Methods > find: Description: overridden in igraph.EdgeSeq\nFor internal use only.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeSeq",
    "Field List > Methods > get_attribute_values: Description: Returns the value of a given edge attribute for all edges.\nParamters: attrname: the name of the attribute\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeSeq",
    "Field List > Methods > is_all: Description: Returns whether the edge sequence contains all the edges exactly once, in the order of their edge IDs.\nThis is used for optimizations in some of the edge selector routines.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeSeq",
    "Field List > Methods > select: Description: overridden in igraph.EdgeSeq\nFor internal use only.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeSeq",
    "Field List > Methods > set_attribute_values: Description: Sets the value of a given edge attribute for all vertices\nParamters: attrname: the name of the attribute\nvalues: the new attribute  in a list\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeSeq",
    "Field List > Methods > instance: Description: Returns the single instance of the configuration object.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > __contains__: Description: Checks whether the given configuration item is set.\nParamters: item: :strthe configuration key to check.\nReturn: [boolTrue if the key has an associated value, False otherwise.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > __delitem__: Description: Deletes the given item from the configuration.\nIf the item has a default value, the default value is written back instead of the current value. Without a default value, the item is really deleted.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > __getitem__: Description: Returns the given configuration item.\nParamters: item: :strthe configuration key to retrieve.\nReturn: [the configuration value]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > __init__: Description: Creates a new configuration instance.\nParamters: filename: file or file-like object to be read. Can be omitted.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > __setitem__: Description: Sets the given configuration item.\nParamters: item: :strthe configuration key to set\nvalue: the new  of the configuration key\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > has_key: Description: Checks if the configuration has a given key.\nParamters: item: :strthe key being sought\nReturn: [boolUndocumented]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > load: Description: Loads the configuration from the given file.\nParamters: stream: name of a file or a file object. The configuration will be loaded from here. Can be omitted, in this case, the user-level configuration is loaded.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > save: Description: Saves the configuration.\nParamters: stream: :Optional[Union[str, IO[str]]]name of a file or a file-like object. The configuration will be saved there. Can be omitted, in this case, the user-level configuration file will be overwritten.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Configuration",
    "Field List > Methods > __call__: Description: Shorthand notation to select()\nThis method simply passes all its arguments to VertexSeq.select().\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexSeq",
    "Field List > Methods > attributes: Description: Returns the list of all the vertex attributes in the graph associated to this vertex sequence.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexSeq",
    "Field List > Methods > find: Description: overrides igraph._igraph.VertexSeq.find\nReturns the first vertex of the vertex sequence that matches some criteria.\nThe selection criteria are equal to the ones allowed by VertexSeq.select. See VertexSeq.select for more details.\nFor instance, to find the first vertex with name foo in graph g:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [For instance, to find the first vertex with name foo in graph g:\n>>> g.vs.find(name=\"foo\")            #doctest:+SKIP, To find an arbitrary isolated vertex:\n>>> g.vs.find(name=\"foo\")            #doctest:+SKIP]\nSection_id: VertexSeq",
    "Field List > Methods > select: Description: overrides igraph._igraph.VertexSeq.select\nSelects a subset of the vertex sequence based on some criteria\nThe selection criteria can be specified by the positional and the keyword arguments. Positional arguments are always processed before keyword arguments.If the first positional argument is None, an empty sequence is returned.If the first positional argument is a callable object, the object will be called for every vertex in the sequence. If it returns True, the vertex will be included, otherwise it will be excluded.If the first positional argument is an iterable, it must return integers and they will be considered as indices of the current vertex set (NOT the whole vertex set of the graph -- the difference matters when one filters a vertex set that has already been filtered by a previous invocation of VertexSeq.select(). In this case, the indices do not refer directly to the vertices of the graph but to the elements of the filtered vertex sequence.If the first positional argument is an integer, all remaining arguments are expected to be integers. They are considered as indices of the current vertex set again.\nKeyword arguments can be used to filter the vertices based on their attributes. The name of the keyword specifies the name of the attribute and the filtering operator, they should be concatenated by an underscore (_) character. Attribute names can also contain underscores, but operator names don't, so the operator is always the largest trailing substring of the keyword name that does not contain an underscore. Possible operators are:eq: equal tone: not equal tolt: less thangt: greater thanle: less than or equal toge: greater than or equal toin: checks if the value of an attribute is in a given listnotin: checks if the value of an attribute is not in a given list\nFor instance, if you want to filter vertices with a numeric age property larger than 200, you have to write:\nParamters: \nReturn: [the new, filtered vertex sequence]\nReferences: []\nRasises: \nSee Also: \nexample: [For instance, if you want to filter vertices with a numeric age property larger than 200, you have to write:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP, Similarly, to filter vertices whose type is in a list of predefined types:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP, If the operator is omitted, it defaults to eq. For instance, the following selector selects vertices whose cluster property equals to 2:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP, Attribute names inferred from keyword arguments are treated specially if they start with an underscore (_). These are not real attributes but refer to specific properties of the vertices, e.g., its degree. The rule is as follows: if an attribute name starts with an underscore, the rest of the name is interpreted as a method of the Graph object. This method is called with the vertex sequence as its first argument (all others left at default values) and vertices are filtered according to the value returned by the method. For instance, if you want to exclude isolated vertices:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP, For properties that take a long time to be computed (e.g., betweenness centrality for large graphs), it is advised to calculate the values in advance and store it in a graph attribute. The same applies when you are selecting based on the same property more than once in the same select() call to avoid calculating it twice unnecessarily. For instance, the following would calculate betweenness centralities twice:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP, It is advised to use this instead:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP]\nSection_id: VertexSeq",
    "Field List > Methods > attribute_names: Description: Inherited from VertexSeq:Returns the attribute name list of the graph's vertices\nSection_id: VertexSeq",
    "Field List > Methods > get_attribute_values: Description: Inherited from VertexSeq:Returns the value of a given vertex attribute for all vertices in a list.\nSection_id: VertexSeq",
    "Field List > Methods > set_attribute_values: Description: Inherited from VertexSeq:Sets the value of a given vertex attribute for all vertices\nSection_id: VertexSeq",
    "Field List > Methods > draw: Description: overridden in igraph.drawing.baseclasses.AbstractGraphDrawer, igraph.drawing.baseclasses.AbstractVertexDrawer, igraph.drawing.cairo.coord.CoordinateSystem, igraph.drawing.cairo.dendrogram.CairoDendrogramDrawer, igraph.drawing.cairo.graph.CairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer, igraph.drawing.cairo.polygon.CairoPolygonDrawer, igraph.drawing.cairo.text.CairoTextDrawer, igraph.drawing.cairo.vertex.CairoVertexDrawer, igraph.drawing.graph.CytoscapeGraphDrawer, igraph.drawing.matplotlib.dendrogram.MatplotlibDendrogramDrawer, igraph.drawing.matplotlib.histogram.MatplotlibHistogramDrawer, igraph.drawing.matplotlib.matrix.MatplotlibMatrixDrawer, igraph.drawing.matplotlib.palette.MatplotlibPaletteDrawer\nAbstract method, must be implemented in derived classes.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractDrawer",
    "Field List > Methods > attribute_names: Description: Returns the list of edge attribute names\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Edge",
    "Field List > Methods > attributes: Description: Returns a dict of attribute names and values for the edge\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Edge",
    "Field List > Methods > count_multiple: Description: Proxy method to Graph.count_multiple()\nThis method calls the count_multiple method of the Graph class with this edge as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.count_multiple() for details.\nexample: []\nSection_id: Edge",
    "Field List > Methods > delete: Description: Proxy method to Graph.delete_edges()\nThis method calls the delete_edges method of the Graph class with this edge as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.delete_edges() for details.\nexample: []\nSection_id: Edge",
    "Field List > Methods > is_loop: Description: Proxy method to Graph.is_loop()\nThis method calls the is_loop method of the Graph class with this edge as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.is_loop() for details.\nexample: []\nSection_id: Edge",
    "Field List > Methods > is_multiple: Description: Proxy method to Graph.is_multiple()\nThis method calls the is_multiple method of the Graph class with this edge as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.is_multiple() for details.\nexample: []\nSection_id: Edge",
    "Field List > Methods > is_mutual: Description: Proxy method to Graph.is_mutual()\nThis method calls the is_mutual method of the Graph class with this edge as the first argument, and returns the result.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.is_mutual() for details.\nexample: []\nSection_id: Edge",
    "Field List > Methods > update_attributes: Description: Updates the attributes of the edge from dict/iterable E and F.\nIf E has a keys() method, it does: for k in E: self[k] = E[k]. If E lacks a keys() method, it does: for (k, v) in E: self[k] = v. In either case, this is followed by: for k in F: self[k] = F[k].\nThis method thus behaves similarly to the update() method of Python dictionaries.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Edge",
    "Field List > Methods > record_generator: Description: Generates a simple class that has the given slots and nothing else\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AttributeCollectorMeta",
    "Field List > Methods > __new__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AttributeCollectorMeta",
    "Field List > Methods > __contains__: Description: Returns whether there are any items associated to the givenkey.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > __delitem__: Description: Removes all the items associated to the given key.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > __getitem__: Description: Returns an arbitrary item associated to the given key. Raises KeyErrorif no such key exists.\nExample:>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])>>> d[\"spam\"]'eggs'\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])\n>>> d[\"spam\"]\n'eggs'\n]\nSection_id: multidict",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > __iter__: Description: Iterates over the keys of the multidict.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > __len__: Description: Returns the number of distinct keys in this multidict.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > __setitem__: Description: Sets the item associated to the given key. Any values associated to thekey will be erased and replaced by value.\nExample:>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])>>> d[\"spam\"] = \"ham\">>> d[\"spam\"]'ham'\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])\n>>> d[\"spam\"] = \"ham\"\n>>> d[\"spam\"]\n'ham'\n]\nSection_id: multidict",
    "Field List > Methods > add: Description: Adds value to the list of items associated to key.\nExample:>>> d = multidict()>>> d.add(\"spam\", \"ham\")>>> d[\"spam\"]'ham'>>> d.add(\"spam\", \"eggs\")>>> d.getlist(\"spam\")['ham', 'eggs']\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [>>> d = multidict()\n>>> d.add(\"spam\", \"ham\")\n>>> d[\"spam\"]\n'ham'\n>>> d.add(\"spam\", \"eggs\")\n>>> d.getlist(\"spam\")\n['ham', 'eggs']\n]\nSection_id: multidict",
    "Field List > Methods > clear: Description: Removes all the items from the multidict.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > get: Description: Returns an arbitrary item associated to the given key. If keydoes not exist or has zero associated items, default will bereturned.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > getlist: Description: Returns the list of values for the given key. An empty list willbe returned if there is no such key.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > iterlists: Description: Iterates over (key, values) pairs where values is the listof values associated with key.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > lists: Description: Returns a list of (key, values) pairs where values is the listof values associated with key.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > update: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: multidict",
    "Field List > Methods > __call__: Description: overrides igraph.app.shell.Shell.__call__\nStarts the embedded shell.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: IPythonShell",
    "Field List > Methods > __init__: Description: overrides igraph.app.shell.ConsoleProgressBarMixin.__init__\nConstructor.\nImports IPython's embedded shell with separator lines removed.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: IPythonShell",
    "Field List > Methods > get_progress_handler: Description: Inherited from Shell:Returns the progress handler (if exists) or None (if not).\nSection_id: IPythonShell",
    "Field List > Methods > get_status_handler: Description: Inherited from Shell:Returns the status handler (if exists) or None (if not).\nSection_id: IPythonShell",
    "Field List > Methods > supports_progress_bar: Description: Inherited from Shell:Checks whether the shell supports progress bars.\nSection_id: IPythonShell",
    "Field List > Methods > supports_status_messages: Description: Inherited from Shell:Checks whether the shell supports status messages.\nSection_id: IPythonShell",
    "Field List > Methods > __init__: Description: Constructs the graph drawer and associates it with the plotly Figure\nParamters: fig: the plotly.graph_objects.Figure to draw into.\nvertex_drawer_factory: Undocumented\nedge_drawer_factory: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyGraphDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyGraphDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the coordinate system.\nThis method must be overridden in derived classes.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CoordinateSystem",
    "Field List > Methods > local_to_context: Description: overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem\nConverts local coordinates to the context coordinate system (given by the bounding box).\nThis method must be overridden in derived classes.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CoordinateSystem",
    "Field List > Methods > __init__: Description: Inherited from AbstractCairoDrawer:Constructs the drawer and associates it to the given Cairo context and the given BoundingBox.\nSection_id: CoordinateSystem",
    "Field List > Methods > bbox.setter: Description: Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.\nSection_id: CoordinateSystem",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs a new polygon drawer that draws on the given Cairo context.\nParamters: context: the Cairo  to draw on\nbbox: ignored, leave it at its default value\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPolygonDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the polygon using the current stroke of the Cairo context.\nParamters: points: the coordinates of the corners of the polygon, in clockwise or counter-clockwise order.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPolygonDrawer",
    "Field List > Methods > draw_path: Description: Sets up a Cairo path for the outline of a polygon on the given Cairo context.\nParamters: points: the coordinates of the corners of the polygon, in clockwise or counter-clockwise order.\ncorner_radius: if zero, an ordinary polygon will be drawn. If positive, the corners of the polygon will be rounded with the given radius.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPolygonDrawer",
    "Field List > Methods > bbox.setter: Description: Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.\nSection_id: CairoPolygonDrawer",
    "Field List > Methods > __init__: Description: Constructs a Gephi graph streamer that will post graphs to agiven file-like object or a Gephi connection.\nencoder must either be None or an instance of json.JSONEncoderand it must contain the JSON encoder to be used when posting JSON objects.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiGraphStreamer",
    "Field List > Methods > iterjsonobj: Description: Iterates over the JSON objects that build up the graph using theGephi graph streaming API. The objects returned from this function arePython objects; they must be formatted with json.dumps beforesending them to the destination.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiGraphStreamer",
    "Field List > Methods > post: Description: Posts the given graph to the destination of the streamer using thegiven JSON encoder. When encoder is None, it falls back to thedefault JSON encoder of the streamer in the encoder property.\ndestination must be a file-like object or an instance ofGephiConnection.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiGraphStreamer",
    "Field List > Methods > send_event: Description: Sends a single JSON event to the given destination using the givenJSON encoder.  When encoder is None, it falls back to thedefault JSON encoder of the streamer in the encoder property.\ndestination must be a file-like object or an instance ofGephiConnection.\nThe method flushes the destination after sending the event. If you wantto avoid this (e.g., because you are sending many events), setflush to False.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiGraphStreamer",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCollection",
    "Field List > Methods > get_size: Description: Get vertex sizes.\nIf width and height are unequal, get the largest of the two.\nParamters: \nReturn: [An array of vertex sizes.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCollection",
    "Field List > Methods > get_sizes: Description: Same as get_size.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCollection",
    "Field List > Methods > set_size: Description: Set vertex sizes.\nThis rescales the current vertex symbol/path linearly, using this value as the largest of width and height.\nParamters: sizes: A sequence of vertex  or a single size.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCollection",
    "Field List > Methods > set_sizes: Description: Same as set_size.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCollection",
    "Field List > Methods > stale: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCollection",
    "Field List > Methods > draw_directed_edge: Description: overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are defined by the attributes of this object.\ndest_vertex: the source vertex. Visual properties are defined by the attributes of this object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: TaperedEdgeDrawer",
    "Field List > Methods > __init__: Description: Inherited from AbstractCairoEdgeDrawer:Constructs the edge drawer.\nSection_id: TaperedEdgeDrawer",
    "Field List > Methods > draw_loop_edge: Description: Inherited from AbstractCairoEdgeDrawer:Draws a loop edge.\nSection_id: TaperedEdgeDrawer",
    "Field List > Methods > draw_undirected_edge: Description: Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge.\nSection_id: TaperedEdgeDrawer",
    "Field List > Methods > __bool__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > __eq__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > __hash__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > __init__: Description: Creates a rectangle.\nThe corners of the rectangle can be specified by either a tuple (four items, two for each corner, respectively), four separate numbers (X and Y coordinates for each corner) or two separate numbers (width and height, the upper left corner is assumed to be at (0,0))\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > __ior__: Description: overridden in igraph.drawing.utils.BoundingBox\nExpands this rectangle to include itself and another completely while still being as small as possible.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1 |= r2\n    >>> r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r1 |= r3\n    >>> r1\n    Rectangle(10.0, 10.0, 90.0, 90.0)\n]\nSection_id: Rectangle",
    "Field List > Methods > __ne__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > bottom: Description: Sets the Y coordinate of the bottom edge of the box\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > contract: Description: Contracts the rectangle by the given margins.\nParamters: \nReturn: [a new Rectangle object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > coords: Description: Sets the coordinates of the corners.\nParamters: coords: a 4-tuple with the coordinates of the corners\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > expand: Description: Expands the rectangle by the given margins.\nParamters: \nReturn: [a new Rectangle object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > height: Description: Sets the height of the rectangle by adjusting the bottom edge.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > intersection: Description: Returns the intersection of this rectangle with another.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.intersection(r2)\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2 & r1\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2.intersection(r1) == r1.intersection(r2)\n    True\n    >>> r1.intersection(r3)\n    Rectangle(0.0, 0.0, 0.0, 0.0)\n]\nSection_id: Rectangle",
    "Field List > Methods > isdisjoint: Description: Returns True if the two rectangles have no intersection.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.isdisjoint(r2)\n    False\n    >>> r2.isdisjoint(r1)\n    False\n    >>> r1.isdisjoint(r3)\n    True\n    >>> r3.isdisjoint(r1)\n    True\n]\nSection_id: Rectangle",
    "Field List > Methods > isempty: Description: Returns True if the rectangle is empty (i.e. it has zero width and height).\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(70, 70, 90, 90)\n    >>> r1.isempty()\n    False\n    >>> r2.isempty()\n    False\n    >>> r1.intersection(r2).isempty()\n    True\n]\nSection_id: Rectangle",
    "Field List > Methods > left: Description: Sets the X coordinate of the left side of the box\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > midx: Description: Moves the center of the box to the given X coordinate\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > midy: Description: Moves the center of the box to the given Y coordinate\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > right: Description: Sets the X coordinate of the right side of the box\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > shape: Description: Sets the shape of the rectangle (width, height).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > top: Description: Sets the Y coordinate of the top edge of the box\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > translate: Description: Translates the rectangle in-place.\nExample:\nParamters: dx: the X coordinate of the translation vector\ndy: the Y coordinate of the translation vector\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> r = Rectangle(10, 20, 50, 70)\n>>> r.translate(30, -10)\n>>> r\nRectangle(40.0, 10.0, 80.0, 60.0)\n]\nSection_id: Rectangle",
    "Field List > Methods > union: Description: Returns the union of this rectangle with another.\nThe resulting rectangle is the smallest rectangle that contains both rectangles.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.union(r2)\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2 | r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2.union(r1) == r1.union(r2)\n    True\n    >>> r1.union(r3)\n    Rectangle(10.0, 10.0, 90.0, 90.0)\n]\nSection_id: Rectangle",
    "Field List > Methods > width: Description: Sets the width of the rectangle by adjusting the right edge.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Rectangle",
    "Field List > Methods > draw_directed_edge: Description: overridden in igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer, igraph.drawing.cairo.edge.CairoArrowEdgeDrawer, igraph.drawing.cairo.edge.TaperedEdgeDrawer, igraph.drawing.matplotlib.edge.MatplotlibEdgeDrawer, igraph.drawing.plotly.edge.PlotlyEdgeDrawer\nDraws a directed edge.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are defined by the attributes of this object.\ndest_vertex: the source vertex. Visual properties are defined by the attributes of this object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractEdgeDrawer",
    "Field List > Methods > draw_undirected_edge: Description: overridden in igraph.drawing.cairo.edge.AbstractCairoEdgeDrawer, igraph.drawing.matplotlib.edge.MatplotlibEdgeDrawer, igraph.drawing.plotly.edge.PlotlyEdgeDrawer\nDraws an undirected edge.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are defined by the attributes of this object.\ndest_vertex: the source vertex. Visual properties are defined by the attributes of this object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractEdgeDrawer",
    "Field List > Methods > get_label_position: Description: Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.\nParamters: edge: the  to be drawn. visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. visual properties are given again as attributes.\ndest_vertex: the target vertex. visual properties are given again as attributes.\nReturn: [a tuple containing two more tuples: the desired position of the label and the desired alignment of the label, where the position is given as c{(x, y)} and the alignment is given as c{(horizontal, vertical)}. members of the alignment tuple are taken from constants in the l{textalignment} class.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractEdgeDrawer",
    "Field List > Methods > get_label_rotation: Description: Get the rotation angle of the label to align with the edge.\nParamters: edge: the  to be drawn. visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. visual properties are given again as attributes.\ndest_vertex: the target vertex. visual properties are given again as attributes.\nReturn: [a float with the desired angle, in degrees (out of 360).]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractEdgeDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.\nParamters: context: the  on which we will draw\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoMatrixDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a Cairo context.\nParamters: matrix: the igraph.Matrix to plot.It accepts the following keyword arguments:bbox:    the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).palette: the palette that can be used to map integer color indices to colors when drawing verticesstyle: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the  are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the  should be square or not. Default is True.grid_width: line width of the grid shown on the . If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the . If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the  being plotted. If it is another , the values of that  are shown in the cells. In this case, the shape of the value  must match the shape of the  being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.If only the row names or the column names are given and the  is square-shaped, the same names are used for both column and row names.\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoMatrixDrawer",
    "Field List > Methods > bbox.setter: Description: Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.\nSection_id: CairoMatrixDrawer",
    "Field List > Methods > Fill: Description: Creates a matrix filled with the given value\nParamters: value: the  to be used\n*args: Undocumented\nshape: the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > Identity: Description: Creates an identity matrix.\nParamters: *args: Undocumented\nshape: the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > Zero: Description: Creates a matrix filled with zeros.\nParamters: *args: Undocumented\nshape: the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __add__: Description: Adds the given value to the matrix.\nParamters: other: either a scalar or a matrix. Scalars will be added to each element of the matrix. Matrices will be added together elementwise.\nReturn: [the result matrix]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __eq__: Description: Checks whether a given matrix is equal to another one\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __getitem__: Description: Returns a single item, a row or a column of the matrix\nParamters: i: f a sngle nteger, returns the th row as a lst. If a slce, returns the correspondng rows as another Matrx object. If a 2-tuple, the frst element of the tuple s used to select a row and the second s used to select a column.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __hash__: Description: Returns a hash value for a matrix.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __iadd__: Description: In-place addition of a matrix or scalar.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __init__: Description: Initializes a matrix.\nParamters: data: the elements of the matrix as a list of lists, or None to create a 0x0 matrix.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __isub__: Description: In-place subtraction of a matrix or scalar.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __iter__: Description: Support for iteration.\nThis is actually implemented as a generator, so there is no need for a separate iterator class. The generator returns copies of the rows in the matrix as lists to avoid messing around with the internals. Feel free to do anything with the copies, the changes won't be reflected in the original matrix.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __len__: Description: Returns the number of rows in the matrix.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __ne__: Description: Checks whether a given matrix is not equal to another one\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __plot__: Description: Plots the matrix to the given Cairo context or matplotlib Axes.\nBesides the usual self-explanatory plotting parameters (context, bbox, palette), it accepts the following keyword arguments:style: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the matrix are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the matrix should be square or not. Default is True.grid_width: line width of the grid shown on the matrix. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the matrix. If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the matrix being plotted. If it is another matrix, the values of that matrix are shown in the cells. In this case, the shape of the value matrix must match the shape of the matrix being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.\nIf only the row names or the column names are given and the matrix is square-shaped, the same names are used for both column and row names.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __setitem__: Description: Sets a single item, a row or a column of the matrix\nParamters: i: f a sngle nteger, sets the th row as a lst. If a slce, sets the correspondng rows from another Matrx object. If a 2-tuple, the frst element of the tuple s used to select a row and the second s used to select a column.\nvalue: the new\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __str__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __sub__: Description: Subtracts the given value from the matrix.\nParamters: other: either a scalar or a matrix. Scalars will be subtracted from each element of the matrix. Matrices will be subtracted together elementwise.\nReturn: [the result matrix]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > max: Description: Returns the maximum of the matrix along the given dimension\nParamters: dim: the ension. 0 means determining the column maximums, 1 means determining the row maximums. If None, the global maximum is returned.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > min: Description: Returns the minimum of the matrix along the given dimension\nParamters: dim: the ension. 0 means determining the column minimums, 1 means determining the row minimums. If None, the global minimum is returned.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matrix",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > draw: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > get_arrow_size: Description: Get arrow sizes for the edges (directed only).\nParamters: \nReturn: [An array of arrow sizes.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > get_arrow_sizes: Description: Same as get_arrow_size.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > get_arrow_width: Description: Get arrow widths for the edges (directed only).\nParamters: \nReturn: [An array of arrow widths.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > get_arrow_widths: Description: Same as get_arrow_width.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > set_arrow_size: Description: Set arrow sizes.\nParamters: sizes: A sequence of arrow  or a single size.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > set_arrow_sizes: Description: Same as set_arrow_size\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > set_arrow_width: Description: Set arrow widths.\nParamters: widths: A sequence of arrow  or a single width.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > set_arrow_widths: Description: Same as set_arrow_width\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > stale: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: EdgeCollection",
    "Field List > Methods > __copy__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > __delitem__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > __getitem__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > __init__: Description: Constructor.\nParamters: coords: the coordinates to be stored in the layout.\ndim: the number of ensions. If None, the number of ensions is determined automatically from the length of the first item of the coordinate list. If there are no entries in the coordinate list, the default will be 2.  Generally, this should be given if the length of the coordinate list is zero, otherwise it should be left as is.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > __len__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > __setitem__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > append: Description: Appends a new point to the layout\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > boundaries: Description: Returns the boundaries of the layout.\nThe boundaries are the minimum and maximum coordinates along all dimensions.\nParamters: border: this value gets subtracted from the minimum bounds and gets added to the maximum bounds before returning the coordinates of the box. Defaults to zero.\nReturn: [the minimum and maximum coordinates along all dimensions, in a tuple containing two lists, one for the minimum coordinates, the other one for the maximum.]\nReferences: []\nRasises: ValueError: if the layout contains no layout items\nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > bounding_box: Description: Returns the bounding box of the layout.\nThe bounding box of the layout is the smallest box enclosing all the points in the layout.\nParamters: border: this value gets subtracted from the minimum bounds and gets added to the maximum bounds before returning the coordinates of the box. Defaults to zero.\nReturn: [the coordinates of the lower left and the upper right corner of the box. \"Lower left\" means the minimum coordinates and \"upper right\" means the maximum. These are encapsulated in a BoundingBox object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > center: Description: Centers the layout around the given point.\nThe point itself can be supplied as multiple unnamed arguments, as a simple unnamed list or as a keyword argument. This operation moves the centroid of the layout to the given point. If no point is supplied, defaults to the origin of the coordinate system.\nParamters: *args: Undocumented\np: the oint where the centroid of the layout will be after the oeration.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > centroid: Description: Returns the centroid of the layout.\nThe centroid of the layout is the arithmetic mean of the points in the layout.\nParamters: \nReturn: [the centroid as a list of floats]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > copy: Description: Creates an exact copy of the layout.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > fit_into: Description: Fits the layout into the given bounding box.\nThe layout will be modified in-place.\nParamters: bbox: the bounding box in which to fit the layout. If the dimension of the layout is d, it can either be a d-tuple (defining the sizes of the box), a 2d-tuple (defining the coordinates of the top left and the bottom right point of the box), or a BoundingBox object (for 2D layouts only).\nkeep_aspect_ratio: whether to keep the aspect ratio of the current layout. If False, the layout will be rescaled to fit exactly into the bounding box. If True, the original aspect ratio of the layout will be kept and it will be centered within the bounding box.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > mirror: Description: Mirrors the layout along the given dimension(s)\nParamters: dim: the list of ensions or a single ension\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > rotate: Description: Rotates the layout by the given degrees on the plane defined by the given two dimensions.\nParamters: angle: the  of the rotation, specified in degrees.\ndim1: the first axis of the plane of the rotation.\ndim2: the second axis of the plane of the rotation.\norigin: the  of the rotation. If not specified, the  will be the  of the coordinate system.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > scale: Description: Scales the layout.\nScaling parameters can be provided either through the scale keyword argument or through plain unnamed arguments. If a single integer or float is given, it is interpreted as a uniform multiplier to be applied on all dimensions. If it is a list or tuple, its length must be equal to the number of dimensions in the layout, and each element must be an integer or float describing the scaling coefficient in one of the dimensions.\nParamters: *args: Undocumented\nscale: scaling coefficients (integer, float, list or tuple)\norigin: the  of scaling (this point will stay in place). Optional, defaults to the  of the coordinate system being used.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > to_radial: Description: Converts a planar layout to a radial one\nThis method applies only to 2D layouts. The X coordinate of the layout is transformed to an angle, with min(x) corresponding to the parameter called min_angle and max(y) corresponding to max_angle. Angles are given in degrees, zero degree corresponds to the direction pointing upwards. The Y coordinate is interpreted as a radius, with min(y) belonging to the minimum and max(y) to the maximum radius given in the arguments.\nThis is not a fully generic polar coordinate transformation, but it is fairly useful in creating radial tree layouts from ordinary top-down ones (that's why the Y coordinate belongs to the radius). It can also be used in conjunction with the Fruchterman-Reingold layout algorithm via its miny and maxy parameters (see Graph.layout_fruchterman_reingold()) to produce radial layouts where the radius belongs to some property of the vertices.\nParamters: min_angle: the angle corresponding to the minimum X value\nmax_angle: the angle corresponding to the maximum X value\nmin_radius: the radius corresponding to the minimum Y value\nmax_radius: the radius corresponding to the maximum Y value\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > transform: Description: Performs an arbitrary transformation on the layout\nAdditional positional and keyword arguments are passed intact to the given function.\nParamters: function: a  which receives the coordinates as a tuple and returns the transformed tuple.\n*args: Undocumented\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > translate: Description: Translates the layout.\nThe translation vector can be provided either through the v keyword argument or through plain unnamed arguments. If unnamed arguments are used, the vector can be supplied as a single list (or tuple) or just as a series of arguments. In all cases, the translation vector must have the same number of dimensions as the layout.\nParamters: *args: Undocumented\nv: the translation ector\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Layout",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ProgressBar",
    "Field List > Methods > clear: Description: Clears the progress bar (i.e. removes it from the screen)\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ProgressBar",
    "Field List > Methods > update: Description: Updates the progress bar.\nParamters: percent: the age to be shown. If None, the previous value will be used.\nmessage: the  to be shown above the progress bar. If None, the previous  will be used.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ProgressBar",
    "Field List > Methods > update_message: Description: Updates the message of the progress bar.\nParamters: message: the  to be shown above the progress bar\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ProgressBar",
    "Field List > Methods > __ior__: Description: overrides igraph.drawing.utils.Rectangle.__ior__\nReplaces this bounding box with the union of itself and another.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n    >>> box1 = BoundingBox(10, 20, 50, 60)\n    >>> box2 = BoundingBox(70, 40, 100, 90)\n    >>> box1 |= box2\n    >>> print(box1)\n    BoundingBox(10.0, 20.0, 100.0, 90.0)\n]\nSection_id: BoundingBox",
    "Field List > Methods > __or__: Description: Takes the union of this bounding box with another.\nThe result is a bounding box which encloses both bounding boxes.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n    >>> box1 = BoundingBox(10, 20, 50, 60)\n    >>> box2 = BoundingBox(70, 40, 100, 90)\n    >>> box1 | box2\n    BoundingBox(10.0, 20.0, 100.0, 90.0)\n]\nSection_id: BoundingBox",
    "Field List > Methods > __bool__: Description: Inherited from Rectangle:Undocumented\nSection_id: BoundingBox",
    "Field List > Methods > __eq__: Description: Inherited from Rectangle:Undocumented\nSection_id: BoundingBox",
    "Field List > Methods > __hash__: Description: Inherited from Rectangle:Undocumented\nSection_id: BoundingBox",
    "Field List > Methods > __init__: Description: Inherited from Rectangle:Creates a rectangle.\nSection_id: BoundingBox",
    "Field List > Methods > __ne__: Description: Inherited from Rectangle:Undocumented\nSection_id: BoundingBox",
    "Field List > Methods > __repr__: Description: Inherited from Rectangle:Undocumented\nSection_id: BoundingBox",
    "Field List > Methods > bottom.setter: Description: Inherited from Rectangle:Sets the Y coordinate of the bottom edge of the box\nSection_id: BoundingBox",
    "Field List > Methods > contract: Description: Inherited from Rectangle:Contracts the rectangle by the given margins.\nSection_id: BoundingBox",
    "Field List > Methods > coords.setter: Description: Inherited from Rectangle:Sets the coordinates of the corners.\nSection_id: BoundingBox",
    "Field List > Methods > expand: Description: Inherited from Rectangle:Expands the rectangle by the given margins.\nSection_id: BoundingBox",
    "Field List > Methods > height.setter: Description: Inherited from Rectangle:Sets the height of the rectangle by adjusting the bottom edge.\nSection_id: BoundingBox",
    "Field List > Methods > intersection: Description: Inherited from Rectangle:Returns the intersection of this rectangle with another.\nSection_id: BoundingBox",
    "Field List > Methods > isdisjoint: Description: Inherited from Rectangle:Returns True if the two rectangles have no intersection.\nSection_id: BoundingBox",
    "Field List > Methods > isempty: Description: Inherited from Rectangle:Returns True if the rectangle is empty (i.e. it has zero width and height).\nSection_id: BoundingBox",
    "Field List > Methods > left.setter: Description: Inherited from Rectangle:Sets the X coordinate of the left side of the box\nSection_id: BoundingBox",
    "Field List > Methods > midx.setter: Description: Inherited from Rectangle:Moves the center of the box to the given X coordinate\nSection_id: BoundingBox",
    "Field List > Methods > midy.setter: Description: Inherited from Rectangle:Moves the center of the box to the given Y coordinate\nSection_id: BoundingBox",
    "Field List > Methods > right.setter: Description: Inherited from Rectangle:Sets the X coordinate of the right side of the box\nSection_id: BoundingBox",
    "Field List > Methods > shape.setter: Description: Inherited from Rectangle:Sets the shape of the rectangle (width, height).\nSection_id: BoundingBox",
    "Field List > Methods > top.setter: Description: Inherited from Rectangle:Sets the Y coordinate of the top edge of the box\nSection_id: BoundingBox",
    "Field List > Methods > translate: Description: Inherited from Rectangle:Translates the rectangle in-place.\nSection_id: BoundingBox",
    "Field List > Methods > union: Description: Inherited from Rectangle:Returns the union of this rectangle with another.\nSection_id: BoundingBox",
    "Field List > Methods > width.setter: Description: Inherited from Rectangle:Sets the width of the rectangle by adjusting the right edge.\nSection_id: BoundingBox",
    "Field List > Methods > __init__: Description: Constructs a Gephi graph streaming drawer that will post graphs to the given Gephi connection. If conn is None, the remaining arguments of the constructor are forwarded intact to the constructor of GephiConnection in order to create a connection. This means that any of the following are valid:GephiGraphStreamingDrawer() will construct a drawer that connects to workspace 0 of the local Gephi instance on port 8080.GephiGraphStreamingDrawer(workspace=2) will connect to workspace 2 of the local Gephi instance on port 8080.GephiGraphStreamingDrawer(port=1234) will connect to workspace 0 of the local Gephi instance on port 1234.GephiGraphStreamingDrawer(host=\"remote\", port=1234, workspace=7) will connect to workspace 7 of the Gephi instance on host remote, port 1234.GephiGraphStreamingDrawer(url=\"http://remote:1234/workspace7) is the same as above, but with an explicit URL.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiGraphStreamingDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nDraws (i.e. sends) the given graph to the destination of the drawer using the Gephi graph streaming API.\nThe following keyword arguments are allowed:encoder lets one specify an instance of json.JSONEncoder that will be used to encode the JSON objects.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiGraphStreamingDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.Cover.__init__\nCreates a cover object for a given graph.\nParamters: graph: the  that will be associated to the cover\nclusters: the list of . If None, it is assumed that there is only a single cluster that covers the whole graph.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCover",
    "Field List > Methods > __plot__: Description: overridden in igraph.CohesiveBlocks\nPlots the cover to the given Cairo context or matplotlib Axes.\nThis is done by calling Graph.__plot__() with the same arguments, but drawing nice colored blobs around the vertex groups.\nThis method understands all the positional and keyword arguments that are understood by Graph.__plot__(), only the differences will be highlighted here:mark_groups: whether to highlight the vertex clusters by colored polygons. Besides the values accepted by Graph.__plot__ (i.e., a dict mapping colors to vertex indices, a list containing lists of vertex indices, or False), the following are also accepted:True: all the clusters will be highlighted, the colors matching the corresponding color indices from the current palette (see the palette keyword argument of Graph.__plot__).A dict mapping cluster indices or tuples of vertex indices to color names.  The given clusters or vertex groups will be highlighted by the given colors.A list of cluster indices. This is equivalent to passing a dict mapping numeric color indices from the current palette to cluster indices; therefore, the cluster referred to by element i of the list will be highlighted by color i from the palette.The value of the plotting.mark_groups configuration key is also taken into account here; if that configuration key is True and mark_groups is not given explicitly, it will automatically be set to True.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.palette: the palette used to resolve numeric color indices to RGBA values. By default, this is an instance of ClusterColoringPalette.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.__plot__() for more supported keyword arguments.\nexample: []\nSection_id: VertexCover",
    "Field List > Methods > crossing: Description: Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCover",
    "Field List > Methods > subgraph: Description: Get the subgraph belonging to a given cluster.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.\nParamters: idx: the cluster index\nReturn: [a copy of the subgraph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCover",
    "Field List > Methods > subgraphs: Description: Gets all the subgraphs belonging to each of the clusters.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.\nParamters: \nReturn: [a list containing copies of the subgraphs]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexCover",
    "Field List > Methods > __getitem__: Description: Inherited from Cover:Returns the cluster with the given index.\nSection_id: VertexCover",
    "Field List > Methods > __iter__: Description: Inherited from Cover:Iterates over the clusters in this cover.\nSection_id: VertexCover",
    "Field List > Methods > __len__: Description: Inherited from Cover:Returns the number of clusters in this cover.\nSection_id: VertexCover",
    "Field List > Methods > __str__: Description: Inherited from Cover:Returns a string representation of the cover.\nSection_id: VertexCover",
    "Field List > Methods > size: Description: Inherited from Cover:Returns the size of a given cluster.\nSection_id: VertexCover",
    "Field List > Methods > size_histogram: Description: Inherited from Cover:Returns the histogram of cluster sizes.\nSection_id: VertexCover",
    "Field List > Methods > sizes: Description: Inherited from Cover:Returns the size of given clusters.\nSection_id: VertexCover",
    "Field List > Methods > summary: Description: Inherited from Cover:Returns the summary of the cover.\nSection_id: VertexCover",
    "Field List > Methods > FromPolar: Description: Constructs a point from polar coordinates.\nradius is the distance of the point from the origin; angle is the angle between the X axis and the vector pointing to the point from the origin.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > __add__: Description: Adds the coordinates of a point to another one\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > __div__: Description: Divides the coordinates by a scalar\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > __mul__: Description: Multiplies the coordinates by a scalar\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > __sub__: Description: Subtracts the coordinates of a point to another one\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > as_polar: Description: Returns the polar coordinate representation of the point.\nParamters: \nReturn: [the radius and the angle in a tuple.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > distance: Description: Returns the distance of the point from another one.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> p1 = Point(5, 7)\n>>> p2 = Point(8, 3)\n>>> p1.distance(p2)\n5.0\n]\nSection_id: Point",
    "Field List > Methods > interpolate: Description: Linearly interpolates between the coordinates of this point and another one.\nParamters: other: the  point\nratio: the interpolation  between 0 and 1. Zero will return this point, 1 will return the other point.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > length: Description: Returns the length of the vector pointing from the origin to this point.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > normalized: Description: Normalizes the coordinates of the point s.t. its length will be 1 after normalization. Returns the normalized point.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > sq_length: Description: Returns the squared length of the vector pointing from the origin to this point.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > towards: Description: Returns the point that is at a given distance from this point towards another one.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Point",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.edge.AbstractCairoEdgeDrawer.__init__\nConstructs the edge drawer.\nParamters: context: a Cairo  on which the edges will be drawn.\npalette: the  that can be used to map integer color indices to colors when drawing edges\nalpha_at_src: Undocumented\nalpha_at_dest: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AlphaVaryingEdgeDrawer",
    "Field List > Methods > draw_directed_edge: Description: overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are defined by the attributes of this object.\ndest_vertex: the source vertex. Visual properties are defined by the attributes of this object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AlphaVaryingEdgeDrawer",
    "Field List > Methods > draw_loop_edge: Description: Inherited from AbstractCairoEdgeDrawer:Draws a loop edge.\nSection_id: AlphaVaryingEdgeDrawer",
    "Field List > Methods > draw_undirected_edge: Description: Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge.\nSection_id: AlphaVaryingEdgeDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.\nParamters: context: the  on which we will draw\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPaletteDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nTODO\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoPaletteDrawer",
    "Field List > Methods > bbox.setter: Description: Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.\nSection_id: CairoPaletteDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.\nParamters: context: the  on which we will draw\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoHistogramDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nTODO\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoHistogramDrawer",
    "Field List > Methods > bbox.setter: Description: Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.\nSection_id: CairoHistogramDrawer",
    "Field List > Methods > __call__: Description: overrides igraph.app.shell.Shell.__call__\nStarts the shell\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: IDLEShell",
    "Field List > Methods > __init__: Description: Constructor.\nImports IDLE's embedded shell. The implementation of this method is ripped from idlelib.PyShell.main() after removing the unnecessary parts.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: IDLEShell",
    "Field List > Methods > get_progress_handler: Description: Inherited from Shell:Returns the progress handler (if exists) or None (if not).\nSection_id: IDLEShell",
    "Field List > Methods > get_status_handler: Description: Inherited from Shell:Returns the status handler (if exists) or None (if not).\nSection_id: IDLEShell",
    "Field List > Methods > supports_progress_bar: Description: Inherited from Shell:Checks whether the shell supports progress bars.\nSection_id: IDLEShell",
    "Field List > Methods > supports_status_messages: Description: Inherited from Shell:Checks whether the shell supports status messages.\nSection_id: IDLEShell",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nInitializes the coordinate system.\nParamters: context: the  on which the coordinate system will be drawn.\nbbox: the bounding box that will contain the coordinate system.\nbounds: minimum and maximum X and Y values in a 4-tuple.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DescartesCoordinateSystem",
    "Field List > Methods > bbox: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.bbox.setter\nSets the bounding box of the coordinate system\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DescartesCoordinateSystem",
    "Field List > Methods > bounds: Description: Sets the lower and upper bounds of the X and Y values\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DescartesCoordinateSystem",
    "Field List > Methods > draw: Description: overrides igraph.drawing.cairo.coord.CoordinateSystem.draw\nDraws the coordinate system.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DescartesCoordinateSystem",
    "Field List > Methods > local_to_context: Description: overrides igraph.drawing.cairo.coord.CoordinateSystem.local_to_context\nConverts local coordinates to the context coordinate system (given by the bounding box).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DescartesCoordinateSystem",
    "Field List > Methods > __init__: Description: overrides igraph.Dendrogram.__init__\nCreates a dendrogram object for a given graph.\nParamters: graph: the  that will be associated to the clustering\nmerges: the  performed given in matrix form.\noptimal_count: the optimal number of clusters where the dendrogram should be cut. This is a hint usually provided by the clustering algorithm that produces the dendrogram. None means that such a hint is not available; the optimal count will then be selected based on the modularity in such a case.\nmodularity_params: arguments that should be passed to Graph.modularity when the modularity is (re)calculated. If the original graph was weighted, you should pass a dictionary containing a weight key with the appropriate value here.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexDendrogram",
    "Field List > Methods > __plot__: Description: overrides igraph.Dendrogram.__plot__\nDraws the vertex dendrogram on the given Cairo context or matplotlib Axes\nSee Dendrogram.__plot__ for the list of supported keyword arguments.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexDendrogram",
    "Field List > Methods > as_clustering: Description: Cuts the dendrogram at the given level and returns a corresponding VertexClustering object.\nParamters: n: the desired umber of clusters. Merges are replayed from the begiig util the membership vector has exactly  distict elemets or util there are o more recorded merges, whichever happes first. If Noe, the optimal cout hit give by the clusterig algorithm will be used If the optimal cout was ot give either, it will be calculated by selectig the level where the modularity is maximal.\nReturn: [a new VertexClustering object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexDendrogram",
    "Field List > Methods > optimal_count: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: VertexDendrogram",
    "Field List > Methods > __str__: Description: Inherited from Dendrogram:Undocumented\nSection_id: VertexDendrogram",
    "Field List > Methods > format: Description: Inherited from Dendrogram:Formats the dendrogram in a foreign format.\nSection_id: VertexDendrogram",
    "Field List > Methods > names.setter: Description: Inherited from Dendrogram:Sets the names of the nodes in the dendrogram\nSection_id: VertexDendrogram",
    "Field List > Methods > summary: Description: Inherited from Dendrogram:Returns the summary of the dendrogram.\nSection_id: VertexDendrogram",
    "Field List > Methods > get_add_edge_event: Description: Generates a Python object corresponding to the event that adds an edgewith the given source, target, directednessr and attributes in the Gephigraph streaming API.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: GephiGraphStreamingAPIFormat",
    "Field List > Methods > get_add_node_event: Description: Generates a Python object corresponding to the event that adds a nodewith the given identifier and attributes in the Gephi graph streaming API.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_add_node_event(\"spam\")\n{'an': {'spam': {}}}\n>>> api.get_add_node_event(\"spam\", dict(ham=\"eggs\"))\n{'an': {'spam': {'ham': 'eggs'}}}\n]\nSection_id: GephiGraphStreamingAPIFormat",
    "Field List > Methods > get_change_edge_event: Description: Generates a Python object corresponding to the event that changes theattributes of some edge in the Gephi graph streaming API. The given attributesare merged into the existing ones; use C{None} as the attribute value todelete a given attribute.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_change_edge_event(\"spam\", dict(ham=\"eggs\"))\n{'ce': {'spam': {'ham': 'eggs'}}}\n>>> api.get_change_edge_event(\"spam\", dict(ham=None))\n{'ce': {'spam': {'ham': None}}}\n]\nSection_id: GephiGraphStreamingAPIFormat",
    "Field List > Methods > get_change_node_event: Description: Generates a Python object corresponding to the event that changes theattributes of some node in the Gephi graph streaming API. The given attributesare merged into the existing ones; use C{None} as the attribute value todelete a given attribute.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_change_node_event(\"spam\", dict(ham=\"eggs\"))\n{'cn': {'spam': {'ham': 'eggs'}}}\n>>> api.get_change_node_event(\"spam\", dict(ham=None))\n{'cn': {'spam': {'ham': None}}}\n]\nSection_id: GephiGraphStreamingAPIFormat",
    "Field List > Methods > get_delete_edge_event: Description: Generates a Python object corresponding to the event that deletes anedge with the given identifier in the Gephi graph streaming API.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_delete_edge_event(\"spam:ham\")\n{'de': {'spam:ham': {}}}\n]\nSection_id: GephiGraphStreamingAPIFormat",
    "Field List > Methods > get_delete_node_event: Description: Generates a Python object corresponding to the event that deletes anode with the given identifier in the Gephi graph streaming API.\nExample:\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_delete_node_event(\"spam\")\n{'dn': {'spam': {}}}\n]\nSection_id: GephiGraphStreamingAPIFormat",
    "Field List > Methods > __init__: Description: overridden in igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer\nConstructs the edge drawer.\nParamters: context: a Cairo  on which the edges will be drawn.\npalette: the  that can be used to map integer color indices to colors when drawing edges\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractCairoEdgeDrawer",
    "Field List > Methods > draw_loop_edge: Description: Draws a loop edge.\nThe default implementation draws a small circle.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nvertex: the  to which the edge is attached. Visual properties are given again as attributes.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractCairoEdgeDrawer",
    "Field List > Methods > draw_undirected_edge: Description: overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nThe default implementation of this method draws undirected edges as straight lines. Loop edges are drawn as small circles.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are given again as attributes.\ndest_vertex: the target vertex. Visual properties are given again as attributes.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractCairoEdgeDrawer",
    "Field List > Methods > draw_directed_edge: Description: Inherited from AbstractEdgeDrawer:Draws a directed edge.\nSection_id: AbstractCairoEdgeDrawer",
    "Field List > Methods > get_label_position: Description: Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.\nSection_id: AbstractCairoEdgeDrawer",
    "Field List > Methods > get_label_rotation: Description: Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge.\nSection_id: AbstractCairoEdgeDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.colors.Palette.__init__\nCreates the palette backed by the given list. The list must contain RGBA quadruplets or color names, which will be resolved first by color_name_to_rgba(). Anything that is understood by color_name_to_rgba() is OK here.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PrecalculatedPalette",
    "Field List > Methods > __len__: Description: Inherited from Palette:Returns the number of colors in this palette\nSection_id: PrecalculatedPalette",
    "Field List > Methods > __plot__: Description: Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes\nSection_id: PrecalculatedPalette",
    "Field List > Methods > __repr__: Description: Inherited from Palette:Undocumented\nSection_id: PrecalculatedPalette",
    "Field List > Methods > clear_cache: Description: Inherited from Palette:Clears the result cache.\nSection_id: PrecalculatedPalette",
    "Field List > Methods > get: Description: Inherited from Palette:Returns the given color from the palette.\nSection_id: PrecalculatedPalette",
    "Field List > Methods > get_many: Description: Inherited from Palette:Returns multiple colors from the palette.\nSection_id: PrecalculatedPalette",
    "Field List > Methods > __init__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FittedPowerLaw",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FittedPowerLaw",
    "Field List > Methods > __str__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FittedPowerLaw",
    "Field List > Methods > summary: Description: Returns the summary of the power law fit.\nParamters: significance: the  level of the Kolmogorov-Smirnov test used to decide whether the input data could have come from the fitted distribution\nReturn: [the summary as a string]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: FittedPowerLaw",
    "Field List > Methods > __getattr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DyadCensus",
    "Field List > Methods > __getitem__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DyadCensus",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DyadCensus",
    "Field List > Methods > __str__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DyadCensus",
    "Field List > Methods > as_dict: Description: Converts the dyad census to a dict using the known dyad names.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DyadCensus",
    "Field List > Methods > __init__: Description: Constructs the graph drawer and associates it with the mpl Axes\nParamters: ax: the matplotlib Axes to draw into.\nvertex_drawer_factory: a factory method that returns an AbstractVertexDrawer instance bound to the given Matplotlib axes. The factory method must take three parameters: the axes and the palette to be used for drawing colored vertices, and the layout of the graph. The default vertex drawer is MatplotlibVertexDrawer.\nedge_drawer_factory: a factory method that returns an AbstractEdgeDrawer instance bound to a given Matplotlib Axes. The factory method must take two parameters: the Axes and the palette to be used for drawing colored edges. The default edge drawer is MatplotlibEdgeDrawer.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibGraphDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibGraphDrawer",
    "Field List > Methods > __contains__: Description: Checks whether item already has an ID or not.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: UniqueIdGenerator",
    "Field List > Methods > __getitem__: Description: Retrieves the ID corresponding to item. Generates a new ID for item if it is the first time we request an ID for it.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: UniqueIdGenerator",
    "Field List > Methods > __init__: Description: Creates a new unique ID generator. id_generator specifies how do we assign new IDs to elements that do not have an ID yet. If it is None, elements will be assigned integer identifiers starting from 0. If it is an integer, elements will be assigned identifiers starting from the given integer. If it is an iterator or generator, its next() method will be called every time a new ID is needed.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: UniqueIdGenerator",
    "Field List > Methods > __len__: Description: Returns the number of items.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: UniqueIdGenerator",
    "Field List > Methods > __setitem__: Description: Overrides the ID for item.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: UniqueIdGenerator",
    "Field List > Methods > reverse_dict: Description: Returns the reverse mapping, i.e., the one that maps from generated IDs to their corresponding objects\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: UniqueIdGenerator",
    "Field List > Methods > values: Description: Returns the values stored so far. If the generator generates items according to the standard sorting order, the values returned will be exactly in the order they were added. This holds for integer IDs for instance (but for many other ID generators as well).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: UniqueIdGenerator",
    "Field List > Methods > draw_path: Description: overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a rhombus on the Cairo context without stroking or filling it.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.draw_path\nexample: []\nSection_id: DiamondDrawer",
    "Field List > Methods > intersection_point: Description: overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the rhombus centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.intersection_point\nexample: []\nSection_id: DiamondDrawer",
    "Field List > Methods > __init__: Description: overridden in igraph.app.shell.ClassicPythonShell, igraph.app.shell.IPythonShell\nUndocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ConsoleProgressBarMixin",
    "Field List > Methods > draw_path: Description: overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a circular path on the Cairo context without stroking or filling it.\nHeight is ignored, it is the width that determines the diameter of the circle.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.draw_path\nexample: []\nSection_id: CircleDrawer",
    "Field List > Methods > intersection_point: Description: overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the circle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: ShapeDrawer.intersection_point\nexample: []\nSection_id: CircleDrawer",
    "Field List > Methods > __init__: Description: Constructs a new polygon drawer that draws on the given Matplotlib axes.\nParamters: fig: the plotly Figure to draw on\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyPolygonDrawer",
    "Field List > Methods > draw: Description: Draws a polygon to the associated axes.\nParamters: points: the coordinates of the corners of the polygon, in clockwise or counter-clockwise order, or None if we are about to use the  property of the class.\ncorner_radius: if zero, an ordinary polygon will be drawn. If positive, the corners of the polygon will be rounded with the given radius.\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyPolygonDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.VertexCover.__init__\nConstructs a new cohesive block structure for the given graph.\nIf any of blocks, cohesion or parent is None, all the arguments will be ignored and Graph.cohesive_blocks() will be called to calculate the cohesive blocks. Otherwise, these three variables should describe the *result* of a cohesive block structure calculation. Chances are that you never have to construct CohesiveBlocks instances directly, just use Graph.cohesive_blocks().\nParamters: graph: the  itself\nblocks: a list containing the ; each block is described as a list containing vertex IDs.\ncohesion: the  of each block. The length of this list must be equal to the length of blocks.\nparent: the  block of each block. Negative values or None mean that there is no  block for that block. There should be only one  block, which covers the entire graph.\nReturn: []\nReferences: []\nRasises: \nSee Also: Graph.cohesive_blocks()\nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > __plot__: Description: overrides igraph.VertexCover.__plot__\nPlots the cohesive block structure to the given Cairo context or matplotlib Axes.\nSince a CohesiveBlocks instance is also a VertexCover, keyword arguments accepted by VertexCover.__plot__() are also accepted here. The only difference is that the vertices are colored according to their maximal cohesions by default, and groups are marked by colored blobs except the last group which encapsulates the whole graph.\nSee the documentation of VertexCover.__plot__() for more details.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > cohesion: Description: Returns the cohesion of the group with the given index.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > cohesions: Description: Returns the list of cohesion values for each group.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > hierarchy: Description: Returns a new graph that describes the hierarchical relationships between the groups.\nThe new graph will be a directed tree; an edge will point from vertex i to vertex j if group i is a superset of group j. In other words, the edges point downwards.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > max_cohesion: Description: Finds the maximum cohesion score among all the groups that contain the given vertex.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > max_cohesions: Description: For each vertex in the graph, returns the maximum cohesion score among all the groups that contain the vertex.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > parent: Description: Returns the parent group index of the group with the given index or None if the given group is the root.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > parents: Description: Returns the list of parent group indices for each group or None if the given group is the root.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CohesiveBlocks",
    "Field List > Methods > crossing: Description: Inherited from VertexCover:Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.\nSection_id: CohesiveBlocks",
    "Field List > Methods > subgraph: Description: Inherited from VertexCover:Get the subgraph belonging to a given cluster.\nSection_id: CohesiveBlocks",
    "Field List > Methods > subgraphs: Description: Inherited from VertexCover:Gets all the subgraphs belonging to each of the clusters.\nSection_id: CohesiveBlocks",
    "Field List > Methods > __init__: Description: overridden in igraph.drawing.graph.CytoscapeGraphDrawer\nConstructs an abstract drawer using the XML-RPC service at the given URL.\nParamters: url: the URL where the XML-RPC calls for the service should be addressed to.\nservice: the name of the  at the XML-RPC address. If None, requests will be directed to the server proxy object constructed by xmlrpclib.ServerProxy; if not None, the given attribute will be looked up in the server proxy object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractXMLRPCDrawer",
    "Field List > Methods > draw: Description: Inherited from AbstractDrawer:Abstract method, must be implemented in derived classes.\nSection_id: AbstractXMLRPCDrawer",
    "Field List > Methods > ensure_layout: Description: Helper method that ensures that layout is an instance of Layout. If it is not, the method will try to convert it to a Layout according to the following rules:If layout is a string, it is assumed to be a name of an igraph layout, and it will be passed on to the layout method of the given graph if graph is not None.If layout is None and graph has a \"layout\" attribute, call this same function with the value of that attribute.If layout is None and graph does not have a \"layout\" attribute, the layout method of graph will be invoked with no parameters, which will call the default layout algorithm.Otherwise, layout will be passed on to the constructor of Layout. This handles lists of lists, lists of tuples and such.\nIf layout is already a Layout instance, it will still be copied and a copy will be returned. This is because graph drawers are allowed to transform the layout for their purposes, and we don't want the transformation to propagate back to the caller.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractGraphDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nAbstract method, must be implemented in derived classes.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: AbstractGraphDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the drawer and associates it to the given palette.\nParamters: context: the  on which we will draw\nbbox: the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).\npalette: the  that can be used to map integer color indices to colors when drawing vertices\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoDendrogramDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Dendrogram in a Cairo context.\nParamters: dendro: the igraph.Dendrogram to plot.It accepts the following keyword arguments:style: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the matrix are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the matrix should be square or not. Default is True.grid_width: line width of the grid shown on the matrix. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the matrix. If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the matrix being plotted. If it is another matrix, the values of that matrix are shown in the cells. In this case, the shape of the value matrix must match the shape of the matrix being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.If only the row names or the column names are given and the matrix is square-shaped, the same names are used for both column and row names.\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoDendrogramDrawer",
    "Field List > Methods > bbox.setter: Description: Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.\nSection_id: CairoDendrogramDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer.__init__\nConstructs the edge drawer.\nParamters: context: a Cairo  on which the edges will be drawn.\npalette: the  that can be used to map integer color indices to colors when drawing edges\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: DarkToLightEdgeDrawer",
    "Field List > Methods > draw_directed_edge: Description: Inherited from AlphaVaryingEdgeDrawer:Draws a directed edge.\nSection_id: DarkToLightEdgeDrawer",
    "Field List > Methods > register: Description: Registers the given shape drawer class under the given names.\nParamters: drawer_class: the shape drawer class to be registered\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ShapeDrawerDirectory",
    "Field List > Methods > register_namespace: Description: Registers all ShapeDrawer classes in the given namespace\nParamters: namespace: a Python dict mapping names to Python objects.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ShapeDrawerDirectory",
    "Field List > Methods > resolve: Description: Given a shape name, returns the corresponding shape drawer class\nParamters: shape: the name of the\nReturn: [the corresponding shape drawer class]\nReferences: []\nRasises: ValueError: if the shape is unknown\nSee Also: \nexample: []\nSection_id: ShapeDrawerDirectory",
    "Field List > Methods > resolve_default: Description: Given a shape name, returns the corresponding shape drawer class or the given default shape drawer if the shape name is unknown.\nParamters: shape: the name of the \ndefault: the  shape drawer to return when the shape is unknown\nReturn: [the shape drawer class corresponding to the given name or the default shape drawer class if the name is unknown]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ShapeDrawerDirectory",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.\nParamters: fig: Undocumented\npalette: the  that can be used to map integer color indices to colors when drawing vertices\nlayout: the  of the vertices in the graph being drawn\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyVerticesDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nDraws the given vertex.\nParamters: visual_vertex: object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.\nvertex: the raw igraph  being drawn\npoint: Undocumented\ncoords: the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyVerticesDrawer",
    "Field List > Methods > draw_label: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: PlotlyVerticesDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.Cut.__init__\nInitializes the flow.\nThis should not be called directly, everything is taken care of by Graph.maxflow.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Flow",
    "Field List > Methods > __repr__: Description: overrides igraph.Cut.__repr__\nUndocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Flow",
    "Field List > Methods > __str__: Description: overrides igraph.Cut.__str__\nUndocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Flow",
    "Field List > Methods > Adjacency: Description: overrides igraph.GraphBase.Adjacency\nGenerates a graph from its adjacency matrix.\nParamters: matrix: the adjacency . Possible types are:a list of listsa numpy 2D array or  (will be converted to list of lists)a scipy.sparse  (will be converted to a COO , but not to a dense )a pandas.DataFrame (column/row names must match, and will be used as vertex names).\nmode: the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The matrix must be symmetric.\"max\" - undirected graph will be created and the number of edges between vertex i and j is max(A(i, j), A(j, i))\"min\" - like \"max\", but with min(A(i, j), A(j, i))\"plus\"  - like \"max\", but with A(i, j) + A(j, i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)\nloops: specifies how to handle loop edges. When False or \"ignore\", the diagonal of the adjacency matrix will be ignored. When True or \"once\", the diagonal is assumed to contain the multiplicity of the corresponding loop edge. When \"twice\", the diagonal is assumed to contain twice the multiplicity of the corresponding loop edge.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Biadjacency: Description: Creates a bipartite graph from a bipartite adjacency matrix.\nExample:\nParamters: matrix: the bipartite adjacency .\ndirected: whether to create a  graph.\nmode: defines the direction of edges in the graph. If \"out\", then edges go from vertices of the first kind (corresponding to rows of the matrix) to vertices of the second kind (the columns of the matrix). If \"in\", the opposite direction is used. \"all\" creates mutual edges. Ignored for undirected graphs.\nmultiple: defines what to do with non-zero entries in the matrix. If False, non-zero entries will create an edge no matter what the value is. If True, non-zero entries are rounded up to the nearest integer and this will be the number of  edges created.\nweighted: defines whether to create a  graph from the adjacency matrix. If it is c{None} then an un graph is created and the multiple argument is used to determine the edges of the graph. If it is a string then for every non-zero matrix entry, an edge is created and the value of the entry is added as an edge attribute named by the  argument. If it is True then a  graph is created and the name of the edge attribute will be \"weight\".\n*args: Undocumented\n**kwds: Undocumented\nReturn: [the graph with a binary vertex attribute named \"type\" that stores the vertex classes.]\nReferences: []\nRasises: ValueError: if the weighted and multiple are passed together.\nSee Also: \nexample: [Example:\n>>> g = Graph.Biadjacency([[0, 1, 1], [1, 1, 0]])]\nSection_id: Graph",
    "Field List > Methods > Bipartite: Description: Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a type attribute afterwards.\nExamples:\nParamters: types: the vertex  as a boolean list. Anything that evaluates to False will denote a vertex of the first kind, anything that evaluates to True will denote a vertex of the second kind.\nedges: the  as a list of tuples.\ndirected: whether to create a  graph. Bipartite networks are usually un, so the default is False\n*args: Undocumented\n**kwds: Undocumented\nReturn: [the graph with a binary vertex attribute named \"type\" that stores the vertex classes.]\nReferences: []\nRasises: \nSee Also: \nexample: [Examples:\n>>> g = Graph.Bipartite([0, 1, 0, 1], [(0, 1), (2, 3), (0, 3)])\n>>> g.is_bipartite()\nTrue\n>>> g.vs[\"type\"]\n[False, True, False, True]\n]\nSection_id: Graph",
    "Field List > Methods > DataFrame: Description: Generates a graph from one or two dataframes.\nParamters: edges: pandas DataFrame containing  and metadata. The first two columns of this DataFrame contain the source and target vertices for each edge. These indicate the vertex IDs as nonnegative integers rather than vertex names unless use_vids is False. Further columns may contain edge attributes.\ndirected: :boolwhether the graph is \nvertices: None (default) or pandas DataFrame containing vertex metadata. The DataFrame's index must contain the vertex IDs as a sequence of intergers from 0 to len() - 1. If use_vids is False, the first column must contain the unique vertex names. Vertex names should be strings for full compatibility, but many functions will work if you set the name with any hashable object. All other columns will be added as vertex attributes by column name.\nuse_vids: :boolwhether to interpret the first two columns of the edges argument as vertex ids (0-based integers) instead of vertex names. If this argument is set to True and the first two columns of edges are not integers, an error is thrown.\nReturn: [the graph\nVertex names in either the edges or vertices arguments that are set to NaN (not a number) will be set to the string \"NA\". That might lead to unexpected behaviour: fill your NaNs with values before calling this function to mitigate.\n]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > DictDict: Description: Constructs a graph from a dict-of-dicts representation.\nEach key can be an integer or a string and represent a vertex. Each value is a dict representing edges (outgoing if the graph is directed) from that vertex. Each dict key is an integer/string for a target vertex, such that an edge will be created between those two vertices. Integers are interpreted as vertex_ids from 0 (as used in igraph), strings are interpreted as vertex names, in which case vertices are given separate numeric ids. Each value is a dictionary of edge attributes for that edge.\nExample:\nParamters: edges: the dict of dict of dicts specifying the  and their attributes\ndirected: :boolwhether to create a  graph\nvertex_name_attr: :strvertex attribute that will store the names\nReturn: [a Graph object]\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> {'Alice': {'Bob': {'weight': 1.5}, 'David': {'weight': 2}}}]\nSection_id: Graph",
    "Field List > Methods > DictList: Description: Constructs a graph from a list-of-dictionaries representation.\nThis function is useful when you have two lists of dictionaries, one for vertices and one for edges, each containing their attributes (e.g. name, weight). Of course, the edge dictionary must also contain two special keys that indicate the source and target vertices connected by that edge. Non-list iterables should work as long as they yield dictionaries or dict-like objects (they should have the 'items' and '__getitem__' methods). For instance, a database query result is likely to be fit as long as it's iterable and yields dict-like objects with every iteration.\nParamters: vertices: the list of dictionaries for the  or None if there are no special attributes assigned to  and we should simply use the edge list of dicts to infer vertex names.\nedges: the list of dictionaries for the . Each dict must have at least the two keys specified by edge_foreign_keys to label the source and target vertices, while additional items will be treated as edge attributes.\ndirected: :boolwhether the constructed graph will be \nvertex_name_attr: :strthe name of the distinguished key in the dicts in the vertex data source that contains the vertex names. Ignored if vertices is None.\nedge_foreign_keys: tuple specifying the attributes in each edge dictionary that contain the source (1st) and target (2nd) vertex names. These items of each dictionary are also added as edge_attributes.\niterative: :boolwhether to add the edges to the graph one by one, ly, or to build a large edge list first and use that to construct the graph. The latter approach is faster but it may not be suitable if your dataset is large. The default is to add the edges in a batch from an edge list.\nReturn: [the graph that was constructed\nExample:\n\n>>> vertices = [{'name': 'apple'}, {'name': 'pear'}, {'name': 'peach'}]\n>>> edges = [{'source': 'apple', 'target': 'pear', 'weight': 1.2},\n...          {'source': 'apple', 'target': 'peach', 'weight': 0.9}]\n>>> g = Graph.DictList(vertices, edges)The graph has three vertices with names and two edges with weights.\n]\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> vertices = [{'name': 'apple'}, {'name': 'pear'}, {'name': 'peach'}]\n>>> edges = [{'source': 'apple', 'target': 'pear', 'weight': 1.2},\n...          {'source': 'apple', 'target': 'peach', 'weight': 0.9}]\n>>> g = Graph.DictList(vertices, edges)]\nSection_id: Graph",
    "Field List > Methods > from_graph_tool: Description: Converts the graph from graph-tool\nParamters: g: raph-tool Graph\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > from_networkx: Description: Converts the graph from networkx\nVertex names will be stored as a vertex_attr_hashable attribute (usually \"_nx_name\", but see below). Because igraph stored vertices in an ordered manner, vertices will get new IDs from 0 up. In case of multigraphs, each edge will have an \"_nx_multiedge_key\" attribute, to distinguish edges that connect the same two vertices.\nParamters: g: networkx Graph or DiGraph\nvertex_attr_hashable: :strattribute used to store the Python hashable used by networkx to identify each vertex. The default value '_nx_name' ensures lossless round trip conversions to/from networkx. An alternative choice is 'name': in that case, using strings for vertex names is recommended and, if the graph is re-exported to networkx, Graph.to_networkx(=\"name\") must be used to recover the correct vertex nomenclature in the exported network.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Full_Bipartite: Description: Generates a full bipartite graph (directed or undirected, with or without loops).\nParamters: n1: the number of vertices of the first kind.\nn2: the number of vertices of the second kind.\ndirected: whether tp generate a  graph.\nmode: if \"out\", then all vertices of the first kind are connected to the others; \"in\" specifies the opposite direction, \"all\" creates mutual edges. Ignored for undirected graphs.\n*args: Undocumented\n**kwds: Undocumented\nReturn: [the graph with a binary vertex attribute named \"type\" that stores the vertex classes.]\nReferences: []\nRasises: \nSee Also: \nexample: [Generates a full bipartite graph (directed or undirected, with or without loops).\n>>> g = Graph.Full_Bipartite(2, 3)\n>>> g.is_bipartite()\nTrue\n>>> g.vs[\"type\"]\n[False, False, True, True, True]\n]\nSection_id: Graph",
    "Field List > Methods > GRG: Description: Generates a random geometric graph.\nThe algorithm drops the vertices randomly on the 2D unit square and connects them if they are closer to each other than the given radius. The coordinates of the vertices are stored in the vertex attributes x and y.\nParamters: n: The umber of vertices i the graph\nradius: The given \ntorus: This should be True if we want to use a  instead of a square.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Incidence: Description: Deprecated alias to Graph.Biadjacency().\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > ListDict: Description: Constructs a graph from a dict-of-lists representation.\nThis function is used to construct a graph from a dictionary of lists. Other, non-list sequences (e.g. tuples) and lazy iterators are are accepted. For each key x, its corresponding value must be a sequence of multiple values y: the edge (x,y) will be created in the graph. x and y must be either one of:two integers: the vertices with those ids will be connectedtwo strings: the vertices with those names will be connected\nIf names are used, the order of vertices is not guaranteed, and each vertex will be given the vertex_name_attr attribute.\nParamters: edges: the dict of sequences describing the \ndirected: :boolwhether to create a  graph\nvertex_name_attr: :strvertex attribute that will store the names\nReturn: [a Graph object\nExample:\n\n>>> mydict = {'apple': ['pear', 'peach'], 'pear': ['peach']}\n>>> g = Graph.ListDict(mydict)# The graph has three vertices with names and three edges connecting # each pair.\n]\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> mydict = {'apple': ['pear', 'peach'], 'pear': ['peach']}\n>>> g = Graph.ListDict(mydict)]\nSection_id: Graph",
    "Field List > Methods > Random_Bipartite: Description: Generates a random bipartite graph with the given number of vertices and edges (if m is given), or with the given number of vertices and the given connection probability (if p is given).\nIf m is given but p is not, the generated graph will have n1 vertices of type 1, n2 vertices of type 2 and m randomly selected edges between them. If p is given but m is not, the generated graph will have n1 vertices of type 1 and n2 vertices of type 2, and each edge will exist between them with probability p.\nParamters: n1: the number of vertices of type 1.\nn2: the number of vertices of type 2.\np: the robability of edges. If given, m must be missing.\nm: the nuber of edges. If given, p ust be issing.\ndirected: whether to generate a  graph.\nneimode: if the graph is directed, specifies how the edges will be generated. If it is \"all\", edges will be generated in both directions (from type 1 to type 2 and vice versa) independently. If it is \"out\" edges will always point from type 1 to type 2. If it is \"in\", edges will always point from type 2 to type 1. This argument is ignored for undirected graphs.\n*args: Undocumented\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Read: Description: Unified reading function for graphs.\nThis method tries to identify the format of the graph given in the first parameter and calls the corresponding reader method.\nThe remaining arguments are passed to the reader method without any changes.\nParamters: f: the ile containing the graph to be loaded\nformat: the  of the file (if known in advance). None means auto-detection. Possible values are: \"ncol\" (NCOL ), \"lgl\" (LGL ), \"graphdb\" (GraphDB ), \"graphml\", \"graphmlz\" (GraphML and gzipped GraphML ), \"gml\" (GML ), \"net\", \"pajek\" (Pajek ), \"dimacs\" (DIMACS ), \"edgelist\", \"edges\" or \"edge\" (edge list), \"adjacency\" (adjacency matrix), \"dl\" (DL  used by UCINET), \"pickle\" (Python pickled ), \"picklez\" (gzipped Python pickled )\n*args: Undocumented\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: IOError: if the file format can't be identified and none was given.\nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Read_Adjacency: Description: Constructs a graph based on an adjacency matrix from the given file.\nAdditional positional and keyword arguments not mentioned here are passed intact to Graph.Adjacency.\nParamters: f: the name o the ile to be read or a ile object\nsep: the string that arates the matrix elements in a row. None means an arbitrary sequence of whitespace characters.\ncomment_char: lines starting with this string are treated as comments.\nattribute: an edge  name where the edge weights are stored in the case of a weighted adjacency matrix. If None, no weights are stored, values larger than 1 are considered as edge multiplicities.\n*args: Undocumented\n**kwds: Undocumented\nReturn: [the created graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Read_DIMACS: Description: overrides igraph.GraphBase.Read_DIMACS\nReads a graph from a file conforming to the DIMACS minimum-cost flow file format.\nFor the exact definition of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm.\nRestrictions compared to the official description of the format are as follows:igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.Node indices start from 1. Only a single source and target node is allowed.\nParamters: f: the name o the ile or a Python ile handle\ndirected: whether the generated graph should be .\nReturn: [the generated graph. The indices of the source and target vertices are attached as graph attributes source and target, the edge capacities are stored in the capacity edge attribute.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Read_GraphMLz: Description: Reads a graph from a zipped GraphML file.\nParamters: f: the name o the ile\nindex: if the GraphML file contains multiple graphs, specified the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here.\nReturn: [the loaded graph object]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Read_Pickle: Description: Reads a graph from Python pickled format\nParamters: fname: the name of the file, a stream to read from, or a string containing the pickled data.\nReturn: [the created graph object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Read_Picklez: Description: Reads a graph from compressed Python pickled format, uncompressing it on-the-fly.\nParamters: fname: the name of the file or a stream to read from.\nReturn: [the created graph object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > TupleList: Description: Constructs a graph from a list-of-tuples representation.\nThis representation assumes that the edges of the graph are encoded in a list of tuples (or lists). Each item in the list must have at least two elements, which specify the source and the target vertices of the edge. The remaining elements (if any) specify the edge attributes of that edge, where the names of the edge attributes originate from the edge_attrs list. The names of the vertices will be stored in the vertex attribute given by vertex_name_attr.\nThe default parameters of this function are suitable for creating unweighted graphs from lists where each item contains the source vertex and the target vertex. If you have a weighted graph, you can use items where the third item contains the weight of the edge by setting edge_attrs to \"weight\" or [\"weight\"]. If you have even more edge attributes, add them to the end of each item in the edges list and also specify the corresponding edge attribute names in edge_attrs as a list.\nParamters: edges: the data source for the . This must be a list where each item is a tuple (or list) containing at least two items: the name of the source and the target vertex. Note that names will be assigned to the name vertex attribute (or another vertex attribute if vertex_name_attr is specified), even if all the vertex names in the list are in fact numbers.\ndirected: :boolwhether the constructed graph will be \nvertex_name_attr: :strthe name of the vertex attribute that will contain the vertex names.\nedge_attrs: the names of the edge attributes that are filled with the extra items in the edge list (starting from index 2, since the first two items are the source and target vertices). If None or an empty sequence, only the source and target vertices will be extracted and additional tuple items will be ignored. If a string, it is interpreted as a single edge attribute.\nweights: alternative way to specify that the graph is weighted. If you set  to true and edge_attrs is not given, it will be assumed that edge_attrs is [\"weight\"] and igraph will parse the third element from each item into an edge weight. If you set  to a string, it will be assumed that edge_attrs contains that string only, and igraph will store the edge  in that attribute.\nReturn: [the graph that was constructed]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > Weighted_Adjacency: Description: Generates a graph from its weighted adjacency matrix.\nParamters: matrix: the adjacency . Possible types are:a list of listsa numpy 2D array or  (will be converted to list of lists)a scipy.sparse  (will be converted to a COO , but not to a dense )\nmode: the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The matrix must be symmetric.\"max\"   - undirected graph will be created and the number of edges between vertex i and j is max(A(i, j), A(j, i))\"min\"   - like \"max\", but with min(A(i, j), A(j, i))\"plus\"  - like \"max\", but with A(i, j) + A(j, i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)These values can also be given as strings without the ADJ prefix.\nattr: the name of the edge ibute that stores the edge weights.\nloops: specifies how to handle loop edges. When False or \"ignore\", the diagonal of the adjacency matrix will be ignored. When True or \"once\", the diagonal is assumed to contain the weight of the corresponding loop edge. When \"twice\", the diagonal is assumed to contain twice the weight of the corresponding loop edge.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __add__: Description: Copies the graph and extends the copy depending on the type of the other object given.\nParamters: graph: Undocumented\nother: if it is an integer, the copy is extended by the given number of vertices. If it is a string, the copy is extended by a single vertex whose name attribute will be equal to the given string. If it is a tuple with two elements, the copy is extended by a single edge. If it is a list of tuples, the copy is extended by multiple edges. If it is a Graph, a disjoint union is performed.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __and__: Description: Graph intersection operator.\nParamters: graph: Undocumented\nother: the  graph to take the intersection with.\nReturn: [the intersected graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __bool__: Description: Returns True if the graph has at least one vertex, False otherwise.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __coerce__: Description: Coercion rules.\nThis method is needed to allow the graph to react to additions with lists, tuples, integers, strings, vertices, edges and so on.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __iadd__: Description: In-place addition (disjoint union).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: __add__\nexample: []\nSection_id: Graph",
    "Field List > Methods > __init__: Description: __init__(n=0, edges=None, directed=False, graph_attrs=None, vertex_attrs=None, edge_attrs=None)\nConstructs a graph from scratch.\nParamters: *args: Undocumented\nn: the umber of vertices. Ca be omitted, the default is zero. Note that if the edge list cotais vertices with idexes larger tha or equal to , the the umber of vertices will be adjusted accordigly.\nedges: the edge list where every list item is a pair of integers. If any of the integers is larger than n − 1, the number of vertices is adjusted accordingly. None means no .\ndirected: whether the graph should be \ngraph_attrs: the attributes of the graph as a dictionary.\nvertex_attrs: the attributes of the vertices as a dictionary. The keys of the dictionary must be the names of the attributes; the values must be iterables with exactly n items where n is the number of vertices.\nedge_attrs: the attributes of the edges as a dictionary. The keys of the dictionary must be the names of the attributes; the values must be iterables with exactly m items where m is the number of edges.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __isub__: Description: In-place subtraction (difference).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: __sub__\nexample: []\nSection_id: Graph",
    "Field List > Methods > __mul__: Description: Copies exact replicas of the original graph an arbitrary number of times.\nParamters: graph: Undocumented\nother: if it is an integer, multiplies the graph by creating the given number of identical copies and taking the disjoint union of them.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __or__: Description: Graph union operator.\nParamters: graph: Undocumented\nother: the  graph to take the union with.\nReturn: [the union graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __plot__: Description: Plots the graph to the given Cairo context or matplotlib Axes.\nThe visual style of vertices and edges can be modified at three places in the following order of precedence (lower indices override higher indices):Keyword arguments of this function (or of plot() which is passed intact to Graph.__plot__().Vertex or edge attributes, specified later in the list of keyword arguments.igraph-wide plotting defaults (see igraph.config.Configuration)Built-in defaults.\nE.g., if the vertex_size keyword attribute is not present, but there exists a vertex attribute named size, the sizes of the vertices will be specified by that attribute.\nBesides the usual self-explanatory plotting parameters (context, bbox, palette), it accepts the following keyword arguments:autocurve: whether to use curves instead of straight lines for multiple edges on the graph plot. This argument may be True or False; when omitted, True is assumed for graphs with less than 10.000 edges and False otherwise.drawer_factory: a subclass of AbstractCairoGraphDrawer which will be used to draw the graph. You may also provide a function here which takes two arguments: the Cairo context to draw on and a bounding box (an instance of BoundingBox). If this keyword argument is missing, igraph will use the default graph drawer which should be suitable for most purposes. It is safe to omit this keyword argument unless you need to use a specific graph drawer.keep_aspect_ratio: whether to keep the aspect ratio of the layout that igraph calculates to place the nodes. True means that the layout will be scaled proportionally to fit into the bounding box where the graph is to be drawn but the aspect ratio will be kept the same (potentially leaving empty space next to, below or above the graph). False means that the layout will be scaled independently along the X and Y axis in order to fill the entire bounding box. The default is False.layout: the layout to be used. If not an instance of Layout, it will be passed to layout to calculate the layout. Note that if you want a deterministic layout that does not change with every plot, you must either use a deterministic layout function (like GraphBase.layout_circle) or calculate the layout in advance and pass a Layout object here.margin: the top, right, bottom, left margins as a 4-tuple. If it has less than 4 elements or is a single float, the elements will be re-used until the length is at least 4.mark_groups: whether to highlight some of the vertex groups by colored polygons. This argument can be one of the following:False: no groups will be highlightedTrue: only valid if the object plotted is a VertexClustering or VertexCover. The vertex groups in the clutering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette. If used when plotting a graph, it will throw an error.A dict mapping tuples of vertex indices to color names. The given vertex groups will be highlighted by the given colors.A list containing pairs or an iterable yielding pairs, where the first element of each pair is a list of vertex indices and the second element is a color.A VertexClustering or VertexCover instance. The vertex groups in the clustering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.vertex_size: size of the vertices. The corresponding vertex attribute is called size. The default is 10. Vertex sizes are measured in the unit of the Cairo context on which igraph is drawing.vertex_color: color of the vertices. The corresponding vertex attribute is color, the default is red.  Colors can be specified either by common X11 color names (see the source code of igraph.drawing.colors for a list of known colors), by 3-tuples of floats (ranging between 0 and 255 for the R, G and B components), by CSS-style string specifications (#rrggbb) or by integer color indices of the specified palette.vertex_frame_color: color of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is frame_color, the default is black. See vertex_color for the possible ways of specifying a color.vertex_frame_width: the width of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is frame_width. The default is 1. Vertex frame widths are measured in the unit of the Cairo context on which igraph is drawing.vertex_shape: shape of the vertices. Alternatively it can be specified by the shape vertex attribute. Possibilities are: square, {circle}, {triangle}, {triangle-down} or hidden. See the source code of igraph.drawing for a list of alternative shape names that are also accepted and mapped to these.vertex_label: labels drawn next to the vertices. The corresponding vertex attribute is label.vertex_label_dist: distance of the midpoint of the vertex label from the center of the corresponding vertex. The corresponding vertex attribute is label_dist.vertex_label_color: color of the label. Corresponding vertex attribute: label_color. See vertex_color for color specification syntax.vertex_label_size: font size of the label, specified in the unit of the Cairo context on which we are drawing. Corresponding vertex attribute: label_size.vertex_label_angle: the direction of the line connecting the midpoint of the vertex with the midpoint of the label. This can be used to position the labels relative to the vertices themselves in conjunction with vertex_label_dist. Corresponding vertex attribute: label_angle. The default is -math.pi/2.vertex_order: drawing order of the vertices. This must be a list or tuple containing vertex indices; vertices are then drawn according to this order.vertex_order_by: an alternative way to specify the drawing order of the vertices; this attribute is interpreted as the name of a vertex attribute, and vertices are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (True, False, \"asc\" and \"desc\" are accepted values).edge_color: color of the edges. The corresponding edge attribute is color, the default is red. See vertex_color for color specification syntax.edge_curved: whether the edges should be curved. Positive numbers correspond to edges curved in a counter-clockwise direction, negative numbers correspond to edges curved in a clockwise direction. Zero represents straight edges. True is interpreted as 0.5, False is interpreted as 0. The default is 0 which makes all the edges straight.edge_width: width of the edges in the default unit of the Cairo context on which we are drawing. The corresponding edge attribute is width, the default is 1.edge_arrow_size: arrow size of the edges. The corresponding edge attribute is arrow_size, the default is 1.edge_arrow_width: width of the arrowhead on the edge. The corresponding edge attribute is arrow_width, the default is 1.edge_order: drawing order of the edges. This must be a list or tuple containing edge indices; edges are then drawn according to this order.edge_order_by: an alternative way to specify the drawing order of the edges; this attribute is interpreted as the name of an edge attribute, and edges are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (True, False, \"asc\" and \"desc\" are accepted values).\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __reduce__: Description: Support for pickling.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __str__: Description: Returns a string representation of the graph.\nBehind the scenes, this method constructs a GraphSummary instance and invokes its __str__ method with a verbosity of 1 and attribute printing turned off.\nSee the documentation of GraphSummary for more details about the output.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __sub__: Description: Removes the given object(s) from the graph\nParamters: graph: Undocumented\nother: if it is an integer, removes the vertex with the given ID from the graph (note that the remaining vertices will get re-indexed!). If it is a tuple, removes the given edge. If it is a graph, takes the difference of the two graphs. Accepts lists of integers or lists of tuples as well, but they can't be mixed! Also accepts Edge and EdgeSeq objects.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > add_edge: Description: Adds a single edge to the graph.\nKeyword arguments (except the source and target arguments) will be assigned to the edge as attributes.\nThe performance cost of adding a single edge or several edges to a graph is similar. Thus, when adding several edges, a single add_edges() call is more efficient than multiple add_edge() calls.\nParamters: graph: Undocumented\nsource: the  vertex of the edge or its name.\ntarget: the  vertex of the edge or its name.\n**kwds: Undocumented\nReturn: [the newly added edge as an Edge object. Use add_edges([(source, target)]) if you don't need the Edge object and want to avoid the overhead of creating it.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > add_edges: Description: overrides igraph.GraphBase.add_edges\nAdds some edges to the graph.\nParamters: graph: Undocumented\nes: the list of edg to be added. Every edge is reprented with a tuple containing the vertex IDs or nam of the two endpoints. Vertic are enumerated from zero.\nattributes: dict of sequences, each of length equal to the number of edges to be added, containing the  of the new edges.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > add_vertex: Description: Adds a single vertex to the graph. Keyword arguments will be assigned as vertex attributes. Note that name as a keyword argument is treated specially; if a graph has name as a vertex attribute, it allows one to refer to vertices by their names in most places where igraph expects a vertex ID.\nParamters: \nReturn: [the newly added vertex as a Vertex object. Use add_vertices(1) if you don't need the Vertex object and want to avoid the overhead of creating t.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > add_vertices: Description: overrides igraph.GraphBase.add_vertices\nAdds some vertices to the graph.\nNote that if n is a sequence of strings, indicating the names of the new vertices, and attributes has a key name, the two conflict. In that case the attribute will be applied.\nParamters: graph: Undocumented\nn: the umber of vertices to be added, or the ame of a sigle vertex to be added, or a sequece of strigs, each correspodig to the ame of a vertex to be added. Names will be assiged to the ame vertex attribute.\nattributes: dict of sequences, each of length equal to the number of vertices to be added, containing the  of the new vertices. If n is a string (so a single vertex is added), then the values of this dict are the  themselves, but if n=1 then they have to be lists of length 1.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > all_st_cuts: Description: overrides igraph.GraphBase.all_st_cuts\nReturns all the cuts between the source and target vertices in a directed graph.\nThis function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.\nReference: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351-372, 1996.\nParamters: graph: Undocumented\nsource: the  vertex ID\ntarget: the  vertex ID\nReturn: [a list of Cut objects.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > all_st_mincuts: Description: overrides igraph.GraphBase.all_st_mincuts\nReturns all the mincuts between the source and target vertices in a directed graph.\nThis function lists all minimum edge-cuts between a source and a target vertex.\nReference: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351-372, 1996.\nParamters: graph: Undocumented\nsource: the  vertex ID\ntarget: the  vertex ID\ncapacity: the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name.\nReturn: [a list of Cut objects.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > as_directed: Description: Returns a directed copy of this graph. Arguments are passed on to GraphBase.to_directed() that is invoked on the copy.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > as_undirected: Description: Returns an undirected copy of this graph. Arguments are passed on to GraphBase.to_undirected() that is invoked on the copy.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > biconnected_components: Description: overrides igraph.GraphBase.biconnected_components\nCalculates the biconnected components of the graph.\nParamters: graph: Undocumented\nreturn_articulation_points: whether to return the articulation points as well\nReturn: [a VertexCover object describing the biconnected components, and optionally the list of articulation points as well]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > bipartite_projection: Description: overrides igraph.GraphBase.bipartite_projection\nProjects a bipartite graph into two one-mode graphs. Edge directions are ignored while projecting.\nExamples:\nParamters: graph: Undocumented\ntypes: an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.\nmultiplicity: if True, then igraph keeps the  of the edges in the projection in an edge attribute called \"weight\". E.g., if there is an A-C-B and an A-D-B triplet in the bipartite graph and there is no other X (apart from X=B and X=D) for which an A-X-B triplet would exist in the bipartite graph, the  of the A-B edge in the projection will be 2.\nprobe1: this argument can be used to specify the order of the projections in the resulting list. If given and non-negative, then it is considered as a vertex ID; the projection containing the vertex will be the first one in the result.\nwhich: this argument can be used to specify  of the two projections should be returned if only one of them is needed. Passing 0 here means that only the first projection is returned, while 1 means that only the second projection is returned. (Note that we use 0 and 1 because Python indexing is zero-based). False is equivalent to 0 and True is equivalent to 1. Any other value means that both projections will be returned in a tuple.\nReturn: [a tuple containing the two projected one-mode graphs if which is not 1 or 2, or the projected one-mode graph specified by the which argument if its value is 0, 1, False or True.]\nReferences: []\nRasises: \nSee Also: \nexample: [Examples:\n>>> g = Graph.Full_Bipartite(10, 5)\n>>> g1, g2 = g.bipartite_projection()\n>>> g1.isomorphic(Graph.Full(10))\nTrue\n>>> g2.isomorphic(Graph.Full(5))\nTrue\n]\nSection_id: Graph",
    "Field List > Methods > bipartite_projection_size: Description: overrides igraph.GraphBase.bipartite_projection_size\nCalculates the number of vertices and edges in the bipartite projections of this graph according to the specified vertex types. This is useful if you have a bipartite graph and you want to estimate the amount of memory you would need to calculate the projections themselves.\nParamters: graph: Undocumented\ntypes: an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.\n*args: Undocumented\n**kwds: Undocumented\nReturn: [a 4-tuple containing the number of vertices and edges in the first projection, followed by the number of vertices and edges in the second projection.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > blocks: Description: Calculates the biconnected components of the graph.\nParamters: graph: Undocumented\nreturn_articulation_points: whether to return the articulation points as well\nReturn: [a VertexCover object describing the biconnected components, and optionally the list of articulation points as well]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > clear: Description: Clears the graph, deleting all vertices, edges, and attributes.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: GraphBase.delete_vertices and Graph.delete_edges.\nexample: []\nSection_id: Graph",
    "Field List > Methods > clusters: Description: Deprecated alias to Graph.connected_components().\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > cohesive_blocks: Description: overrides igraph.GraphBase.cohesive_blocks\nCalculates the cohesive block structure of the graph.\nCohesive blocking is a method of determining hierarchical subsets of graph vertices based on their structural cohesion (i.e. vertex connectivity). For a given graph G, a subset of its vertices S is said to be maximally k-cohesive if there is no superset of S with vertex connectivity greater than or equal to k. Cohesive blocking is a process through which, given a k-cohesive set of vertices, maximally l-cohesive subsets are recursively identified with l > k. Thus a hierarchy of vertex subsets is obtained in the end, with the entire graph G at its root.\nParamters: \nReturn: [an instance of CohesiveBlocks. See the documentation of CohesiveBlocks for more information.]\nReferences: []\nRasises: \nSee Also: CohesiveBlocks\nexample: []\nSection_id: Graph",
    "Field List > Methods > community_edge_betweenness: Description: overrides igraph.GraphBase.community_edge_betweenness\nCommunity structure based on the betweenness of the edges in the network.\nThe idea is that the betweenness of the edges connecting two communities is typically high, as many of the shortest paths between nodes in separate communities go through them. So we gradually remove the edge with the highest betweenness and recalculate the betweennesses after every removal. This way sooner or later the network falls of to separate components. The result of the clustering will be represented by a dendrogram.\nParamters: graph: Undocumented\nclusters: the number of  we would like to see. This practically defines the \"level\" where we \"cut\" the dendrogram to get the membership vector of the vertices. If None, the dendrogram is cut at the level that maximizes the modularity when the graph is unweighted; otherwise the dendrogram is cut at at a single cluster (because cluster count selection based on modularities does not make sense for this method if not all the weights are equal).\ndirected: whether the directionality of the edges should be taken into account or not.\nweights: name of an edge attribute or a list containing edge .\nReturn: [a VertexDendrogram object, initally cut at the maximum modularity or at the desired number of clusters.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_fastgreedy: Description: overrides igraph.GraphBase.community_fastgreedy\nCommunity structure based on the greedy optimization of modularity.\nThis algorithm merges individual nodes into communities in a way that greedily maximizes the modularity score of the graph. It can be proven that if no merge can increase the current modularity score, the algorithm can be stopped since no further increase can be achieved.\nThis algorithm is said to run almost in linear time on sparse graphs.\nReference: A Clauset, MEJ Newman and C Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).\nParamters: graph: Undocumented\nweights: edge attribute name or a list containing edge\nReturn: [an appropriate VertexDendrogram object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_infomap: Description: overrides igraph.GraphBase.community_infomap\nFinds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.\n\nParamters: graph: Undocumented\nedge_weights: name of an edge attribute or a list containing edge weights.\nvertex_weights: name of a vertex attribute or a list containing vertex weights.\ntrials: the number of attempts to partition the network.\nReturn: [an appropriate VertexClustering object with an extra attribute called codelength that stores the code length determined by the algorithm.]\nReferences: [M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks, PNAS 105, 1118 (2008). http://dx.doi.org/10.1073/pnas.0706851105, http://arxiv.org/abs/0707.0609.M. Rosvall, D. Axelsson, and C. T. Bergstrom: The map equation, Eur Phys. J Special Topics 178, 13 (2009). http://dx.doi.org/10.1140/epjst/e2010-01179-1, http://arxiv.org/abs/0906.1405.]\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_label_propagation: Description: overrides igraph.GraphBase.community_label_propagation\nFinds the community structure of the graph according to the label propagation method of Raghavan et al.\nInitially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.\nNote that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al. on how to come up with an aggregated community structure.\nAlso note that the community _labels_ (numbers) have no semantic meaning and igraph is free to re-number communities. If you use fixed labels, igraph may still re-number the communities, but co-community membership constraints will be respected: if you had two vertices with fixed labels that belonged to the same community, they will still be in the same community at the end. Similarly, if you had two vertices with fixed labels that belonged to different communities, they will still be in different communities at the end.\nReference: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938.\nParamters: graph: Undocumented\nweights: name of an edge attribute or a list containing edge \ninitial: name of a vertex attribute or a list containing the  vertex labels. Labels are identified by integers from zero to n − 1 where n is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.\nfixed: a list of booleans for each vertex. True corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be . It may also be the name of a vertex attribute; each attribute value will be interpreted as a Boolean.\nReturn: [an appropriate VertexClustering object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_leading_eigenvector: Description: overrides igraph.GraphBase.community_leading_eigenvector\nNewman's leading eigenvector method for detecting community structure.\nThis is the proper implementation of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.\nReference: MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087\nParamters: graph: Undocumented\nclusters: the desired number of communities. If None, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.\nweights: name of an edge attribute or a list containing edge .\narpack_options: an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.\nReturn: [an appropriate VertexClustering object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_leiden: Description: overrides igraph.GraphBase.community_leiden\nFinds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman.\nReference: Traag, V. A., Waltman, L., & van Eck, N. J. (2019). From Louvain to Leiden: guaranteeing well-connected communities. Scientific Reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z\nParamters: graph: Undocumented\nobjective_function: whether to use the Constant Potts Model (CPM) or modularity. Must be either \"CPM\" or \"modularity\".\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nresolution: the  parameter to use. Higher s lead to more smaller communities, while lower s lead to fewer larger communities.\nbeta: parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.\ninitial_membership: if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.\nn_iterations: the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. Using a negative number of iterations will run until a stable iteration is encountered (i.e. the quality was not increased during that iteration).\nnode_weights: the node weights used in the Leiden algorithm. If this is not provided, it will be automatically determined on the basis of whether you want to use CPM or modularity. If you do provide this, please make sure that you understand what you are doing.\n**kwds: Undocumented\nReturn: [an appropriate VertexClustering object with an extra attribute called quality that stores the value of the internal quality function optimized by the algorithm.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_multilevel: Description: overrides igraph.GraphBase.community_multilevel\nCommunity structure based on the multilevel algorithm of Blondel et al.\nThis is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrunk to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity anymore after shrinking the communities to vertices.\nThis algorithm is said to run almost in linear time on sparse graphs.\nReference: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008). http://arxiv.org/abs/0803.0476\nParamters: graph: Undocumented\nweights: edge attribute name or a list containing edge \nreturn_levels: if True, the communities at each level are returned in a list. If False, only the community structure with the best modularity is returned.\nresolution: the  parameter to use in the modularity measure. Smaller values result in a smaller number of larger clusters, while higher values yield a large number of small clusters. The classical modularity measure assumes a  parameter of 1.\nReturn: [a list of VertexClustering objects, one corresponding to each level (if return_levels is True), or a VertexClustering corresponding to the best modularity.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_optimal_modularity: Description: overrides igraph.GraphBase.community_optimal_modularity\nCalculates the optimal modularity score of the graph and the corresponding community structure.\nThis function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.\nParamters: \nReturn: [the calculated membership vector and the corresponding modularity in a tuple.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_spinglass: Description: overrides igraph.GraphBase.community_spinglass\nFinds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt.\n\nParamters: graph: Undocumented\n*args: Undocumented\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nspins: integer, the number of  to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.\nparupdate: whether to update the spins of the vertices in parallel (synchronously) or not\nstart_temp: the starting temperature\nstop_temp: the stop temperature\ncool_fact: cooling factor for the simulated annealing\nupdate_rule: specifies the null model of the simulation. Possible values are \"config\" (a random graph with the same vertex degrees as the input graph) or \"simple\" (a random graph with the same number of edges)\ngamma: the  argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.\nimplementation: currently igraph contains two s of the spinglass community detection algorithm. The faster original  is the default. The other  is able to take into account negative weights, this can be chosen by setting  to \"neg\"\nlambda_: the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used. Note the underscore at the end of the argument name; this is due to the fact that lambda is a reserved keyword in Python.\nReturn: [an appropriate VertexClustering object.]\nReferences: [Reichardt J and Bornholdt S: Statistical mechanics of community detection. Phys Rev E 74:016110 (2006). http://arxiv.org/abs/cond-mat/0603718.Traag VA and Bruggeman J: Community detection in networks with positive and negative links. Phys Rev E 80:036115 (2009). http://arxiv.org/abs/0811.2329.]\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > community_walktrap: Description: overrides igraph.GraphBase.community_walktrap\nCommunity detection algorithm of Latapy & Pons, based on random walks.\nThe basic idea of the algorithm is that short random walks tend to stay in the same community. The result of the clustering will be represented as a dendrogram.\nReference: Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106.\nParamters: graph: Undocumented\nweights: name of an edge attribute or a list containing edge \nsteps: length of random walks to perform\nReturn: [a VertexDendrogram object, initially cut at the maximum modularity.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > components: Description: Calculates the (strong or weak) connected components for a given graph.\nParamters: graph: Undocumented\nmode: must be either \"strong\" or \"weak\", depending on the connected components being sought. Optional, defaults to \"strong\".\nReturn: [a VertexClustering object]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > connected_components: Description: overrides igraph.GraphBase.connected_components\nCalculates the (strong or weak) connected components for a given graph.\nParamters: graph: Undocumented\nmode: must be either \"strong\" or \"weak\", depending on the connected components being sought. Optional, defaults to \"strong\".\nReturn: [a VertexClustering object]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > count_automorphisms_vf2: Description: Returns the number of automorphisms of the graph.\nThis function simply calls count_isomorphisms_vf2 with the graph itgraph. See count_isomorphisms_vf2 for an explanation of the parameters.\nParamters: \nReturn: [the number of automorphisms of the graph]\nReferences: []\nRasises: \nSee Also: Graph.count_isomorphisms_vf2\nexample: []\nSection_id: Graph",
    "Field List > Methods > degree_distribution: Description: Calculates the degree distribution of the graph.\nUnknown keyword arguments are directly passed to GraphBase.degree.\nParamters: graph: Undocumented\nbin_width: the bin width of the histogram\n*args: Undocumented\n**kwds: Undocumented\nReturn: [a histogram representing the degree distribution of the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > delete_edges: Description: overrides igraph.GraphBase.delete_edges\nDeletes some edges from the graph.\nThe set of edges to be deleted is determined by the positional and keyword arguments. If the function is called without any arguments, all edges are deleted. If any keyword argument is present, or the first positional argument is callable, an edge sequence is derived by calling EdgeSeq.select with the same positional and keyword arguments. Edges in the derived edge sequence will be removed. Otherwise, the first positional argument is considered as follows:\nDeprecation notice: delete_edges(None) has been replaced by delete_edges() - with no arguments - since igraph 0.8.3.None - deletes all edges (deprecated since 0.8.3)a single integer - deletes the edge with the given IDa list of integers - deletes the edges denoted by the given IDsa list of 2-tuples - deletes the edges denoted by the given source-target vertex pairs. When multiple edges are present between a given source-target vertex pair, only one is removed.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > dfs: Description: Conducts a depth first search (DFS) on the graph.\nParamters: vid: the root vertex ID\nmode: either \"in\" or \"out\" or \"all\", ignored for undirected graphs.\nReturn: [a tuple with the following items:\n\nThe vertex IDs visited (in order)\nThe parent of every vertex in the DFS\n\n]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > disjoint_union: Description: Creates the disjoint union of two (or more) graphs.\nParamters: graph: Undocumented\nother: graph or list of graphs to be united with the current one.\nReturn: [the disjoint union graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > dyad_census: Description: overrides igraph.GraphBase.dyad_census\nCalculates the dyad census of the graph.\nDyad census means classifying each pair of vertices of a directed graph into three categories: mutual (there is an edge from a to b and also from b to a), asymmetric (there is an edge from a to b or from b to a but not the other way round) and null (there is no connection between a and b).\nReference: Holland, P.W. and Leinhardt, S. A Method for Detecting Structure in Sociometric Data. American Journal of Sociology, 70, 492-513, 1970.\nParamters: \nReturn: [a DyadCensus object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > get_adjacency: Description: overrides igraph.GraphBase.get_adjacency\nReturns the adjacency matrix of a graph.\nParamters: type: either GET_ADJACENCY_LOWER (uses the lower triangle of the matrix) or GET_ADJACENCY_UPPER (uses the upper triangle) or GET_ADJACENCY_BOTH (uses both parts). Ignored for directed graphs.\nattribute: if None, returns the ordinary adjacency matrix. When the name of a valid edge  is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given  where there is an edge. Multiple edges are not supported, the value written in the matrix in this case will be unpredictable. This parameter is ignored if eids is True\ndefault: the  value written to the cells in the case of adjacency matrices with attributes.\neids: specifies whether the edge IDs should be returned in the adjacency matrix. Since zero is a valid edge ID, the cells in the matrix that correspond to unconnected vertex pairs will contain -1 instead of 0 if  is True. If  is False, the number of edges will be returned in the matrix for each vertex pair.\nReturn: [the adjacency matrix as a Matrix.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > get_adjacency_sparse: Description: Returns the adjacency matrix of a graph as a SciPy CSR matrix.\nParamters: attribute: if None, returns the ordinary adjacency matrix. When the name of a valid edge  is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given  where there is an edge.\nReturn: [the adjacency matrix as a scipy.sparse.csr_matrix.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > get_adjlist: Description: Returns the adjacency list representation of the graph.\nThe adjacency list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the neighbors of the given vertex.\nParamters: mode: if \"out\", returns the successors of the vertex. If \"in\", returns the predecessors of the vertex. If \"all\", both the predecessors and the successors will be returned. Ignored for undirected graphs.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > get_all_simple_paths: Description: Calculates all the simple paths from a given node to some other nodes (or all of them) in a graph.\nA path is simple if its vertices are unique, i.e. no vertex is visited more than once.\nNote that potentially there are exponentially many paths between two vertices of a graph, especially if your graph is lattice-like. In this case, you may run out of memory when using this function.\nParamters: v: the source for the calculated paths\nto: a vertex selecr describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.\ncutoff: maximum length of path that is considered. If negative, paths of all lengths are considered.\nmode: the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones.\nReturn: [all of the simple paths from the given node to every other reachable node in the graph in a list. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > get_automorphisms_vf2: Description: Returns all the automorphisms of the graph\nThis function simply calls get_isomorphisms_vf2 with the graph itgraph. See get_isomorphisms_vf2 for an explanation of the parameters.\nParamters: \nReturn: [a list of lists, each item containing a possible mapping of the graph vertices to itgraph according to the automorphism]\nReferences: []\nRasises: \nSee Also: Graph.get_isomorphisms_vf2\nexample: []\nSection_id: Graph",
    "Field List > Methods > get_biadjacency: Description: overrides igraph.GraphBase.get_biadjacency\nReturns the bipartite adjacency matrix of a bipartite graph. The bipartite adjacency matrix is an n times m matrix, where n and m are the number of vertices in the two vertex classes.\nParamters: graph: Undocumented\ntypes: an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.\n*args: Undocumented\n**kwds: Undocumented\nReturn: [the bipartite adjacency matrix and two lists in a triplet. The first list defines the mapping between row indices of the matrix and the original vertex IDs. The second list is the same for the column indices.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > get_edge_dataframe: Description: Export edges with attributes to pandas.DataFrame\nIf you want to use source and target vertex IDs as index, you can do:\nParamters: \nReturn: [a pandas.DataFrame representing edges and their attributes. The index uses edge IDs, from 0 to M - 1 where M is the number of edges. The first two columns of the dataframe represent the IDs of source and target vertices for each edge. These columns have names \"source\" and \"target\". If your edges have attributes with the same names, they will be present in the dataframe, but not in the first two columns.]\nReferences: []\nRasises: \nSee Also: \nexample: [If you want to use source and target vertex IDs as index, you can do:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_edge_dataframe()\n>>> df.set_index(['source', 'target'], inplace=True), If you want to use vertex names in the source and target columns:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_edge_dataframe()\n>>> df.set_index(['source', 'target'], inplace=True)]\nSection_id: Graph",
    "Field List > Methods > get_incidence: Description: Deprecated alias to Graph.get_biadjacency().\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > get_inclist: Description: Returns the incidence list representation of the graph.\nThe incidence list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the IDs of the incident edges of the given vertex.\nParamters: graph: Undocumented\nmode: if \"out\", returns the successors of the vertex. If \"in\", returns the predecessors of the vertex. If \"all\", both the predecessors and the successors will be returned. Ignored for undirected graphs.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > get_vertex_dataframe: Description: Export vertices with attributes to pandas.DataFrame\nIf you want to use vertex names as index, you can do:\nParamters: \nReturn: [a pandas.DataFrame representing vertices and their attributes. The index uses vertex IDs, from 0 to N - 1 where N is the number of vertices.]\nReferences: []\nRasises: \nSee Also: \nexample: [If you want to use vertex names as index, you can do:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_vertex_dataframe()\n>>> df.set_index('name', inplace=True)]\nSection_id: Graph",
    "Field List > Methods > gomory_hu_tree: Description: overrides igraph.GraphBase.gomory_hu_tree\nCalculates the Gomory-Hu tree of an undirected graph with optional edge capacities.\nThe Gomory-Hu tree is a concise representation of the value of all the maximum flows (or minimum cuts) in a graph. The vertices of the tree correspond exactly to the vertices of the original graph in the same order. Edges of the Gomory-Hu tree are annotated by flow values.  The value of the maximum flow (or minimum cut) between an arbitrary (u,v) vertex pair in the original graph is then given by the minimum flow value (i.e. edge annotation) along the shortest path between u and v in the Gomory-Hu tree.\nParamters: graph: Undocumented\ncapacity: the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name.\nflow: the name of the edge attribute in the returned graph in which the  values will be stored.\nReturn: [the Gomory-Hu tree as a Graph object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > indegree: Description: Returns the in-degrees in a list.\nSee GraphBase.degree for possible arguments.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > intersection: Description: Creates the intersection of two (or more) graphs.\nParamters: graph: Undocumented\nother: graph or list of graphs to be intersected with the current one.\nbyname: whether to use vertex names instead of ids. See igraph.operators.intersection for details.\nReturn: [the intersection graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > is_named: Description: Returns whether the graph is named.\nA graph is named if and only if it has a \"name\" vertex attribute.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > is_weighted: Description: Returns whether the graph is weighted.\nA graph is weighted if and only if it has a \"weight\" edge attribute.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > k_core: Description: Returns some k-cores of the graph.\nThe method accepts an arbitrary number of arguments representing the desired indices of the k-cores to be returned. The arguments can also be lists or tuples. The result is a single Graph object if an only integer argument was given, otherwise the result is a list of Graph objects representing the desired k-cores in the order the arguments were specified. If no argument is given, returns all k-cores in increasing order of k.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > layout: Description: Returns the layout of the graph according to a layout algorithm.\nParameters and keyword arguments not specified here are passed to the layout algorithm directly. See the documentation of the layout algorithms for the explanation of these parameters.\nRegistered layout names understood by this method are:auto, automatic: automatic layout (see Graph.layout_auto)bipartite: bipartite layout (see GraphBase.layout_bipartite)circle, circular: circular layout (see GraphBase.layout_circle)dh, davidson_harel: Davidson-Harel layout (see GraphBase.layout_davidson_harel)drl: DrL layout for large graphs (see GraphBase.layout_drl)drl_3d: 3D DrL layout for large graphs (see GraphBase.layout_drl)fr, fruchterman_reingold: Fruchterman-Reingold layout (see GraphBase.layout_fruchterman_reingold).fr_3d, fr3d, fruchterman_reingold_3d: 3D Fruchterman- Reingold layout (see GraphBase.layout_fruchterman_reingold).grid: regular grid layout in 2D (see GraphBase.layout_grid)grid_3d: regular grid layout in 3D (see GraphBase.layout_grid)graphopt: the graphopt algorithm (see GraphBase.layout_graphopt)kk, kamada_kawai: Kamada-Kawai layout (see GraphBase.layout_kamada_kawai)kk_3d, kk3d, kamada_kawai_3d: 3D Kamada-Kawai layout (see GraphBase.layout_kamada_kawai)lgl, large, large_graph: Large Graph Layout (see GraphBase.layout_lgl)mds: multidimensional scaling layout (see GraphBase.layout_mds)random: random layout (see GraphBase.layout_random)random_3d: random 3D layout (see GraphBase.layout_random)rt, tree, reingold_tilford: Reingold-Tilford tree layout (see GraphBase.layout_reingold_tilford)rt_circular, reingold_tilford_circular: circular Reingold-Tilford tree layout (see GraphBase.layout_reingold_tilford_circular)sphere, spherical, circle_3d, circular_3d: spherical layout (see GraphBase.layout_circle)star: star layout (see GraphBase.layout_star)sugiyama: Sugiyama layout (see Graph.layout_sugiyama)\nParamters: graph: Undocumented\nlayout: the  to use. This can be one of the registered  names or a callable which returns either a Layout object or a list of lists containing the coordinates. If None, uses the value of the plotting. configuration key.\n*args: Undocumented\n**kwds: Undocumented\nReturn: [a Layout object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > layout_auto: Description: Chooses and runs a suitable layout function based on simple topological properties of the graph.\nThis function tries to choose an appropriate layout function for the graph using the following rules:If the graph has an attribute called layout, it will be used. It may either be a Layout instance, a list of coordinate pairs, the name of a layout function, or a callable function which generates the layout when called with the graph as a parameter.Otherwise, if the graph has vertex attributes called x and y, these will be used as coordinates in the layout. When a 3D layout is requested (by setting dim to 3), a vertex attribute named z will also be needed.Otherwise, if the graph is connected and has at most 100 vertices, the Kamada-Kawai layout will be used (see GraphBase.layout_kamada_kawai()).Otherwise, if the graph has at most 1000 vertices, the Fruchterman-Reingold layout will be used (see GraphBase.layout_fruchterman_reingold()).If everything else above failed, the DrL layout algorithm will be used (see GraphBase.layout_drl()).\nAll the arguments of this function except dim are passed on to the chosen layout function (in case we have to call some layout function).\nParamters: graph: Undocumented\n*args: Undocumented\ndim: specifies whether we would like to obtain a 2D or a 3D layout.\nReturn: [a Layout object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > layout_sugiyama: Description: Places the vertices using a layered Sugiyama layout.\nThis is a layered layout that is most suitable for directed acyclic graphs, although it works on undirected or cyclic graphs as well.\nEach vertex is assigned to a layer and each layer is placed on a horizontal line. Vertices within the same layer are then permuted using the barycenter heuristic that tries to minimize edge crossings.\nDummy vertices will be added on edges that span more than one layer. The returned layout therefore contains more rows than the number of nodes in the original graph; the extra rows correspond to the dummy vertices.\n\nParamters: graph: Undocumented\nlayers: a vector specifying a non-negative integer layer index for each vertex, or the name of a numeric vertex attribute that contains the layer indices. If None, a layering will be determined automatically. For undirected graphs, a spanning tree will be extracted and vertices will be assigned to  using a breadth first search from the node with the largest degree. For directed graphs, cycles are broken by reversing the direction of edges in an approximate feedback arc set using the heuristic of Eades, Lin and Smyth, and then using longest path layering to place the vertices in .\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nhgap: minimum horizontal gap between vertices in the same layer.\nvgap: vertical gap between layers. The layer index will be multiplied by  to obtain the Y coordinate.\nmaxiter: maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings.\nreturn_extended_graph: specifies that the extended graph with the added dummy vertices should also be returned. When this is True, the result will be a tuple containing the layout and the extended graph. The first |V| nodes of the extended graph will correspond to the nodes of the original graph, the remaining ones are dummy nodes. Plotting the extended graph with the returned layout and hidden dummy nodes will produce a layout that is similar to the original graph, but with the added edge bends. The extended graph also contains an edge attribute called _original_eid which specifies the ID of the edge in the original graph from which the edge of the extended graph was created.\nReturn: [the calculated layout, which may (and usually will) have more rows than the number of vertices; the remaining rows correspond to the dummy nodes introduced in the layering step. When return_extended_graph is True, it will also contain the extended graph.]\nReferences: [:K Sugiyama, S Tagawa, M Toda: Methods for visual understanding of hierarchical system structures. IEEE Systems, Man and Cybernetics 11(2):109-125, 1981.P Eades, X Lin and WF Smyth: A fast effective heuristic for the feedback arc set problem. Information Processing Letters 47:319-323, 1993.]\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > maxflow: Description: overrides igraph.GraphBase.maxflow\nReturns a maximum flow between the given source and target vertices in a graph.\nA maximum flow from source to target is an assignment of non-negative real numbers to the edges of the graph, satisfying two properties:For each edge, the flow (i.e. the assigned number) is not more than the capacity of the edge (see the capacity argument)For every vertex except the source and the target, the incoming flow is the same as the outgoing flow.\nThe value of the flow is the incoming flow of the target or the outgoing flow of the source (which are equal). The maximum flow is the maximum possible such value.\nParamters: graph: Undocumented\nsource: Undocumented\ntarget: Undocumented\ncapacity: the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name.\nReturn: [a Flow object describing the maximum flow]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > maximum_bipartite_matching: Description: Finds a maximum matching in a bipartite graph.\nA maximum matching is a set of edges such that each vertex is incident on at most one matched edge and the number (or weight) of such edges in the set is as large as possible.\nParamters: graph: Undocumented\ntypes: vertex  in a list or the name of a vertex attribute holding vertex . Types should be denoted by zeros and ones (or False and True) for the two sides of the bipartite graph. If omitted, it defaults to type, which is the default vertex type attribute for bipartite graphs.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\neps: a small real number used in equality tests in the weighted bipartite matching algorithm. Two real numbers are considered equal in the algorithm if their difference is smaller than this value. This is required to avoid the accumulation of numerical errors. If you pass None here, igraph will try to determine an appropriate value automatically.\nReturn: [an instance of Matching.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > mincut: Description: overrides igraph.GraphBase.mincut\nCalculates the minimum cut between the given source and target vertices or within the whole graph.\nThe minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if neither the source nor the target are given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated.\nFor undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.\nParamters: graph: Undocumented\nsource: the  vertex ID. If None, the target must also be None and the calculation will be done for the entire graph (i.e. all possible vertex pairs).\ntarget: the  vertex ID. If None, the source must also be None and the calculation will be done for the entire graph (i.e. all possible vertex pairs).\ncapacity: the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name.\nReturn: [a Cut object describing the minimum cut]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > modularity: Description: overrides igraph.GraphBase.modularity\nCalculates the modularity score of the graph with respect to a given clustering.\nThe modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It's defined as Q = 1 ⁄ (2m)*sum(Aij − gamma*ki*kj ⁄ (2m)delta(ci, cj), i, j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, and Ci and cj are the types of the two vertices (i and j), and gamma is a resolution parameter that defaults to 1 for the classical definition of modularity. delta(x, y) is one iff x = y, 0 otherwise.\nIf edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges adjacent to vertex i, kj is the total weight of edges adjacent to vertex j and m is the total edge weight in the graph.\nReference: MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.\nParamters: membership: a  list or a VertexClustering object\nweights: optional edge  or None if all edges are weighed equally. Attribute names are also allowed.\nresolution: the  parameter gamma in the formula above. The classical definition of modularity is retrieved when the  parameter is set to 1.\ndirected: whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un.\nReturn: [the modularity score]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > outdegree: Description: Returns the out-degrees in a list.\nSee GraphBase.degree for possible arguments.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > pagerank: Description: Calculates the PageRank values of a graph.\nParamters: graph: Undocumented\nvertices: the indices of the  being queried. None means all of the .\ndirected: whether to consider  paths.\ndamping: the  factor. 1 −  is the probability of resetting the random walk to a uniform distribution in each step.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\narpack_options: an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used. This argument is ignored if not the ARPACK implementation is used, see the implementation argument.\nimplementation: which  to use to solve the PageRank eigenproblem. Possible values are:\"prpack\": use the PRPACK library. This is a new  in igraph 0.7\"arpack\": use the ARPACK library. This  was used from version 0.5, until version 0.7.\nReturn: [a list with the PageRank values of the specified vertices.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > path_length_hist: Description: overrides igraph.GraphBase.path_length_hist\nReturns the path length histogram of the graph\nParamters: directed: whether to consider  paths. Ignored for un graphs.\nReturn: [a Histogram object. The object will also have an unconnected attribute that stores the number of unconnected vertex pairs (where the second vertex can not be reached from the first one). The latter one will be of type long (and not a simple integer), since this can be very large.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > shortest_paths: Description: Deprecated alias to Graph.distances().\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > spanning_tree: Description: Calculates a minimum spanning tree for a graph.\nReference: Prim, R.C. Shortest connection networks and some generalizations. Bell System Technical Journal 36:1389-1401, 1957.\nParamters: weights: a vector containing  for every edge in the graph. None means that the graph is unweighted.\nreturn_tree: whether to return the minimum spanning tree (when  is True) or to return the IDs of the edges in the minimum spanning tree instead (when  is False). The default is True for historical reasons as this argument was introduced in igraph 0.6.\nReturn: [the spanning tree as a Graph object if return_tree is True or the IDs of the edges that constitute the spanning tree if return_tree is False.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > st_mincut: Description: overrides igraph.GraphBase.st_mincut\nCalculates the minimum cut between the source and target vertices in a graph.\nParamters: graph: Undocumented\nsource: the  vertex ID\ntarget: the  vertex ID\ncapacity: the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same .\nReturn: [the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > summary: Description: Returns the summary of the graph.\nThe output of this method is similar to the output of the __str__ method. If verbosity is zero, only the header line is returned (see __str__ for more details), otherwise the header line and the edge list is printed.\nBehind the scenes, this method constructs a GraphSummary object and invokes its __str__ method.\nParamters: verbosity: if zero, only the header line is returned (see __str__ for more details), otherwise the header line and the full edge list is printed.\nwidth: the number of characters to use in one line. If None, no limit will be enforced on the line lengths.\n*args: Undocumented\n**kwds: Undocumented\nReturn: [the summary of the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > to_dict_dict: Description: Export graph to dictionary of dicts of edge attributes\nThis function is the reverse of Graph.DictDict.\nExample:\nParamters: graph: Undocumented\nuse_vids: :boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.\nedge_attrs: :Union[str, Sequence[str]]list of edge attributes to export. None (default) signified all attributes (unlike Graph.to_tuple_list). A string is acceptable to signify a single attribute and will be wrapped in a list internally.\nskip_none: :boolwhether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.\nvertex_name_attr: :stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.\nReturn: [dictionary of dictionaries of dictionaries, with the outer keys vertex ids/names, the middle keys ids/names of their neighbors, and the innermost dictionary representing attributes of that edge.]\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> g = Graph.Full(3)\n>>> g.es['name'] = ['first_edge', 'second', 'third']\n>>> g.to_dict_dict()\n{0: {1: {'name': 'first_edge'}, 2: {'name': 'second'}}, 1: {2: {'name': 'third'}}}\n]\nSection_id: Graph",
    "Field List > Methods > to_dict_list: Description: Export graph as two lists of dictionaries, for vertices and edges.\nThis function is the reverse of Graph.DictList.\nExample:\nParamters: graph: Undocumented\nuse_vids: :boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.\nskip_none: :boolwhether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.\nvertex_name_attr: :stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.\nReturn: [a tuple with two lists of dictionaries, representing the vertices and the edges, respectively, with their attributes.]\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"], >>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"], >>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"]]\nSection_id: Graph",
    "Field List > Methods > to_graph_tool: Description: Converts the graph to graph-tool\nData types: graph-tool only accepts specific data types. See the following web page for a list:\nhttps://graph-tool.skewed.de/static/doc/quickstart.html\nNote: because of the restricted data types in graph-tool, vertex and edge attributes require to be type-consistent across all vertices or edges. If you set the property for only some vertices/edges, the other will be tagged as None in igraph, so they can only be converted to graph-tool with the type 'object' and any other conversion will fail.\nParamters: graph: Undocumented\ngraph_attributes: dictionary of graph attributes to transfer. Keys are attributes from the graph, values are data types (see below). None means no graph attributes are transferred.\nvertex_attributes: dictionary of vertex attributes to transfer. Keys are attributes from the vertices, values are data types (see below). None means no vertex attributes are transferred.\nedge_attributes: dictionary of edge attributes to transfer. Keys are attributes from the edges, values are data types (see below). None means no vertex attributes are transferred.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > to_list_dict: Description: Export graph to a dictionary of lists (or other sequences).\nThis function is the reverse of Graph.ListDict.\nExample:\nParamters: graph: Undocumented\nuse_vids: :boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.\nsequence_constructor: :callableconstructor for the data structure to be used as values of the dictionary. The default (list) makes a dict of lists, with each list representing the neighbors of the vertex specified in the respective dictionary key.\nvertex_name_attr: :stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.\nReturn: [dictionary of sequences, keyed by vertices, with each value containing the neighbors of that vertex.]\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> g = Graph.Full(3)\n>>> g.to_sequence_dict() -> {0: [1, 2], 1: [2]}\n>>> g.to_sequence_dict(sequence_constructor=tuple) -> {0: (1, 2), 1: (2,)}\n>>> g.vs['name'] = ['apple', 'pear', 'peach']\n>>> g.to_sequence_dict(use_vids=False)\n{'apple': ['pear', 'peach'], 'pear': ['peach']}\n]\nSection_id: Graph",
    "Field List > Methods > to_networkx: Description: Converts the graph to networkx format.\nigraph has ordered vertices and edges, but networkx does not. To keep track of the original order, the '_igraph_index' vertex property is added to both vertices and edges.\nParamters: graph: Undocumented\ncreate_using: specifies which NetworkX graph class to use when constructing the graph. None means to let igraph infer the most appropriate class based on whether the graph is directed and whether it has multi-edges.\nvertex_attr_hashable: :strvertex attribute used to name vertices in the exported network. The default \"_nx_name\" ensures round trip conversions to/from networkx are lossless.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > to_tuple_list: Description: Export graph to a list of edge tuples\nThis function is the reverse of Graph.TupleList.\nExample:\nParamters: graph: Undocumented\nuse_vids: :boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.\nedge_attrs: :Union[str, Sequence[str]]list of edge attributes to export in addition to source and target vertex, which are always the first two elements of each tuple. None (default) is equivalent to an empty list. A string is acceptable to signify a single attribute and will be wrapped in a list internally.\nvertex_name_attr: :stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.\nReturn: [a list of tuples, each representing an edge of the graph.]\nReferences: []\nRasises: \nSee Also: \nexample: [Example:\n>>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"], >>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"], >>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"]]\nSection_id: Graph",
    "Field List > Methods > transitivity_avglocal_undirected: Description: overrides igraph.GraphBase.transitivity_avglocal_undirected\nCalculates the average of the vertex transitivities of the graph.\nIn the unweighted case, the transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter. The calculation is slightly more involved for weighted graphs; in this case, weights are taken into account according to the formula of Barrat et al (see the references).\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it simply takes the average local transitivity across the whole network.\n\nParamters: mode: defines how to treat vertices with degree less than two. If TRANSITIVITY_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will be excluded from the average.\nweights: edge  to be used. Can be a sequence or iterable or even an edge attribute name.\nReturn: []\nReferences: [Watts DJ and Strogatz S: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: The architecture of complex weighted networks. PNAS 101, 3747 (2004). http://arxiv.org/abs/cond-mat/0311416.]\nRasises: \nSee Also: transitivity_undirected(), transitivity_local_undirected()\nexample: []\nSection_id: Graph",
    "Field List > Methods > triad_census: Description: overrides igraph.GraphBase.triad_census\nCalculates the triad census of the graph.\nReference: Davis, J.A. and Leinhardt, S. The Structure of Positive Interpersonal Relations in Small Groups. In: J. Berger (Ed.), Sociological Theories in Progress, Volume 2, 218-251. Boston: Houghton Mifflin (1972).\nParamters: \nReturn: [a TriadCensus object.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > union: Description: Creates the union of two (or more) graphs.\nParamters: graph: Undocumented\nother: graph or list of graphs to be united with the current one.\nbyname: whether to use vertex names instead of ids. See igraph.operators.union for details.\nReturn: [the union graph]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > write: Description: Unified writing function for graphs.\nThis method tries to identify the format of the graph given in the first parameter (based on extension) and calls the corresponding writer method.\nThe remaining arguments are passed to the writer method without any changes.\nParamters: graph: Undocumented\nf: the ile containing the graph to be saved\nformat: the  of the file (if one wants to override the  determined from the filename extension, or the filename itself is a stream). None means auto-detection. Possible values are:\"adjacency\": adjacency matrix \"dimacs\": DIMACS \"dot\", \"graphviz\": GraphViz DOT \"edgelist\", \"edges\" or \"edge\": numeric edge list \"gml\": GML \"graphml\" and \"graphmlz\": standard and gzipped GraphML \"gw\", \"leda\", \"lgr\": LEDA native \"lgl\": LGL \"ncol\": NCOL \"net\", \"pajek\": Pajek \"pickle\", \"picklez\": standard and gzipped Python pickled \"svg\": SVG \n*args: Undocumented\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: IOError: if the file format can't be identified and none was given.\nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > write_adjacency: Description: Writes the adjacency matrix of the graph to the given file\nAll the remaining arguments not mentioned here are passed intact to Graph.get_adjacency.\nParamters: graph: Undocumented\nf: the name o the ile to be written.\nsep: the string that arates the matrix elements in a row\neol: the string that separates the rows of the matrix. Please note that igraph is able to read back the written adjacency matrix if and only if this is a single newline character\n*args: Undocumented\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > write_dimacs: Description: overrides igraph.GraphBase.write_dimacs\nWrites the graph in DIMACS format to the given file.\nParamters: graph: Undocumented\nf: the name o the ile to be written or a Python ile handle.\nsource: the  vertex ID. If None, igraph will try to infer it from the  graph attribute.\ntarget: the  vertex ID. If None, igraph will try to infer it from the  graph attribute.\ncapacity: the capacities of the edges in a list or the name of an edge attribute that holds the capacities. If there is no such edge attribute, every edge will have a  of 1.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > write_graphmlz: Description: Writes the graph to a zipped GraphML file.\nThe library uses the gzip compression algorithm, so the resulting file can be unzipped with regular gzip uncompression (like gunzip or zcat from Unix command line) or the Python gzip module.\nUses a temporary file to store intermediate GraphML data, so make sure you have enough free space to store the unzipped GraphML file as well.\nParamters: graph: Undocumented\nf: the name o the ile to be written.\ncompresslevel: the level of compression. 1 is fastest and produces the least compression, and 9 is slowest and produces the most compression.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > write_pickle: Description: Saves the graph in Python pickled format\nParamters: graph: Undocumented\nfname: the name of the file or a stream to save to. If None, saves the graph to a string and returns the string.\nversion: pickle protocol  to be used. If -1, uses the highest protocol available\nReturn: [None if the graph was saved successfully to the given file, or a string if fname was None.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > write_picklez: Description: Saves the graph in Python pickled format, compressed with gzip.\nSaving in this format is a bit slower than saving in a Python pickle without compression, but the final file takes up much less space on the hard drive.\nParamters: graph: Undocumented\nfname: the name of the file or a stream to save to.\nversion: pickle protocol  to be used. If -1, uses the highest protocol available\nReturn: [None if the graph was saved successfully to the given file.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > write_svg: Description: Saves the graph as an SVG (Scalable Vector Graphics) file\nThe file will be Inkscape (http://inkscape.org) compatible. In Inkscape, as nodes are rearranged, the edges auto-update.\nParamters: graph: Undocumented\nfname: the name of the file or a Python file handle\nlayout: the  of the graph. Can be either an explicitly specified  (using a list of coordinate pairs) or the name of a  algorithm (which should refer to a method in the Graph object, but without the _ prefix.\nwidth: the preferred  in pixels (default: 400)\nheight: the preferred  in pixels (default: 400)\nlabels: the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the . It can also be None.\ncolors: the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the . A color can be anything acceptable in an SVG file.\nshapes: the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the  as integers. Shape 0 means hidden (nothing is drawn), shape 1 is a circle, shape 2 is a rectangle and shape 3 is a rectangle that automatically sizes to the inner text.\nvertex_size: vertex size in pixels\nedge_colors: the edge colors. Either it is the name of an edge attribute to use, or a list explicitly specifying the colors. A color can be anything acceptable in an SVG file.\nedge_stroke_widths: the stroke widths of the edges. Either it is the name of an edge attribute to use, or a list explicitly specifying the stroke widths. The stroke width can be anything acceptable in an SVG file.\nfont_size: font size. If it is a string, it is written into the SVG file as-is (so you can specify anything which is valid as the value of the font-size style). If it is a number, it is interpreted as pixel size and converted to the proper attribute value accordingly.\n*args: Undocumented\n**kwds: Undocumented\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Graph",
    "Field List > Methods > __new__: Description: Inherited from GraphBase:Create and return a new object.  See help(type) for accurate signature.\nSection_id: Graph",
    "Field List > Methods > all_minimal_st_separators: Description: Inherited from GraphBase:Returns a list containing all the minimal s-t separators of a graph.\nSection_id: Graph",
    "Field List > Methods > are_connected: Description: Inherited from GraphBase:Decides whether two given vertices are directly connected.\nSection_id: Graph",
    "Field List > Methods > articulation_points: Description: Inherited from GraphBase:Returns the list of articulation points in the graph.\nSection_id: Graph",
    "Field List > Methods > assortativity: Description: Inherited from GraphBase:Returns the assortativity of the graph based on numeric properties of the vertices.\nSection_id: Graph",
    "Field List > Methods > assortativity_degree: Description: Inherited from GraphBase:Returns the assortativity of a graph based on vertex degrees.\nSection_id: Graph",
    "Field List > Methods > assortativity_nominal: Description: Inherited from GraphBase:Returns the assortativity of the graph based on vertex categories.\nSection_id: Graph",
    "Field List > Methods > Asymmetric_Preference: Description: Inherited from GraphBase:Generates a graph based on asymmetric vertex types and connection probabilities.\nSection_id: Graph",
    "Field List > Methods > Atlas: Description: Inherited from GraphBase:Generates a graph from the Graph Atlas.\nSection_id: Graph",
    "Field List > Methods > attributes: Description: Inherited from GraphBase:No summary\nSection_id: Graph",
    "Field List > Methods > authority_score: Description: Inherited from GraphBase:Calculates Kleinberg's authority score for the vertices of the graph\nSection_id: Graph",
    "Field List > Methods > automorphism_group: Description: Inherited from GraphBase:Calculates the generators of the automorphism group of a graph using the BLISS isomorphism algorithm.\nSection_id: Graph",
    "Field List > Methods > average_path_length: Description: Inherited from GraphBase:Calculates the average path length in a graph.\nSection_id: Graph",
    "Field List > Methods > Barabasi: Description: Inherited from GraphBase:Generates a graph based on the Barabási-Albert model.\nSection_id: Graph",
    "Field List > Methods > betweenness: Description: Inherited from GraphBase:Calculates or estimates the betweenness of vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > bfs: Description: Inherited from GraphBase:Conducts a breadth first search (BFS) on the graph.\nSection_id: Graph",
    "Field List > Methods > bfsiter: Description: Inherited from GraphBase:Constructs a breadth first search (BFS) iterator of the graph.\nSection_id: Graph",
    "Field List > Methods > bibcoupling: Description: Inherited from GraphBase:Calculates bibliographic coupling scores for given vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > bridges: Description: Inherited from GraphBase:Returns the list of bridges in the graph.\nSection_id: Graph",
    "Field List > Methods > canonical_permutation: Description: Inherited from GraphBase:Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.\nSection_id: Graph",
    "Field List > Methods > chordal_completion: Description: Inherited from GraphBase:Returns the list of edges needed to be added to the graph to make it chordal.\nSection_id: Graph",
    "Field List > Methods > clique_number: Description: Inherited from GraphBase:Returns the clique number of the graph.\nSection_id: Graph",
    "Field List > Methods > cliques: Description: Inherited from GraphBase:Returns some or all cliques of the graph as a list of tuples.\nSection_id: Graph",
    "Field List > Methods > closeness: Description: Inherited from GraphBase:Calculates the closeness centralities of given vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > cocitation: Description: Inherited from GraphBase:Calculates cocitation scores for given vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > complementer: Description: Inherited from GraphBase:Returns the complementer of the graph\nSection_id: Graph",
    "Field List > Methods > compose: Description: Inherited from GraphBase:Returns the composition of two graphs.\nSection_id: Graph",
    "Field List > Methods > constraint: Description: Inherited from GraphBase:Calculates Burt's constraint scores for given vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > contract_vertices: Description: Inherited from GraphBase:Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.\nSection_id: Graph",
    "Field List > Methods > convergence_degree: Description: Inherited from GraphBase:Undocumented (yet).\nSection_id: Graph",
    "Field List > Methods > convergence_field_size: Description: Inherited from GraphBase:Undocumented (yet).\nSection_id: Graph",
    "Field List > Methods > copy: Description: Inherited from GraphBase:Creates a copy of the graph.\nSection_id: Graph",
    "Field List > Methods > coreness: Description: Inherited from GraphBase:Finds the coreness (shell index) of the vertices of the network.\nSection_id: Graph",
    "Field List > Methods > count_automorphisms: Description: Inherited from GraphBase:Calculates the number of automorphisms of a graph using the BLISS isomorphism algorithm.\nSection_id: Graph",
    "Field List > Methods > count_isomorphisms_vf2: Description: Inherited from GraphBase:Determines the number of isomorphisms between the graph and another one\nSection_id: Graph",
    "Field List > Methods > count_multiple: Description: Inherited from GraphBase:Counts the multiplicities of the given edges.\nSection_id: Graph",
    "Field List > Methods > count_subisomorphisms_vf2: Description: Inherited from GraphBase:Determines the number of subisomorphisms between the graph and another one\nSection_id: Graph",
    "Field List > Methods > De_Bruijn: Description: Inherited from GraphBase:Generates a de Bruijn graph with parameters (m, n)\nSection_id: Graph",
    "Field List > Methods > decompose: Description: Inherited from GraphBase:Decomposes the graph into subgraphs.\nSection_id: Graph",
    "Field List > Methods > degree: Description: Inherited from GraphBase:Returns some vertex degrees from the graph.\nSection_id: Graph",
    "Field List > Methods > Degree_Sequence: Description: Inherited from GraphBase:Generates a graph with a given degree sequence.\nSection_id: Graph",
    "Field List > Methods > delete_vertices: Description: Inherited from GraphBase:Deletes vertices and all its edges from the graph.\nSection_id: Graph",
    "Field List > Methods > density: Description: Inherited from GraphBase:Calculates the density of the graph.\nSection_id: Graph",
    "Field List > Methods > dfsiter: Description: Inherited from GraphBase:Constructs a depth first search (DFS) iterator of the graph.\nSection_id: Graph",
    "Field List > Methods > diameter: Description: Inherited from GraphBase:Calculates the diameter of the graph.\nSection_id: Graph",
    "Field List > Methods > difference: Description: Inherited from GraphBase:Subtracts the given graph from the original\nSection_id: Graph",
    "Field List > Methods > distances: Description: Inherited from GraphBase:Calculates shortest path lengths for given vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > diversity: Description: Inherited from GraphBase:Calculates the structural diversity index of the vertices.\nSection_id: Graph",
    "Field List > Methods > dominator: Description: Inherited from GraphBase:Returns the dominator tree from the given root node\nSection_id: Graph",
    "Field List > Methods > eccentricity: Description: Inherited from GraphBase:Calculates the eccentricities of given vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > ecount: Description: Inherited from GraphBase:Counts the number of edges.\nSection_id: Graph",
    "Field List > Methods > edge_attributes: Description: Inherited from GraphBase:No summary\nSection_id: Graph",
    "Field List > Methods > edge_betweenness: Description: Inherited from GraphBase:Calculates or estimates the edge betweennesses in a graph.\nSection_id: Graph",
    "Field List > Methods > edge_connectivity: Description: Inherited from GraphBase:Calculates the edge connectivity of the graph or between some vertices.\nSection_id: Graph",
    "Field List > Methods > eigen_adjacency: Description: Inherited from GraphBase:Undocumented\nSection_id: Graph",
    "Field List > Methods > eigenvector_centrality: Description: Inherited from GraphBase:Calculates the eigenvector centralities of the vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > Erdos_Renyi: Description: Inherited from GraphBase:Generates a graph based on the Erdős-Rényi model.\nSection_id: Graph",
    "Field List > Methods > Establishment: Description: Inherited from GraphBase:Generates a graph based on a simple growing model with vertex types.\nSection_id: Graph",
    "Field List > Methods > Famous: Description: Inherited from GraphBase:Generates a famous graph based on its name.\nSection_id: Graph",
    "Field List > Methods > farthest_points: Description: Inherited from GraphBase:Returns two vertex IDs whose distance equals the actual diameter of the graph.\nSection_id: Graph",
    "Field List > Methods > feedback_arc_set: Description: Inherited from GraphBase:Calculates an approximately or exactly minimal feedback arc set.\nSection_id: Graph",
    "Field List > Methods > Forest_Fire: Description: Inherited from GraphBase:Generates a graph based on the forest fire model\nSection_id: Graph",
    "Field List > Methods > Full: Description: Inherited from GraphBase:Generates a full graph (directed or undirected, with or without loops).\nSection_id: Graph",
    "Field List > Methods > Full_Citation: Description: Inherited from GraphBase:Generates a full citation graph\nSection_id: Graph",
    "Field List > Methods > fundamental_cycles: Description: Inherited from GraphBase:Finds a single fundamental cycle basis of the graph\nSection_id: Graph",
    "Field List > Methods > get_all_shortest_paths: Description: Inherited from GraphBase:Calculates all of the shortest paths from/to a given node in a graph.\nSection_id: Graph",
    "Field List > Methods > get_diameter: Description: Inherited from GraphBase:Returns a path with the actual diameter of the graph.\nSection_id: Graph",
    "Field List > Methods > get_edgelist: Description: Inherited from GraphBase:Returns the edge list of a graph.\nSection_id: Graph",
    "Field List > Methods > get_eid: Description: Inherited from GraphBase:Returns the edge ID of an arbitrary edge between vertices v1 and v2\nSection_id: Graph",
    "Field List > Methods > get_eids: Description: Inherited from GraphBase:Returns the edge IDs of some edges between some vertices.\nSection_id: Graph",
    "Field List > Methods > get_isomorphisms_vf2: Description: Inherited from GraphBase:Returns all isomorphisms between the graph and another one\nSection_id: Graph",
    "Field List > Methods > get_k_shortest_paths: Description: Inherited from GraphBase:Calculates the k shortest paths from/to a given node in a graph.\nSection_id: Graph",
    "Field List > Methods > get_shortest_path: Description: Inherited from GraphBase:Calculates the shortest path from a source vertex to a target vertex in a graph.\nSection_id: Graph",
    "Field List > Methods > get_shortest_path_astar: Description: Inherited from GraphBase:Calculates the shortest path from a source vertex to a target vertex in a graph using the A-Star algorithm and a heuristic function.\nSection_id: Graph",
    "Field List > Methods > get_shortest_paths: Description: Inherited from GraphBase:Calculates the shortest paths from/to a given node in a graph.\nSection_id: Graph",
    "Field List > Methods > get_subisomorphisms_lad: Description: Inherited from GraphBase:Returns all subisomorphisms between the graph and another one using the LAD algorithm.\nSection_id: Graph",
    "Field List > Methods > get_subisomorphisms_vf2: Description: Inherited from GraphBase:Returns all subisomorphisms between the graph and another one\nSection_id: Graph",
    "Field List > Methods > girth: Description: Inherited from GraphBase:Returns the girth of the graph.\nSection_id: Graph",
    "Field List > Methods > Growing_Random: Description: Inherited from GraphBase:Generates a growing random graph.\nSection_id: Graph",
    "Field List > Methods > harmonic_centrality: Description: Inherited from GraphBase:Calculates the harmonic centralities of given vertices in a graph.\nSection_id: Graph",
    "Field List > Methods > has_multiple: Description: Inherited from GraphBase:Checks whether the graph has multiple edges.\nSection_id: Graph",
    "Field List > Methods > Hexagonal_Lattice: Description: Inherited from GraphBase:Generates a regular hexagonal lattice.\nSection_id: Graph",
    "Field List > Methods > hub_score: Description: Inherited from GraphBase:Calculates Kleinberg's hub score for the vertices of the graph\nSection_id: Graph",
    "Field List > Methods > incident: Description: Inherited from GraphBase:Returns the edges a given vertex is incident on.\nSection_id: Graph",
    "Field List > Methods > independence_number: Description: Inherited from GraphBase:Returns the independence number of the graph.\nSection_id: Graph",
    "Field List > Methods > independent_vertex_sets: Description: Inherited from GraphBase:Returns some or all independent vertex sets of the graph as a list of tuples.\nSection_id: Graph",
    "Field List > Methods > induced_subgraph: Description: Inherited from GraphBase:Returns a subgraph spanned by the given vertices.\nSection_id: Graph",
    "Field List > Methods > is_acyclic: Description: Inherited from GraphBase:Returns whether the graph is acyclic (i.e. contains no cycles).\nSection_id: Graph",
    "Field List > Methods > is_biconnected: Description: Inherited from GraphBase:Decides whether the graph is biconnected.\nSection_id: Graph",
    "Field List > Methods > is_bipartite: Description: Inherited from GraphBase:Decides whether the graph is bipartite or not.\nSection_id: Graph",
    "Field List > Methods > is_chordal: Description: Inherited from GraphBase:Returns whether the graph is chordal or not.\nSection_id: Graph",
    "Field List > Methods > is_connected: Description: Inherited from GraphBase:Decides whether the graph is connected.\nSection_id: Graph",
    "Field List > Methods > is_dag: Description: Inherited from GraphBase:Checks whether the graph is a DAG (directed acyclic graph).\nSection_id: Graph",
    "Field List > Methods > is_directed: Description: Inherited from GraphBase:Checks whether the graph is directed.\nSection_id: Graph",
    "Field List > Methods > is_loop: Description: Inherited from GraphBase:Checks whether a specific set of edges contain loop edges\nSection_id: Graph",
    "Field List > Methods > is_minimal_separator: Description: Inherited from GraphBase:Decides whether the given vertex set is a minimal separator.\nSection_id: Graph",
    "Field List > Methods > is_multiple: Description: Inherited from GraphBase:Checks whether an edge is a multiple edge.\nSection_id: Graph",
    "Field List > Methods > is_mutual: Description: Inherited from GraphBase:Checks whether an edge has an opposite pair.\nSection_id: Graph",
    "Field List > Methods > is_separator: Description: Inherited from GraphBase:Decides whether the removal of the given vertices disconnects the graph.\nSection_id: Graph",
    "Field List > Methods > is_simple: Description: Inherited from GraphBase:Checks whether the graph is simple (no loop or multiple edges).\nSection_id: Graph",
    "Field List > Methods > is_tree: Description: Inherited from GraphBase:Checks whether the graph is a (directed or undirected) tree graph.\nSection_id: Graph",
    "Field List > Methods > Isoclass: Description: Inherited from GraphBase:Generates a graph with a given isomorphism class.\nSection_id: Graph",
    "Field List > Methods > isoclass: Description: Inherited from GraphBase:Returns the isomorphism class of the graph or its subgraph.\nSection_id: Graph",
    "Field List > Methods > isomorphic: Description: Inherited from GraphBase:Checks whether the graph is isomorphic to another graph.\nSection_id: Graph",
    "Field List > Methods > isomorphic_bliss: Description: Inherited from GraphBase:Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.\nSection_id: Graph",
    "Field List > Methods > isomorphic_vf2: Description: Inherited from GraphBase:Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.\nSection_id: Graph",
    "Field List > Methods > K_Regular: Description: Inherited from GraphBase:Generates a k-regular random graph\nSection_id: Graph",
    "Field List > Methods > Kautz: Description: Inherited from GraphBase:Generates a Kautz graph with parameters (m, n)\nSection_id: Graph",
    "Field List > Methods > knn: Description: Inherited from GraphBase:Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.\nSection_id: Graph",
    "Field List > Methods > laplacian: Description: Inherited from GraphBase:Returns the Laplacian matrix of a graph.\nSection_id: Graph",
    "Field List > Methods > largest_cliques: Description: Inherited from GraphBase:Returns the largest cliques of the graph as a list of tuples.\nSection_id: Graph",
    "Field List > Methods > largest_independent_vertex_sets: Description: Inherited from GraphBase:Returns the largest independent vertex sets of the graph as a list of tuples.\nSection_id: Graph",
    "Field List > Methods > Lattice: Description: Inherited from GraphBase:Generates a regular square lattice.\nSection_id: Graph",
    "Field List > Methods > layout_bipartite: Description: Inherited from GraphBase:Place the vertices of a bipartite graph in two layers.\nSection_id: Graph",
    "Field List > Methods > layout_circle: Description: Inherited from GraphBase:Places the vertices of the graph uniformly on a circle or a sphere.\nSection_id: Graph",
    "Field List > Methods > layout_davidson_harel: Description: Inherited from GraphBase:Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.\nSection_id: Graph",
    "Field List > Methods > layout_drl: Description: Inherited from GraphBase:Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.\nSection_id: Graph",
    "Field List > Methods > layout_fruchterman_reingold: Description: Inherited from GraphBase:Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.\nSection_id: Graph",
    "Field List > Methods > layout_graphopt: Description: Inherited from GraphBase:This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.\nSection_id: Graph",
    "Field List > Methods > layout_grid: Description: Inherited from GraphBase:Places the vertices of a graph in a 2D or 3D grid.\nSection_id: Graph",
    "Field List > Methods > layout_kamada_kawai: Description: Inherited from GraphBase:Places the vertices on a plane according to the Kamada-Kawai algorithm.\nSection_id: Graph",
    "Field List > Methods > layout_lgl: Description: Inherited from GraphBase:Places the vertices on a 2D plane according to the Large Graph Layout.\nSection_id: Graph",
    "Field List > Methods > layout_mds: Description: Inherited from GraphBase:Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.\nSection_id: Graph",
    "Field List > Methods > layout_random: Description: Inherited from GraphBase:Places the vertices of the graph randomly.\nSection_id: Graph",
    "Field List > Methods > layout_reingold_tilford: Description: Inherited from GraphBase:Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.\nSection_id: Graph",
    "Field List > Methods > layout_reingold_tilford_circular: Description: Inherited from GraphBase:Circular Reingold-Tilford layout for trees.\nSection_id: Graph",
    "Field List > Methods > layout_star: Description: Inherited from GraphBase:Calculates a star-like layout for the graph.\nSection_id: Graph",
    "Field List > Methods > layout_umap: Description: Inherited from GraphBase:Uniform Manifold Approximation and Projection (UMAP).\nSection_id: Graph",
    "Field List > Methods > LCF: Description: Inherited from GraphBase:Generates a graph from LCF notation.\nSection_id: Graph",
    "Field List > Methods > linegraph: Description: Inherited from GraphBase:Returns the line graph of the graph.\nSection_id: Graph",
    "Field List > Methods > list_triangles: Description: Inherited from GraphBase:Lists the triangles of the graph\nSection_id: Graph",
    "Field List > Methods > maxdegree: Description: Inherited from GraphBase:Returns the maximum degree of a vertex set in the graph.\nSection_id: Graph",
    "Field List > Methods > maxflow_value: Description: Inherited from GraphBase:Returns the value of the maximum flow between the source and target vertices.\nSection_id: Graph",
    "Field List > Methods > maximal_cliques: Description: Inherited from GraphBase:Returns the maximal cliques of the graph as a list of tuples.\nSection_id: Graph",
    "Field List > Methods > maximal_independent_vertex_sets: Description: Inherited from GraphBase:Returns the maximal independent vertex sets of the graph as a list of tuples.\nSection_id: Graph",
    "Field List > Methods > maximum_cardinality_search: Description: Inherited from GraphBase:Conducts a maximum cardinality search on the graph. The function computes a rank alpha for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.\nSection_id: Graph",
    "Field List > Methods > mincut_value: Description: Inherited from GraphBase:Returns the minimum cut between the source and target vertices or within the whole graph.\nSection_id: Graph",
    "Field List > Methods > minimum_cycle_basis: Description: Inherited from GraphBase:Computes a minimum cycle basis of the graph\nSection_id: Graph",
    "Field List > Methods > minimum_size_separators: Description: Inherited from GraphBase:Returns a list containing all separator vertex sets of minimum size.\nSection_id: Graph",
    "Field List > Methods > modularity_matrix: Description: Inherited from GraphBase:Calculates the modularity matrix of the graph.\nSection_id: Graph",
    "Field List > Methods > motifs_randesu: Description: Inherited from GraphBase:Counts the number of motifs in the graph\nSection_id: Graph",
    "Field List > Methods > motifs_randesu_estimate: Description: Inherited from GraphBase:Counts the total number of motifs in the graph\nSection_id: Graph",
    "Field List > Methods > motifs_randesu_no: Description: Inherited from GraphBase:Counts the total number of motifs in the graph\nSection_id: Graph",
    "Field List > Methods > neighborhood: Description: Inherited from GraphBase:For each vertex specified by vertices, returns the vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.\nSection_id: Graph",
    "Field List > Methods > neighborhood_size: Description: Inherited from GraphBase:For each vertex specified by vertices, returns the number of vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist...\nSection_id: Graph",
    "Field List > Methods > neighbors: Description: Inherited from GraphBase:Returns adjacent vertices to a given vertex.\nSection_id: Graph",
    "Field List > Methods > permute_vertices: Description: Inherited from GraphBase:Permutes the vertices of the graph according to the given permutation and returns the new graph.\nSection_id: Graph",
    "Field List > Methods > personalized_pagerank: Description: Inherited from GraphBase:Calculates the personalized PageRank values of a graph.\nSection_id: Graph",
    "Field List > Methods > predecessors: Description: Inherited from GraphBase:Returns the predecessors of a given vertex.\nSection_id: Graph",
    "Field List > Methods > Preference: Description: Inherited from GraphBase:Generates a graph based on vertex types and connection probabilities.\nSection_id: Graph",
    "Field List > Methods > Prufer: Description: Inherited from GraphBase:Generates a tree from its Prüfer sequence.\nSection_id: Graph",
    "Field List > Methods > radius: Description: Inherited from GraphBase:Calculates the radius of the graph.\nSection_id: Graph",
    "Field List > Methods > random_walk: Description: Inherited from GraphBase:Performs a random walk of a given length from a given node.\nSection_id: Graph",
    "Field List > Methods > Read_DL: Description: Inherited from GraphBase:Reads an UCINET DL file and creates a graph based on it.\nSection_id: Graph",
    "Field List > Methods > Read_Edgelist: Description: Inherited from GraphBase:Reads an edge list from a file and creates a graph based on it.\nSection_id: Graph",
    "Field List > Methods > Read_GML: Description: Inherited from GraphBase:Reads a GML file and creates a graph based on it.\nSection_id: Graph",
    "Field List > Methods > Read_GraphDB: Description: Inherited from GraphBase:Reads a GraphDB format file and creates a graph based on it.\nSection_id: Graph",
    "Field List > Methods > Read_GraphML: Description: Inherited from GraphBase:Reads a GraphML format file and creates a graph based on it.\nSection_id: Graph",
    "Field List > Methods > Read_Lgl: Description: Inherited from GraphBase:Reads an .lgl file used by LGL.\nSection_id: Graph",
    "Field List > Methods > Read_Ncol: Description: Inherited from GraphBase:Reads an .ncol file used by LGL.\nSection_id: Graph",
    "Field List > Methods > Read_Pajek: Description: Inherited from GraphBase:Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj).\nSection_id: Graph",
    "Field List > Methods > Realize_Bipartite_Degree_Sequence: Description: Inherited from GraphBase:Generates a bipartite graph from the degree sequences of its partitions.\nSection_id: Graph",
    "Field List > Methods > Realize_Degree_Sequence: Description: Inherited from GraphBase:Generates a graph from a degree sequence.\nSection_id: Graph",
    "Field List > Methods > Recent_Degree: Description: Inherited from GraphBase:Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.\nSection_id: Graph",
    "Field List > Methods > reciprocity: Description: Inherited from GraphBase:Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph...\nSection_id: Graph",
    "Field List > Methods > reverse_edges: Description: Inherited from GraphBase:Reverses the direction of some edges in the graph.\nSection_id: Graph",
    "Field List > Methods > rewire: Description: Inherited from GraphBase:Randomly rewires the graph while preserving the degree distribution.\nSection_id: Graph",
    "Field List > Methods > rewire_edges: Description: Inherited from GraphBase:Rewires the edges of a graph with constant probability.\nSection_id: Graph",
    "Field List > Methods > Ring: Description: Inherited from GraphBase:Generates a ring graph.\nSection_id: Graph",
    "Field List > Methods > SBM: Description: Inherited from GraphBase:Generates a graph based on a stochastic block model.\nSection_id: Graph",
    "Field List > Methods > similarity_dice: Description: Inherited from GraphBase:Dice similarity coefficient of vertices.\nSection_id: Graph",
    "Field List > Methods > similarity_inverse_log_weighted: Description: Inherited from GraphBase:Inverse log-weighted similarity coefficient of vertices.\nSection_id: Graph",
    "Field List > Methods > similarity_jaccard: Description: Inherited from GraphBase:Jaccard similarity coefficient of vertices.\nSection_id: Graph",
    "Field List > Methods > simplify: Description: Inherited from GraphBase:Simplifies a graph by removing self-loops and/or multiple edges.\nSection_id: Graph",
    "Field List > Methods > Star: Description: Inherited from GraphBase:Generates a star graph.\nSection_id: Graph",
    "Field List > Methods > Static_Fitness: Description: Inherited from GraphBase:Generates a non-growing graph with edge probabilities proportional to node fitnesses.\nSection_id: Graph",
    "Field List > Methods > Static_Power_Law: Description: Inherited from GraphBase:Generates a non-growing graph with prescribed power-law degree distributions.\nSection_id: Graph",
    "Field List > Methods > strength: Description: Inherited from GraphBase:Returns the strength (weighted degree) of some vertices from the graph\nSection_id: Graph",
    "Field List > Methods > subcomponent: Description: Inherited from GraphBase:Determines the indices of vertices which are in the same component as a given vertex.\nSection_id: Graph",
    "Field List > Methods > subgraph_edges: Description: Inherited from GraphBase:Returns a subgraph spanned by the given edges.\nSection_id: Graph",
    "Field List > Methods > subisomorphic_lad: Description: Inherited from GraphBase:Checks whether a subgraph of the graph is isomorphic to another graph.\nSection_id: Graph",
    "Field List > Methods > subisomorphic_vf2: Description: Inherited from GraphBase:Checks whether a subgraph of the graph is isomorphic to another graph.\nSection_id: Graph",
    "Field List > Methods > successors: Description: Inherited from GraphBase:Returns the successors of a given vertex.\nSection_id: Graph",
    "Field List > Methods > to_directed: Description: Inherited from GraphBase:Converts an undirected graph to directed.\nSection_id: Graph",
    "Field List > Methods > to_prufer: Description: Inherited from GraphBase:Converts a tree graph into a Prüfer sequence.\nSection_id: Graph",
    "Field List > Methods > to_undirected: Description: Inherited from GraphBase:Converts a directed graph to undirected.\nSection_id: Graph",
    "Field List > Methods > topological_sorting: Description: Inherited from GraphBase:Calculates a possible topological sorting of the graph.\nSection_id: Graph",
    "Field List > Methods > transitivity_local_undirected: Description: Inherited from GraphBase:Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.\nSection_id: Graph",
    "Field List > Methods > transitivity_undirected: Description: Inherited from GraphBase:Calculates the global transitivity (clustering coefficient) of the graph.\nSection_id: Graph",
    "Field List > Methods > Tree: Description: Inherited from GraphBase:Generates a tree in which almost all vertices have the same number of children.\nSection_id: Graph",
    "Field List > Methods > Tree_Game: Description: Inherited from GraphBase:Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.\nSection_id: Graph",
    "Field List > Methods > Triangular_Lattice: Description: Inherited from GraphBase:Generates a regular triangular lattice.\nSection_id: Graph",
    "Field List > Methods > unfold_tree: Description: Inherited from GraphBase:Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.\nSection_id: Graph",
    "Field List > Methods > vcount: Description: Inherited from GraphBase:Counts the number of vertices.\nSection_id: Graph",
    "Field List > Methods > vertex_attributes: Description: Inherited from GraphBase:No summary\nSection_id: Graph",
    "Field List > Methods > vertex_coloring_greedy: Description: Inherited from GraphBase:Calculates a greedy vertex coloring for the graph based on some heuristics.\nSection_id: Graph",
    "Field List > Methods > vertex_connectivity: Description: Inherited from GraphBase:Calculates the vertex connectivity of the graph or between some vertices.\nSection_id: Graph",
    "Field List > Methods > Watts_Strogatz: Description: Inherited from GraphBase:This function generates networks with the small-world property based on a variant of the Watts-Strogatz model. The network is obtained by first creating a periodic undirected lattice, then rewiring both endpoints of each edge with probability ...\nSection_id: Graph",
    "Field List > Methods > write_dot: Description: Inherited from GraphBase:Writes the graph in DOT format to the given file.\nSection_id: Graph",
    "Field List > Methods > write_edgelist: Description: Inherited from GraphBase:Writes the edge list of a graph to a file.\nSection_id: Graph",
    "Field List > Methods > write_gml: Description: Inherited from GraphBase:Writes the graph in GML format to the given file.\nSection_id: Graph",
    "Field List > Methods > write_graphml: Description: Inherited from GraphBase:Writes the graph to a GraphML file.\nSection_id: Graph",
    "Field List > Methods > write_leda: Description: Inherited from GraphBase:Writes the graph to a file in LEDA native format.\nSection_id: Graph",
    "Field List > Methods > write_lgl: Description: Inherited from GraphBase:Writes the edge list of a graph to a file in .lgl format.\nSection_id: Graph",
    "Field List > Methods > write_ncol: Description: Inherited from GraphBase:Writes the edge list of a graph to a file in .ncol format.\nSection_id: Graph",
    "Field List > Methods > write_pajek: Description: Inherited from GraphBase:Writes the graph in Pajek format to the given file.\nSection_id: Graph",
    "Field List > Methods > draw_directed_edge: Description: overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are defined by the attributes of this object.\ndest_vertex: the source vertex. Visual properties are defined by the attributes of this object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoArrowEdgeDrawer",
    "Field List > Methods > __init__: Description: Inherited from AbstractCairoEdgeDrawer:Constructs the edge drawer.\nSection_id: CairoArrowEdgeDrawer",
    "Field List > Methods > draw_loop_edge: Description: Inherited from AbstractCairoEdgeDrawer:Draws a loop edge.\nSection_id: CairoArrowEdgeDrawer",
    "Field List > Methods > draw_undirected_edge: Description: Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge.\nSection_id: CairoArrowEdgeDrawer",
    "Field List > Methods > __init__: Description: overrides igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given Cairo context and the given BoundingBox.\nParamters: context: the  on which we will draw\nbbox: the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).\npalette: the  that can be used to map integer color indices to colors when drawing vertices\nlayout: the  of the vertices in the graph being drawn\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoVertexDrawer",
    "Field List > Methods > draw: Description: overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nDraws the given vertex.\nParamters: visual_vertex: object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.\nvertex: the raw igraph  being drawn\ncoords: the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: CairoVertexDrawer",
    "Field List > Methods > __init__: Description: Initializes the matching.\nParamters: graph: the  the matching belongs to\nmatching: a numeric vector where element i corresponds to vertex i of the graph. Element i is -1 or if the corresponding vertex is unmatched, otherwise it contains the index of the vertex to which vertex i is matched.\ntypes: the  of the vertices if the graph is bipartite. It must either be the name of a vertex attribute (which will be retrieved for all vertices) or a list. Elements in the list will be converted to boolean values True or False, and this will determine which part of the bipartite graph a given vertex belongs to.\nReturn: []\nReferences: []\nRasises: ValueError: if the matching vector supplied does not describe a valid matching of the graph.\nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > __len__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > __repr__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > __str__: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > edges: Description: Returns an edge sequence that contains the edges in the matching.\nIf there are multiple edges between a pair of matched vertices, only one of them will be returned.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > is_matched: Description: Returns whether the given vertex is matched to another one.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > is_maximal: Description: Returns whether the matching is maximal.\nA matching is maximal when it is not possible to extend it any more with extra edges; in other words, unmatched vertices in the graph must be adjacent to matched vertices only.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > match_of: Description: Returns the vertex a given vertex is matched to.\nParamters: vertex: the  we are interested in; either an integer index or an instance of Vertex.\nReturn: [the index of the vertex matched to the given vertex, either as an integer index (if vertex was integer) or as an instance of Vertex. When the vertex is unmatched, returns None.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > matching: Description: Sets the matching vector.\nParamters: value: the matching vector which must contain the ID of the vertex matching vertex i at the ith position, or -1 if the vertex is unmatched.\nReturn: []\nReferences: []\nRasises: ValueError: if the matching vector supplied does not describe a valid matching of the graph.\nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > types: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Matching",
    "Field List > Methods > __init__: Description: Constructs the edge drawer.\nParamters: context: a Matplotlib axes object on which the edges will be drawn.\npalette: the  that can be used to map integer color indices to colors when drawing edges\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibEdgeDrawer",
    "Field List > Methods > build_patch: Description: Undocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibEdgeDrawer",
    "Field List > Methods > draw_directed_edge: Description: overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are defined by the attributes of this object.\ndest_vertex: the source vertex. Visual properties are defined by the attributes of this object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibEdgeDrawer",
    "Field List > Methods > draw_undirected_edge: Description: overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nParamters: edge: the  to be drawn. Visual properties of the  are defined by the attributes of this object.\nsrc_vertex: the source vertex. Visual properties are defined by the attributes of this object.\ndest_vertex: the source vertex. Visual properties are defined by the attributes of this object.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: MatplotlibEdgeDrawer",
    "Field List > Methods > get_label_position: Description: Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.\nSection_id: MatplotlibEdgeDrawer",
    "Field List > Methods > get_label_rotation: Description: Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge.\nSection_id: MatplotlibEdgeDrawer",
    "Field List > Methods > __call__: Description: overrides igraph.app.shell.Shell.__call__\nStarts the embedded shell.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ClassicPythonShell",
    "Field List > Methods > __init__: Description: overrides igraph.app.shell.ConsoleProgressBarMixin.__init__\nConstructor.\nImports Python's classic shell\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: ClassicPythonShell",
    "Field List > Methods > get_progress_handler: Description: Inherited from Shell:Returns the progress handler (if exists) or None (if not).\nSection_id: ClassicPythonShell",
    "Field List > Methods > get_status_handler: Description: Inherited from Shell:Returns the status handler (if exists) or None (if not).\nSection_id: ClassicPythonShell",
    "Field List > Methods > supports_progress_bar: Description: Inherited from Shell:Checks whether the shell supports progress bars.\nSection_id: ClassicPythonShell",
    "Field List > Methods > supports_status_messages: Description: Inherited from Shell:Checks whether the shell supports status messages.\nSection_id: ClassicPythonShell",
    "Field List > Methods > __getitem__: Description: Returns the members of the specified cluster.\nParamters: idx: the index of the cluster\nReturn: [the members of the specified cluster as a list]\nReferences: []\nRasises: IndexError: if the index is out of bounds\nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > __init__: Description: overridden in igraph.VertexClustering\nConstructor.\nParamters: membership: the  list -- that is, the cluster index in which each element of the set belongs to.\nparams: additional parameters to be stored in this object's dictionary.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > __iter__: Description: Iterates over the clusters in this clustering.\nThis method will return a generator that generates the clusters one by one.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > __len__: Description: Returns the number of clusters.\nParamters: \nReturn: [the number of clusters]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > __str__: Description: overridden in igraph.Cut\nUndocumented\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > as_cover: Description: overridden in igraph.VertexClustering\nReturns a Cover that contains the same clusters as this clustering.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > compare_to: Description: Compares this clustering to another one using some similarity or distance metric.\nThis is a convenience method that simply calls compare_communities with the two clusterings as arguments. Any extra positional or keyword argument is also forwarded to compare_communities.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > size: Description: Returns the size of a given cluster.\nParamters: idx: the cluster in which we are interested.\nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > size_histogram: Description: Returns the histogram of cluster sizes.\nParamters: bin_width: the bin width of the histogram\nReturn: [a Histogram object]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > sizes: Description: Returns the size of given clusters.\nThe indices are given as positional arguments. If there are no positional arguments, the function will return the sizes of all clusters.\nParamters: \nReturn: []\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Field List > Methods > summary: Description: Returns the summary of the clustering.\nThe summary includes the number of items and clusters, and also the list of members for each of the clusters if the verbosity is nonzero.\nParamters: verbosity: determines whether the cluster members should be printed. Zero  prints the number of items and clusters only.\nwidth: Undocumented\nReturn: [the summary of the clustering as a string.]\nReferences: []\nRasises: \nSee Also: \nexample: []\nSection_id: Clustering",
    "Section_id: RandomNodeSampler\nDescription: An implementation of random node sampling. Nodes are sampled with uniform probability. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: Number of nodes. Default is 100.\nseed: Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes randomly.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: DegreeBasedSampler\nDescription: An implementation of degree based sampling. Nodes are sampled proportional to the degree centrality of nodes. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: Number of nodes. Default is 100.\nseed: Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes proportional to the degree.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: PageRankBasedSampler\nDescription: An implementation of PageRank based sampling. Nodes are sampled proportional to the PageRank score of nodes. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: Number of nodes. Default is 100.\nseed: Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes randomly proportional to the normalized pagerank score.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: RandomEdgeSampler\nDescription: An implementation of random edge sampling. Edges are sampled with the same uniform probability randomly. For details about the algorithm see this paper.\nField List: Parameters: number_of_edges: int - Number of edges. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling edges randomly.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled edges.",
    "Section_id: RandomNodeEdgeSampler\nDescription: An implementation of random node-edge sampling. The algorithm first randomly samples a node. From this node it samples an edge with a neighbor. For details about the algorithm see this paper.\nField List: Parameters: number_of_edges: int - Number of edges. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling edges randomly from randomly sampled nodes.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled edges.",
    "Section_id: HybridNodeEdgeSampler\nDescription: An implementation of hybrid node-edge sampling. The algorithm alternates between two sampling methods. (A) Random uniform edge sampling. (B) The algorithm first randomly samples a node. From this node it samples an edge with a neighbor. For details about the algorithm see this paper.\nField List: Parameters: number_of_edges: int - Number of edges. Default is 100.\nseed: int - Random seed. Default is 42.\np: float - Hybridization probability. Default is 0.8.\nMethods: sample: Description: Sampling edges randomly from randomly sampled nodes or sampling random edges.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled edges.",
    "Section_id: RandomEdgeSamplerWithInduction\nDescription: An implementation of random edge sampling with edge set induction. The algorithm randomly samples edges with a fixed probability. Edges between nodes which are already in the sample are retained with an induction step. For details about the algorithm see this paper.\nField List: Parameters: number_of_edges: int - Number of edges. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling edges randomly with induction.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled edges.",
    "Section_id: GraphReader\nDescription: Class to read benchmark datasets for the sampling task.\nField List: Parameters: dataset: str - Dataset of interest. One of facebook/wikipedia/github/twitch/deezer/lastfm. Default is ‘wikipedia’.\nMethods: get_graph: Description: Getting the graph.\nReturn types: graph: NetworkX graph - Graph of interest.",
    "Section_id: DiffusionSampler\nDescription: An implementation of exploration sampling by a diffusion branching process. A simple diffusion which creates an induced subgraph by an incrementally diffusion. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes with a diffusion process.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: DiffusionTreeSampler\nDescription: An implementation of exploration sampling by a diffusion branching process. A simple diffusion which creates an induced tree by an incrementally diffusion. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes with a diffusion process.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: ForestFireSampler\nDescription: An implementation of forest fire sampling. The procedure is a stochastic snowball sampling method where the expansion is proportional to the burning probability. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of sampled nodes. Default is 100.\np: float - Burning probability. Default is 0.4.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes iteratively with a forest fire sampler.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: SpikyBallSampler\nDescription: An implementation of spiky ball sampling. The procedure is a filtered breadth-first search sampling method where the expansion is is performed over a random subset of neighbors. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of sampled nodes. Default is 100.\nsampling_probability: float - Edge sampling probability. Default is 0.1.\ninitial_nodes_ratio: float - Initial ratio of sampled nodes. Default is 0.1.\nseed: int - Random seed. Default is 42.\nmax_hops: int - Number of hops. Default is 100000.\nmode: str - Sampling procedure, one of: (\"edgeball\", \"hubball\", \"coreball\", \"fireball\", \"firecoreball\"). Default is ‘fireball’.\nmax_visited_nodes_backlog: int - Maximal number of nodes in restart queue. Default is 100.\nrestart_hop_size: int - Mimimal number of nodes to pop from restart queue. Default is 10.\ndistrib_coeff: float - Proposal distribution power coefficient. Default is 1.0.\nMethods: sample: Description: Sampling nodes iteratively with a spiky ball sampler.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: CommonNeighborAwareRandomWalkSampler\nDescription: An implementation of node sampling by common neighbor aware random walks. The random walker is biased to visit neighbors that have a lower number of common neighbors. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes with a single common neighbor aware random walk.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: NonBackTrackingRandomWalkSampler\nDescription: An implementation of node sampling by non back-tracking random walks. The process generates a random walk in which the random walker cannot make steps backwards. This way the tottering behaviour of random walkers can be avoided. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes with a single non back-tracking random walk.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled edges.",
    "Section_id: LoopErasedRandomWalkSampler\nDescription: An implementation of node sampling by loop-erased random walks. The random walkers samples a fixed number of nodes. Only edges that connect so far unconnected nodes to the sampled node set are added to the edge set (cycles are erased). The resulting graph is always an undirected tree. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes with a single loop-erased random walk.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled edges.",
    "Section_id: RandomWalkSampler\nDescription: An implementation of node sampling by random walks. A simple random walker which creates an induced subgraph by walking around. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes with a single random walk.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: RandomWalkWithRestartSampler\nDescription: An implementation of node sampling by random walks with restart. The process is a discrete random walker on nodes which teleports back to the staring node with a fixed probability. This results in a connected subsample from the original input graph. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\np: float - Restart probability. Default is 0.1.\nMethods: sample: Description: Sampling nodes with a single random walk that restarts.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: MetropolisHastingsRandomWalkSampler\nDescription: An implementation of node sampling by Metropolis Hastings random walks. The random walker has a probabilistic acceptance condition for adding new nodes to the sampled node set. This constraint can be parametrized by the rejection constraint exponent. The sampled graph is always connected. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nalpha: float - Rejection constraint exponent. Default is 1.0.\nMethods: sample: Description: Sampling nodes with a Metropolis Hastings single random walk.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled edges.",
    "Section_id: SnowBallSampler\nDescription: An implementation of node sampling by snow ball search. Starting from a source node the algorithm places a fixed number of neighbors in a queue of nodes to explore. The expansion goes on until the target number of sampled vertices is reached. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nk: int - Bound on degree. Default is 50.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling a graph with randomized snow ball sampling.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: CirculatedNeighborsRandomWalkSampler\nDescription: An implementation of circulated neighbor random walk sampling. The process simulates a random walker. Vertices of a neighbourhood are randomly reshuffled after all of them is sampled from the vicinity of a node. This way the walker can escape closely knit communities. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of sampled nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes iteratively with a circulated neighbor random walk sampler.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: BreadthFirstSearchSampler\nDescription: An implementation of node sampling by breadth first search. The starting node is selected randomly and neighbors are added to the queue by shuffling them randomly.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling a graph with randomized breadth first search.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: DepthFirstSearchSampler\nDescription: An implementation of node sampling by depth first search. The starting node is selected randomly and neighbors are added to the last in first out queue by shuffling them randomly.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling a graph with randomized depth first search.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: RandomWalkWithJumpSampler\nDescription: An implementation of node sampling by random walks with jumps. The process is a discrete random walker on nodes which teleports back to a random node with a fixed probability. This might result in a disconnected subsample from the original input graph. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\np: float - Jump (teleport) probability. Default is 0.1.\nMethods: sample: Description: Sampling nodes with a single random walk jumps.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: CommunityStructureExpansionSampler\nDescription: An implementation of community structure preserving expansion sampling. Starting with a random source node the procedure chooses a node which is connected to the already sampled nodes. This node is the one with the largest community expansion score. The extracted subgraph is always connected. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of sampled nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes iteratively with a community structure expansion sampler.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nstart_node: int, optional - The start node.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: FrontierSampler\nDescription: An implementation of frontier sampling. A fixed number of random walkers traverses the graph and the walkers which make a step are selected randomly. The procedure might result in a disconnected graph as the walks might never connect with each other. For details about the algorithm see this paper.\nField List: Parameters: number_of_seeds: int - Number of seed nodes. Default is 10.\nnumber_of_nodes: int - Number of nodes to sample. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes and edges with a frontier sampler.\nArg types: graph: NetworkX graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX graph - The graph of sampled nodes.",
    "Section_id: RandomNodeNeighborSampler\nDescription: An implementation of random node-neighbor sampling. The process uniformly samples a fixed number of nodes first. Later it induces the neighboring nodes as the node set and the edges between all of the nodes. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling nodes randomly.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section_id: ShortestPathSampler\nDescription: An implementation of shortest path sampling. The procedure samples pairs of nodes and chooses a random shortest path between them. Vertices and edges on this shortest path are added to the induces subgraph that is extracted. For details about the algorithm see this paper.\nField List: Parameters: number_of_nodes: int - Number of nodes to sample. Default is 100.\nseed: int - Random seed. Default is 42.\nMethods: sample: Description: Sampling with a shortest path sampler.\nArg types: graph: NetworkX or NetworKit graph - The graph to be sampled from.\nReturn types: new_graph: NetworkX or NetworKit graph - The graph of sampled nodes.",
    "Section ID: freeze\nDescription: [Modify graph to prevent further change by adding or removing\nnodes or edges., Node and edge data can still be modified.]\nField List: Parameters:: G : graph: A NetworkX graph\nMethods: []\nRubrics: Notes: To “unfreeze” a graph you must make a copy by creating a new graph object:\nExamples: G=nx.path_graph(4)\nG=nx.freeze(G)\ntry:\nG.add_edge(4,5)\nexceptnx.NetworkXErroraserr:\nprint(str(err))\n# Frozen graph can't be modified",
    "Section ID: PlanarEmbedding\nDescription: [Represents a planar graph with its planar embedding., The planar embedding is given by a combinatorial embedding ., Neighbor ordering:, In comparison to a usual graph structure, the embedding also stores the\norder of all neighbors for every vertex.\nThe order of the neighbors can be given in clockwise (cw) direction or\ncounterclockwise (ccw) direction. This order is stored as edge attributes\nin the underlying directed graph. For the edge (u, v) the edge attribute\n‘cw’ is set to the neighbor of u that follows immediately after v in\nclockwise direction., In order for a PlanarEmbedding to be valid it must fulfill multiple\nconditions. It is possible to check if these conditions are fulfilled with\nthe method check_structure() .\nThe conditions are:, As long as a PlanarEmbedding is invalid only the following methods should\nbe called:, Even though the graph is a subclass of nx.DiGraph, it can still be used\nfor algorithms that require undirected graphs, because the method is_directed() is overridden. This is possible, because a valid\nPlanarGraph must have edges in both directions., Half edges:, In methods like add_half_edge the term “half-edge” is used, which is\na term that is used in doubly connected edge lists . It is used\nto emphasize that the edge is only in one direction and there exists\nanother half-edge in the opposite direction.\nWhile conventional edges always have two faces (including outer face) next\nto them, it is possible to assign each half-edge exactly one face.\nFor a half-edge (u, v) that is oriented such that u is below v then the\nface that belongs to (u, v) is to the right of this half-edge., Examples, Create an embedding of a star graph (compare nx.star_graph(3) ):, Alternatively the same embedding can also be defined in counterclockwise\norientation. The following results in exactly the same PlanarEmbedding:, After creating a graph, it is possible to validate that the PlanarEmbedding\nobject is correct:]\nField List: Parameters:: incoming_graph_data : input graph (optional, default: None): Data to initialize graph.  If None (default) an empty\ngraph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.\nattr : keyword arguments, optional (default= no attributes): Attributes to add to graph as key=value pairs.\nMethods: []\nRubrics: Examples: G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}",
    "Section ID: triadic_census\nDescription: [Determines the triadic census of a directed graph., The triadic census is a count of how many of the 16 possible types of\ntriads are present in a directed graph. If a list of nodes is passed, then\nonly those triads are taken into account which have elements of nodelist in them.]\nField List: Parameters:: G : digraph: A NetworkX DiGraph\nnodelist : list: List of nodes for which you want to calculate triadic census\nReturns:: census : dict: Dictionary with triad type as keys and number of occurrences as values.\nRaises:: ValueError: Ifnodelistcontains duplicate nodes or nodes not inG.\nIf you want to ignore this you can preprocess withset(nodelist)&G.nodes\nMethods: []\nRubrics: Notes: This algorithm has complexity \\(O(m)\\) where \\(m\\) is the number of edges in\nthe graph. For undirected graphs, the triadic census can be computed by first converting\nthe graph into a directed graph using the G.to_directed() method.\nAfter this conversion, only the triad types 003, 102, 201 and 300 will be\npresent in the undirected scenario.\nReferences: [1]Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\nalgorithm for large sparse networks with small maximum degree,\nUniversity of Ljubljana,http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf\nExamples: G=nx.DiGraph([(1,2),(2,3),(3,1),(3,4),(4,1),(4,2)])\ntriadic_census=nx.triadic_census(G)\nforkey,valueintriadic_census.items():\nprint(f\"{key}: {value}\")\n# 003: 0\n# 012: 0\n# 102: 0\n# 021D: 0\n# 021U: 0\n# 021C: 0\n# 111D: 0\n# 111U: 0\n# 030T: 2\n# 030C: 2\n# 201: 0\n# 120D: 0\n# 120U: 0\n# 120C: 0\n# 210: 0\n# 300: 0",
    "Section ID: maximum_branching\nDescription: [Returns a maximum branching from G.]\nField List: Parameters:: G : (multi)digraph-like: The graph to be searched.\nattr : str: The edge attribute used to in determining optimality.\ndefault : float: The value of the edge attribute used if an edge does not have\nthe attributeattr.\npreserve_attrs : bool: If True, preserve the other attributes of the original graph (that are not\npassed toattr)\npartition : str: The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum.\nReturns:: B : (multi)digraph-like: A maximum branching.\nMethods: []\nRubrics:",
    "Section ID: from_prufer_sequence\nDescription: [Returns the tree corresponding to the given Prüfer sequence., A Prüfer sequence is a list of n - 2 numbers between 0 and n - 1, inclusive. The tree corresponding to a given Prüfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence.]\nField List: Parameters:: sequence : list: A Prüfer sequence, which is a list ofn- 2 integers between\nzero andn- 1, inclusive.\nReturns:: NetworkX graph: The tree corresponding to the given Prüfer sequence.\nRaises:: NetworkXError: If the Prüfer sequence is not valid.\nMethods: []\nRubrics: Notes: There is a bijection from labeled trees to Prüfer sequences. This\nfunction is the inverse of the from_prufer_sequence() function. Sometimes Prüfer sequences use nodes labeled from 1 to n instead\nof from 0 to n - 1. This function requires nodes to be labeled in\nthe latter form. You can use networkx.relabel_nodes() to\nrelabel the nodes of your tree to the appropriate format. This implementation is from [1] and has a running time of \\(O(n)\\) .\nReferences: [1]Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n“An optimal algorithm for Prufer codes.”Journal of Software Engineering and Applications2.02 (2009): 111.\n<https://doi.org/10.4236/jsea.2009.22016>\nExamples: There is a bijection between Prüfer sequences and labeled trees, so\nthis function is the inverse of theto_prufer_sequence()function:\nedges=[(0,3),(1,3),(2,3),(3,4),(4,5)]\ntree=nx.Graph(edges)\nsequence=nx.to_prufer_sequence(tree)\nsequence\n# [3, 3, 3, 4]\ntree2=nx.from_prufer_sequence(sequence)\nlist(tree2.edges())==edges\n# True",
    "Section ID: sets\nDescription: [Returns bipartite node sets of graph G., Raises an exception if the graph is not bipartite or if the input\ngraph is disconnected and thus more than one valid solution exists.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.]\nField List: Parameters:: G : NetworkX graph: \ntop_nodes : container, optional: Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised.\nReturns:: X : set: Nodes from one side of the bipartite graph.\nY : set: Nodes from the other side.\nRaises:: AmbiguousSolution: Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected.\nNetworkXError: Raised if the input graph is not bipartite.\nMethods: []\nRubrics: Examples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nX,Y=bipartite.sets(G)\nlist(X)\n# [0, 2]\nlist(Y)\n# [1, 3]",
    "Section ID: eigenvector_centrality_numpy\nDescription: [Compute the eigenvector centrality for the graph G., Eigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node \\(i\\) is the \\(i\\) -th element of a left eigenvector associated with the eigenvalue \\(\\lambda\\) of maximum modulus that is positive. Such an eigenvector \\(x\\) is\ndefined up to a multiplicative constant by the equation, where \\(A\\) is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to, That is, adding the eigenvector centralities of the predecessors of \\(i\\) one obtains the eigenvector centrality of \\(i\\) multiplied by \\(\\lambda\\) . In the case of undirected graphs, \\(x\\) also solves the familiar\nright-eigenvector equation \\(Ax = \\lambda x\\) ., By virtue of the Perron–Frobenius theorem [1] , if G is strongly\nconnected there is a unique eigenvector \\(x\\) , and all its entries\nare strictly positive., If G is not strongly connected there might be several left\neigenvectors associated with \\(\\lambda\\) , and some of their elements\nmight be zero.]\nField List: Parameters:: G : graph: A networkx graph.\nmax_iter : integer, optional (default=50): Maximum number of Arnoldi update iterations allowed.\ntol : float, optional (default=0): Relative accuracy for eigenvalues (stopping criterion).\nThe default value of 0 implies machine precision.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal. Otherwise holds the\nname of the edge attribute used as weight. In this measure the\nweight is interpreted as the connection strength.\nReturns:: nodes : dictionary: Dictionary of nodes with eigenvector centrality as the value. The\nassociated vector has unit Euclidean norm and the values are\nnonegative.\nRaises:: NetworkXPointlessConcept: If the graph G is the null graph.\nArpackNoConvergence: When the requested convergence is not obtained. The currently\nconverged eigenvalues and eigenvectors can be found as\neigenvalues and eigenvectors attributes of the exception object.\nMethods: []\nRubrics: Notes: Eigenvector centrality was introduced by Landau [2] for chess\ntournaments. It was later rediscovered by Wei [3] and then\npopularized by Kendall [4] in the context of sport ranking. Berge\nintroduced a general definition for graphs based on social connections [5] . Bonacich [6] reintroduced again eigenvector centrality and made\nit popular in link analysis. This function computes the left dominant eigenvector, which corresponds\nto adding the centrality of predecessors: this is the usual approach.\nTo add the centrality of successors first reverse the graph with G.reverse() . This implementation uses the SciPysparseeigenvaluesolver (ARPACK)\nto find the largest eigenvalue/eigenvector pair using Arnoldi iterations [7] .\nReferences: [1]Abraham Berman and Robert J. Plemmons.\n“Nonnegative Matrices in the Mathematical Sciences.”\nClassics in Applied Mathematics. SIAM, 1994.  [2]Edmund Landau.\n“Zur relativen Wertbemessung der Turnierresultate.”\nDeutsches Wochenschach, 11:366–369, 1895.  [3]Teh-Hsing Wei.\n“The Algebraic Foundations of Ranking Theory.”\nPhD thesis, University of Cambridge, 1952.  [4]Maurice G. Kendall.\n“Further contributions to the theory of paired comparisons.”\nBiometrics, 11(1):43–62, 1955.https://www.jstor.org/stable/3001479  [5]Claude Berge\n“Théorie des graphes et ses applications.”\nDunod, Paris, France, 1958.  [6]Phillip Bonacich.\n“Technique for analyzing overlapping memberships.”\nSociological Methodology, 4:176–185, 1972.https://www.jstor.org/stable/270732  [7]Arnoldi iteration::https://en.wikipedia.org/wiki/Arnoldi_iteration\nExamples: G=nx.path_graph(4)\ncentrality=nx.eigenvector_centrality_numpy(G)\nprint([f\"{node} {centrality[node]:0.2f}\"fornodeincentrality])\n# ['0 0.37', '1 0.60', '2 0.60', '3 0.37']",
    "Section ID: algebraic_connectivity\nDescription: [Returns the algebraic connectivity of an undirected graph., The algebraic connectivity of a connected undirected graph is the second\nsmallest eigenvalue of its Laplacian matrix.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nweight : object, optional (default: None): The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.\nnormalized : bool, optional (default: False): Whether the normalized Laplacian matrix is used.\ntol : float, optional (default: 1e-8): Tolerance of relative residual in eigenvalue computation.\nmethod : string, optional (default: ‘tracemin_pcg’): Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), ‘lanczos’ (Lanczos iteration)\nor ‘lobpcg’ (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver‘tracemin_pcg’Preconditioned conjugate gradient method‘tracemin_lu’LU factorization\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: algebraic_connectivity : float: Algebraic connectivity.\nRaises:: NetworkXNotImplemented: If G is directed.\nNetworkXError: If G has less than two nodes.\nMethods: []\nRubrics: Notes: Edge weights are interpreted by their absolute values. For MultiGraph’s,\nweights of parallel edges are summed. Zero-weighted edges are ignored.\nExamples: For undirected graphs algebraic connectivity can tell us if a graph is connected or notGis connected iffalgebraic_connectivity(G)>0:\nG=nx.complete_graph(5)\nnx.algebraic_connectivity(G)>0\n# True\nG.add_node(10)# G is no longer connected\nnx.algebraic_connectivity(G)>0\n# False",
    "Section ID: strongly_connected_components\nDescription: [Generate nodes in strongly connected components of graph.]\nField List: Parameters:: G : NetworkX Graph: A directed graph.\nReturns:: comp : generator of sets: A generator of sets of nodes, one for each strongly connected\ncomponent of G.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: Uses Tarjan’s algorithm[R827335e01166-1]_ with Nuutila’s modifications[R827335e01166-2]_.\nNonrecursive version of algorithm.\nReferences: [1]Depth-first search and linear graph algorithms, R. Tarjan\nSIAM Journal of Computing 1(2):146-160, (1972).  [2]On finding the strongly connected components in a directed graph.\nE. Nuutila and E. Soisalon-Soinen\nInformation Processing Letters 49(1): 9-14, (1994)..\nExamples: Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[len(c)forcinsorted(nx.strongly_connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest component, it’s more efficient to\nuse max instead of sort.\nlargest=max(nx.strongly_connected_components(G),key=len)",
    "Section ID: min_edge_cover\nDescription: [Returns a set of edges which constitutes\nthe minimum edge cover of the graph., The smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered.]\nField List: Parameters:: G : NetworkX graph: An undirected bipartite graph.\nmatching_algorithm : function: A function that returns a maximum cardinality matching in a\ngiven bipartite graph. The function must take one input, the\ngraphG, and return a dictionary mapping each node to its\nmate. If not specified,hopcroft_karp_matching()will be used. Other possibilities includeeppstein_matching(),\nReturns:: set: A set of the edges in a minimum edge cover of the graph, given as\npairs of nodes. It contains both the edges(u,v)and(v,u)for given nodesuandvamong the edges of minimum edge cover.\nMethods: []\nRubrics: Notes: An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.\nA minimum edge cover is an edge covering of smallest cardinality. Due to its implementation, the worst-case running time of this algorithm\nis bounded by the worst-case running time of the function matching_algorithm .",
    "Section ID: adjacency_matrix\nDescription: [Returns adjacency matrix of G.]\nField List: Parameters:: G : graph: A NetworkX graph\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\ndtype : NumPy data-type, optional: The desired data-type for the array.\nIf None, then the NumPy default is used.\nweight : string or None, optional (default=’weight’): The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1.\nReturns:: A : SciPy sparse array: Adjacency matrix representation of G.\nMethods: []\nRubrics: Notes: For directed graphs, entry i,j corresponds to an edge from i to j. If you want a pure Python adjacency matrix representation try\nnetworkx.convert.to_dict_of_dicts which will return a\ndictionary-of-dictionaries format that can be addressed as a\nsparse matrix. For MultiGraph/MultiDiGraph with parallel edges the weights are summed.\nSee to_numpy_array for other options. The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the edge weight attribute\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting SciPy sparse array can be modified as follows:",
    "Section ID: null_graph\nDescription: [Returns the Null graph with no nodes or edges., See empty_graph for the use of create_using.]\nField List: Methods: []\nRubrics:",
    "Section ID: single_source_dijkstra_path_length\nDescription: [Find shortest weighted path lengths in G from a source node., Compute the shortest path length between source and all other\nreachable nodes for a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: Starting node for path\ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: length : dict: Dict keyed by node to shortest path length from source.\nRaises:: NodeNotFound: Ifsourceis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.\nExamples: G=nx.path_graph(5)\nlength=nx.single_source_dijkstra_path_length(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4",
    "Section ID: effective_graph_resistance\nDescription: [Returns the Effective graph resistance of G., Also known as the Kirchhoff index., The effective graph resistance is defined as the sum\nof the resistance distance of every node pair in G [1] ., If weight is not provided, then a weight of 1 is used for all edges., The effective graph resistance of a disconnected graph is infinite.]\nField List: Parameters:: G : NetworkX graph: A graph\nweight : string or None, optional (default=None): The edge data key used to compute the effective graph resistance.\nIf None, then each edge has weight 1.\ninvert_weight : boolean (default=True): Proper calculation of resistance distance requires building the\nLaplacian matrix with the reciprocal of the weight. Not required\nif the weight is already inverted. Weight cannot be zero.\nReturns:: RG : float: The effective graph resistance ofG.\nRaises:: NetworkXNotImplemented: IfGis a directed graph.\nNetworkXError: IfGdoes not contain any nodes.\nMethods: []\nRubrics: Notes: The implementation is based on Theorem 2.2 in [2] . Self-loops are ignored.\nMulti-edges are contracted in one edge with weight equal to the harmonic sum of the weights.\nReferences: [1]Wolfram\n“Kirchhoff Index.”https://mathworld.wolfram.com/KirchhoffIndex.html  [2]W. Ellens, F. M. Spieksma, P. Van Mieghem, A. Jamakovic, R. E. Kooij.\nEffective graph resistance.\nLin. Alg. Appl. 435:2491-2506, 2011.\nExamples: G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nround(nx.effective_graph_resistance(G),10)\n# 10.25",
    "Section ID: is_aperiodic\nDescription: [Returns True if G is aperiodic., A directed graph is aperiodic if there is no integer k > 1 that\ndivides the length of every cycle in the graph.]\nField List: Parameters:: G : NetworkX DiGraph: A directed graph\nReturns:: bool: True if the graph is aperiodic False otherwise\nRaises:: NetworkXError: IfGis not directed\nMethods: []\nRubrics: Notes: This uses the method outlined in [1] , which runs in \\(O(m)\\) time\ngiven \\(m\\) edges in G . Note that a graph is not aperiodic if it is\nacyclic as every integer trivial divides length 0 cycles.\nReferences: [1]Jarvis, J. P.; Shier, D. R. (1996),\n“Graph-theoretic analysis of finite Markov chains,”\nin Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:\nA Multidisciplinary Approach, CRC Press.\nExamples: A graph consisting of one cycle, the length of which is 2. Thereforek=2divides the length of every cycle in the graph and thus the graph\nisnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,1)])\nnx.is_aperiodic(DG)\n# False\nA graph consisting of two cycles: one of length 2 and the other of length 3.\nThe cycle lengths are coprime, so there is no single value of k wherek>1that divides each cycle length and therefore the graph isaperiodic:\nDG=nx.DiGraph([(1,2),(2,3),(3,1),(1,4),(4,1)])\nnx.is_aperiodic(DG)\n# True\nA graph consisting of two cycles: one of length 2 and the other of length 4.\nThe lengths of the cycles share a common factork=2, and therefore\nthe graph isnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,1),(3,4),(4,5),(5,6),(6,3)])\nnx.is_aperiodic(DG)\n# False\nAn acyclic graph, therefore the graph isnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,3)])\nnx.is_aperiodic(DG)\n# False",
    "Section ID: adamic_adar_index\nDescription: [Compute the Adamic-Adar index of all node pairs in ebunch., Adamic-Adar index of u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .\nThis index leads to zero-division for nodes only connected via self-loops.\nIt is intended to be used when no self-loops are present.]\nField List: Parameters:: G : graph: NetworkX undirected graph.\nebunch : iterable of node pairs, optional (default = None): Adamic-Adar index will be computed for each pair of nodes given\nin the iterable. The pairs must be given as 2-tuples (u, v)\nwhere u and v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.\nReturns:: piter : iterator: An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Adamic-Adar index.\nRaises:: NetworkXNotImplemented: IfGis aDiGraph, aMultigraphor aMultiDiGraph.\nNodeNotFound: Ifebunchhas a node that is not inG.\nMethods: []\nRubrics: References: [1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf\nExamples: G=nx.complete_graph(5)\npreds=nx.adamic_adar_index(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 2.16404256\n# (2, 3) -> 2.16404256",
    "Section ID: incremental_closeness_centrality\nDescription: [Incremental closeness centrality for nodes., Compute closeness centrality for nodes using level-based work filtering\nas described in Incremental Algorithms for Closeness Centrality by Sariyuce et al., Level-based work filtering detects unnecessary updates to the closeness\ncentrality and filters them out., —\nFrom “Incremental Algorithms for Closeness Centrality”:, Theorem 1: Let \\(G = (V, E)\\) be a graph and u and v be two vertices in V\nsuch that there is no edge (u, v) in E. Let \\(G' = (V, E \\cup uv)\\) Then \\(cc[s] = cc'[s]\\) if and only if \\(\\left|dG(s, u) - dG(s, v)\\right| \\leq 1\\) ., Where \\(dG(u, v)\\) denotes the length of the shortest path between\ntwo vertices u, v in a graph G, cc[s] is the closeness centrality for a\nvertex s in V, and cc’[s] is the closeness centrality for a\nvertex s in V, with the (u, v) edge added.\n—, We use Theorem 1 to filter out updates when adding or removing an edge.\nWhen adding an edge (u, v), we compute the shortest path lengths from all\nother nodes to u and to v before the node is added. When removing an edge,\nwe compute the shortest path lengths after the edge is removed. Then we\napply Theorem 1 to use previously computed closeness centrality for nodes\nwhere \\(\\left|dG(s, u) - dG(s, v)\\right| \\leq 1\\) . This works only for\nundirected, unweighted graphs; the distance argument is not supported., Closeness centrality [1] of a node u is the reciprocal of the\nsum of the shortest path distances from u to all n-1 other nodes.\nSince the sum of distances depends on the number of nodes in the\ngraph, closeness is normalized by the sum of minimum possible\ndistances n-1 ., where d(v,u) is the shortest-path distance between v and u ,\nand n is the number of nodes in the graph., Notice that higher values of closeness indicate higher centrality.]\nField List: Parameters:: G : graph: A NetworkX graph\nedge : tuple: The modified edge (u, v) in the graph.\nprev_cc : dictionary: The previous closeness centrality for all nodes in the graph.\ninsertion : bool, optional: If True (default) the edge was inserted, otherwise it was deleted from the graph.\nwf_improved : bool, optional (default=True): If True, scale by the fraction of nodes reachable. This gives the\nWasserman and Faust improved formula. For single component graphs\nit is the same as the original formula.\nReturns:: nodes : dictionary: Dictionary of nodes with closeness centrality as the value.\nMethods: []\nRubrics: Notes: The closeness centrality is normalized to (n-1)/(|G|-1) where n is the number of nodes in the connected part of graph\ncontaining the node.  If the graph is not completely connected,\nthis algorithm computes the closeness centrality for each\nconnected part separately.\nReferences: [1]Freeman, L.C., 1979. Centrality in networks: I.\nConceptual clarification.  Social Networks 1, 215–239.https://doi.org/10.1016/0378-8733(78)90021-7  [2]Sariyuce, A.E. ; Kaya, K. ; Saule, E. ; Catalyiirek, U.V. Incremental\nAlgorithms for Closeness Centrality. 2013 IEEE International Conference on Big Datahttp://sariyuce.com/papers/bigdata13.pdf",
    "Section ID: spectral_graph_forge\nDescription: [Returns a random simple graph with spectrum resembling that of G, This algorithm, called Spectral Graph Forge (SGF), computes the\neigenvectors of a given graph adjacency matrix, filters them and\nbuilds a random graph with a similar eigenstructure.\nSGF has been proved to be particularly useful for synthesizing\nrealistic social networks and it can also be used to anonymize\ngraph sensitive data.]\nField List: Parameters:: G : Graph: \nalpha : float: Ratio representing the percentage of eigenvectors of G to consider,\nvalues in [0,1].\ntransformation : string, optional: Represents the intended matrix linear transformation, possible values\nare ‘identity’ and ‘modularity’\nseed : integer, random_state, or None (default): Indicator of numpy random number generation state.\nSeeRandomness.\nReturns:: H : Graph: A graph with a similar eigenvector structure of the input one.\nRaises:: NetworkXError: If transformation has a value different from ‘identity’ or ‘modularity’\nMethods: []\nRubrics: Notes: Spectral Graph Forge (SGF) generates a random simple graph resembling the\nglobal properties of the given one.\nIt leverages the low-rank approximation of the associated adjacency matrix\ndriven by the alpha precision parameter.\nSGF preserves the number of nodes of the input graph and their ordering.\nThis way, nodes of output graphs resemble the properties of the input one\nand attributes can be directly mapped. It considers the graph adjacency matrices which can optionally be\ntransformed to other symmetric real matrices (currently transformation\noptions include identity and modularity ).\nThe modularity transformation, in the sense of Newman’s modularity matrix\nallows the focusing on community structure related properties of the graph. SGF applies a low-rank approximation whose fixed rank is computed from the\nratio alpha of the input graph adjacency matrix dimension.\nThis step performs a filtering on the input eigenvectors similar to the low\npass filtering common in telecommunications. The filtered values (after truncation) are used as input to a Bernoulli\nsampling for constructing a random adjacency matrix.\nReferences: [1]L. Baldesi, C. T. Butts, A. Markopoulou, “Spectral Graph Forge:\nGraph Generation Targeting Modularity”, IEEE Infocom, ‘18.https://arxiv.org/abs/1801.01715  [2]M. Newman, “Networks: an introduction”, Oxford university press,\n2010\nExamples: G=nx.karate_club_graph()\nH=nx.spectral_graph_forge(G,0.3)",
    "Section ID: maybe_regular_expander\nDescription: [Utility for creating a random regular expander., Returns a random \\(d\\) -regular graph on \\(n\\) nodes which is an expander\ngraph with very good probability.]\nField List: Parameters:: n : int: The number of nodes.\nd : int: The degree of each node.\ncreate_using : Graph Instance or Constructor: Indicator of type of graph to return.\nIf a Graph-type instance, then clear and use it.\nIf a constructor, call it to create an empty graph.\nUse the Graph constructor by default.\nmax_tries : int. (default: 100): The number of allowed loops when generating each independent cycle\nseed : (default: None): Seed used to set random number generation state. See :ref`Randomness<randomness>`.\nReturns:: G : graph: The constructed undirected graph.\nRaises:: NetworkXError: If\\(d % 2 != 0\\)as the degree must be even.\nIf\\(n - 1\\)is less than :math:` 2d ` as the graph is complete at most.\nIf max_tries is reached\nMethods: []\nRubrics: Notes: The nodes are numbered from \\(0\\) to \\(n - 1\\) . The graph is generated by taking \\(d / 2\\) random independent cycles. Joel Friedman proved that in this model the resulting\ngraph is an expander with probability \\(1 - O(n^{-\\tau})\\) where \\(\\tau = \\lceil (\\sqrt{d - 1}) / 2 \\rceil - 1\\) . [1]\nReferences: [1]Joel Friedman,\nA Proof of Alon’s Second Eigenvalue Conjecture and Related Problems, 2004https://arxiv.org/abs/cs/0405020\nExamples: G=nx.maybe_regular_expander(n=200,d=6,seed=8020)",
    "Section ID: parse_pajek\nDescription: [Parse Pajek format graph from string or iterable.]\nField List: Parameters:: lines : string or iterable: Data in Pajek format.\nReturns:: G : NetworkX graph:\nMethods: []\nRubrics:",
    "Section ID: core_number\nDescription: [Returns the core number for each node., A k-core is a maximal subgraph that contains nodes of degree k or more., The core number of a node is the largest value k of a k-core containing\nthat node.]\nField List: Parameters:: G : NetworkX graph: An undirected or directed graph\nReturns:: core_number : dictionary: A dictionary keyed by node to the core number.\nRaises:: NetworkXNotImplemented: IfGis a multigraph or contains self loops.\nMethods: []\nRubrics: Notes: For directed graphs the node degree is defined to be the\nin-degree + out-degree.\nReferences: [1]An O(m) Algorithm for Cores Decomposition of Networks\nVladimir Batagelj and Matjaz Zaversnik, 2003.https://arxiv.org/abs/cs.DS/0310049\nExamples: degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nnx.core_number(H)\n# {0: 1, 1: 2, 2: 2, 3: 2, 4: 1, 5: 2, 6: 0}\nG=nx.DiGraph()\nG.add_edges_from([(1,2),(2,1),(2,3),(2,4),(3,4),(4,3)])\nnx.core_number(G)\n# {1: 2, 2: 2, 3: 2, 4: 2}",
    "Section ID: biconnected_components\nDescription: [Returns a generator of sets of nodes, one set for each biconnected\ncomponent of the graph, Biconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph. Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.  The\nremoval of articulation points will increase the number of connected\ncomponents of the graph., Notice that by convention a dyad is considered a biconnected component.]\nField List: Parameters:: G : NetworkX Graph: An undirected graph.\nReturns:: nodes : generator: Generator of sets of nodes, one set for each biconnected component.\nRaises:: NetworkXNotImplemented: If the input graph is not undirected.\nMethods: []\nRubrics: Notes: The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.\nReferences: [1]Hopcroft, J.; Tarjan, R. (1973).\n“Efficient algorithms for graph manipulation”.\nCommunications of the ACM 16: 372–378. doi:10.1145/362248.362272\nExamples: G=nx.lollipop_graph(5,1)\nprint(nx.is_biconnected(G))\n# False\nbicomponents=list(nx.biconnected_components(G))\nlen(bicomponents)\n# 2\nG.add_edge(0,5)\nprint(nx.is_biconnected(G))\n# True\nbicomponents=list(nx.biconnected_components(G))\nlen(bicomponents)\n# 1\nYou can generate a sorted list of biconnected components, largest\nfirst, using sort.\nG.remove_edge(0,5)\n[len(c)forcinsorted(nx.biconnected_components(G),key=len,reverse=True)]\n# [5, 2]\nIf you only want the largest connected component, it’s more\nefficient to use max instead of sort.\nGc=max(nx.biconnected_components(G),key=len)\nTo create the components as subgraphs use:(G.subgraph(c).copy()forcinbiconnected_components(G))",
    "Section ID: directed_edge_swap\nDescription: [Swap three edges in a directed graph while keeping the node degrees fixed., A directed edge swap swaps three edges such that a -> b -> c -> d becomes\na -> c -> b -> d. This pattern of swapping allows all possible states with the\nsame in- and out-degree distribution in a directed graph to be reached., If the swap would create parallel edges (e.g. if a -> c already existed in the\nprevious example), another attempt is made to find a suitable trio of edges.]\nField List: Parameters:: G : DiGraph: A directed graph\nnswap : integer (optional, default=1): Number of three-edge (directed) swaps to perform\nmax_tries : integer (optional, default=100): Maximum number of attempts to swap edges\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : DiGraph: The graph after the edges are swapped.\nRaises:: NetworkXError: IfGis not directed, or\nIf nswap > max_tries, or\nIf there are fewer than 4 nodes or 3 edges inG.\nNetworkXAlgorithmError: If the number of swap attempts exceedsmax_triesbeforenswapswaps are made\nMethods: []\nRubrics: Notes: Does not enforce any connectivity constraints. The graph G is modified in place. A later swap is allowed to undo a previous swap.\nReferences: [1]Erdős, Péter L., et al. “A Simple Havel-Hakimi Type Algorithm to Realize\nGraphical Degree Sequences of Directed Graphs.” ArXiv:0905.4913 [Math],\nJan. 2010. https://doi.org/10.48550/arXiv.0905.4913.\nPublished  2010 in Elec. J. Combinatorics (17(1)). R66.\nhttp://www.combinatorics.org/Volume_17/PDF/v17i1r66.pdf  [2]“Combinatorics - Reaching All Possible Simple Directed Graphs with a given\nDegree Sequence with 2-Edge Swaps.” Mathematics Stack Exchange,https://math.stackexchange.com/questions/22272/. Accessed 30 May 2022.",
    "Section ID: read_adjlist\nDescription: [Read graph in adjacency list format from path.]\nField List: Parameters:: path : string or file: Filename or file handle to read.\nFilenames ending in .gz or .bz2 will be uncompressed.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nnodetype : Python type, optional: Convert nodes to this type.\ncomments : string, optional: Marker for comment lines\ndelimiter : string, optional: Separator for node labels.  The default is whitespace.\nReturns:: G: NetworkX graph: The graph corresponding to the lines in adjacency list format.\nMethods: []\nRubrics: Notes: This format does not store graph or node data.\nExamples: G=nx.path_graph(4)\nnx.write_adjlist(G,\"test.adjlist\")\nG=nx.read_adjlist(\"test.adjlist\")\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in ‘rb’ mode.\nfh=open(\"test.adjlist\",\"rb\")\nG=nx.read_adjlist(fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_adjlist(G,\"test.adjlist.gz\")\nG=nx.read_adjlist(\"test.adjlist.gz\")\nThe optional nodetype is a function to convert node strings to nodetype.\nFor example\nG=nx.read_adjlist(\"test.adjlist\",nodetype=int)\nwill attempt to convert all nodes to integer type.\nSince nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)\nThe optional create_using parameter indicates the type of NetworkX graph\ncreated.  The default isnx.Graph, an undirected graph.\nTo read the data as a directed graph use\nG=nx.read_adjlist(\"test.adjlist\",create_using=nx.DiGraph)",
    "Section ID: generate_edgelist\nDescription: [Generate a single line of the bipartite graph G in edge list format.]\nField List: Parameters:: G : NetworkX graph: The graph is assumed to have node attributepartset to 0,1 representing\nthe two graph parts\ndelimiter : string, optional: Separator for node labels\ndata : bool or list of keys: If False generate no edge data.  If True use a dictionary\nrepresentation of edge data.  If a list of keys use a list of data\nvalues corresponding to the keys.\nReturns:: lines : string: Lines of data in adjlist format.\nMethods: []\nRubrics: Examples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nG[1][2][\"weight\"]=3\nG[2][3][\"capacity\"]=12\nforlineinbipartite.generate_edgelist(G,data=False):\nprint(line)\n# 0 1\n# 2 1\n# 2 3\nforlineinbipartite.generate_edgelist(G):\nprint(line)\n# 0 1 {}\n# 2 1 {'weight': 3}\n# 2 3 {'capacity': 12}\nforlineinbipartite.generate_edgelist(G,data=[\"weight\"]):\nprint(line)\n# 0 1\n# 2 1 3\n# 2 3",
    "Section ID: steiner_tree\nDescription: [Return an approximation to the minimum Steiner tree of a graph., The minimum Steiner tree of G w.r.t a set of terminal_nodes (also S )\nis a tree within G that spans those nodes and has minimum size (sum of\nedge weights) among all such trees., The approximation algorithm is specified with the method keyword\nargument. All three available algorithms produce a tree whose weight is\nwithin a (2-(2/l)) factor of the weight of the optimal Steiner tree,\nwhere l is the minimum number of leaf nodes across all possible Steiner\ntrees.]\nField List: Parameters:: G : NetworkX graph: \nterminal_nodes : list: A list of terminal nodes for which minimum steiner tree is\nto be found.\nweight : string (default = ‘weight’): Use the edge attribute specified by this string as the edge weight.\nAny edge attribute not present defaults to 1.\nmethod : string, optional (default = ‘mehlhorn’): The algorithm to use to approximate the Steiner tree.\nSupported options: ‘kou’, ‘mehlhorn’.\nOther inputs produce a ValueError.\nReturns:: NetworkX graph: Approximation to the minimum steiner tree ofGinduced byterminal_nodes.\nRaises:: NetworkXNotImplemented: IfGis directed.\nValueError: If the specifiedmethodis not supported.\nMethods: []\nRubrics: Notes: For multigraphs, the edge between two nodes with minimum weight is the\nedge put into the Steiner tree.\nReferences: [1]Steiner_tree_problem on Wikipedia.https://en.wikipedia.org/wiki/Steiner_tree_problem  [2]Kou, L., G. Markowsky, and L. Berman. 1981.\n‘A Fast Algorithm for Steiner Trees’.\nActa Informatica 15 (2): 141–45.https://doi.org/10.1007/BF00288961.  [3]Mehlhorn, Kurt. 1988.\n‘A Faster Approximation Algorithm for the Steiner Problem in Graphs’.\nInformation Processing Letters 27 (3): 125–28.https://doi.org/10.1016/0020-0190(88)90066-X.",
    "Section ID: is_k_edge_connected\nDescription: [Tests to see if a graph is k-edge-connected., Is it impossible to disconnect the graph by removing fewer than k edges?\nIf so, then G is k-edge-connected.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nk : integer: edge connectivity to test for\nReturns:: boolean: True if G is k-edge-connected.\nMethods: []\nRubrics: Examples: G=nx.barbell_graph(10,0)\nnx.is_k_edge_connected(G,k=1)\n# True\nnx.is_k_edge_connected(G,k=2)\n# False",
    "Section ID: spectral_bisection\nDescription: [Bisect the graph using the Fiedler vector., This method uses the Fiedler vector to bisect a graph.\nThe partition is defined by the nodes which are associated with\neither positive or negative values in the vector.]\nField List: Parameters:: G : NetworkX Graph: \nweight : str, optional (default: weight): The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.\nnormalized : bool, optional (default: False): Whether the normalized Laplacian matrix is used.\ntol : float, optional (default: 1e-8): Tolerance of relative residual in eigenvalue computation.\nmethod : string, optional (default: ‘tracemin_pcg’): Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), ‘lanczos’ (Lanczos iteration)\nor ‘lobpcg’ (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver‘tracemin_pcg’Preconditioned conjugate gradient method‘tracemin_lu’LU factorization\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: bisection : tuple of sets: Sets with the bisection of nodes\nMethods: []\nRubrics: References: [1]M. E. J Newman ‘Networks: An Introduction’, pages 364-370\nOxford University Press 2011.\nExamples: G=nx.barbell_graph(3,0)\nnx.spectral_bisection(G)\n# ({0, 1, 2}, {3, 4, 5})",
    "Section ID: tree_all_pairs_lowest_common_ancestor\nDescription: [Yield the lowest common ancestor for sets of pairs in a tree.]\nField List: Parameters:: G : NetworkX directed graph (must be a tree): \nroot : node, optional (default: None): The root of the subtree to operate on.\nIf None, assume the entire graph has exactly one source and use that.\npairs : iterable or iterator of pairs of nodes, optional (default: None): The pairs of interest. If None, Defaults to all pairs of nodes\nunderrootthat have a lowest common ancestor.\nReturns:: lcas : generator of tuples((u,v),lca)whereuandvare nodes: inpairsandlcais their lowest common ancestor.\nMethods: []\nRubrics: Notes: Only defined on non-null trees represented with directed edges from\nparents to children. Uses Tarjan’s off-line lowest-common-ancestors\nalgorithm. Runs in time \\(O(4 \\times (V + E + P))\\) time, where 4 is the largest\nvalue of the inverse Ackermann function likely to ever come up in actual\nuse, and \\(P\\) is the number of pairs requested (or \\(V^2\\) if all are needed). Tarjan, R. E. (1979), “Applications of path compression on balanced trees”,\nJournal of the ACM 26 (4): 690-715, doi:10.1145/322154.322161.\nExamples: importpprint\nG=nx.DiGraph([(1,3),(2,4),(1,2)])\npprint.pprint(dict(nx.tree_all_pairs_lowest_common_ancestor(G)))\n# {(1, 1): 1,\n#  (2, 1): 1,\n#  (2, 2): 2,\n#  (3, 1): 1,\n#  (3, 2): 1,\n#  (3, 3): 3,\n#  (3, 4): 1,\n#  (4, 1): 1,\n#  (4, 2): 2,\n#  (4, 4): 4}\nWe can also usepairsargument to specify the pairs of nodes for which we\nwant to compute lowest common ancestors. Here is an example:\ndict(nx.tree_all_pairs_lowest_common_ancestor(G,pairs=[(1,4),(2,3)]))\n# {(2, 3): 1, (1, 4): 1}",
    "Section ID: is_digraphical\nDescription: [Returns True if some directed graph can realize the in- and out-degree\nsequences.]\nField List: Parameters:: in_sequence : list or iterable container: A sequence of integer node in-degrees\nout_sequence : list or iterable container: A sequence of integer node out-degrees\nReturns:: valid : bool: True if in and out-sequences are digraphic False if not.\nMethods: []\nRubrics: Notes: This algorithm is from Kleitman and Wang [1] .\nThe worst case runtime is \\(O(s \\times \\log n)\\) where \\(s\\) and \\(n\\) are the\nsum and length of the sequences respectively.\nReferences: [1]D.J. Kleitman and D.L. Wang\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)\nExamples: G=nx.DiGraph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nin_seq=(dforn,dinG.in_degree())\nout_seq=(dforn,dinG.out_degree())\nnx.is_digraphical(in_seq,out_seq)\n# True\nTo test a non-digraphical scenario:\n>>> in_seq_list = [d for n, d in G.in_degree()]\n>>> in_seq_list[-1] += 1\n>>> nx.is_digraphical(in_seq_list, out_seq)\nFalse",
    "Section ID: panther_similarity\nDescription: [Returns the Panther similarity of nodes in the graph G to node v ., Panther is a similarity metric that says “two objects are considered\nto be similar if they frequently appear on the same paths.” [1] .]\nField List: Parameters:: G : NetworkX graph: A NetworkX graph\nsource : node: Source node for which to find the topksimilar other nodes\nk : int (default = 5): The number of most similar nodes to return.\npath_length : int (default = 5): How long the randomly generated paths should be (Tin[1])\nc : float (default = 0.5): A universal positive constant used to scale the number\nof sample random paths to generate.\ndelta : float (default = 0.1): The probability that the similarity\\(S\\)is not an epsilon-approximation to (R, phi),\nwhere\\(R\\)is the number of random paths and\\(\\phi\\)is the probability\nthat an element sampled from a set\\(A \\subseteq D\\), where\\(D\\)is the domain.\neps : float or None (default = None): The error bound. Per[1], a good value issqrt(1/|E|). Therefore,\nif no value is provided, the recommended computed value will be used.\nweight : string or None, optional (default=”weight”): The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.\nReturns:: similarity : dictionary: Dictionary of nodes to similarity scores (as floats). Note:\nthe self-similarity (i.e.,v) will not be included in\nthe returned dictionary. So, fork=5, a dictionary of\ntop 4 nodes and their similarity scores will be returned.\nRaises:: NetworkXUnfeasible: Ifsourceis an isolated node.\nNodeNotFound: Ifsourceis not inG.\nMethods: []\nRubrics: Notes: The isolated nodes in G are ignored.\nReferences: [1](1,2,3)Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.\nPanther: Fast top-k similarity search on large networks.\nIn Proceedings of the ACM SIGKDD International Conference\non Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445–1454).\nAssociation for Computing Machinery.https://doi.org/10.1145/2783258.2783267.\nExamples: G=nx.star_graph(10)\nsim=nx.panther_similarity(G,0)",
    "Section ID: degree_mixing_matrix\nDescription: [Returns mixing matrix for attribute.]\nField List: Parameters:: G : graph: NetworkX graph object.\nx: string (‘in’,’out’): The degree type for source node (directed graphs only).\ny: string (‘in’,’out’): The degree type for target node (directed graphs only).\nnodes: list or iterable (optional): Build the matrix using only nodes in container.\nThe default is all nodes.\nweight: string or None, optional (default=None): The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.\nnormalized : bool (default=True): Return counts if False or probabilities if True.\nmapping : dictionary, optional: Mapping from node degree to integer index in matrix.\nIf not specified, an arbitrary ordering will be used.\nReturns:: m: numpy array: Counts, or joint probability, of occurrence of node degree.\nMethods: []\nRubrics: Notes: Definitions of degree mixing matrix vary on whether the matrix\nshould include rows for degree values that don’t arise. Here we\ndo not include such empty-rows. But you can force them to appear\nby inputting a mapping that includes those values. See examples.\nExamples: G=nx.star_graph(3)\nmix_mat=nx.degree_mixing_matrix(G)\nmix_mat\n# array([[0. , 0.5],\n#        [0.5, 0. ]])\nIf you want every possible degree to appear as a row, even if no nodes\nhave that degree, usemappingas follows,\nmax_degree=max(degforn,deginG.degree)\nmapping={x:xforxinrange(max_degree+1)}# identity mapping\nmix_mat=nx.degree_mixing_matrix(G,mapping=mapping)\nmix_mat\n# array([[0. , 0. , 0. , 0. ],\n#        [0. , 0. , 0. , 0.5],\n#        [0. , 0. , 0. , 0. ],\n#        [0. , 0.5, 0. , 0. ]])",
    "Section ID: chordless_cycles\nDescription: [Find simple chordless cycles of a graph., A simplecycle is a closed path where no node appears twice.  In a simple\ncycle, a chord is an additional edge between two nodes in the cycle.  A chordlesscycle is a simple cycle without chords.  Said differently, a\nchordless cycle is a cycle C in a graph G where the number of edges in the\ninduced graph G[C] is equal to the length of C ., Note that some care must be taken in the case that G is not a simple graph\nnor a simple digraph.  Some authors limit the definition of chordless cycles\nto have a prescribed minimum length; we do not., In a directed graph, two chordless cycles are distinct if they are not\ncyclic permutations of each other.  In an undirected graph, two chordless\ncycles are distinct if they are not cyclic permutations of each other nor of\nthe other’s reversal., Optionally, the cycles are bounded in length., We use an algorithm strongly inspired by that of Dias et al [1] .  It has\nbeen modified in the following ways:]\nField List: Parameters:: G : NetworkX DiGraph: A directed graph\nlength_bound : int or None, optional (default=None): If length_bound is an int, generate all simple cycles of G with length at\nmost length_bound.  Otherwise, generate all simple cycles of G.\nYields:: list of nodes: Each cycle is represented by a list of nodes along the cycle.\nRaises:: ValueError: when length_bound < 0.\nMethods: []\nRubrics: Notes: When length_bound is None, and the graph is simple, the time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) chordless cycles.\nReferences: [1]Efficient enumeration of chordless cycles\nE. Dias and D. Castonguay and H. Longo and W.A.R. Jradihttps://arxiv.org/abs/1309.1051\nExamples: sorted(list(nx.chordless_cycles(nx.complete_graph(4))))\n# [[1, 0, 2], [1, 0, 3], [2, 0, 3], [2, 1, 3]]",
    "Section ID: bipartite_layout\nDescription: [Position nodes in two straight lines.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\nnodes : list or container: Nodes in one node set of the bipartite graph.\nThis set will be placed on left or top.\nalign : string (default=’vertical’): The alignment of nodes. Vertical or horizontal.\nscale : number (default: 1): Scale factor for positions.\ncenter : array-like or None: Coordinate pair around which to center the layout.\naspect_ratio : number (default=4/3):: The ratio of the width to the height of the layout.\nReturns:: pos : dict: A dictionary of positions keyed by node.\nMethods: []\nRubrics: Notes: This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.\nExamples: G=nx.bipartite.gnmk_random_graph(3,5,10,seed=123)\ntop=nx.bipartite.sets(G)[0]\npos=nx.bipartite_layout(G,top)",
    "Section ID: degree_centrality\nDescription: [Compute the degree centrality for nodes in a bipartite network., The degree centrality for a node v is the fraction of nodes\nconnected to it.]\nField List: Parameters:: G : graph: A bipartite network\nnodes : list or container: Container with all nodes in one bipartite node set.\nReturns:: centrality : dictionary: Dictionary keyed by node with bipartite degree centrality as the value.\nMethods: []\nRubrics: Notes: The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both bipartite node\nsets. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX. For unipartite networks, the degree centrality values are\nnormalized by dividing by the maximum possible degree (which is n-1 where n is the number of nodes in G). In the bipartite case, the maximum possible degree of a node in a\nbipartite node set is the number of nodes in the opposite node set [1] .  The degree centrality for a node v in the bipartite\nsets U with n nodes and V with m nodes is\nReferences: [1]Borgatti, S.P. and Halgin, D. In press. “Analyzing Affiliation\nNetworks”. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28\nExamples: G=nx.wheel_graph(5)\ntop_nodes={0,1,2}\nnx.bipartite.degree_centrality(G,nodes=top_nodes)\n# {0: 2.0, 1: 1.5, 2: 1.5, 3: 1.0, 4: 1.0}",
    "Section ID: bethe_hessian_matrix\nDescription: [Returns the Bethe Hessian matrix of G., The Bethe Hessian is a family of matrices parametrized by r, defined as\nH(r) = (r^2 - 1) I - r A + D where A is the adjacency matrix, D is the\ndiagonal matrix of node degrees, and I is the identify matrix. It is equal\nto the graph laplacian when the regularizer r = 1., The default choice of regularizer should be the ratio [2]]\nField List: Parameters:: G : Graph: A NetworkX graph\nr : float: Regularizer parameter\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced byG.nodes().\nReturns:: H : scipy.sparse.csr_array: The Bethe Hessian matrix ofG, with parameterr.\nMethods: []\nRubrics: References: [1]A. Saade, F. Krzakala and L. Zdeborová\n“Spectral Clustering of Graphs with the Bethe Hessian”,\nAdvances in Neural Information Processing Systems, 2014.  [2]C. M. Le, E. Levina\n“Estimating the number of communities in networks by spectral methods”\narXiv:1507.00827, 2015.\nExamples: k=[3,2,2,1,0]\nG=nx.havel_hakimi_graph(k)\nH=nx.bethe_hessian_matrix(G)\nH.toarray()\n# array([[ 3.5625, -1.25  , -1.25  , -1.25  ,  0.    ],\n#        [-1.25  ,  2.5625, -1.25  ,  0.    ,  0.    ],\n#        [-1.25  , -1.25  ,  2.5625,  0.    ,  0.    ],\n#        [-1.25  ,  0.    ,  0.    ,  1.5625,  0.    ],\n#        [ 0.    ,  0.    ,  0.    ,  0.    ,  0.5625]])",
    "Section ID: complement\nDescription: [Returns the graph complement of G.]\nField List: Parameters:: G : graph: A NetworkX graph\nReturns:: GC : A new graph.:\nMethods: []\nRubrics: Notes: Note that complement does not create self-loops and also\ndoes not produce parallel edges for MultiGraphs. Graph, node, and edge data are not propagated to the new graph.\nExamples: G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nG_complement=nx.complement(G)\nG_complement.edges()# This shows the edges of the complemented graph\n# EdgeView([(1, 4), (1, 5), (2, 4), (2, 5), (4, 5)])",
    "Section ID: projected_graph\nDescription: [Returns the projection of B onto one of its node sets., Returns the graph G that is the projection of the bipartite graph B\nonto the specified nodes. They retain their attributes and are connected\nin G if they have a common neighbor in B.]\nField List: Parameters:: B : NetworkX graph: The input graph should be bipartite.\nnodes : list or iterable: Nodes to project onto (the “bottom” nodes).\nmultigraph: bool (default=False): If True return a multigraph where the multiple edges represent multiple\nshared neighbors.  They edge key in the multigraph is assigned to the\nlabel of the neighbor.\nReturns:: Graph : NetworkX graph or multigraph: A graph that is the projection onto the given nodes.\nMethods: []\nRubrics: Notes: No attempt is made to verify that the input graph B is bipartite.\nReturns a simple graph that is the projection of the bipartite graph B\nonto the set of nodes given in list nodes.  If multigraph=True then\na multigraph is returned with an edge for every shared neighbor. Directed graphs are allowed as input.  The output will also then\nbe a directed graph with edges if there is a directed path between\nthe nodes. The graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nExamples: fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(4)\nG=bipartite.projected_graph(B,[1,3])\nlist(G)\n# [1, 3]\nlist(G.edges())\n# [(1, 3)]\nIf nodesa, andbare connected through both nodes 1 and 2 then\nbuilding a multigraph results in two edges in the projection onto\n[a,b]:\nB=nx.Graph()\nB.add_edges_from([(\"a\",1),(\"b\",1),(\"a\",2),(\"b\",2)])\nG=bipartite.projected_graph(B,[\"a\",\"b\"],multigraph=True)\nprint([sorted((u,v))foru,vinG.edges()])\n# [['a', 'b'], ['a', 'b']]",
    "Section ID: tree_isomorphism\nDescription: [Given two undirected (or free) trees t1 and t2 ,\nthis routine will determine if they are isomorphic.\nIt returns the isomorphism, a mapping of the nodes of t1 onto the nodes\nof t2 , such that two trees are then identical., Note that two trees may have more than one isomorphism, and this\nroutine just returns one valid mapping.]\nField List: Parameters:: t1 : undirected NetworkX graph: One of the trees being compared\nt2 : undirected NetworkX graph: The other tree being compared\nReturns:: isomorphism : list: A list of pairs in which the left element is a node int1and the right element is a node int2.  The pairs are in\narbitrary order.  If the nodes in one tree is mapped to the names in\nthe other, then trees will be identical. Note that an isomorphism\nwill not necessarily be unique.Ift1andt2are not isomorphic, then it returns the empty list.\nMethods: []\nRubrics: Notes: This runs in O(n*log(n)) time for trees with n nodes.",
    "Section ID: optimize_edit_paths\nDescription: [GED (graph edit distance) calculation: advanced interface., Graph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions., Graph edit distance is defined as minimum cost of edit path.]\nField List: Parameters:: G1, G2: graphs: The two graphs G1 and G2 must be of the same type.\nnode_match : callable: A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.\nedge_match : callable: A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.\nnode_subst_cost, node_del_cost, node_ins_cost : callable: Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.\nedge_subst_cost, edge_del_cost, edge_ins_cost : callable: Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.\nupper_bound : numeric: Maximum edit distance to consider.\nstrictly_decreasing : bool: If True, return consecutive approximations of strictly\ndecreasing cost.  Otherwise, return all edit paths of cost\nless than or equal to the previous minimum cost.\nroots : 2-tuple: Tuple where first element is a node in G1 and the second\nis a node in G2.\nThese nodes are forced to be matched in the comparison to\nallow comparison between rooted graphs.\ntimeout : numeric: Maximum number of seconds to execute.\nAfter timeout is met, the current best GED is returned.\nReturns:: Generator of tuples (node_edit_path, edge_edit_path, cost): node_edit_path : list of tuples (u, v)\nedge_edit_path : list of tuples ((u1, v1), (u2, v2))\ncost : numeric\nMethods: []\nRubrics: References: [1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816",
    "Section ID: single_source_dijkstra_path\nDescription: [Find shortest weighted paths in G from a source node., Compute shortest path between source and all other reachable\nnodes for a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path.\ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: paths : dictionary: Dictionary of shortest path lengths keyed by target.\nRaises:: NodeNotFound: Ifsourceis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.\nExamples: G=nx.path_graph(5)\npath=nx.single_source_dijkstra_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]",
    "Section ID: dfs_postorder_nodes\nDescription: [Generate nodes in a depth-first-search post-ordering starting at source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Specify starting node for depth-first search.\ndepth_limit : int, optional (default=len(G)): Specify the maximum search depth.\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: nodes: generator: A generator of nodes in a depth-first-search post-ordering.\nMethods: []\nRubrics: Notes: If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein’s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n“ Depth-limited search ”.\nExamples: G=nx.path_graph(5)\nlist(nx.dfs_postorder_nodes(G,source=0))\n# [4, 3, 2, 1, 0]\nlist(nx.dfs_postorder_nodes(G,source=0,depth_limit=2))\n# [1, 0]",
    "Section ID: tree_broadcast_center\nDescription: [Return the Broadcast Center of the tree G ., The broadcast center of a graph G denotes the set of nodes having\nminimum broadcast time [1] . This is a linear algorithm for determining\nthe broadcast center of a tree with N nodes, as a by-product it also\ndetermines the broadcast time from the broadcast center.]\nField List: Parameters:: G : undirected graph: The graph should be an undirected tree\nReturns:: BC : (int, set) tuple: minimum broadcast number of the tree, set of broadcast centers\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics: References: [1]Slater, P.J., Cockayne, E.J., Hedetniemi, S.T,\nInformation dissemination in trees. SIAM J.Comput. 10(4), 692–701 (1981)",
    "Section ID: mycielski_graph\nDescription: [Generator for the n_th Mycielski Graph., The Mycielski family of graphs is an infinite set of graphs. \\(M_1\\) is the singleton graph, \\(M_2\\) is two vertices with an\nedge, and, for \\(i > 2\\) , \\(M_i\\) is the Mycielskian of \\(M_{i-1}\\) ., More information can be found at http://mathworld.wolfram.com/MycielskiGraph.html]\nField List: Parameters:: n : int: The desired Mycielski Graph.\nReturns:: M : graph: The n_th Mycielski Graph\nMethods: []\nRubrics: Notes: The first graph in the Mycielski sequence is the singleton graph.\nThe Mycielskian of this graph is not the \\(P_2\\) graph, but rather the \\(P_2\\) graph with an extra, isolated vertex. The second Mycielski\ngraph is the \\(P_2\\) graph, so the first two are hard coded.\nThe remaining graphs are generated using the Mycielski operation.",
    "Section ID: hits\nDescription: [Returns HITS hubs and authorities values for nodes., The HITS algorithm computes two numbers for a node.\nAuthorities estimates the node value based on the incoming links.\nHubs estimates the node value based on outgoing links.]\nField List: Parameters:: G : graph: A NetworkX graph\nmax_iter : integer, optional: Maximum number of iterations in power method.\ntol : float, optional: Error tolerance used to check convergence in power method iteration.\nnstart : dictionary, optional: Starting value of each node for power method iteration.\nnormalized : bool (default=True): Normalize results by the sum of all of the values.\nReturns:: (hubs,authorities) : two-tuple of dictionaries: Two dictionaries keyed by node containing the hub and authority\nvalues.\nRaises:: PowerIterationFailedConvergence: If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod.\nMethods: []\nRubrics: Notes: The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop\nafter max_iter iterations or an error tolerance of\nnumber_of_nodes(G)*tol has been reached. The HITS algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs.\nReferences: [1]A. Langville and C. Meyer,\n“A survey of eigenvector methods of web information retrieval.”http://citeseer.ist.psu.edu/713792.html  [2]Jon Kleinberg,\nAuthoritative sources in a hyperlinked environment\nJournal of the ACM 46 (5): 604-32, 1999.\ndoi:10.1145/324133.324140.\nhttp://www.cs.cornell.edu/home/kleinber/auth.pdf.\nExamples: G=nx.path_graph(4)\nh,a=nx.hits(G)",
    "Section ID: transitive_closure_dag\nDescription: [Returns the transitive closure of a directed acyclic graph., This function is faster than the function transitive_closure , but fails\nif the graph has a cycle., The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a non-null path from v to w in G.]\nField List: Parameters:: G : NetworkX DiGraph: A directed acyclic graph (DAG)\ntopo_order: list or tuple, optional: A topological order for G (if None, the function will compute one)\nReturns:: NetworkX DiGraph: The transitive closure ofG\nRaises:: NetworkXNotImplemented: IfGis not directed\nNetworkXUnfeasible: IfGhas a cycle\nMethods: []\nRubrics: Notes: This algorithm is probably simple enough to be well-known but I didn’t find\na mention in the literature.\nExamples: DG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure_dag(DG)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3)])",
    "Section ID: kamada_kawai_layout\nDescription: [Position nodes using Kamada-Kawai path-length cost-function.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\ndist : dict (default=None): A two-level dictionary of optimal distances between nodes,\nindexed by source and destination node.\nIf None, the distance is computed using shortest_path_length().\npos : dict or None  optional (default=None): Initial positions for nodes as a dictionary with node as keys\nand values as a coordinate list or tuple.  If None, then use\ncircular_layout() for dim >= 2 and a linear layout for dim == 1.\nweight : string or None   optional (default=’weight’): The edge attribute that holds the numerical value used for\nthe edge weight.  If None, then all edge weights are 1.\nscale : number (default: 1): Scale factor for positions.\ncenter : array-like or None: Coordinate pair around which to center the layout.\ndim : int: Dimension of layout.\nReturns:: pos : dict: A dictionary of positions keyed by node\nMethods: []\nRubrics: Examples: G=nx.path_graph(4)\npos=nx.kamada_kawai_layout(G)",
    "Section ID: minimum_cut\nDescription: [Compute the value and the node partition of a minimum (s, t)-cut., Use the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow.]\nField List: Parameters:: flowG : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\n_s : node: Source node for the flow.\n_t : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nflow_func : function: A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.\nkwargs : Any other keyword parameter is passed to the function that: computes the maximum flow.\nReturns:: cut_value : integer, float: Value of the minimum cut.\npartition : pair of node sets: A partitioning of the nodes that defines a minimum cut.\nRaises:: NetworkXUnbounded: If the graph has a path of infinite capacity, all cuts have\ninfinite capacity and the function raises a NetworkXError.\nMethods: []\nRubrics: Notes: The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.\nExamples: G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nminimum_cut computes both the value of the\nminimum cut and the node partition:\ncut_value,partition=nx.minimum_cut(G,\"x\",\"y\")\nreachable,non_reachable=partition\n‘partition’ here is a tuple with the two sets of nodes that define\nthe minimum cut. You can compute the cut set of edges that induce\nthe minimum cut as follows:\ncutset=set()\nforu,nbrsin((n,G[n])forninreachable):\ncutset.update((u,v)forvinnbrsifvinnon_reachable)\nprint(sorted(cutset))\n# [('c', 'y'), ('x', 'b')]\ncut_value==sum(G.edges[u,v][\"capacity\"]for(u,v)incutset)\n# True\nYou can also use alternative algorithms for computing the\nminimum cut by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\ncut_value==nx.minimum_cut(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True",
    "Section ID: UnionMultiAdjacency\nDescription: [A read-only union of two dict MultiAdjacencies., The two input dict-of-dict-of-dict-of-dicts represent the union of G.succ and G.pred for MultiDiGraphs. Return values are UnionAdjacency.\nThe inner level of dict is read-write. But the outer levels are read-only.]\nField List: Methods: []\nRubrics:",
    "Section ID: local_constraint\nDescription: [Returns the local constraint on the node u with respect to\nthe node v in the graph G ., Formally, the local constraint on u with respect to v , denoted \\(\\ell(u, v)\\) , is defined by, where \\(N(v)\\) is the set of neighbors of \\(v\\) and \\(p_{uv}\\) is the\nnormalized mutual weight of the (directed or undirected) edges\njoining \\(u\\) and \\(v\\) , for each vertex \\(u\\) and \\(v\\)  [1] . The mutual\nweight of \\(u\\) and \\(v\\) is the sum of the weights of edges joining\nthem (edge weights are assumed to be one if the graph is\nunweighted).]\nField List: Parameters:: G : NetworkX graph: The graph containinguandv. This can be either\ndirected or undirected.\nu : node: A node in the graphG.\nv : node: A node in the graphG.\nweight : None or string, optional: If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nReturns:: float: The constraint of the nodevin the graphG.\nMethods: []\nRubrics: References: [1]Burt, Ronald S.\n“Structural holes and good ideas”.\nAmerican Journal of Sociology (110): 349–399.",
    "Section ID: mycielskian\nDescription: [Returns the Mycielskian of a simple, undirected graph G, The Mycielskian of graph preserves a graph’s triangle free\nproperty while increasing the chromatic number by 1., The Mycielski Operation on a graph, \\(G=(V, E)\\) , constructs a new\ngraph with \\(2|V| + 1\\) nodes and \\(3|E| + |V|\\) edges., The construction is as follows:, Let \\(V = {0, ..., n-1}\\) . Construct another vertex set \\(U = {n, ..., 2n}\\) and a vertex, w .\nConstruct a new graph, M , with vertices \\(U \\bigcup V \\bigcup w\\) .\nFor edges, \\((u, v) \\in E\\) add edges \\((u, v), (u, v + n)\\) , and \\((u + n, v)\\) to M. Finally, for all vertices \\(u \\in U\\) , add\nedge \\((u, w)\\) to M., The Mycielski Operation can be done multiple times by repeating the above\nprocess iteratively., More information can be found at https://en.wikipedia.org/wiki/Mycielskian]\nField List: Parameters:: G : graph: A simple, undirected NetworkX graph\niterations : int: The number of iterations of the Mycielski operation to\nperform on G. Defaults to 1. Must be a non-negative integer.\nReturns:: M : graph: The Mycielskian of G after the specified number of iterations.\nMethods: []\nRubrics: Notes: Graph, node, and edge data are not necessarily propagated to the new graph.",
    "Section ID: from_dict_of_lists\nDescription: [Returns a graph from a dictionary of lists.]\nField List: Parameters:: d : dictionary of lists: A dictionary of lists adjacency representation.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nMethods: []\nRubrics: Examples: dol={0:[1]}# single edge (0,1)\nG=nx.from_dict_of_lists(dol)\nor\nG=nx.Graph(dol)# use Graph constructor",
    "Section ID: tadpole_graph\nDescription: [Returns the (m,n)-tadpole graph; C_m connected to P_n ., This graph on m+n nodes connects a cycle of size m to a path of length n .\nIt looks like a tadpole. It is also called a kite graph or a dragon graph., ( Sourcecode , png )]\nField List: Parameters:: m, n : int or iterable container of nodes: If an integer, nodes are fromrange(m)andrange(m,m+n).\nIf a container of nodes, those nodes appear in the graph.\nWarning:mandnare not checked for duplicates and if present the\nresulting graph may not be as desired.The nodes formappear in the cycle graph\\(C_m\\)and the nodes\nfornappear in the path\\(P_n\\).\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: Networkx graph: A cycle of sizemconnected to a path of lengthn.\nRaises:: NetworkXError: Ifm<2. The tadpole graph is undefined form<2.\nMethods: []\nRubrics: Notes: The 2 subgraphs are joined via an edge (m-1,m) .\nIf n=0 , this is a cycle graph. m and/or n can be a container of nodes instead of an integer.",
    "Section ID: generate_adjlist\nDescription: [Generate a single line of the graph G in adjacency list format.]\nField List: Parameters:: G : NetworkX graph: \ndelimiter : string, optional: Separator for node labels\nReturns:: lines : string: Lines of data in adjlist format.\nMethods: []\nRubrics: Notes: The default delimiter=\"\" will result in unexpected results if node names contain\nwhitespace characters. To avoid this problem, specify an alternate delimiter when spaces are\nvalid in node names. NB: This option is not available for data that isn’t user-generated.\nExamples: G=nx.lollipop_graph(4,3)\nforlineinnx.generate_adjlist(G):\nprint(line)\n# 0 1 2 3\n# 1 2 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6\n# 6",
    "Section ID: lollipop_graph\nDescription: [Returns the Lollipop Graph; K_m connected to P_n ., This is the Barbell Graph without the right barbell., ( Sourcecode , png )]\nField List: Parameters:: m, n : int or iterable container of nodes: If an integer, nodes are fromrange(m)andrange(m,m+n).\nIf a container of nodes, those nodes appear in the graph.\nWarning:mandnare not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.The nodes formappear in the complete graph\\(K_m\\)and the nodes\nfornappear in the path\\(P_n\\)\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: Networkx graph: A complete graph withmnodes connected to a path of lengthn.\nMethods: []\nRubrics: Notes: The 2 subgraphs are joined via an edge (m-1,m) .\nIf n=0 , this is merely a complete graph. (This graph is an extremal example in David Aldous and Jim\nFill’s etext on Random Walks on Graphs.)",
    "Section ID: FilterMultiAdjacency\nDescription: [A read-only Mapping of Mappings with filtering criteria\nfor nodes and edges., It is a view into a dict-of-dict-of-dict-of-dict data structure,\nand it selects nodes and edges that satisfy specific criteria\ndefined by NODE_OK and EDGE_OK , respectively.]\nField List: Methods: []\nRubrics:",
    "Section ID: greedy_color\nDescription: [Color a graph using various strategies of greedy graph coloring., Attempts to color a graph using as few colors as possible, where no\nneighbors of a node can have same color as the node itself. The\ngiven strategy determines the order in which nodes are colored., The strategies are described in [1] , and smallest-last is based on [2] .]\nField List: Parameters:: G : NetworkX graph: \nstrategy : string or function(G, colors): A function (or a string representing a function) that provides\nthe coloring strategy, by returning nodes in the ordering they\nshould be colored.Gis the graph, andcolorsis a\ndictionary of the currently assigned colors, keyed by nodes. The\nfunction must return an iterable over all the nodes inG.If the strategy function is an iterator generator (that is, a\nfunction withyieldstatements), keep in mind that thecolorsdictionary will be updated after eachyield, since\nthis function chooses colors greedily.Ifstrategyis a string, it must be one of the following,\neach of which represents one of the built-in strategy functions.'largest_first''random_sequential''smallest_last''independent_set''connected_sequential_bfs''connected_sequential_dfs''connected_sequential'(alias for the previous strategy)'saturation_largest_first''DSATUR'(alias for the previous strategy)\ninterchange: bool: Will use the color interchange algorithm described by[3]if set\ntoTrue.Note thatsaturation_largest_firstandindependent_setdo not work with interchange. Furthermore, if you use\ninterchange with your own strategy function, you cannot rely\non the values in thecolorsargument.\nReturns:: A dictionary with keys representing nodes and values representing: \ncorresponding coloring.:\nRaises:: NetworkXPointlessConcept: Ifstrategyissaturation_largest_firstorindependent_setandinterchangeisTrue.\nMethods: []\nRubrics: References: [1]Adrian Kosowski, and Krzysztof Manuszewski,\nClassical Coloring of Graphs, Graph Colorings, 2-19, 2004.\nISBN 0-8218-3458-4.  [2]David W. Matula, and Leland L. Beck, “Smallest-last\nordering and clustering and graph coloring algorithms.”J. ACM30,\n3 (July 1983), 417–427. <https://doi.org/10.1145/2402.322385>  [3]Maciej M. Sysło, Narsingh Deo, Janusz S. Kowalik,\nDiscrete Optimization Algorithms with Pascal Programs, 415-424, 1983.\nISBN 0-486-45353-7.\nExamples: G=nx.cycle_graph(4)\nd=nx.coloring.greedy_color(G,strategy=\"largest_first\")\ndin[{0:0,1:1,2:0,3:1},{0:1,1:0,2:1,3:0}]\n# True",
    "Section ID: shortest_augmenting_path\nDescription: [Find a maximum single-commodity flow using the shortest augmenting path\nalgorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has a running time of \\(O(n^2 m)\\) for \\(n\\) nodes and \\(m\\) edges.]\nField List: Parameters:: G : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\ns : node: Source node for the flow.\nt : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nresidual : NetworkX graph: Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.\nvalue_only : bool: If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.\ntwo_phase : bool: If True, a two-phase variant is used. The two-phase variant improves\nthe running time on unit-capacity networks from\\(O(nm)\\)to\\(O(\\min(n^{2/3}, m^{1/2}) m)\\). Default value: False.\ncutoff : integer, float: If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None.\nReturns:: R : NetworkX DiGraph: Residual network after computing the maximum flow.\nRaises:: NetworkXError: The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.\nNetworkXUnbounded: If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded.\nMethods: []\nRubrics: Notes: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.\nExamples: fromnetworkx.algorithms.flowimportshortest_augmenting_path\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=shortest_augmenting_path(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True",
    "Section ID: fast_could_be_isomorphic\nDescription: [Returns False if graphs are definitely not isomorphic., True does NOT guarantee isomorphism.]\nField List: Parameters:: G1, G2 : graphs: The two graphs G1 and G2 must be the same type.\nMethods: []\nRubrics: Notes: Checks for matching degree and triangle sequences. The triangle\nsequence contains the number of triangles each node is part of.",
    "Section ID: directed_havel_hakimi_graph\nDescription: [Returns a directed graph with the given degree sequences.]\nField List: Parameters:: in_deg_sequence : list of integers: Each list entry corresponds to the in-degree of a node.\nout_deg_sequence : list of integers: Each list entry corresponds to the out-degree of a node.\ncreate_using : NetworkX graph constructor, optional (default DiGraph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : DiGraph: A graph with the specified degree sequences.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence\nRaises:: NetworkXError: If the degree sequences are not digraphical.\nMethods: []\nRubrics: Notes: Algorithm as described by Kleitman and Wang [1] .\nReferences: [1]D.J. Kleitman and D.L. Wang\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)",
    "Section ID: random_unlabeled_tree\nDescription: [Returns a tree or list of trees chosen randomly., Returns one or more (depending on number_of_trees )\nunlabeled trees with n nodes drawn uniformly at random.]\nField List: Parameters:: n : int: The number of nodes\nnumber_of_trees : int or None (default): If not None, this number of trees is generated and returned.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: networkx.Graph : or list of : networkx.Graph: A singlenetworkx.Graph(or a list thereof, ifnumber_of_treesis specified) with nodes in the set {0, …,n- 1}.\nRaises:: NetworkXPointlessConcept: Ifnis zero (because the null graph is not a tree).\nMethods: []\nRubrics: Notes: This function generates an unlabeled tree uniformly at random using\nWilf’s algorithm “Free” of [1] . The algorithm needs to\ncompute some counting functions that are relatively expensive:\nin case several trees are needed, it is advisable to use the number_of_trees optional argument to reuse the counting\nfunctions.\nReferences: [1]Wilf, Herbert S. “The uniform selection of free trees.”\nJournal of Algorithms 2.2 (1981): 204-207.https://doi.org/10.1016/0196-6774(81)90021-3",
    "Section ID: betweenness_centrality\nDescription: [Compute betweenness centrality for nodes in a bipartite network., Betweenness centrality of a node v is the sum of the\nfraction of all-pairs shortest paths that pass through v ., Values of betweenness are normalized by the maximum possible\nvalue which for bipartite graphs is limited by the relative size\nof the two node sets [1] ., Let n be the number of nodes in the node set U and m be the number of nodes in the node set V , then\nnodes in U are normalized by dividing by, where, and nodes in V are normalized by dividing by, where,]\nField List: Parameters:: G : graph: A bipartite graph\nnodes : list or container: Container with all nodes in one bipartite node set.\nReturns:: betweenness : dictionary: Dictionary keyed by node with bipartite betweenness centrality\nas the value.\nMethods: []\nRubrics: Notes: The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both node sets.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nReferences: [1]Borgatti, S.P. and Halgin, D. In press. “Analyzing Affiliation\nNetworks”. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28\nExamples: G=nx.cycle_graph(4)\ntop_nodes={1,2}\nnx.bipartite.betweenness_centrality(G,nodes=top_nodes)\n# {0: 0.25, 1: 0.25, 2: 0.25, 3: 0.25}",
    "Section ID: modularity\nDescription: [Returns the modularity of the given partition of the graph., Modularity is defined in [1] as, where \\(m\\) is the number of edges (or sum of all edge weights as in [5] ), \\(A\\) is the adjacency matrix of G , \\(k_i\\) is the (weighted) degree of \\(i\\) , \\(\\gamma\\) is the resolution parameter, and \\(\\delta(c_i, c_j)\\) is 1 if \\(i\\) and \\(j\\) are in the same community else 0., According to [2] (and verified by some algebra) this can be reduced to, where the sum iterates over all communities \\(c\\) , \\(m\\) is the number of edges, \\(L_c\\) is the number of intra-community links for community \\(c\\) , \\(k_c\\) is the sum of degrees of the nodes in community \\(c\\) ,\nand \\(\\gamma\\) is the resolution parameter., The resolution parameter sets an arbitrary tradeoff between intra-group\nedges and inter-group edges. More complex grouping patterns can be\ndiscovered by analyzing the same network with multiple values of gamma\nand then combining the results [3] . That said, it is very common to\nsimply use gamma=1. More on the choice of gamma is in [4] ., The second formula is the one actually used in calculation of the modularity.\nFor directed graphs the second formula replaces \\(k_c\\) with \\(k^{in}_c k^{out}_c\\) .]\nField List: Parameters:: G : NetworkX Graph: \ncommunities : list or iterable of set of nodes: These node sets must represent a partition of G’s nodes.\nweight : string or None, optional (default=”weight”): The edge attribute that holds the numerical value used\nas a weight. If None or an edge does not have that attribute,\nthen that edge has weight 1.\nresolution : float (default=1): If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities.\nReturns:: Q : float: The modularity of the partition.\nRaises:: NotAPartition: Ifcommunitiesis not a partition of the nodes ofG.\nMethods: []\nRubrics: References: [1]M. E. J. Newman “Networks: An Introduction”, page 224.\nOxford University Press, 2011.  [2]Clauset, Aaron, Mark EJ Newman, and Cristopher Moore.\n“Finding community structure in very large networks.”\nPhys. Rev. E 70.6 (2004). <https://arxiv.org/abs/cond-mat/0408187>  [3]Reichardt and Bornholdt “Statistical Mechanics of Community Detection”\nPhys. Rev. E 74, 016110, 2006.https://doi.org/10.1103/PhysRevE.74.016110  [4]M. E. J. Newman, “Equivalence between modularity optimization and\nmaximum likelihood methods for community detection”\nPhys. Rev. E 94, 052315, 2016.https://doi.org/10.1103/PhysRevE.94.052315  [5]Blondel, V.D. et al. “Fast unfolding of communities in large\nnetworks” J. Stat. Mech 10008, 1-12 (2008).https://doi.org/10.1088/1742-5468/2008/10/P10008\nExamples: G=nx.barbell_graph(3,0)\nnx.community.modularity(G,[{0,1,2},{3,4,5}])\n# 0.35714285714285715\nnx.community.modularity(G,nx.community.label_propagation_communities(G))\n# 0.35714285714285715",
    "Section ID: dfs_edges\nDescription: [Iterate over edges in a depth-first-search (DFS)., Perform a depth-first-search over the nodes of G and yield\nthe edges in order. This may not generate all edges in G (see edge_dfs ).]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Specify starting node for depth-first search and yield edges in\nthe component reachable from source.\ndepth_limit : int, optional (default=len(G)): Specify the maximum search depth.\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nYields:: edge: 2-tuple of nodes: Yields edges resulting from the depth-first-search.\nMethods: []\nRubrics: Notes: If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein’s\ndepth-first search function in PADS [1] , with modifications\nto allow depth limits based on the Wikipedia article\n“Depth-limited search” [2] .\nReferences: [1]http://www.ics.uci.edu/~eppstein/PADS  [2]https://en.wikipedia.org/wiki/Depth-limited_search\nExamples: G=nx.path_graph(5)\nlist(nx.dfs_edges(G,source=0))\n# [(0, 1), (1, 2), (2, 3), (3, 4)]\nlist(nx.dfs_edges(G,source=0,depth_limit=2))\n# [(0, 1), (1, 2)]",
    "Section ID: write_gml\nDescription: [Write a graph G in GML format to the file or file handle path .]\nField List: Parameters:: G : NetworkX graph: The graph to be converted to GML.\npath : filename or filehandle: The filename or filehandle to write. Files whose names end with .gz or\n.bz2 will be compressed.\nstringizer : callable, optional: Astringizerwhich converts non-int/non-float/non-dict values into\nstrings. If it cannot convert a value into a string, it should raise aValueErrorto indicate that. Default value: None.\nRaises:: NetworkXError: Ifstringizercannot convert a value into a string, or the value to\nconvert is not a string whilestringizeris None.\nMethods: []\nRubrics: Notes: Graph attributes named ‘directed’, ‘multigraph’, ‘node’ or\n‘edge’, node attributes named ‘id’ or ‘label’, edge attributes\nnamed ‘source’ or ‘target’ (or ‘key’ if G is a multigraph)\nare ignored because these attribute names are used to encode the graph\nstructure. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . Note that while we allow non-standard GML to be read from a file, we make\nsure to write GML format. In particular, underscores are not allowed in\nattribute names.\nFor additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.\nExamples: G=nx.path_graph(4)\nnx.write_gml(G,\"test.gml\")\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_gml(G,\"test.gml.gz\")",
    "Section ID: predecessor\nDescription: [Returns dict of predecessors for the path from source to all nodes in G.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: Starting node for path\ntarget : node label, optional: Ending node for path. If provided only predecessors between\nsource and target are returned\ncutoff : integer, optional: Depth to stop the search. Only paths of length <= cutoff are returned.\nreturn_seen : bool, optional (default=None): Whether to return a dictionary, keyed by node, of the level (number of\nhops) to reach the node (as seen during breadth-first-search).\nReturns:: pred : dictionary: Dictionary, keyed by node, of predecessors in the shortest path.\n(pred, seen): tuple of dictionaries: Ifreturn_seenargument is set toTrue, then a tuple of dictionaries\nis returned. The first element is the dictionary, keyed by node, of\npredecessors in the shortest path. The second element is the dictionary,\nkeyed by node, of the level (number of hops) to reach the node (as seen\nduring breadth-first-search).\nMethods: []\nRubrics: Examples: G=nx.path_graph(4)\nlist(G)\n# [0, 1, 2, 3]\nnx.predecessor(G,0)\n# {0: [], 1: [0], 2: [1], 3: [2]}\nnx.predecessor(G,0,return_seen=True)\n# ({0: [], 1: [0], 2: [1], 3: [2]}, {0: 0, 1: 1, 2: 2, 3: 3})",
    "Section ID: to_pydot\nDescription: [Returns a pydot graph from a NetworkX graph N.]\nField List: Parameters:: N : NetworkX graph: A graph created with NetworkX\nMethods: []\nRubrics: Examples: K5=nx.complete_graph(5)\nP=nx.nx_pydot.to_pydot(K5)",
    "Section ID: goldberg_radzik\nDescription: [Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs., The algorithm has a running time of \\(O(mn)\\) where \\(n\\) is the number of\nnodes and \\(m\\) is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights.]\nField List: Parameters:: G : NetworkX graph: The algorithm works for all types of graphs, including directed\ngraphs and multigraphs.\nsource: node label: Starting node for path\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: pred, dist : dictionaries: Returns two dictionaries keyed by node to predecessor in the\npath and to the distance from the source respectively.\nRaises:: NodeNotFound: Ifsourceis not inG.\nNetworkXUnbounded: If the (di)graph contains a negative (di)cycle, the\nalgorithm raises an exception to indicate the presence of the\nnegative (di)cycle.  Note: any negative weight edge in an\nundirected graph is a negative cycle.As of NetworkX v3.2, a zero weight cycle is no longer\nincorrectly reported as a negative weight cycle.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionaries returned only have keys for nodes reachable from\nthe source. In the case where the (di)graph is not connected, if a component\nnot containing the source contains a negative (di)cycle, it\nwill not be detected.\nExamples: G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.goldberg_radzik(G,0)\nsorted(pred.items())\n# [(0, None), (1, 0), (2, 1), (3, 2), (4, 3)]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\nG=nx.cycle_graph(5,create_using=nx.DiGraph())\nG[1][2][\"weight\"]=-7\nnx.goldberg_radzik(G,0)Traceback (most recent call last):    ...networkx.exception.NetworkXUnboundedNegative cycle detected.",
    "Section ID: flatten\nDescription: [Return flattened version of (possibly nested) iterable object.]\nField List: Methods: []\nRubrics:",
    "Section ID: louvain_communities\nDescription: [Find the best partition of a graph using the Louvain Community Detection\nAlgorithm., Louvain Community Detection Algorithm is a simple method to extract the community\nstructure of a network. This is a heuristic method based on modularity optimization. [1], The algorithm works in 2 steps. On the first step it assigns every node to be\nin its own community and then for each node it tries to find the maximum positive\nmodularity gain by moving each node to all of its neighbor communities. If no positive\ngain is achieved the node remains in its original community., The modularity gain obtained by moving an isolated node \\(i\\) into a community \\(C\\) can\neasily be calculated by the following formula (combining [1]  [2] and some algebra):, where \\(m\\) is the size of the graph, \\(k_{i,in}\\) is the sum of the weights of the links\nfrom \\(i\\) to nodes in \\(C\\) , \\(k_i\\) is the sum of the weights of the links incident to node \\(i\\) , \\(\\Sigma_{tot}\\) is the sum of the weights of the links incident to nodes in \\(C\\) and \\(\\gamma\\) is the resolution parameter., For the directed case the modularity gain can be computed using this formula according to [3], where \\(k_i^{out}\\) , \\(k_i^{in}\\) are the outer and inner weighted degrees of node \\(i\\) and \\(\\Sigma_{tot}^{in}\\) , \\(\\Sigma_{tot}^{out}\\) are the sum of in-going and out-going links incident\nto nodes in \\(C\\) ., The first phase continues until no individual move can improve the modularity., The second phase consists in building a new network whose nodes are now the communities\nfound in the first phase. To do so, the weights of the links between the new nodes are given by\nthe sum of the weight of the links between nodes in the corresponding two communities. Once this\nphase is complete it is possible to reapply the first phase creating bigger communities with\nincreased modularity., The above two phases are executed until no modularity gain is achieved (or is less than\nthe threshold , or until max_levels is reached)., Be careful with self-loops in the input graph. These are treated as\npreviously reduced communities – as if the process had been started\nin the middle of the algorithm. Large self-loop edge weights thus\nrepresent strong communities and in practice may be hard to add\nother nodes to.  If your input graph edge weights for self-loops\ndo not represent already reduced communities you may want to remove\nthe self-loops before inputting that graph.]\nField List: Parameters:: G : NetworkX graph: \nweight : string or None, optional (default=”weight”): The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.\nresolution : float, optional (default=1): If resolution is less than 1, the algorithm favors larger communities.\nGreater than 1 favors smaller communities\nthreshold : float, optional (default=0.0000001): Modularity gain threshold for each level. If the gain of modularity\nbetween 2 levels of the algorithm is less than the given threshold\nthen the algorithm stops and returns the resulting communities.\nmax_level : int or None, optional (default=None): The maximum number of levels (steps of the algorithm) to compute.\nMust be a positive integer or None. If None, then there is no max\nlevel and the threshold parameter determines the stopping condition.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: list: A list of sets (partition ofG). Each set represents one community and contains\nall the nodes that constitute it.\nMethods: []\nRubrics: Notes: The order in which the nodes are considered can affect the final output. In the algorithm\nthe ordering happens using a random shuffle.\nReferences: [1](1,2)Blondel, V.D. et al. Fast unfolding of communities in\nlarge networks. J. Stat. Mech 10008, 1-12(2008).https://doi.org/10.1088/1742-5468/2008/10/P10008  [2]Traag, V.A., Waltman, L. & van Eck, N.J. From Louvain to Leiden: guaranteeing\nwell-connected communities. Sci Rep 9, 5233 (2019).https://doi.org/10.1038/s41598-019-41695-z  [3]Nicolas Dugué, Anthony Perez. Directed Louvain : maximizing modularity in directed networks.\n[Research Report] Université d’Orléans. 2015. hal-01231784.https://hal.archives-ouvertes.fr/hal-01231784\nExamples: importnetworkxasnx\nG=nx.petersen_graph()\nnx.community.louvain_communities(G,seed=123)\n# [{0, 4, 5, 7, 9}, {1, 2, 3, 6, 8}]",
    "Section ID: dijkstra_predecessor_and_distance\nDescription: [Compute weighted shortest path length and predecessors., Uses Dijkstra’s Method to obtain the shortest weighted paths\nand return dictionaries of predecessors for each node and\ndistance for each node from the source .]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: Starting node for path\ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: pred, distance : dictionaries: Returns two dictionaries representing a list of predecessors\nof a node and the distance to each node.\nRaises:: NodeNotFound: Ifsourceis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The list of predecessors contains more than one element only when\nthere are more than one shortest paths to the key node.\nExamples: G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.dijkstra_predecessor_and_distance(G,0)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\npred,dist=nx.dijkstra_predecessor_and_distance(G,0,1)\nsorted(pred.items())\n# [(0, []), (1, [0])]\nsorted(dist.items())\n# [(0, 0), (1, 1)]",
    "Section ID: has_path\nDescription: [Returns True if G has a path from source to target .]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path\ntarget : node: Ending node for path\nMethods: []\nRubrics:",
    "Section ID: gn_graph\nDescription: [Returns the growing network (GN) digraph with n nodes., The GN graph is built by adding nodes one at a time with a link to one\npreviously added node.  The target node for the link is chosen with\nprobability based on degree.  The default attachment kernel is a linear\nfunction of the degree of a node., The graph is always a (directed) tree.]\nField List: Parameters:: n : int: The number of nodes for the generated graph.\nkernel : function: The attachment kernel.\ncreate_using : NetworkX graph constructor, optional (default DiGraph): Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: References: [1]P. L. Krapivsky and S. Redner,\nOrganization of Growing Random Networks,\nPhys. Rev. E, 63, 066123, 2001.\nExamples: To create the undirected GN graph, use theto_directed()method:\nD=nx.gn_graph(10)# the GN graph\nG=D.to_undirected()# the undirected version\nTo specify an attachment kernel, use thekernelkeyword argument:\nD=nx.gn_graph(10,kernel=lambdax:x**1.5)# A_k = k^1.5",
    "Section ID: group_betweenness_centrality\nDescription: [Compute the group betweenness centrality for a group of nodes., Group betweenness centrality of a group of nodes \\(C\\) is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in \\(C\\), where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|C)\\) is the number of\nthose paths passing through some node in group \\(C\\) . Note that \\((s, t)\\) are not members of the group ( \\(V-C\\) is the set of nodes\nin \\(V\\) that are not in \\(C\\) ).]\nField List: Parameters:: G : graph: A NetworkX graph.\nC : list or set or list of lists or list of sets: A group or a list of groups containing nodes which belong to G, for which group betweenness\ncentrality is to be calculated.\nnormalized : bool, optional (default=True): If True, group betweenness is normalized by1/((|V|-|C|)(|V|-|C|-1))where|V|is the number of nodes in G and|C|is the number of nodes in C.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.\nendpoints : bool, optional (default=False): If True include the endpoints in the shortest path counts.\nReturns:: betweenness : list of floats or float: If C is a single group then return a float. If C is a list with\nseveral groups then return a list of group betweenness centralities.\nRaises:: NodeNotFound: If node(s) in C are not present in G.\nMethods: []\nRubrics: Notes: Group betweenness centrality is described in [1] and its importance discussed in [3] .\nThe initial implementation of the algorithm is mentioned in [2] . This function uses\nan improved algorithm presented in [4] . The number of nodes in the group must be a maximum of n - 2 where n is the total number of nodes in the graph. For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nbetween “u” and “v” are counted as two possible paths (one each\ndirection) while undirected paths between “u” and “v” are counted\nas one path. Said another way, the sum in the expression above is\nover all s!=t for directed graphs and for s<t for undirected graphs.\nReferences: [1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]Ulrik Brandes:\nOn Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.9610&rep=rep1&type=pdf  [3]Sourav Medya et. al.:\nGroup Centrality Maximization via Network Design.\nSIAM International Conference on Data Mining, SDM 2018, 126–134.https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf  [4]Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n“Fast algorithm for successive computation of group betweenness centrality.”https://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709",
    "Section ID: to_latex_raw\nDescription: [Return a string of the LaTeX/TikZ code to draw G, This function produces just the code for the tikzpicture\nwithout any enclosing environment.]\nField List: Parameters:: G : NetworkX graph: The NetworkX graph to be drawn\npos : string or dict (default “pos”): The name of the node attribute onGthat holds the position of each node.\nPositions can be sequences of length 2 with numbers for (x,y) coordinates.\nThey can also be strings to denote positions in TikZ style, such as (x, y)\nor (angle:radius).\nIf a dict, it should be keyed by node to a position.\nIf an empty dict, a circular layout is computed by TikZ.\ntikz_options : string: The tikzpicture options description defining the options for the picture.\nOften large scale options like[scale=2].\ndefault_node_options : string: The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict: The name of the node attribute onGthat holds the options for each node.\nOr a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict: The name of the node attribute onGthat holds the node label (text)\ndisplayed for each node. If the attribute is “” or not present, the node\nitself is drawn as a string. LaTeX processing such as\"$A_1$\"is allowed.\nOr a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string: The options for the scope drawing all edges. The default is “[-]” for\nundirected graphs and “[->]” for directed graphs.\nedge_options : string or dict: The name of the edge attribute onGthat holds the options for each edge.\nIf the edge is a self-loop and\"loop\"notinedge_optionsthe option\n“loop,” is added to the options for the self-loop edge. Hence you can\nuse “[loop above]” explicitly, but the default is “[loop]”.\nOr a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict: The name of the edge attribute onGthat holds the edge label (text)\ndisplayed for each edge. If the attribute is “” or not present, no edge\nlabel is drawn.\nOr a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict: The name of the edge attribute onGthat holds the label options for\neach edge. For example, “[sloped,above,blue]”. The default is no options.\nOr a dict keyed by edge to a string holding the label options for that edge.\nReturns:: latex_code : string: The text string which draws the desired graph(s) when compiled by LaTeX.\nMethods: []\nRubrics:",
    "Section ID: draw_networkx\nDescription: [Draw the graph G using Matplotlib., Draw the graph with Matplotlib with options for node positions,\nlabeling, titles, and many other drawing features.\nSee draw() for simple drawing without labels or axes.]\nField List: Parameters:: G : graph: A networkx graph\npos : dictionary, optional: A dictionary with nodes as keys and positions as values.\nIf not specified a spring layout positioning will be computed.\nSeenetworkx.drawing.layoutfor functions that\ncompute node positions.\narrows : bool or None, optional (default=None): IfNone, directed graphs draw arrowheads withFancyArrowPatch, while undirected graphs draw edges\nviaLineCollectionfor speed.\nIfTrue, draw arrowheads with FancyArrowPatches (bendable and stylish).\nIfFalse, draw edges using LineCollection (linear and fast).\nFor directed graphs, if True draw arrowheads.\nNote: Arrows will be the same color as edges.\narrowstyle : str (default=’-|>’ for directed graphs): For directed graphs, choose the style of the arrowsheads.\nFor undirected graphs default to ‘-’Seematplotlib.patches.ArrowStylefor more options.\narrowsize : int or list (default=10): For directed graphs, choose the size of the arrow head’s length and\nwidth. A list of values can be passed in to assign a different size for arrow head’s length and width.\nSeematplotlib.patches.FancyArrowPatchfor attributemutation_scalefor more info.\nwith_labels : bool (default=True): Set to True to draw labels on the nodes.\nax : Matplotlib Axes object, optional: Draw the graph in the specified Matplotlib axes.\nnodelist : list (default=list(G)): Draw only specified nodes\nedgelist : list (default=list(G.edges())): Draw only specified edges\nnode_size : scalar or array (default=300): Size of nodes.  If an array is specified it must be the\nsame length as nodelist.\nnode_color : color or array of colors (default=’#1f78b4’): Node color. Can be a single color or a sequence of colors with the same\nlength as nodelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the cmap and vmin,vmax parameters. See\nmatplotlib.scatter for more details.\nnode_shape : string (default=’o’): The shape of the node.  Specification is as matplotlib.scatter\nmarker, one of ‘so^>v<dph8’.\nalpha : float or None (default=None): The node and edge transparency\ncmap : Matplotlib colormap, optional: Colormap for mapping intensities of nodes\nvmin,vmax : float, optional: Minimum and maximum for node colormap scaling\nlinewidths : scalar or sequence (default=1.0): Line width of symbol border\nwidth : float or array of floats (default=1.0): Line width of edges\nedge_color : color or array of colors (default=’k’): Edge color. Can be a single color or a sequence of colors with the same\nlength as edgelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.\nedge_cmap : Matplotlib colormap, optional: Colormap for mapping intensities of edges\nedge_vmin,edge_vmax : floats, optional: Minimum and maximum for edge colormap scaling\nstyle : string (default=solid line): Edge line style e.g.: ‘-’, ‘–’, ‘-.’, ‘:’\nor words like ‘solid’ or ‘dashed’.\n(Seematplotlib.patches.FancyArrowPatch:linestyle)\nlabels : dictionary (default=None): Node labels in a dictionary of text labels keyed by node\nfont_size : int (default=12 for nodes, 10 for edges): Font size for text labels\nfont_color : color (default=’k’ black): Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.\nfont_weight : string (default=’normal’): Font weight\nfont_family : string (default=’sans-serif’): Font family\nlabel : string, optional: Label for graph legend\nhide_ticks : bool, optional: Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False.\nkwds : optional keywords: See networkx.draw_networkx_nodes(), networkx.draw_networkx_edges(), and\nnetworkx.draw_networkx_labels() for a description of optional keywords.\nMethods: []\nRubrics: Notes: For directed graphs, arrows  are drawn at the head end.  Arrows can be\nturned off with keyword arrows=False.\nExamples: G=nx.dodecahedral_graph()\nnx.draw(G)\nnx.draw(G,pos=nx.spring_layout(G))# use spring layout\nimportmatplotlib.pyplotasplt\nlimits=plt.axis(\"off\")# turn off axis\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html",
    "Section ID: parse_edgelist\nDescription: [Parse lines of an edge list representation of a graph.]\nField List: Parameters:: lines : list or iterator of strings: Input data in edgelist format\ncomments : string, optional: Marker for comment lines. Default is'#'. To specify that no character\nshould be treated as a comment, usecomments=None.\ndelimiter : string, optional: Separator for node labels. Default isNone, meaning any whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nnodetype : Python type, optional: Convert nodes to this type. Default isNone, meaning no conversion is\nperformed.\ndata : bool or list of (label,type) tuples: IfFalsegenerate no edge data or ifTrueuse a dictionary\nrepresentation of edge data or a list tuples specifying dictionary\nkey names and types for edge data.\nReturns:: G: NetworkX Graph: The graph corresponding to lines\nMethods: []\nRubrics: Examples: Edgelist with no data:\nlines=[\"1 2\",\"2 3\",\"3 4\"]\nG=nx.parse_edgelist(lines,nodetype=int)\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges())\n# [(1, 2), (2, 3), (3, 4)]\nEdgelist with data in Python dictionary representation:\nlines=[\"1 2 {'weight': 3}\",\"2 3 {'weight': 27}\",\"3 4 {'weight': 3.0}\"]\nG=nx.parse_edgelist(lines,nodetype=int)\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]\nEdgelist with data in a list:\nlines=[\"1 2 3\",\"2 3 27\",\"3 4 3.0\"]\nG=nx.parse_edgelist(lines,nodetype=int,data=((\"weight\",float),))\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]",
    "Section ID: FilterMultiInner\nDescription: [A read-only Mapping of Mappings with filtering criteria for nodes and edges., It is a view into a dict-of-dict-of-dict-of-dict data structure, and it selects nodes\nand edges that meet specific criteria defined by NODE_OK and EDGE_OK .]\nField List: Methods: []\nRubrics:",
    "Section ID: hide_multidiedges\nDescription: [Returns a filter function that hides specific multi-directed edges.]\nField List: Methods: []\nRubrics:",
    "Section ID: random_shell_graph\nDescription: [Returns a random shell graph for the constructor given.]\nField List: Parameters:: constructor : list of three-tuples: Represents the parameters for a shell, starting at the center\nshell.  Each element of the list must be of the form(n,m,d), wherenis the number of nodes in the shell,mis\nthe number of edges in the shell, anddis the ratio of\ninter-shell (next) edges to intra-shell edges. Ifdis zero,\nthere will be no intra-shell edges, and ifdis one there\nwill be all possible intra-shell edges.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: Examples: constructor=[(10,20,0.8),(20,40,0.8)]\nG=nx.random_shell_graph(constructor)",
    "Section ID: joint_degree_graph\nDescription: [Generates a random simple graph with the given joint degree dictionary.]\nField List: Parameters:: joint_degrees : dictionary of dictionary of integers: A joint degree dictionary in which entryjoint_degrees[k][l]is the\nnumber of edges joining nodes of degreekwith nodes of degreel.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : Graph: A graph with the specified joint degree dictionary.\nRaises:: NetworkXError: Ifjoint_degreesdictionary is not realizable.\nMethods: []\nRubrics: Notes: In each iteration of the “while loop” the algorithm picks two disconnected\nnodes v and w , of degree k and l correspondingly,  for which joint_degrees[k][l] has not reached its target yet. It then adds\nedge ( v , w ) and increases the number of edges in graph G by one. The intelligence of the algorithm lies in the fact that  it is always\npossible to add an edge between such disconnected nodes v and w ,\neven if one or both nodes do not have free stubs. That is made possible by\nexecuting a “neighbor switch”, an edge rewiring move that releases\na free stub while keeping the joint degree of G the same. The algorithm continues for E (number of edges) iterations of\nthe “while loop”, at the which point all entries of the given joint_degrees[k][l] have reached their target values and the\nconstruction is complete.\nReferences: [1]M. Gjoka, B. Tillman, A. Markopoulou, “Construction of Simple\nGraphs with a Target Joint Degree Matrix and Beyond”, IEEE Infocom, ‘15\nExamples: joint_degrees={\n1:{4:1},\n2:{2:2,3:2,4:2},\n3:{2:2,4:1},\n4:{1:1,2:2,3:1},\n}\nG=nx.joint_degree_graph(joint_degrees)",
    "Section ID: cumulative_distribution\nDescription: [Returns normalized cumulative distribution from discrete distribution.]\nField List: Methods: []\nRubrics:",
    "Section ID: waxman_graph\nDescription: [Returns a Waxman random graph., The Waxman random graph model places n nodes uniformly at random\nin a rectangular domain. Each pair of nodes at distance d is\njoined by an edge with probability, This function implements both Waxman models, using the L keyword\nargument.]\nField List: Parameters:: n : int or iterable: Number of nodes or iterable of nodes\nbeta: float: Model parameter\nalpha: float: Model parameter\nL : float, optional: Maximum distance between nodes.  If not specified, the actual distance\nis calculated.\ndomain : four-tuple of numbers, optional: Domain size, given as a tuple of the form(x_min,y_min,x_max,y_max).\nmetric : function: A metric on vectors of numbers (represented as lists or\ntuples). This must be a function that accepts two lists (or\ntuples) as input and yields a number as output. The function\nmust also satisfy the four requirements of ametric.\nSpecifically, if\\(d\\)is the function and\\(x\\),\\(y\\),\nand\\(z\\)are vectors in the graph, then\\(d\\)must satisfy\\(d(x, y) \\ge 0\\),\\(d(x, y) = 0\\)if and only if\\(x = y\\),\\(d(x, y) = d(y, x)\\),\\(d(x, z) \\le d(x, y) + d(y, z)\\).If this argument is not specified, the Euclidean distance metric is\nused.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\npos_name : string, default=”pos”: The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.\nReturns:: Graph: A random Waxman graph, undirected and without self-loops. Each\nnode has a node attribute'pos'that stores the position of\nthat node in Euclidean space as generated by this function.\nMethods: []\nRubrics: Notes: Starting in NetworkX 2.0 the parameters alpha and beta align with their\nusual roles in the probability distribution. In earlier versions their\npositions in the expression were reversed. Their position in the calling\nsequence reversed as well to minimize backward incompatibility.\nReferences: [1]B. M. Waxman,Routing of multipoint connections.\nIEEE J. Select. Areas Commun. 6(9),(1988) 1617–1622.\nExamples: Specify an alternate distance metric using themetrickeyword\nargument. For example, to use the “taxicab metric” instead of the\ndefaultEuclidean metric:\ndist=lambdax,y:sum(abs(a-b)fora,binzip(x,y))\nG=nx.waxman_graph(10,0.5,0.1,metric=dist)",
    "Section ID: restricted_view\nDescription: [Returns a view of G with hidden nodes and edges., The resulting subgraph filters out node nodes and edges edges .\nFiltered out nodes also filter out any of their edges.]\nField List: Parameters:: G : NetworkX Graph: \nnodes : iterable: An iterable of nodes. Nodes not present inGare ignored.\nedges : iterable: An iterable of edges. Edges not present inGare ignored.\nReturns:: subgraph : SubGraph View: A read-only restricted view ofGfiltering out nodes and edges.\nChanges toGare reflected in the view.\nMethods: []\nRubrics: Notes: To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) If you create a subgraph of a subgraph recursively you may end up\nwith a chain of subgraph views. Such chains can get quite slow\nfor lengths near 15. To avoid long chains, try to make your subgraph\nbased on the original graph.  We do not rule out chains programmatically\nso that odd cases like an edge_subgraph of a restricted_view can be created.\nExamples: G=nx.path_graph(5)\nH=nx.restricted_view(G,[0],[(1,2),(3,4)])\nlist(H.nodes)\n# [1, 2, 3, 4]\nlist(H.edges)\n# [(2, 3)]",
    "Section ID: show_nodes\nDescription: [Filter class to show specific nodes.]\nField List: Methods: []\nRubrics:",
    "Section ID: bfs_layers\nDescription: [Returns an iterator of all the layers in breadth-first search traversal.]\nField List: Parameters:: G : NetworkX graph: A graph over which to find the layers using breadth-first search.\nsources : node inGor list of nodes inG: Specify starting nodes for single source or multiple sources breadth-first search\nYields:: layer: list of nodes: Yields list of nodes at the same distance from sources\nMethods: []\nRubrics: Examples: G=nx.path_graph(5)\ndict(enumerate(nx.bfs_layers(G,[0,4])))\n# {0: [0, 4], 1: [1, 3], 2: [2]}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(enumerate(nx.bfs_layers(H,[1])))\n# {0: [1], 1: [0, 3, 4], 2: [2], 3: [5, 6]}\ndict(enumerate(nx.bfs_layers(H,[1,6])))\n# {0: [1, 6], 1: [0, 3, 4, 2], 2: [5]}",
    "Section ID: write_dot\nDescription: [Write NetworkX graph G to Graphviz dot format on path.]\nField List: Parameters:: G : graph: A networkx graph\npath : filename: Filename or file handle to write\nMethods: []\nRubrics: Notes: To use a specific graph layout, call A.layout prior to write_dot .\nNote that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info.",
    "Section ID: groups\nDescription: [Converts a many-to-one mapping into a one-to-many mapping., many_to_one must be a dictionary whose keys and values are all hashable ., The return value is a dictionary mapping values from many_to_one to sets of keys from many_to_one that have that value., Examples]\nField List: Methods: []\nRubrics: Examples: fromnetworkx.utilsimportgroups\nmany_to_one={\"a\":1,\"b\":1,\"c\":2,\"d\":3,\"e\":3}\ngroups(many_to_one)\n# {1: {'a', 'b'}, 2: {'c'}, 3: {'e', 'd'}}",
    "Section ID: is_pseudographical\nDescription: [Returns True if some pseudograph can realize the sequence., Every nonnegative integer sequence with an even sum is pseudographical\n(see [1] ).]\nField List: Parameters:: sequence : list or iterable container: A sequence of integer node degrees\nReturns:: valid : bool: True if the sequence is a pseudographic degree sequence and False if not.\nMethods: []\nRubrics: Notes: The worst-case run time is \\(O(n)\\) where n is the length of the sequence.\nReferences: [1]F. Boesch and F. Harary. “Line removal algorithms for graphs\nand their degree lists”, IEEE Trans. Circuits and Systems, CAS-23(12),\npp. 778-782 (1976).\nExamples: G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_pseudographical(sequence)\n# True\nTo test a non-pseudographical sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_pseudographical(sequence_list)\nFalse",
    "Section ID: adjacency_graph\nDescription: [Returns graph from adjacency data format.]\nField List: Parameters:: data : dict: Adjacency list formatted graph data\ndirected : bool: If True, and direction not specified in data, return a directed graph.\nmultigraph : bool: If True, and multigraph not specified in data, return a multigraph.\nattrs : dict: A dictionary that contains two keys ‘id’ and ‘key’. The corresponding\nvalues provide the attribute names for storing NetworkX-internal graph\ndata. The values should be unique. Default value:dict(id='id',key='key').\nReturns:: G : NetworkX graph: A NetworkX graph object\nMethods: []\nRubrics: Notes: The default value of attrs will be changed in a future release of NetworkX.\nExamples: fromnetworkx.readwriteimportjson_graph\nG=nx.Graph([(1,2)])\ndata=json_graph.adjacency_data(G)\nH=json_graph.adjacency_graph(data)",
    "Section ID: edge_betweenness_partition\nDescription: [Partition created by iteratively removing the highest edge betweenness edge., This algorithm works by calculating the edge betweenness for all\nedges and removing the edge with the highest value. It is then\ndetermined whether the graph has been broken into at least number_of_sets connected components.\nIf not the process is repeated.]\nField List: Parameters:: G : NetworkX Graph, DiGraph or MultiGraph: Graph to be partitioned\nnumber_of_sets : int: Number of sets in the desired partition of the graph\nweight : key, optional, default=None: The key to use if using weights for edge betweenness calculation\nReturns:: C : list of sets: Partition of the nodes of G\nRaises:: NetworkXError: If number_of_sets is <= 0 or if number_of_sets > len(G)\nMethods: []\nRubrics: Notes: This algorithm is fairly slow, as both the calculation of connected\ncomponents and edge betweenness relies on all pairs shortest\npath algorithms. They could potentially be combined to cut down\non overall computation time.\nReferences: [1]Santo Fortunato ‘Community Detection in Graphs’ Physical Reports\nVolume 486, Issue 3-5 p. 75-174http://arxiv.org/abs/0906.0612\nExamples: G=nx.karate_club_graph()\npart=nx.community.edge_betweenness_partition(G,2)\n{0,1,3,4,5,6,7,10,11,12,13,16,17,19,21}inpart\n# True\n{2,8,9,14,15,18,20,22,23,24,25,26,27,28,29,30,31,32,33}inpart\n# True",
    "Section ID: minimum_spanning_edges\nDescription: [Generate edges in a minimum spanning forest of an undirected\nweighted graph., A minimum spanning tree is a subgraph of the graph (a tree)\nwith the minimum sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph.]\nField List: Parameters:: G : undirected Graph: An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.\nalgorithm : string: The algorithm to use when finding a minimum spanning tree. Valid\nchoices are ‘kruskal’, ‘prim’, or ‘boruvka’. The default is ‘kruskal’.\nweight : string: Edge data key to use for weight (default ‘weight’).\nkeys : bool: Whether to yield edge key in multigraphs in addition to the edge.\nIfGis not a multigraph, this is ignored.\ndata : bool, optional: If True yield the edge data along with the edge.\nignore_nan : bool (default: False): If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead.\nReturns:: edges : iterator: An iterator over edges in a maximum spanning tree ofG.\nEdges connecting nodesuandvare represented as tuples:(u,v,k,d)or(u,v,k)or(u,v,d)or(u,v)IfGis a multigraph,keysindicates whether the edge keykwill\nbe reported in the third position in the edge tuple.dataindicates\nwhether the edge datadictdwill appear at the end of the edge tuple.IfGis not a multigraph, the tuples are(u,v,d)ifdatais True\nor(u,v)ifdatais False.\nMethods: []\nRubrics: Notes: For Borůvka’s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. Modified code from David Eppstein, April 2006 http://www.ics.uci.edu/~eppstein/PADS/\nExamples: fromnetworkx.algorithmsimporttree\nFind minimum spanning edges by Kruskal’s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.minimum_spanning_edges(G,algorithm=\"kruskal\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [1, 2], [2, 3]]\nFind minimum spanning edges by Prim’s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.minimum_spanning_edges(G,algorithm=\"prim\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [1, 2], [2, 3]]",
    "Section ID: generate_pajek\nDescription: [Generate lines in Pajek graph format.]\nField List: Parameters:: G : graph: A Networkx graph\nMethods: []\nRubrics: References: See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information.",
    "Section ID: write_pajek\nDescription: [Write graph in Pajek format to path.]\nField List: Parameters:: G : graph: A Networkx graph\npath : file or string: File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed.\nMethods: []\nRubrics: References: See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information.\nExamples: G=nx.path_graph(4)\nnx.write_pajek(G,\"test.net\")",
    "Section ID: AtlasView\nDescription: [An AtlasView is a Read-only Mapping of Mappings., It is a View into a dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter level is read-only.]\nField List: Methods: []\nRubrics:",
    "Section ID: diameter\nDescription: [Returns a lower bound on the diameter of the graph G., The function computes a lower bound on the diameter (i.e., the maximum eccentricity)\nof a directed or undirected graph G. The procedure used varies depending on the graph\nbeing directed or not., If G is an undirected graph, then the function uses the 2-sweep algorithm [1] .\nThe main idea is to pick the farthest node from a random node and return its eccentricity., Otherwise, if G is a directed graph, the function uses the 2-dSweep algorithm [2] ,\nThe procedure starts by selecting a random source node \\(s\\) from which it performs a\nforward and a backward BFS. Let \\(a_1\\) and \\(a_2\\) be the farthest nodes in the forward and\nbackward cases, respectively. Then, it computes the backward eccentricity of \\(a_1\\) using\na backward BFS and the forward eccentricity of \\(a_2\\) using a forward BFS.\nFinally, it returns the best lower bound between the two., In both cases, the time complexity is linear with respect to the size of G.]\nField List: Parameters:: G : NetworkX graph: \nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: d : integer: Lower Bound on the Diameter of G\nRaises:: NetworkXError: If the graph is empty or\nIf the graph is undirected and not connected or\nIf the graph is directed and not strongly connected.\nMethods: []\nRubrics: References: [1]Magnien, Clémence, Matthieu Latapy, and Michel Habib.Fast computation of empirically tight bounds for the diameter of massive graphs.Journal of Experimental Algorithmics (JEA), 2009.https://arxiv.org/pdf/0904.2728.pdf  [2]Crescenzi, Pierluigi, Roberto Grossi, Leonardo Lanzi, and Andrea Marino.On computing the diameter of real-world directed (weighted) graphs.International Symposium on Experimental Algorithms. Springer, Berlin, Heidelberg, 2012.https://courses.cs.ut.ee/MTAT.03.238/2014_fall/uploads/Main/diameter.pdf\nExamples: G=nx.path_graph(10)# undirected graph\nnx.diameter(G)\n# 9\nG=nx.cycle_graph(3,create_using=nx.DiGraph)# directed graph\nnx.diameter(G)\n# 2",
    "Section ID: uniform_random_intersection_graph\nDescription: [Returns a uniform random intersection graph.]\nField List: Parameters:: n : int: The number of nodes in the first bipartite set (nodes)\nm : int: The number of nodes in the second bipartite set (attributes)\np : float: Probability of connecting nodes between bipartite sets\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: References: [1]K.B. Singer-Cohen, Random Intersection Graphs, 1995,\nPhD thesis, Johns Hopkins University  [2]Fill, J. A., Scheinerman, E. R., and Singer-Cohen, K. B.,\nRandom intersection graphs when m = !(n):\nAn equivalence theorem relating the evolution of the g(n, m, p)\nand g(n, p) models. Random Struct. Algorithms 16, 2 (2000), 156–176.",
    "Section ID: SpanningTreeIterator\nDescription: [Iterate over all spanning trees of a graph in either increasing or\ndecreasing cost., Notes, This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges) as well as a modified Kruskal’s Algorithm\nto generate minimum spanning trees which respect the partition of edges.\nFor spanning trees with the same weight, ties are broken arbitrarily., References]\nField List: Parameters:: G : nx.Graph: The directed graph which we need to iterate trees over\nweight : String, default = “weight”: The edge attribute used to store the weight of the edge\nminimum : bool, default = True: Return the trees in increasing order while true and decreasing order\nwhile false.\nignore_nan : bool, default = False: If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead.\nMethods: []\nRubrics: Notes: This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges) as well as a modified Kruskal’s Algorithm\nto generate minimum spanning trees which respect the partition of edges.\nFor spanning trees with the same weight, ties are broken arbitrarily.\nReferences: [1]G.K. Janssens, K. Sörensen, An algorithm to generate all spanning\ntrees in order of increasing cost, Pesquisa Operacional, 2005-08,\nVol. 25 (2), p. 219-229,https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en",
    "Section ID: estrada_index\nDescription: [Returns the Estrada index of a the graph G., The Estrada Index is a topological index of folding or 3D “compactness” ( [1] ).]\nField List: Parameters:: G: graph:\nReturns:: estrada index: float:\nRaises:: NetworkXError: If the graph is not undirected and simple.\nMethods: []\nRubrics: Notes: Let G=(V,E) be a simple undirected graph with n nodes  and let lambda_{1}leqlambda_{2}leqcdotslambda_{n} be a non-increasing ordering of the eigenvalues of its adjacency\nmatrix A . The Estrada index is ( [1] , [2] )\nReferences: [1](1,2)E. Estrada, “Characterization of 3D molecular structure”,\nChem. Phys. Lett. 319, 713 (2000).https://doi.org/10.1016/S0009-2614(00)00158-5  [2]José Antonio de la Peñaa, Ivan Gutman, Juan Rada,\n“Estimating the Estrada index”,\nLinear Algebra and its Applications. 427, 1 (2007).https://doi.org/10.1016/j.laa.2007.06.020\nExamples: G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nei=nx.estrada_index(G)\nprint(f\"{ei:0.5}\")\n# 20.55",
    "Section ID: add_cycle\nDescription: [Add a cycle to the Graph G_to_add_to.]\nField List: Parameters:: G_to_add_to : graph: A NetworkX graph\nnodes_for_cycle: iterable container: A container of nodes.  A cycle will be constructed from\nthe nodes (in order) and added to the graph.\nattr : keyword arguments, optional (default= no attributes): Attributes to add to every edge in cycle.\nMethods: []\nRubrics: Examples: G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[10,11,12],weight=7)",
    "Section ID: random_degree_sequence_graph\nDescription: [Returns a simple random graph with the given degree sequence., If the maximum degree \\(d_m\\) in the sequence is \\(O(m^{1/4})\\) then the\nalgorithm produces almost uniform random graphs in \\(O(m d_m)\\) time\nwhere \\(m\\) is the number of edges.]\nField List: Parameters:: sequence : list of integers: Sequence of degrees\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ntries : int, optional: Maximum number of tries to create a graph\nReturns:: G : Graph: A graph with the specified degree sequence.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in the sequence.\nRaises:: NetworkXUnfeasible: If the degree sequence is not graphical.\nNetworkXError: If a graph is not produced in specified number of tries\nMethods: []\nRubrics: Notes: The generator algorithm [1] is not guaranteed to produce a graph.\nReferences: [1]Moshen Bayati, Jeong Han Kim, and Amin Saberi,\nA sequential algorithm for generating random graphs.\nAlgorithmica, Volume 58, Number 4, 860-910,\nDOI: 10.1007/s00453-009-9340-1\nExamples: sequence=[1,2,2,3]\nG=nx.random_degree_sequence_graph(sequence,seed=42)\nsorted(dforn,dinG.degree())\n# [1, 2, 2, 3]",
    "Section ID: all_simple_paths\nDescription: [Generate all simple paths in the graph G from source to target., A simple path is a path with no repeated nodes.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path\ntarget : nodes: Single node or iterable of nodes at which to end path\ncutoff : integer, optional: Depth to stop the search. Only paths of length <= cutoff are returned.\nReturns:: path_generator: generator: A generator that produces lists of simple paths.  If there are no paths\nbetween the source and target within the given cutoff the generator\nproduces no output. If it is possible to traverse the same sequence of\nnodes in multiple ways, namely through parallel edges, then it will be\nreturned multiple times (once for each viable edge combination).\nMethods: []\nRubrics: Notes: This algorithm uses a modified depth-first search to generate the\npaths [1] .  A single path can be found in \\(O(V+E)\\) time but the\nnumber of simple paths in a graph can be very large, e.g. \\(O(n!)\\) in\nthe complete graph of order \\(n\\) . This function does not check that a path exists between source and target . For large graphs, this may result in very long runtimes.\nConsider using has_path to check that a path exists between source and target before calling this function on large graphs.\nReferences: [1]R. Sedgewick, “Algorithms in C, Part 5: Graph Algorithms”,\nAddison Wesley Professional, 3rd ed., 2001.\nExamples: This iterator generates lists of nodes:\nG=nx.complete_graph(4)\nforpathinnx.all_simple_paths(G,source=0,target=3):\nprint(path)\n\n# [0, 1, 2, 3]\n# [0, 1, 3]\n# [0, 2, 1, 3]\n# [0, 2, 3]\n# [0, 3]\nYou can generate only those paths that are shorter than a certain\nlength by using thecutoffkeyword argument:\npaths=nx.all_simple_paths(G,source=0,target=3,cutoff=2)\nprint(list(paths))\n# [[0, 1, 3], [0, 2, 3], [0, 3]]\nTo get each path as the corresponding list of edges, you can use thenetworkx.utils.pairwise()helper function:\npaths=nx.all_simple_paths(G,source=0,target=3)\nforpathinmap(nx.utils.pairwise,paths):\nprint(list(path))\n# [(0, 1), (1, 2), (2, 3)]\n# [(0, 1), (1, 3)]\n# [(0, 2), (2, 1), (1, 3)]\n# [(0, 2), (2, 3)]\n# [(0, 3)]\nPass an iterable of nodes as target to generate all paths ending in any of several nodes:\nG=nx.complete_graph(4)\nforpathinnx.all_simple_paths(G,source=0,target=[3,2]):\nprint(path)\n\n# [0, 1, 2]\n# [0, 1, 2, 3]\n# [0, 1, 3]\n# [0, 1, 3, 2]\n# [0, 2]\n# [0, 2, 1, 3]\n# [0, 2, 3]\n# [0, 3]\n# [0, 3, 1, 2]\n# [0, 3, 2]\nThe singleton path fromsourceto itself is considered a simple path and is\nincluded in the results:\nG=nx.empty_graph(5)\nlist(nx.all_simple_paths(G,source=0,target=0))\n# [[0]]\nG=nx.path_graph(3)\nlist(nx.all_simple_paths(G,source=0,target={0,1,2}))\n# [[0], [0, 1], [0, 1, 2]]\nIterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph using a functional programming approach:\nfromitertoolsimportchain\nfromitertoolsimportproduct\nfromitertoolsimportstarmap\nfromfunctoolsimportpartial\n\nchaini=chain.from_iterable\n\nG=nx.DiGraph([(0,1),(1,2),(0,3),(3,2)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=(vforv,dinG.out_degree()ifd==0)\nall_paths=partial(nx.all_simple_paths,G)\nlist(chaini(starmap(all_paths,product(roots,leaves))))\n# [[0, 1, 2], [0, 3, 2]]\nThe same list computed using an iterative approach:\nG=nx.DiGraph([(0,1),(1,2),(0,3),(3,2)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=(vforv,dinG.out_degree()ifd==0)\nall_paths=[]\nforrootinroots:\nforleafinleaves:\npaths=nx.all_simple_paths(G,root,leaf)\nall_paths.extend(paths)\nall_paths\n# [[0, 1, 2], [0, 3, 2]]\nIterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph passing all leaves together to avoid unnecessary\ncompute:\nG=nx.DiGraph([(0,1),(2,1),(1,3),(1,4)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=[vforv,dinG.out_degree()ifd==0]\nall_paths=[]\nforrootinroots:\npaths=nx.all_simple_paths(G,root,leaves)\nall_paths.extend(paths)\nall_paths\n# [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]\nIf parallel edges offer multiple ways to traverse a given sequence of\nnodes, this sequence of nodes will be returned multiple times:\nG=nx.MultiDiGraph([(0,1),(0,1),(1,2)])\nlist(nx.all_simple_paths(G,0,2))\n# [[0, 1, 2], [0, 1, 2]]",
    "Section ID: overlap_weighted_projected_graph\nDescription: [Overlap weighted projection of B onto one of its node sets., The overlap weighted projection is the projection of the bipartite\nnetwork B onto the specified nodes with weights representing\nthe Jaccard index between the neighborhoods of the two nodes in the\noriginal bipartite network [1] :, or if the parameter ‘jaccard’ is False, the fraction of common\nneighbors by minimum of both nodes degree in the original\nbipartite graph [1] :, The nodes retain their attributes and are connected in the resulting\ngraph if have an edge to a common node in the original bipartite graph.]\nField List: Parameters:: B : NetworkX graph: The input graph should be bipartite.\nnodes : list or iterable: Nodes to project onto (the “bottom” nodes).\njaccard: Bool (default=True):\nReturns:: Graph : NetworkX graph: A graph that is the projection onto the given nodes.\nMethods: []\nRubrics: Notes: No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nReferences: [1](1,2)Borgatti, S.P. and Halgin, D. In press. Analyzing Affiliation\nNetworks. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.\nExamples: fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(5)\nnodes=[0,2,4]\nG=bipartite.overlap_weighted_projected_graph(B,nodes)\nlist(G)\n# [0, 2, 4]\nlist(G.edges(data=True))\n# [(0, 2, {'weight': 0.5}), (2, 4, {'weight': 0.5})]\nG=bipartite.overlap_weighted_projected_graph(B,nodes,jaccard=False)\nlist(G.edges(data=True))\n# [(0, 2, {'weight': 1.0}), (2, 4, {'weight': 1.0})]",
    "Section ID: reciprocity\nDescription: [Compute the reciprocity in a directed graph., The reciprocity of a directed graph is defined as the ratio\nof the number of edges pointing in both directions to the total\nnumber of edges in the graph.\nFormally, \\(r = |{(u,v) \\in G|(v,u) \\in G}| / |{(u,v) \\in G}|\\) ., The reciprocity of a single node u is defined similarly,\nit is the ratio of the number of edges in both directions to\nthe total number of edges attached to node u.]\nField List: Parameters:: G : graph: A networkx directed graph\nnodes : container of nodes, optional (default=whole graph): Compute reciprocity for nodes in this container.\nReturns:: out : dictionary: Reciprocity keyed by node label.\nMethods: []\nRubrics: Notes: The reciprocity is not defined for isolated nodes.\nIn such cases this function will return None.",
    "Section ID: articulation_points\nDescription: [Yield the articulation points, or cut vertices, of a graph., An articulation point or cut vertex is any node whose removal (along with\nall its incident edges) increases the number of connected components of\na graph.  An undirected connected graph without articulation points is\nbiconnected. Articulation points belong to more than one biconnected\ncomponent of a graph., Notice that by convention a dyad is considered a biconnected component.]\nField List: Parameters:: G : NetworkX Graph: An undirected graph.\nYields:: node: An articulation point in the graph.\nRaises:: NetworkXNotImplemented: If the input graph is not undirected.\nMethods: []\nRubrics: Notes: The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.\nReferences: [1]Hopcroft, J.; Tarjan, R. (1973).\n“Efficient algorithms for graph manipulation”.\nCommunications of the ACM 16: 372–378. doi:10.1145/362248.362272\nExamples: G=nx.barbell_graph(4,2)\nprint(nx.is_biconnected(G))\n# False\nlen(list(nx.articulation_points(G)))\n# 4\nG.add_edge(2,8)\nprint(nx.is_biconnected(G))\n# True\nlen(list(nx.articulation_points(G)))\n# 0",
    "Section ID: all_neighbors\nDescription: [Returns all of the neighbors of a node in the graph., If the graph is directed returns predecessors as well as successors.]\nField List: Parameters:: graph : NetworkX graph: Graph to find neighbors.\nnode : node: The node whose neighbors will be returned.\nReturns:: neighbors : iterator: Iterator of neighbors\nMethods: []\nRubrics:",
    "Section ID: newman_watts_strogatz_graph\nDescription: [Returns a Newman–Watts–Strogatz small-world graph.]\nField List: Parameters:: n : int: The number of nodes.\nk : int: Each node is joined with itsknearest neighbors in a ring\ntopology.\np : float: The probability of adding a new edge for each edge.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: Notes: First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is\nconnected with its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).  Then shortcuts are created by adding new edges as follows: for\neach edge \\((u, v)\\) in the underlying “ \\(n\\) -ring with \\(k\\) nearest\nneighbors” with probability \\(p\\) add a new edge \\((u, w)\\) with\nrandomly-chosen existing node \\(w\\) .  In contrast with watts_strogatz_graph() , no edges are removed.\nReferences: [1]M. E. J. Newman and D. J. Watts,\nRenormalization group analysis of the small-world network model,\nPhysics Letters A, 263, 341, 1999.https://doi.org/10.1016/S0375-9601(99)00757-4",
    "Section ID: bellman_ford_predecessor_and_distance\nDescription: [Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs., The algorithm has a running time of \\(O(mn)\\) where \\(n\\) is the number of\nnodes and \\(m\\) is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights., If a negative cycle is detected, you can use find_negative_cycle() to return the cycle and examine it. Shortest paths are not defined when\na negative cycle exists because once reached, the path can cycle forever\nto build up arbitrarily low weights.]\nField List: Parameters:: G : NetworkX graph: The algorithm works for all types of graphs, including directed\ngraphs and multigraphs.\nsource: node label: Starting node for path\ntarget : node label, optional: Ending node for path\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nheuristic : bool: Determines whether to use a heuristic to early detect negative\ncycles at a hopefully negligible cost.\nReturns:: pred, dist : dictionaries: Returns two dictionaries keyed by node to predecessor in the\npath and to the distance from the source respectively.\nRaises:: NodeNotFound: Ifsourceis not inG.\nNetworkXUnbounded: If the (di)graph contains a negative (di)cycle, the\nalgorithm raises an exception to indicate the presence of the\nnegative (di)cycle.  Note: any negative weight edge in an\nundirected graph is a negative cycle.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionaries returned only have keys for nodes reachable from\nthe source. In the case where the (di)graph is not connected, if a component\nnot containing the source contains a negative (di)cycle, it\nwill not be detected. In NetworkX v2.1 and prior, the source node had predecessor [None] .\nIn NetworkX v2.2 this changed to the source node having predecessor []\nExamples: G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.bellman_ford_predecessor_and_distance(G,0)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\npred,dist=nx.bellman_ford_predecessor_and_distance(G,0,1)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\nG=nx.cycle_graph(5,create_using=nx.DiGraph())\nG[1][2][\"weight\"]=-7\nnx.bellman_ford_predecessor_and_distance(G,0)Traceback (most recent call last):    ...networkx.exception.NetworkXUnboundedNegative cycle detected.",
    "Section ID: eccentricity\nDescription: [Returns the eccentricity of nodes in G., The eccentricity of a node v is the maximum distance from v to\nall other nodes in G.]\nField List: Parameters:: G : NetworkX graph: A graph\nv : node, optional: Return value of specified node\nsp : dict of dicts, optional: All pairs shortest path lengths as a dictionary of dictionaries\nweight : string, function, or None (default=None): If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances.\nReturns:: ecc : dictionary: A dictionary of eccentricity values keyed by node.\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\ndict(nx.eccentricity(G))\n# {1: 2, 2: 3, 3: 2, 4: 2, 5: 3}\ndict(nx.eccentricity(G,v=[1,5]))# This returns the eccentricity of node 1 & 5\n# {1: 2, 5: 3}",
    "Section ID: UnionMultiInner\nDescription: [A read-only union of two inner dicts of MultiAdjacencies., The two input dict-of-dict-of-dicts represent the union of G.succ[node] and G.pred[node] for MultiDiGraphs.\nReturn values are UnionAtlas.\nThe inner level of dict is read-write. But the outer levels are read-only.]\nField List: Methods: []\nRubrics:",
    "Section ID: generalized_degree\nDescription: [Compute the generalized degree for nodes., For each node, the generalized degree shows how many edges of given\ntriangle multiplicity the node is connected to. The triangle multiplicity\nof an edge is the number of triangles an edge participates in. The\ngeneralized degree of node \\(i\\) can be written as a vector \\(\\mathbf{k}_i=(k_i^{(0)}, \\dotsc, k_i^{(N-2)})\\) where \\(k_i^{(j)}\\) is the number of edges attached to node \\(i\\) that\nparticipate in \\(j\\) triangles.]\nField List: Parameters:: G : graph: \nnodes : container of nodes, optional (default=all nodes in G): Compute the generalized degree for nodes in this container.\nReturns:: out : Counter, or dictionary of Counters: Generalized degree of specified nodes. The Counter is keyed by edge\ntriangle multiplicity.\nMethods: []\nRubrics: Notes: Self loops are ignored. In a network of N nodes, the highest triangle multiplicity an edge can have\nis N-2. The return value does not include a zero entry if no edges of a\nparticular triangle multiplicity are present. The number of triangles node \\(i\\) is attached to can be recovered from\nthe generalized degree \\(\\mathbf{k}_i=(k_i^{(0)}, \\dotsc,\nk_i^{(N-2)})\\) by \\((k_i^{(1)}+2k_i^{(2)}+\\dotsc +(N-2)k_i^{(N-2)})/2\\) .\nReferences: [1]Networks with arbitrary edge multiplicities by V. Zlatić,\nD. Garlaschelli and G. Caldarelli, EPL (Europhysics Letters),\nVolume 97, Number 2 (2012).https://iopscience.iop.org/article/10.1209/0295-5075/97/28005\nExamples: G=nx.complete_graph(5)\nprint(nx.generalized_degree(G,0))\n# Counter({3: 4})\nprint(nx.generalized_degree(G))\n# {0: Counter({3: 4}), 1: Counter({3: 4}), 2: Counter({3: 4}), 3: Counter({3: 4}), 4: Counter({3: 4})}\nTo recover the number of triangles attached to a node:\nk1=nx.generalized_degree(G,0)\nsum([k*vfork,vink1.items()])/2==nx.triangles(G,0)\n# True",
    "Section ID: number_of_edges\nDescription: [Returns the number of edges in the graph., This function wraps the G.number_of_edges function.]\nField List: Methods: []\nRubrics:",
    "Section ID: read_graphml\nDescription: [Read graph in GraphML format from path.]\nField List: Parameters:: path : file or string: File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed.\nnode_type: Python type (default: str): Convert node ids to this type\nedge_key_type: Python type (default: int): Convert graphml edge ids to this type. Multigraphs use id as edge key.\nNon-multigraphs add to edge attribute dict with name “id”.\nforce_multigraph : bool (default: False): If True, return a multigraph with edge keys. If False (the default)\nreturn a multigraph when multiedges are in the graph.\nReturns:: graph: NetworkX graph: If parallel edges are present orforce_multigraph=Truethen\na MultiGraph or MultiDiGraph is returned. Otherwise a Graph/DiGraph.\nThe returned graph is directed if the file indicates it should be.\nMethods: []\nRubrics: Notes: Default node and edge attributes are not propagated to each node and edge.\nThey can be obtained from G.graph and applied to node and edge attributes\nif desired using something like this:",
    "Section ID: draw_random\nDescription: [Draw the graph G with a random layout., This is a convenience function equivalent to:]\nField List: Parameters:: G : graph: A networkx graph\nkwargs : optional keywords: Seedraw_networkxfor a description of optional keywords.\nMethods: []\nRubrics: Notes: The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call random_layout directly and reuse the result:\nExamples: G=nx.lollipop_graph(4,3)\nnx.draw_random(G)",
    "Section ID: average_clustering\nDescription: [Compute the average bipartite clustering coefficient., A clustering coefficient for the whole graph is the average,, where n is the number of nodes in G ., Similar measures for the two bipartite sets can be defined [1], where X is a bipartite set of G .]\nField List: Parameters:: G : graph: a bipartite graph\nnodes : list or iterable, optional: A container of nodes to use in computing the average.\nThe nodes should be either the entire graph (the default) or one of the\nbipartite sets.\nmode : string: The pairwise bipartite clustering method.\nIt must be “dot”, “max”, or “min”\nReturns:: clustering : float: The average bipartite clustering for the given set of nodes or the\nentire graph if no nodes are specified.\nMethods: []\nRubrics: Notes: The container of nodes passed to this function must contain all of the nodes\nin one of the bipartite sets (“top” or “bottom”) in order to compute\nthe correct average bipartite clustering coefficients.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nReferences: [1]Latapy, Matthieu, Clémence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31–48.\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.star_graph(3)# star graphs are bipartite\nbipartite.average_clustering(G)\n# 0.75\nX,Y=bipartite.sets(G)\nbipartite.average_clustering(G,X)\n# 0.0\nbipartite.average_clustering(G,Y)\n# 1.0",
    "Section ID: astar_path\nDescription: [Returns a list of nodes in a shortest path between source and target\nusing the A* (“A-star”) algorithm., There may be more than one shortest path.  This returns only one.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path\ntarget : node: Ending node for path\nheuristic : function: A function to evaluate the estimate of the distance\nfrom the a node to the target.  The function takes\ntwo nodes arguments and must return a number.\nIf the heuristic is inadmissible (if it might\noverestimate the cost of reaching the goal from a node),\nthe result may not be a shortest path.\nThe algorithm does not support updating heuristic\nvalues for the same node due to caching the first\nheuristic calculation per node.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\ncutoff : float, optional: If this is provided, the search will be bounded to this value. I.e. if\nthe evaluation function surpasses this value for a node n, the node will not\nbe expanded further and will be ignored. More formally, let h’(n) be the\nheuristic function, and g(n) be the cost of reaching n from the source node. Then,\nif g(n) + h’(n) > cutoff, the node will not be explored further.\nNote that if the heuristic is inadmissible, it is possible that paths\nare ignored even though they satisfy the cutoff.\nRaises:: NetworkXNoPath: If no path exists between source and target.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.\nExamples: G=nx.path_graph(5)\nprint(nx.astar_path(G,0,4))\n# [0, 1, 2, 3, 4]\nG=nx.grid_graph(dim=[3,3])# nodes are two-tuples (x,y)\nnx.set_edge_attributes(G,{e:e[1][0]*2foreinG.edges()},\"cost\")\ndefdist(a,b):\n(x1,y1)=a\n(x2,y2)=b\nreturn((x1-x2)**2+(y1-y2)**2)**0.5\nprint(nx.astar_path(G,(0,0),(2,2),heuristic=dist,weight=\"cost\"))\n# [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]",
    "Section ID: eigenvector_centrality\nDescription: [Compute the eigenvector centrality for the graph G., Eigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node \\(i\\) is the \\(i\\) -th element of a left eigenvector associated with the eigenvalue \\(\\lambda\\) of maximum modulus that is positive. Such an eigenvector \\(x\\) is\ndefined up to a multiplicative constant by the equation, where \\(A\\) is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to, That is, adding the eigenvector centralities of the predecessors of \\(i\\) one obtains the eigenvector centrality of \\(i\\) multiplied by \\(\\lambda\\) . In the case of undirected graphs, \\(x\\) also solves the familiar\nright-eigenvector equation \\(Ax = \\lambda x\\) ., By virtue of the Perron–Frobenius theorem [1] , if G is strongly\nconnected there is a unique eigenvector \\(x\\) , and all its entries\nare strictly positive., If G is not strongly connected there might be several left\neigenvectors associated with \\(\\lambda\\) , and some of their elements\nmight be zero.]\nField List: Parameters:: G : graph: A networkx graph.\nmax_iter : integer, optional (default=100): Maximum number of power iterations.\ntol : float, optional (default=1.0e-6): Error tolerance (in Euclidean norm) used to check convergence in\npower iteration.\nnstart : dictionary, optional (default=None): Starting value of power iteration for each node. Must have a nonzero\nprojection on the desired eigenvector for the power method to converge.\nIf None, this implementation uses an all-ones vector, which is a safe\nchoice.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal. Otherwise holds the\nname of the edge attribute used as weight. In this measure the\nweight is interpreted as the connection strength.\nReturns:: nodes : dictionary: Dictionary of nodes with eigenvector centrality as the value. The\nassociated vector has unit Euclidean norm and the values are\nnonegative.\nRaises:: NetworkXPointlessConcept: If the graph G is the null graph.\nNetworkXError: If each value innstartis zero.\nPowerIterationFailedConvergence: If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod.\nMethods: []\nRubrics: Notes: Eigenvector centrality was introduced by Landau [2] for chess\ntournaments. It was later rediscovered by Wei [3] and then\npopularized by Kendall [4] in the context of sport ranking. Berge\nintroduced a general definition for graphs based on social connections [5] . Bonacich [6] reintroduced again eigenvector centrality and made\nit popular in link analysis. This function computes the left dominant eigenvector, which corresponds\nto adding the centrality of predecessors: this is the usual approach.\nTo add the centrality of successors first reverse the graph with G.reverse() . The implementation uses power iteration [7] to compute a dominant\neigenvector starting from the provided vector nstart . Convergence is\nguaranteed as long as nstart has a nonzero projection on a dominant\neigenvector, which certainly happens using the default value. The method stops when the change in the computed vector between two\niterations is smaller than an error tolerance of G.number_of_nodes()*tol or after max_iter iterations, but in the second case it\nraises an exception. This implementation uses \\((A + I)\\) rather than the adjacency matrix \\(A\\) because the change preserves eigenvectors, but it shifts the\nspectrum, thus guaranteeing convergence even for networks with\nnegative eigenvalues of maximum modulus.\nReferences: [1]Abraham Berman and Robert J. Plemmons.\n“Nonnegative Matrices in the Mathematical Sciences.”\nClassics in Applied Mathematics. SIAM, 1994.  [2]Edmund Landau.\n“Zur relativen Wertbemessung der Turnierresultate.”\nDeutsches Wochenschach, 11:366–369, 1895.  [3]Teh-Hsing Wei.\n“The Algebraic Foundations of Ranking Theory.”\nPhD thesis, University of Cambridge, 1952.  [4]Maurice G. Kendall.\n“Further contributions to the theory of paired comparisons.”\nBiometrics, 11(1):43–62, 1955.https://www.jstor.org/stable/3001479  [5]Claude Berge\n“Théorie des graphes et ses applications.”\nDunod, Paris, France, 1958.  [6]Phillip Bonacich.\n“Technique for analyzing overlapping memberships.”\nSociological Methodology, 4:176–185, 1972.https://www.jstor.org/stable/270732  [7]Power iteration::https://en.wikipedia.org/wiki/Power_iteration\nExamples: G=nx.path_graph(4)\ncentrality=nx.eigenvector_centrality(G)\nsorted((v,f\"{c:0.2f}\")forv,cincentrality.items())\n# [(0, '0.37'), (1, '0.60'), (2, '0.60'), (3, '0.37')]",
    "Section ID: diameter\nDescription: [Returns the diameter of the graph G., The diameter is the maximum eccentricity.]\nField List: Parameters:: G : NetworkX graph: A graph\ne : eccentricity dictionary, optional: A precomputed dictionary of eccentricities.\nweight : string, function, or None: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances.\nReturns:: d : integer: Diameter of graph\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.diameter(G)\n# 3",
    "Section ID: modularity_spectrum\nDescription: [Returns eigenvalues of the modularity matrix of G.]\nField List: Parameters:: G : Graph: A NetworkX Graph or DiGraph\nReturns:: evals : NumPy array: Eigenvalues\nMethods: []\nRubrics: References: [1]M. E. J. Newman, “Modularity and community structure in networks”,\nProc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006.",
    "Section ID: induced_subgraph\nDescription: [Returns a SubGraph view of G showing only nodes in nbunch., The induced subgraph of a graph on a set of nodes N is the\ngraph with nodes N and edges from G which have both ends in N.]\nField List: Parameters:: G : NetworkX Graph: \nnbunch : node, container of nodes or None (for all nodes):\nReturns:: subgraph : SubGraph View: A read-only view of the subgraph inGinduced by the nodes.\nChanges to the graphGwill be reflected in the view.\nMethods: []\nRubrics: Notes: To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) For an inplace reduction of a graph to a subgraph you can remove nodes: G.remove_nodes_from(ninGifnnotinset(nbunch)) If you are going to compute subgraphs of your subgraphs you could\nend up with a chain of views that can be very slow once the chain\nhas about 15 views in it. If they are all induced subgraphs, you\ncan short-cut the chain by making them all subgraphs of the original\ngraph. The graph class method G.subgraph does this when G is\na subgraph. In contrast, this function allows you to choose to build\nchains or not, as you wish. The returned subgraph is a view on G .\nExamples: G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=nx.induced_subgraph(G,[0,1,3])\nlist(H.edges)\n# [(0, 1)]\nlist(H.nodes)\n# [0, 1, 3]",
    "Section ID: sigma\nDescription: [Returns the small-world coefficient (sigma) of the given graph., The small-world coefficient is defined as:\nsigma = C/Cr / L/Lr\nwhere C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Cr and Lr are respectively the average\nclustering coefficient and average shortest path length of an equivalent\nrandom graph., A graph is commonly classified as small-world if sigma>1.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nniter : integer (optional, default=100): Approximate number of rewiring per edge to compute the equivalent\nrandom graph.\nnrand : integer (optional, default=10): Number of random graphs generated to compute the average clustering\ncoefficient (Cr) and average shortest path length (Lr).\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: sigma : float: The small-world coefficient of G.\nMethods: []\nRubrics: Notes: The implementation is adapted from Humphries et al. [1]  [2] .\nReferences: [1]The brainstem reticular formation is a small-world, not scale-free,\nnetwork M. D. Humphries, K. Gurney and T. J. Prescott,\nProc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.  [2]Humphries and Gurney (2008).\n“Network ‘Small-World-Ness’: A Quantitative Method for Determining\nCanonical Network Equivalence”.\nPLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.",
    "Section ID: erdos_renyi_graph\nDescription: [Returns a \\(G_{n,p}\\) random graph, also known as an Erdős-Rényi graph\nor a binomial graph., The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) .]\nField List: Parameters:: n : int: The number of nodes.\np : float: Probability for edge creation.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : bool, optional (default=False): If True, this function returns a directed graph.\nMethods: []\nRubrics: Notes: This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .\nReferences: [1]Erdős and A. Rényi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).",
    "Section ID: draw_planar\nDescription: [Draw a planar networkx graph G with planar layout., This is a convenience function equivalent to:]\nField List: Parameters:: G : graph: A planar networkx graph\nkwargs : optional keywords: Seedraw_networkxfor a description of optional keywords.\nRaises:: NetworkXException: WhenGis not planar\nMethods: []\nRubrics: Notes: The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call planar_layout directly and reuse the result:\nExamples: G=nx.path_graph(4)\nnx.draw_planar(G)",
    "Section ID: to_directed\nDescription: [Returns a directed view of the graph graph ., Identical to graph.to_directed(as_view=True)\nNote that graph.to_directed defaults to as_view=False while this function always provides a view.]\nField List: Methods: []\nRubrics:",
    "Section ID: node_boundary\nDescription: [Returns the node boundary of nbunch1 ., The node boundary of a set S with respect to a set T is the\nset of nodes v in T such that for some u in S , there is an\nedge joining u to v . If T is not specified, it is assumed to\nbe the set of all nodes not in S .]\nField List: Parameters:: G : NetworkX graph: \nnbunch1 : iterable: Iterable of nodes in the graph representing the set of nodes\nwhose node boundary will be returned. (This is the setSfrom\nthe definition above.)\nnbunch2 : iterable: Iterable of nodes representing the target (or “exterior”) set of\nnodes. (This is the setTfrom the definition above.) If not\nspecified, this is assumed to be the set of all nodes inGnot innbunch1.\nReturns:: set: The node boundary ofnbunch1with respect tonbunch2.\nMethods: []\nRubrics: Notes: Any element of nbunch that is not in the graph G will be\nignored. nbunch1 and nbunch2 are usually meant to be disjoint, but in\nthe interest of speed and generality, that is not required here.\nExamples: G=nx.wheel_graph(6)\nWhen nbunch2=None:\nlist(nx.node_boundary(G,(3,4)))\n# [0, 2, 5]\nWhen nbunch2 is given:\nlist(nx.node_boundary(G,(3,4),(0,1,5)))\n# [0, 5]",
    "Section ID: metric_closure\nDescription: [Return the metric closure of a graph., The metric closure of a graph G is the complete graph in which each edge\nis weighted by the shortest path distance between the nodes in G .]\nField List: Parameters:: G : NetworkX graph:\nReturns:: NetworkX graph: Metric closure of the graphG.\nMethods: []\nRubrics:",
    "Section ID: find_negative_cycle\nDescription: [Returns a cycle with negative total weight if it exists., Bellman-Ford is used to find shortest_paths. That algorithm\nstops if there exists a negative cycle. This algorithm\npicks up from there and returns the found negative cycle., The cycle consists of a list of nodes in the cycle order. The last\nnode equals the first to make it a cycle.\nYou can look up the edge weights in the original graph. In the case\nof multigraphs the relevant edge is the minimal weight edge between\nthe nodes in the 2-tuple., If the graph has no negative cycle, a NetworkXError is raised.]\nField List: Parameters:: G : NetworkX graph: \nsource: node label: The search for the negative cycle will start from this node.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: cycle : list: A list of nodes in the order of the cycle found. The last node\nequals the first to indicate a cycle.\nRaises:: NetworkXError: If no negative cycle is found.\nMethods: []\nRubrics: Examples: G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,2),(1,2,2),(2,0,1),(1,4,2),(4,0,-5)])\nnx.find_negative_cycle(G,0)\n# [4, 0, 1, 4]",
    "Section ID: py_random_state\nDescription: [Decorator to generate a random.Random instance (or equiv)., This decorator processes random_state_argument using nx.utils.create_py_random_state() .\nThe input value can be a seed (integer), or a random number generator:]\nField List: Parameters:: random_state_argument : string or int: The name of the argument or the index of the argument in args that is\nto be converted to the random.Random instance or numpy.random.RandomState\ninstance that mimics basic methods of random.Random.\nReturns:: _random_state : function: Function whose random_state_argument is converted to a Random instance.\nMethods: []\nRubrics: Examples: Decorate functions like this:\n@py_random_state(\"random_state\")defrandom_float(random_state=None):returnrandom_state.rand()@py_random_state(0)defrandom_float(rng=None):returnrng.rand()@py_random_state(1)defrandom_array(dims,seed=12345):returnseed.rand(*dims)",
    "Section ID: NotATree\nDescription: []\nField List: Methods: []\nRubrics:",
    "Section ID: all_pairs_node_connectivity\nDescription: [Compute node connectivity between all pairs of nodes., Pairwise or local node connectivity between two distinct and nonadjacent\nnodes is the minimum number of nodes that must be removed (minimum\nseparating cutset) to disconnect them. By Menger’s theorem, this is equal\nto the number of node independent paths (paths that share no nodes other\nthan source and target). Which is what we compute in this function., This algorithm is a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs.]\nField List: Parameters:: G : NetworkX graph: \nnbunch: container: Container of nodes. If provided node connectivity will be computed\nonly over pairs of nodes in nbunch.\ncutoff : integer: Maximum node connectivity to consider. If None, the minimum degree\nof source or target is used as a cutoff in each pair of nodes.\nDefault value None.\nReturns:: K : dictionary: Dictionary, keyed by source and target, of pairwise node connectivity\nMethods: []\nRubrics: References: [1]White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf\nExamples: A 3 node cycle with one extra node attached has connectivity 2 between all\nnodes in the cycle and connectivity 1 between the extra node and the rest:\nG=nx.cycle_graph(3)\nG.add_edge(2,3)\nimportpprint# for nice dictionary formatting\npprint.pprint(nx.all_pairs_node_connectivity(G))\n# {0: {1: 2, 2: 2, 3: 1},\n#  1: {0: 2, 2: 2, 3: 1},\n#  2: {0: 2, 1: 2, 3: 1},\n#  3: {0: 1, 1: 1, 2: 1}}",
    "Section ID: google_matrix\nDescription: [Returns the Google matrix of the graph.]\nField List: Parameters:: G : graph: A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.\nalpha : float: The damping factor.\npersonalization: dict, optional: The “personalization vector” consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nweight : key, optional: Edge data key to use as weight.  If None weights are set to 1.\ndangling: dict, optional: The outedges to be assigned to any “dangling” nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified) This must be selected to result in an irreducible transition\nmatrix (see notes below). It may be common to have the dangling dict to\nbe the same as the personalization dict.\nReturns:: A : 2D NumPy ndarray: Google matrix of the graph\nMethods: []\nRubrics: Notes: The array returned represents the transition matrix that describes the\nMarkov chain used in PageRank. For PageRank to converge to a unique\nsolution (i.e., a unique stationary distribution in a Markov chain), the\ntransition matrix must be irreducible. In other words, it must be that\nthere exists a path between every pair of nodes in the graph, or else there\nis the potential of “rank sinks.” This implementation works with Multi(Di)Graphs. For multigraphs the\nweight between two nodes is set to be the sum of all edge weights\nbetween those nodes.",
    "Section ID: min_edge_cover\nDescription: [Returns the min cardinality edge cover of the graph as a set of edges., A smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered. This function follows that process. A maximum matching\nalgorithm can be specified for the first step of the algorithm.\nThe resulting set may return a set with one 2-tuple for each edge,\n(the usual case) or with both 2-tuples (u,v) and (v,u) for\neach edge. The latter is only done when a bipartite matching algorithm\nis specified as matching_algorithm .]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nmatching_algorithm : function: A function that returns a maximum cardinality matching forG.\nThe function must take one input, the graphG, and return\neither a set of edges (with only one direction for the pair of nodes)\nor a dictionary mapping each node to its mate. If not specified,max_weight_matching()is used.\nCommon bipartite matching functions includehopcroft_karp_matching()oreppstein_matching().\nReturns:: min_cover : set: A set of the edges in a minimum edge cover in the form of tuples.\nIt contains only one of the equivalent 2-tuples(u,v)and(v,u)for each edge. If a bipartite method is used to compute the matching,\nthe returned set contains both the 2-tuples(u,v)and(v,u)for each edge of a minimum edge cover.\nMethods: []\nRubrics: Notes: An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.\nThe minimum edge cover is an edge covering of smallest cardinality. Due to its implementation, the worst-case running time of this algorithm\nis bounded by the worst-case running time of the function matching_algorithm . Minimum edge cover for G can also be found using the min_edge_covering function in networkx.algorithms.bipartite.covering which is\nsimply this function with a default matching algorithm of hopcraft_karp_matching()\nExamples: G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nsorted(nx.min_edge_cover(G))\n# [(2, 1), (3, 0)]",
    "Section ID: is_directed\nDescription: [Return True if graph is directed.]\nField List: Methods: []\nRubrics:",
    "Section ID: bfs_successors\nDescription: [Returns an iterator of successors in breadth-first-search from source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Specify starting node for breadth-first search\ndepth_limit : int, optional(default=len(G)): Specify the maximum search depth\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: succ: iterator: (node, successors) iterator wheresuccessorsis the non-empty list of\nsuccessors ofnodein a breadth first search fromsource.\nTo appear in the iterator,nodemust have successors.\nMethods: []\nRubrics: Notes: Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004.The modifications\nto allow depth limits based on the Wikipedia article\n“ Depth-limited-search ”.\nExamples: G=nx.path_graph(3)\ndict(nx.bfs_successors(G,0))\n# {0: [1], 1: [2]}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(nx.bfs_successors(H,0))\n# {0: [1, 2], 1: [3, 4], 2: [5, 6]}\nG=nx.Graph()\nnx.add_path(G,[0,1,2,3,4,5,6])\nnx.add_path(G,[2,7,8,9,10])\ndict(nx.bfs_successors(G,source=1,depth_limit=3))\n# {1: [0, 2], 2: [3, 7], 3: [4], 7: [8]}\nG=nx.DiGraph()\nnx.add_path(G,[0,1,2,3,4,5])\ndict(nx.bfs_successors(G,source=3))\n# {3: [4], 4: [5]}",
    "Section ID: average_node_connectivity\nDescription: [Returns the average connectivity of a graph G., The average connectivity bar{kappa} of a graph G is the average\nof local node connectivity over all pairs of nodes of G [1] .]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. Seelocal_node_connectivity()for details. The choice of the default function may change from\nversion to version and should not be relied on. Default value: None.\nReturns:: K : float: Average node connectivity\nMethods: []\nRubrics: References: [1]Beineke, L., O. Oellermann, and R. Pippert (2002). The average\nconnectivity of a graph. Discrete mathematics 252(1-3), 31-45.http://www.sciencedirect.com/science/article/pii/S0012365X01001807",
    "Section ID: hexagonal_lattice_graph\nDescription: [Returns an m by n hexagonal lattice graph., The hexagonal lattice graph is a graph whose nodes and edges are\nthe hexagonal tiling of the plane., The returned graph will have m rows and n columns of hexagons. Odd numbered columns are shifted up relative to even numbered columns., Positions of nodes are computed by default or with_positionsisTrue .\nNode positions creating the standard embedding in the plane\nwith sidelength 1 and are stored in the node attribute ‘pos’. pos=nx.get_node_attributes(G,'pos') creates a dict ready for drawing.]\nField List: Parameters:: m : int: The number of rows of hexagons in the lattice.\nn : int: The number of columns of hexagons in the lattice.\nperiodic : bool: Whether to make a periodic grid by joining the boundary vertices.\nFor this to worknmust be even and bothn>1andm>1.\nThe periodic connections create another row and column of hexagons\nso these graphs have fewer nodes as boundary nodes are identified.\nwith_positions : bool (default: True): Store the coordinates of each node in the graph node attribute ‘pos’.\nThe coordinates provide a lattice with vertical columns of hexagons\noffset to interleave and cover the plane.\nPeriodic positions shift the nodes vertically in a nonlinear way so\nthe edges don’t overlap so much.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nIf graph is directed, edges will point up or right.\nReturns:: NetworkX graph: Thembynhexagonal lattice graph.\nMethods: []\nRubrics:",
    "Section ID: k_random_intersection_graph\nDescription: [Returns a intersection graph with randomly chosen attribute sets for\neach node that are of equal size (k).]\nField List: Parameters:: n : int: The number of nodes in the first bipartite set (nodes)\nm : int: The number of nodes in the second bipartite set (attributes)\nk : float: Size of attribute set to assign to each node.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: References: [1]Godehardt, E., and Jaworski, J.\nTwo models of random intersection graphs and their applications.\nElectronic Notes in Discrete Mathematics 10 (2001), 129–132.",
    "Section ID: nodes\nDescription: [Returns a NodeView over the graph nodes., This function wraps the G.nodes property.]\nField List: Methods: []\nRubrics:",
    "Section ID: subgraph_centrality_exp\nDescription: [Returns the subgraph centrality for each node of G., Subgraph centrality  of a node n is the sum of weighted closed\nwalks of all lengths starting and ending at node n . The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ( [1] ).]\nField List: Parameters:: G: graph:\nReturns:: nodes:dictionary: Dictionary of nodes with subgraph centrality as the value.\nRaises:: NetworkXError: If the graph is not undirected and simple.\nMethods: []\nRubrics: Notes: This version of the algorithm exponentiates the adjacency matrix. The subgraph centrality of a node u in G can be found using\nthe matrix exponential of the adjacency matrix of G [1] ,\nReferences: [1](1,2,3)Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n“Subgraph centrality in complex networks”,\nPhysical Review E 71, 056103 (2005).https://arxiv.org/abs/cond-mat/0504730\nExamples: (Example from[1])\n>>> G = nx.Graph(\n…     [\n…         (1, 2),\n…         (1, 5),\n…         (1, 8),\n…         (2, 3),\n…         (2, 8),\n…         (3, 4),\n…         (3, 6),\n…         (4, 5),\n…         (4, 7),\n…         (5, 6),\n…         (6, 7),\n…         (7, 8),\n…     ]\n… )\n>>> sc = nx.subgraph_centrality_exp(G)\n>>> print([f”{node} {sc[node]:0.2f}” for node in sorted(sc)])\n[‘1 3.90’, ‘2 3.90’, ‘3 3.64’, ‘4 3.71’, ‘5 3.64’, ‘6 3.71’, ‘7 3.64’, ‘8 3.90’]",
    "Section ID: maximum_spanning_arborescence\nDescription: [Returns a maximum spanning arborescence from G.]\nField List: Parameters:: G : (multi)digraph-like: The graph to be searched.\nattr : str: The edge attribute used to in determining optimality.\ndefault : float: The value of the edge attribute used if an edge does not have\nthe attributeattr.\npreserve_attrs : bool: If True, preserve the other attributes of the original graph (that are not\npassed toattr)\npartition : str: The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum.\nReturns:: B : (multi)digraph-like: A maximum spanning arborescence.\nRaises:: NetworkXException: If the graph does not contain a maximum spanning arborescence.\nMethods: []\nRubrics:",
    "Section ID: laplacian_spectrum\nDescription: [Returns eigenvalues of the Laplacian of G]\nField List: Parameters:: G : graph: A NetworkX graph\nweight : string or None, optional (default=’weight’): The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.\nReturns:: evals : NumPy array: Eigenvalues\nMethods: []\nRubrics: Notes: For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array() for other options.\nExamples: The multiplicity of 0 as an eigenvalue of the laplacian matrix is equal\nto the number of connected components of G.\nG=nx.Graph()# Create a graph with 5 nodes and 3 connected components\nG.add_nodes_from(range(5))\nG.add_edges_from([(0,2),(3,4)])\nnx.laplacian_spectrum(G)\n# array([0., 0., 0., 2., 2.])",
    "Section ID: edge_expansion\nDescription: [Returns the edge expansion between two node sets., The edge expansion is the quotient of the cut size and the smaller\nof the cardinalities of the two sets. [1]]\nField List: Parameters:: G : NetworkX graph: \nS : collection: A collection of nodes inG.\nT : collection: A collection of nodes inG.\nweight : object: Edge attribute key to use as weight. If not specified, edges\nhave weight one.\nReturns:: number: The edge expansion between the two setsSandT.\nMethods: []\nRubrics: References: [1]Fan Chung.Spectral Graph Theory.\n(CBMS Regional Conference Series in Mathematics, No. 92),\nAmerican Mathematical Society, 1997, ISBN 0-8218-0315-8\n<http://www.math.ucsd.edu/~fan/research/revised.html>",
    "Section ID: adjacency_data\nDescription: [Returns data in adjacency format that is suitable for JSON serialization\nand use in JavaScript documents.]\nField List: Parameters:: G : NetworkX graph: \nattrs : dict: A dictionary that contains two keys ‘id’ and ‘key’. The corresponding\nvalues provide the attribute names for storing NetworkX-internal graph\ndata. The values should be unique. Default value:dict(id='id',key='key').If some user-defined graph data use these attribute names as data keys,\nthey may be silently dropped.\nReturns:: data : dict: A dictionary with adjacency formatted data.\nRaises:: NetworkXError: If values in attrs are not unique.\nMethods: []\nRubrics: Notes: Graph, node, and link attributes will be written when using this format\nbut attribute keys must be strings if you want to serialize the resulting\ndata with JSON. The default value of attrs will be changed in a future release of NetworkX.\nExamples: fromnetworkx.readwriteimportjson_graph\nG=nx.Graph([(1,2)])\ndata=json_graph.adjacency_data(G)\nTo serialize with json\nimportjson\ns=json.dumps(data)",
    "Section ID: max_flow_min_cost\nDescription: [Returns a maximum (s, t)-flow of minimum cost., G is a digraph with edge costs and capacities. There is a source\nnode s and a sink node t. This function finds a maximum flow from\ns to t whose total cost is minimized.]\nField List: Parameters:: G : NetworkX graph: DiGraph on which a minimum cost flow satisfying all demands is\nto be found.\ns: node label: Source of the flow.\nt: node label: Destination of the flow.\ncapacity: string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nweight: string: Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: ‘weight’.\nReturns:: flowDict: dictionary: Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v).\nRaises:: NetworkXError: This exception is raised if the input graph is not directed or\nnot connected.\nNetworkXUnbounded: This exception is raised if there is an infinite capacity path\nfrom s to t in G. In this case there is no maximum flow. This\nexception is also raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nis unbounded below.\nMethods: []\nRubrics: Notes: This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\nExamples: G=nx.DiGraph()\nG.add_edges_from(\n[\n(1,2,{\"capacity\":12,\"weight\":4}),\n(1,3,{\"capacity\":20,\"weight\":6}),\n(2,3,{\"capacity\":6,\"weight\":-3}),\n(2,6,{\"capacity\":14,\"weight\":1}),\n(3,4,{\"weight\":9}),\n(3,5,{\"capacity\":10,\"weight\":5}),\n(4,2,{\"capacity\":19,\"weight\":13}),\n(4,5,{\"capacity\":4,\"weight\":0}),\n(5,7,{\"capacity\":28,\"weight\":2}),\n(6,5,{\"capacity\":11,\"weight\":1}),\n(6,7,{\"weight\":8}),\n(7,4,{\"capacity\":6,\"weight\":6}),\n]\n)\nmincostFlow=nx.max_flow_min_cost(G,1,7)\nmincost=nx.cost_of_flow(G,mincostFlow)\nmincost\n# 373\nfromnetworkx.algorithms.flowimportmaximum_flow\nmaxFlow=maximum_flow(G,1,7)[1]\nnx.cost_of_flow(G,maxFlow)>=mincost\n# True\nmincostFlowValue=sum((mincostFlow[u][7]foruinG.predecessors(7)))-sum(\n(mincostFlow[7][v]forvinG.successors(7))\n)\nmincostFlowValue==nx.maximum_flow_value(G,1,7)\n# True",
    "Section ID: node_connectivity\nDescription: [Returns node connectivity for a graph or digraph G., Node connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local node\nconnectivity: the minimum number of nodes that must be removed to break\nall paths from source to target in G.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\ns : node: Source node. Optional. Default value: None.\nt : node: Target node. Optional. Default value: None.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.\nReturns:: K : integer: Node connectivity of G, or local node connectivity if source\nand target are provided.\nMethods: []\nRubrics: Notes: This is a flow based implementation of node connectivity. The\nalgorithm works by solving \\(O((n-\\delta-1+\\delta(\\delta-1)/2))\\) maximum flow problems on an auxiliary digraph. Where \\(\\delta\\) is the minimum degree of G. For details about the auxiliary\ndigraph and the computation of local node connectivity see local_node_connectivity() . This implementation is based\non algorithm 11 in [1] .\nReferences: [1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\nExamples: # Platonic icosahedral graph is 5-node-connected\nG=nx.icosahedral_graph()\nnx.node_connectivity(G)\n# 5\nYou can use alternative flow algorithms for the underlying maximum\nflow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions. Alternative\nflow functions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnx.node_connectivity(G,flow_func=shortest_augmenting_path)\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local node connectivity.\nnx.node_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_node_connectivity()for details.",
    "Section ID: hide_diedges\nDescription: [Returns a filter function that hides specific directed edges.]\nField List: Methods: []\nRubrics:",
    "Section ID: in_degree_centrality\nDescription: [Compute the in-degree centrality for nodes., The in-degree centrality for a node v is the fraction of nodes its\nincoming edges are connected to.]\nField List: Parameters:: G : graph: A NetworkX graph\nReturns:: nodes : dictionary: Dictionary of nodes with in-degree centrality as values.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.\nExamples: G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.in_degree_centrality(G)\n# {0: 0.0, 1: 0.3333333333333333, 2: 0.6666666666666666, 3: 0.6666666666666666}",
    "Section ID: is_at_free\nDescription: [Check if a graph is AT-free., The method uses the find_asteroidal_triple method to recognize\nan AT-free graph. If no asteroidal triple is found the graph is\nAT-free and True is returned. If at least one asteroidal triple is\nfound the graph is not AT-free and False is returned.]\nField List: Parameters:: G : NetworkX Graph: The graph to check whether is AT-free or not.\nReturns:: bool: True if G is AT-free and False otherwise.\nMethods: []\nRubrics: Examples: G=nx.Graph([(0,1),(0,2),(1,2),(1,3),(1,4),(4,5)])\nnx.is_at_free(G)\n# True\nG=nx.cycle_graph(6)\nnx.is_at_free(G)\n# False",
    "Section ID: strong_product\nDescription: [Returns the strong product of G and H., The strong product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\(u==v\\) and \\((x,y)\\) is an edge in \\(H\\) , or \\(x==y\\) and \\((u,v)\\) is an edge in \\(G\\) , or \\((u,v)\\) is an edge in \\(G\\) and \\((x,y)\\) is an edge in \\(H\\) .]\nField List: Parameters:: G, H: graphs: Networkx graphs.\nReturns:: P: NetworkX graph: The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected.\nRaises:: NetworkXError: If G and H are not both directed or both undirected.\nMethods: []\nRubrics: Notes: Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.\nExamples: G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.strong_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph",
    "Section ID: current_flow_betweenness_centrality\nDescription: [Compute current-flow betweenness centrality for nodes., Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths., Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] .]\nField List: Parameters:: G : graph: A NetworkX graph\nnormalized : bool, optional (default=True): If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.\nweight : string or None, optional (default=None): Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.\ndtype : data type (float): Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.\nsolver : string (default=’full’): Type of linear solver to use for computing the flow matrix.\nOptions are “full” (uses most memory), “lu” (recommended), and\n“cg” (uses least memory).\nReturns:: nodes : dictionary: Dictionary of nodes with betweenness centrality as the value.\nMethods: []\nRubrics: Notes: Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a ‘weight’ attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\nReferences: [1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS ‘05).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005).",
    "Section ID: nodes_with_selfloops\nDescription: [Returns an iterator over nodes with self loops., A node with a self loop has an edge with both ends adjacent\nto that node.]\nField List: Returns:: nodelist : iterator: A iterator over nodes with self loops.\nMethods: []\nRubrics: Examples: G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(1,1)\nG.add_edge(1,2)\nlist(nx.nodes_with_selfloops(G))\n# [1]",
    "Section ID: from_nested_tuple\nDescription: [Returns the rooted tree corresponding to the given nested tuple., The nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, () . A tree with k subtrees is represented\nby a tuple of length k in which each element is the nested tuple\nrepresentation of a subtree.]\nField List: Parameters:: sequence : tuple: A nested tuple representing a rooted tree.\nsensible_relabeling : bool: Whether to relabel the nodes of the tree so that nodes are\nlabeled in increasing order according to their breadth-first\nsearch order from the root node.\nReturns:: NetworkX graph: The tree corresponding to the given nested tuple, whose root\nnode is node 0. Ifsensible_labelingisTrue, nodes will\nbe labeled in breadth-first search order starting from the root\nnode.\nMethods: []\nRubrics: Notes: This function is not the inverse of to_nested_tuple() ; the\nonly guarantee is that the rooted trees are isomorphic.\nExamples: Sensible relabeling ensures that the nodes are labeled from the root\nstarting at 0:\nbalanced=(((),()),((),()))\nT=nx.from_nested_tuple(balanced,sensible_relabeling=True)\nedges=[(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)]\nall((u,v)inT.edges()or(v,u)inT.edges()for(u,v)inedges)\n# True",
    "Section ID: frucht_graph\nDescription: [Returns the Frucht Graph., The Frucht Graph is the smallest cubical graph whose\nautomorphism group consists only of the identity element [1] .\nIt has 12 nodes and 18 edges and no nontrivial symmetries.\nIt is planar and Hamiltonian [2] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Frucht Graph with 12 nodes and 18 edges\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Frucht_graph  [2]https://mathworld.wolfram.com/FruchtGraph.html",
    "Section ID: from_scipy_sparse_array\nDescription: [Creates a new graph from an adjacency matrix given as a SciPy sparse\narray.]\nField List: Parameters:: A: scipy.sparse array: An adjacency matrix representation of a graph\nparallel_edges : Boolean: If this is True,create_usingis a multigraph, andAis an\ninteger matrix, then entry(i, j)in the matrix is interpreted as the\nnumber of parallel edges joining verticesiandjin the graph.\nIf it is False, then the entries in the matrix are interpreted as\nthe weight of a single edge joining the vertices.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nedge_attribute: string: Name of edge attribute to store matrix numeric value. The data will\nhave the same type as the matrix entry (int, float, (real,imag)).\nMethods: []\nRubrics: Notes: For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of A corresponds to an edge from i to j. If create_using is networkx.MultiGraph or networkx.MultiDiGraph , parallel_edges is True, and the\nentries of A are of type int , then this function returns a\nmultigraph (constructed from create_using ) with parallel edges.\nIn this case, edge_attribute will be ignored. If create_using indicates an undirected multigraph, then only the edges\nindicated by the upper triangle of the matrix A will be added to the\ngraph.\nExamples: importscipyassp\nA=sp.sparse.eye(2,2,1)\nG=nx.from_scipy_sparse_array(A)\nIfcreate_usingindicates a multigraph and the matrix has only integer\nentries andparallel_edgesis False, then the entries will be treated\nas weights for edges joining the nodes (without creating parallel edges):\nA=sp.sparse.csr_array([[1,1],[1,2]])\nG=nx.from_scipy_sparse_array(A,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 2}})\nIfcreate_usingindicates a multigraph and the matrix has only integer\nentries andparallel_edgesis True, then the entries will be treated\nas the number of parallel edges joining those two vertices:\nA=sp.sparse.csr_array([[1,1],[1,2]])\nG=nx.from_scipy_sparse_array(A,parallel_edges=True,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 1}, 1: {'weight': 1}})",
    "Section ID: disjoint_union_all\nDescription: [Returns the disjoint union of all graphs., This operation forces distinct integer node labels starting with 0\nfor the first graph in the list and numbering consecutively.]\nField List: Parameters:: graphs : iterable: Iterable of NetworkX graphs\nReturns:: U : A graph with the same type as the first graph in list:\nRaises:: ValueError: Ifgraphsis an empty list.\nNetworkXError: In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\nMethods: []\nRubrics: Notes: For operating on mixed type graphs, they should be converted to the same type. Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.\nExamples: G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(4,5),(5,6)])\nU=nx.disjoint_union_all([G1,G2])\nlist(U.nodes())\n# [0, 1, 2, 3, 4, 5]\nlist(U.edges())\n# [(0, 1), (1, 2), (3, 4), (4, 5)]",
    "Section ID: hide_nodes\nDescription: [Returns a filter function that hides specific nodes.]\nField List: Methods: []\nRubrics:",
    "Section ID: cubical_graph\nDescription: [Returns the 3-regular Platonic Cubical Graph, The skeleton of the cube (the nodes and edges) form a graph, with 8\nnodes, and 12 edges. It is a special case of the hypercube graph.\nIt is one of 5 Platonic graphs, each a skeleton of its\nPlatonic solid [1] .\nSuch graphs arise in parallel processing in computers.]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: A cubical graph with 8 nodes and 12 edges\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Cube#Cubical_graph",
    "Section ID: k_corona\nDescription: [Returns the k-corona of G., The k-corona is the subgraph of nodes in the k-core which have\nexactly k neighbors in the k-core.]\nField List: Parameters:: G : NetworkX graph: A graph or directed graph\nk : int: The order of the corona.\ncore_number : dictionary, optional: Precomputed core numbers for the graph G.\nReturns:: G : NetworkX graph: The k-corona subgraph\nRaises:: NetworkXNotImplemented: The k-corona is not defined for multigraphs or graphs with self loops.\nMethods: []\nRubrics: Notes: For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.\nReferences: [1]k -core (bootstrap) percolation on complex networks:\nCritical phenomena and nonlocal effects,\nA. V. Goltsev, S. N. Dorogovtsev, and J. F. F. Mendes,\nPhys. Rev. E 73, 056101 (2006)http://link.aps.org/doi/10.1103/PhysRevE.73.056101\nExamples: degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_corona(H,k=2).nodes\n# NodeView((1, 2, 3, 5))",
    "Section ID: all_triads\nDescription: [A generator of all possible triads in G.]\nField List: Parameters:: G : digraph: A NetworkX DiGraph\nReturns:: all_triads : generator of DiGraphs: Generator of triads (order-3 DiGraphs)\nMethods: []\nRubrics: Examples: G=nx.DiGraph([(1,2),(2,3),(3,1),(3,4),(4,1),(4,2)])\nfortriadinnx.all_triads(G):\nprint(triad.edges)\n# [(1, 2), (2, 3), (3, 1)]\n# [(1, 2), (4, 1), (4, 2)]\n# [(3, 1), (3, 4), (4, 1)]\n# [(2, 3), (3, 4), (4, 2)]",
    "Section ID: average_degree_connectivity\nDescription: [Compute the average degree connectivity of graph., The average degree connectivity is the average nearest neighbor degree of\nnodes with degree k. For weighted graphs, an analogous measure can\nbe computed using the weighted average neighbors degree defined in [1] , for a node i , as, where s_i is the weighted degree of node i , w_{ij} is the weight of the edge that links i and j ,\nand N(i) are the neighbors of node i .]\nField List: Parameters:: G : NetworkX graph: \nsource : “in”|”out”|”in+out” (default:”in+out”): Directed graphs only. Use “in”- or “out”-degree for source node.\ntarget : “in”|”out”|”in+out” (default:”in+out”: Directed graphs only. Use “in”- or “out”-degree for target node.\nnodes : list or iterable (optional): Compute neighbor connectivity for these nodes. The default is all\nnodes.\nweight : string or None, optional (default=None): The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.\nReturns:: d : dict: A dictionary keyed by degree k with the value of average connectivity.\nRaises:: NetworkXError: If eithersourceortargetare not one of ‘in’,\n‘out’, or ‘in+out’.\nIf eithersourceortargetis passed for an undirected graph.\nMethods: []\nRubrics: References: [1]A. Barrat, M. Barthélemy, R. Pastor-Satorras, and A. Vespignani,\n“The architecture of complex weighted networks”.\nPNAS 101 (11): 3747–3752 (2004).\nExamples: G=nx.path_graph(4)\nG.edges[1,2][\"weight\"]=3\nnx.average_degree_connectivity(G)\n# {1: 2.0, 2: 1.5}\nnx.average_degree_connectivity(G,weight=\"weight\")\n# {1: 2.0, 2: 1.75}",
    "Section ID: reverse\nDescription: [Returns the reverse directed graph of G.]\nField List: Parameters:: G : directed graph: A NetworkX directed graph\ncopy : bool: If True, then a new graph is returned. If False, then the graph is\nreversed in place.\nReturns:: H : directed graph: The reversed G.\nRaises:: NetworkXError: If graph is undirected.\nMethods: []\nRubrics: Examples: G=nx.DiGraph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nG_reversed=nx.reverse(G)\nG_reversed.edges()\n# OutEdgeView([(2, 1), (3, 1), (3, 2), (4, 3), (5, 3)])",
    "Section ID: average_neighbor_degree\nDescription: [Returns the average degree of the neighborhood of each node., In an undirected graph, the neighborhood N(i) of node i contains the\nnodes that are connected to i by an edge., For directed graphs, N(i) is defined according to the parameter source :, The average neighborhood degree of a node i is, where N(i) are the neighbors of node i and k_j is\nthe degree of node j which belongs to N(i) . For weighted\ngraphs, an analogous measure can be defined [1] ,, where s_i is the weighted degree of node i , w_{ij} is the weight of the edge that links i and j and N(i) are the neighbors of node i .]\nField List: Parameters:: G : NetworkX graph: \nsource : string (“in”|”out”|”in+out”), optional (default=”out”): Directed graphs only.\nUse “in”- or “out”-neighbors of source node.\ntarget : string (“in”|”out”|”in+out”), optional (default=”out”): Directed graphs only.\nUse “in”- or “out”-degree for target node.\nnodes : list or iterable, optional (default=G.nodes): Compute neighbor degree only for specified nodes.\nweight : string or None, optional (default=None): The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.\nReturns:: d: dict: A dictionary keyed by node to the average degree of its neighbors.\nRaises:: NetworkXError: If eithersourceortargetare not one of ‘in’, ‘out’, or ‘in+out’.\nIf eithersourceortargetis passed for an undirected graph.\nMethods: []\nRubrics: References: [1]A. Barrat, M. Barthélemy, R. Pastor-Satorras, and A. Vespignani,\n“The architecture of complex weighted networks”.\nPNAS 101 (11): 3747–3752 (2004).\nExamples: G=nx.path_graph(4)\nG.edges[0,1][\"weight\"]=5\nG.edges[2,3][\"weight\"]=3\nnx.average_neighbor_degree(G)\n# {0: 2.0, 1: 1.5, 2: 1.5, 3: 2.0}\nnx.average_neighbor_degree(G,weight=\"weight\")\n# {0: 2.0, 1: 1.1666666666666667, 2: 1.25, 3: 2.0}\nG=nx.DiGraph()\nnx.add_path(G,[0,1,2,3])\nnx.average_neighbor_degree(G,source=\"in\",target=\"in\")\n# {0: 0.0, 1: 0.0, 2: 1.0, 3: 1.0}\nnx.average_neighbor_degree(G,source=\"out\",target=\"out\")\n# {0: 1.0, 1: 1.0, 2: 0.0, 3: 0.0}",
    "Section ID: weakly_connected_components\nDescription: [Generate weakly connected components of G.]\nField List: Parameters:: G : NetworkX graph: A directed graph\nReturns:: comp : generator of sets: A generator of sets of nodes, one for each weakly connected\ncomponent of G.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: For directed graphs only.\nExamples: Generate a sorted list of weakly connected components, largest first.\nG=nx.path_graph(4,create_using=nx.DiGraph())\nnx.add_path(G,[10,11,12])\n[len(c)forcinsorted(nx.weakly_connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest component, it’s more efficient to\nuse max instead of sort:\nlargest_cc=max(nx.weakly_connected_components(G),key=len)",
    "Section ID: degree_sequence_tree\nDescription: [Make a tree for the given degree sequence., A tree has #nodes-#edges=1 so\nthe degree sequence must have\nlen(deg_sequence)-sum(deg_sequence)/2=1]\nField List: Methods: []\nRubrics:",
    "Section ID: contracted_nodes\nDescription: [Returns the graph that results from contracting u and v ., Node contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes.]\nField List: Parameters:: G : NetworkX graph: The graph whose nodes will be contracted.\nu, v : nodes: Must be nodes inG.\nself_loops : Boolean: If this is True, any edges joininguandvinGbecome\nself-loops on the new node in the returned graph.\ncopy : Boolean: If this is True (default True), make a copy ofGand return that instead of directly changingG.\nReturns:: Networkx graph: If Copy is True,\nA new graph object of the same type asG(leavingGunmodified)\nwithuandvidentified in a single node. The right nodevwill be merged into the nodeu, so onlyuwill appear in the\nreturned graph.\nIf copy is False,\nModifiesGwithuandvidentified in a single node.\nThe right nodevwill be merged into the nodeu, so\nonlyuwill appear in the returned graph.\nMethods: []\nRubrics: Notes: For multigraphs, the edge keys for the realigned edges may\nnot be the same as the edge keys for the old edges. This is\nnatural because edge keys are unique only within each pair of nodes. For non-multigraphs where u and v are adjacent to a third node w , the edge ( v , w ) will be contracted into the edge ( u , w ) with its attributes stored into a “contraction” attribute. This function is also available as identified_nodes .\nExamples: Contracting two nonadjacent nodes of the cycle graph on four nodesC_4yields the path graph (ignoring parallel edges):\nG=nx.cycle_graph(4)\nM=nx.contracted_nodes(G,1,3)\nP3=nx.path_graph(3)\nnx.is_isomorphic(M,P3)\n# True\nG=nx.MultiGraph(P3)\nM=nx.contracted_nodes(G,0,2)\nM.edges\n# MultiEdgeView([(0, 1, 0), (0, 1, 1)])\nG=nx.Graph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.nodes())\n# [1]\nlist(H.edges())\n# [(1, 1)]\nIn aMultiDiGraphwith a self loop, the in and out edges will\nbe treated separately as edges, so while contracting a node which\nhas a self loop the contraction will add multiple edges:\nG=nx.MultiDiGraph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2)\nlist(H.edges())# edge 1->2, 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1), (1, 1)]\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.edges())# edge 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1)]",
    "Section ID: is_isolate\nDescription: [Determines whether a node is an isolate., An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.]\nField List: Parameters:: G : NetworkX graph: \nn : node: A node inG.\nReturns:: is_isolate : bool: True if and only ifnhas no neighbors.\nMethods: []\nRubrics: Examples: G=nx.Graph()\nG.add_edge(1,2)\nG.add_node(3)\nnx.is_isolate(G,2)\n# False\nnx.is_isolate(G,3)\n# True",
    "Section ID: transitive_reduction\nDescription: [Returns transitive reduction of a directed graph, The transitive reduction of G = (V,E) is a graph G- = (V,E-) such that\nfor all v,w in V there is an edge (v,w) in E- if and only if (v,w) is\nin E and there is no path from v to w in G with length greater than 1.]\nField List: Parameters:: G : NetworkX DiGraph: A directed acyclic graph (DAG)\nReturns:: NetworkX DiGraph: The transitive reduction ofG\nRaises:: NetworkXError: IfGis not a directed acyclic graph (DAG) transitive reduction is\nnot uniquely defined and aNetworkXErrorexception is raised.\nMethods: []\nRubrics: References: https://en.wikipedia.org/wiki/Transitive_reduction\nExamples: To perform transitive reduction on a DiGraph:\nDG=nx.DiGraph([(1,2),(2,3),(1,3)])\nTR=nx.transitive_reduction(DG)\nlist(TR.edges)\n# [(1, 2), (2, 3)]\nTo avoid unnecessary data copies, this implementation does not return a\nDiGraph with node/edge data.\nTo perform transitive reduction on a DiGraph and transfer node/edge data:\nDG=nx.DiGraph()\nDG.add_edges_from([(1,2),(2,3),(1,3)],color=\"red\")\nTR=nx.transitive_reduction(DG)\nTR.add_nodes_from(DG.nodes(data=True))\nTR.add_edges_from((u,v,DG.edges[u,v])foru,vinTR.edges)\nlist(TR.edges(data=True))\n# [(1, 2, {'color': 'red'}), (2, 3, {'color': 'red'})]",
    "Section ID: write_multiline_adjlist\nDescription: [Write the graph G in multiline adjacency list format to path]\nField List: Parameters:: G : NetworkX graph: \npath : string or file: Filename or file handle to write to.\nFilenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional: Marker for comment lines\ndelimiter : string, optional: Separator for node labels\nencoding : string, optional: Text encoding.\nMethods: []\nRubrics: Examples: G=nx.path_graph(4)\nnx.write_multiline_adjlist(G,\"test.adjlist\")\nThe path can be a file handle or a string with the name of the file. If a\nfile handle is provided, it has to be opened in ‘wb’ mode.\nfh=open(\"test.adjlist\",\"wb\")\nnx.write_multiline_adjlist(G,fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_multiline_adjlist(G,\"test.adjlist.gz\")",
    "Section ID: optimal_edit_paths\nDescription: [Returns all minimum-cost edit paths transforming G1 to G2., Graph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions.]\nField List: Parameters:: G1, G2: graphs: The two graphs G1 and G2 must be of the same type.\nnode_match : callable: A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.\nedge_match : callable: A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.\nnode_subst_cost, node_del_cost, node_ins_cost : callable: Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.\nedge_subst_cost, edge_del_cost, edge_ins_cost : callable: Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.\nupper_bound : numeric: Maximum edit distance to consider.\nReturns:: edit_paths : list of tuples (node_edit_path, edge_edit_path): node_edit_path : list of tuples (u, v)\nedge_edit_path : list of tuples ((u1, v1), (u2, v2))\ncost : numeric: Optimal edit path cost (graph edit distance). When the cost\nis zero, it indicates thatG1andG2are isomorphic.\nMethods: []\nRubrics: Notes: To transform G1 into a graph isomorphic to G2 , apply the node\nand edge edits in the returned edit_paths .\nIn the case of isomorphic graphs, the cost is zero, and the paths\nrepresent different isomorphic mappings (isomorphisms). That is, the\nedits involve renaming nodes and edges to match the structure of G2 .\nReferences: [1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816\nExamples: G1=nx.cycle_graph(4)\nG2=nx.wheel_graph(5)\npaths,cost=nx.optimal_edit_paths(G1,G2)\nlen(paths)\n# 40\ncost\n# 5.0",
    "Section ID: bellman_ford_path\nDescription: [Returns the shortest path from source to target in a weighted graph G.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node\ntarget : node: Ending node\nweight : string or function (default=”weight”): If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: path : list: List of nodes in a shortest path.\nRaises:: NodeNotFound: Ifsourceis not inG.\nNetworkXNoPath: If no path exists between source and target.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\nExamples: G=nx.path_graph(5)\nnx.bellman_ford_path(G,0,4)\n# [0, 1, 2, 3, 4]",
    "Section ID: dfs_preorder_nodes\nDescription: [Generate nodes in a depth-first-search pre-ordering starting at source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Specify starting node for depth-first search and return nodes in\nthe component reachable from source.\ndepth_limit : int, optional (default=len(G)): Specify the maximum search depth.\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: nodes: generator: A generator of nodes in a depth-first-search pre-ordering.\nMethods: []\nRubrics: Notes: If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein’s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n“ Depth-limited search ”.\nExamples: G=nx.path_graph(5)\nlist(nx.dfs_preorder_nodes(G,source=0))\n# [0, 1, 2, 3, 4]\nlist(nx.dfs_preorder_nodes(G,source=0,depth_limit=2))\n# [0, 1, 2]",
    "Section ID: voronoi_cells\nDescription: [Returns the Voronoi cells centered at center_nodes with respect\nto the shortest-path distance metric., If \\(C\\) is a set of nodes in the graph and \\(c\\) is an element of \\(C\\) ,\nthe Voronoi cell centered at a node \\(c\\) is the set of all nodes \\(v\\) that are closer to \\(c\\) than to any other center node in \\(C\\) with\nrespect to the shortest-path distance metric. [1], For directed graphs, this will compute the “outward” Voronoi cells,\nas defined in [1] , in which distance is measured from the center\nnodes to the target node. For the “inward” Voronoi cells, use the DiGraph.reverse() method to reverse the orientation of the\nedges before invoking this function on the directed graph.]\nField List: Parameters:: G : NetworkX graph: \ncenter_nodes : set: A nonempty set of nodes in the graphGthat represent the\ncenter of the Voronoi cells.\nweight : string or function: The edge attribute (or an arbitrary function) representing the\nweight of an edge. This keyword argument is as described in the\ndocumentation formulti_source_dijkstra_path(),\nfor example.\nReturns:: dictionary: A mapping from center node to set of all nodes in the graph\ncloser to that center node than to any other center node. The\nkeys of the dictionary are the element ofcenter_nodes, and\nthe values of the dictionary form a partition of the nodes ofG.\nRaises:: ValueError: Ifcenter_nodesis empty.\nMethods: []\nRubrics: References: [1](1,2)Erwig, Martin. (2000),”The graph Voronoi diagram with applications.”Networks, 36: 156–163.https://doi.org/10.1002/1097-0037(200010)36:3<156::AID-NET2>3.0.CO;2-L\nExamples: To get only the partition of the graph induced by the Voronoi cells,\ntake the collection of all values in the returned dictionary:\nG=nx.path_graph(6)\ncenter_nodes={0,3}\ncells=nx.voronoi_cells(G,center_nodes)\npartition=set(map(frozenset,cells.values()))\nsorted(map(sorted,partition))\n# [[0, 1], [2, 3, 4, 5]]",
    "Section ID: collaboration_weighted_projected_graph\nDescription: [Newman’s weighted projection of B onto one of its node sets., The collaboration weighted projection is the projection of the\nbipartite network B onto the specified nodes with weights assigned\nusing Newman’s collaboration model [1] :, where u and v are nodes from the bottom bipartite node set,\nand k is a node of the top node set.\nThe value d_k is the degree of node k in the bipartite\nnetwork and delta_{u}^{k} is 1 if node u is\nlinked to node k in the original bipartite graph or 0 otherwise., The nodes retain their attributes and are connected in the resulting\ngraph if have an edge to a common node in the original bipartite\ngraph.]\nField List: Parameters:: B : NetworkX graph: The input graph should be bipartite.\nnodes : list or iterable: Nodes to project onto (the “bottom” nodes).\nReturns:: Graph : NetworkX graph: A graph that is the projection onto the given nodes.\nMethods: []\nRubrics: Notes: No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nReferences: [1]Scientific collaboration networks: II.\nShortest paths, weighted networks, and centrality,\nM. E. J. Newman, Phys. Rev. E 64, 016132 (2001).\nExamples: fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(5)\nB.add_edge(1,5)\nG=bipartite.collaboration_weighted_projected_graph(B,[0,2,4,5])\nlist(G)\n# [0, 2, 4, 5]\nforedgeinsorted(G.edges(data=True)):\nprint(edge)\n# (0, 2, {'weight': 0.5})\n# (0, 5, {'weight': 0.5})\n# (2, 4, {'weight': 1.0})\n# (2, 5, {'weight': 0.5})",
    "Section ID: information_centrality\nDescription: [Compute current-flow closeness centrality for nodes., Current-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality.]\nField List: Parameters:: G : graph: A NetworkX graph.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight reflects the capacity or the strength of the\nedge.\ndtype: data type (default=float): Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.\nsolver: string (default=’lu’): Type of linear solver to use for computing the flow matrix.\nOptions are “full” (uses most memory), “lu” (recommended), and\n“cg” (uses least memory).\nReturns:: nodes : dictionary: Dictionary of nodes with current flow closeness centrality as the value.\nMethods: []\nRubrics: Notes: The algorithm is from Brandes [1] . See also [2] for the original definition of information centrality.\nReferences: [1]Ulrik Brandes and Daniel Fleischer,\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS ‘05).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]Karen Stephenson and Marvin Zelen:\nRethinking centrality: Methods and examples.\nSocial Networks 11(1):1-37, 1989.https://doi.org/10.1016/0378-8733(89)90016-6",
    "Section ID: minimum_cycle_basis\nDescription: [Returns a minimum weight cycle basis for G, Minimum weight means a cycle basis for which the total weight\n(length for unweighted graphs) of all the cycles is minimum.]\nField List: Parameters:: G : NetworkX Graph: \nweight: string: name of the edge attribute to use for edge weights\nReturns:: A list of cycle lists.  Each cycle list is a list of nodes: \nwhich forms a cycle (loop) in G. Note that the nodes are not: \nnecessarily returned in a order by which they appear in the cycle:\nMethods: []\nRubrics: Examples: G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.minimum_cycle_basis(G)\n# [[5, 4, 3, 0], [3, 2, 1, 0]]",
    "Section ID: k_core\nDescription: [Returns the k-core of G., A k-core is a maximal subgraph that contains nodes of degree k or more.]\nField List: Parameters:: G : NetworkX graph: A graph or directed graph\nk : int, optional: The order of the core. If not specified return the main core.\ncore_number : dictionary, optional: Precomputed core numbers for the graph G.\nReturns:: G : NetworkX graph: The k-core subgraph\nRaises:: NetworkXNotImplemented: The k-core is not defined for multigraphs or graphs with self loops.\nMethods: []\nRubrics: Notes: The main core is the core with k as the largest core_number. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.\nReferences: [1]An O(m) Algorithm for Cores Decomposition of Networks\nVladimir Batagelj and Matjaz Zaversnik,  2003.https://arxiv.org/abs/cs.DS/0310049\nExamples: degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_core(H).nodes\n# NodeView((1, 2, 3, 5))",
    "Section ID: total_spanning_tree_weight\nDescription: [Returns the total weight of all spanning trees of G ., Kirchoff’s Tree Matrix Theorem [1] , [2] states that the determinant of any\ncofactor of the Laplacian matrix of a graph is the number of spanning trees\nin the graph. For a weighted Laplacian matrix, it is the sum across all\nspanning trees of the multiplicative weight of each tree. That is, the\nweight of each tree is the product of its edge weights., For unweighted graphs, the total weight equals the number of spanning trees in G ., For directed graphs, the total weight follows by summing over all directed\nspanning trees in G that start in the root node [3] .]\nField List: Parameters:: G : NetworkX Graph: \nweight : string or None, optional (default=None): The key for the edge attribute holding the edge weight.\nIf None, then each edge has weight 1.\nroot : node (only required for directed graphs): A node in the directed graphG.\nReturns:: total_weight : float: Undirected graphs:The sum of the total multiplicative weights for all spanning trees inG.Directed graphs:The sum of the total multiplicative weights for all spanning trees ofG,\nrooted at noderoot.\nUndirected graphs:: The sum of the total multiplicative weights for all spanning trees inG.\nDirected graphs:: The sum of the total multiplicative weights for all spanning trees ofG,\nrooted at noderoot.\nRaises:: NetworkXPointlessConcept: IfGdoes not contain any nodes.\nNetworkXError: If the graphGis not (weakly) connected,\nor ifGis directed and the root node is not specified or not in G.\nMethods: []\nRubrics: Notes: Self-loops are excluded. Multi-edges are contracted in one edge\nequal to the sum of the weights.\nReferences: [1]Wikipedia\n“Kirchhoff’s theorem.”https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem  [2]Kirchhoff, G. R.\nÜber die Auflösung der Gleichungen, auf welche man\nbei der Untersuchung der linearen Vertheilung\nGalvanischer Ströme geführt wird\nAnnalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.  [3]Margoliash, J.\n“Matrix-Tree Theorem for Directed Graphs”https://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf\nExamples: G=nx.complete_graph(5)\nround(nx.total_spanning_tree_weight(G))\n# 125\nG=nx.Graph()\nG.add_edge(1,2,weight=2)\nG.add_edge(1,3,weight=1)\nG.add_edge(2,3,weight=1)\nround(nx.total_spanning_tree_weight(G,\"weight\"))\n# 5",
    "Section ID: node_redundancy\nDescription: [Computes the node redundancy coefficients for the nodes in the bipartite\ngraph G ., The redundancy coefficient of a node v is the fraction of pairs of\nneighbors of v that are both linked to other nodes. In a one-mode\nprojection these nodes would be linked together even if v were\nnot there., More formally, for any vertex v , the redundancy coefficient of `v` is\ndefined by, where N(v) is the set of neighbors of v in G .]\nField List: Parameters:: G : graph: A bipartite graph\nnodes : list or iterable (optional): Compute redundancy for these nodes. The default is all nodes in G.\nReturns:: redundancy : dictionary: A dictionary keyed by node with the node redundancy value.\nRaises:: NetworkXError: If any of the nodes in the graph (or innodes, if specified) has\n(out-)degree less than two (which would result in division by zero,\naccording to the definition of the redundancy coefficient).\nMethods: []\nRubrics: References: [1]Latapy, Matthieu, Clémence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31–48.\nExamples: Compute the redundancy coefficient of each node in a graph:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nrc[0]\n# 1.0\nCompute the average redundancy for the graph:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nsum(rc.values())/len(G)\n# 1.0\nCompute the average redundancy for a set of nodes:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nnodes=[0,2]\nsum(rc[n]forninnodes)/len(nodes)\n# 1.0",
    "Section ID: compose_all\nDescription: [Returns the composition of all graphs., Composition is the simple union of the node sets and edge sets.\nThe node sets of the supplied graphs need not be disjoint.]\nField List: Parameters:: graphs : iterable: Iterable of NetworkX graphs\nReturns:: C : A graph with the same type as the first graph in list:\nRaises:: ValueError: Ifgraphsis an empty list.\nNetworkXError: In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\nMethods: []\nRubrics: Notes: For operating on mixed type graphs, they should be converted to the same type. Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.\nExamples: G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(3,4),(5,6)])\nC=nx.compose_all([G1,G2])\nlist(C.nodes())\n# [1, 2, 3, 4, 5, 6]\nlist(C.edges())\n# [(1, 2), (2, 3), (3, 4), (5, 6)]",
    "Section ID: maximum_independent_set\nDescription: [Returns an approximate maximum independent set., Independent set or stable set is a set of vertices in a graph, no two of\nwhich are adjacent. That is, it is a set I of vertices such that for every\ntwo vertices in I, there is no edge connecting the two. Equivalently, each\nedge in the graph has at most one endpoint in I. The size of an independent\nset is the number of vertices it contains [1] ., A maximum independent set is a largest independent set for a given graph G\nand its size is denoted \\(\\alpha(G)\\) . The problem of finding such a set is called\nthe maximum independent set problem and is an NP-hard optimization problem.\nAs such, it is unlikely that there exists an efficient algorithm for finding\na maximum independent set of a graph., The Independent Set algorithm is based on [2] .]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nReturns:: iset : Set: The apx-maximum independent set\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics: Notes: Finds the \\(O(|V|/(log|V|)^2)\\) apx of independent set in the worst case.\nReferences: [1]Wikipedia: Independent set  [2]Boppana, R., & Halldórsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180–196. Springer.\nExamples: G=nx.path_graph(10)\nnx.approximation.maximum_independent_set(G)\n# {0, 2, 4, 6, 9}",
    "Section ID: read_dot\nDescription: [Returns a NetworkX graph from a dot file on path.]\nField List: Parameters:: path : file or string: File name or file handle to read.\nMethods: []\nRubrics:",
    "Section ID: read_weighted_edgelist\nDescription: [Read a graph as list of edges with numeric weights.]\nField List: Parameters:: path : file or string: File or filename to read. If a file is provided, it must be\nopened in ‘rb’ mode.\nFilenames ending in .gz or .bz2 will be uncompressed.\ncomments : string, optional: The character used to indicate the start of a comment.\ndelimiter : string, optional: The string used to separate values.  The default is whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nnodetype : int, float, str, Python type, optional: Convert node data from strings to specified type\nencoding: string, optional: Specify which encoding to use when reading file.\nReturns:: G : graph: A networkx Graph or other type specified with create_using\nMethods: []\nRubrics: Notes: Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.) Example edgelist file format. With numeric edge data:",
    "Section ID: circular_ladder_graph\nDescription: [Returns the circular ladder graph \\(CL_n\\) of length n., \\(CL_n\\) consists of two concentric n-cycles in which\neach of the n pairs of concentric nodes are joined by an edge., Node labels are the integers 0 to n-1, ( Sourcecode , png )]\nField List: Methods: []\nRubrics:",
    "Section ID: node_attribute_xy\nDescription: [Returns iterator of node-attribute pairs for all edges in G.]\nField List: Parameters:: G: NetworkX graph: \nattribute: key: The node attribute key.\nnodes: list or iterable (optional): Use only edges that are incident to specified nodes.\nThe default is all nodes.\nReturns:: (x, y): 2-tuple: Generates 2-tuple of (attribute, attribute) values.\nMethods: []\nRubrics: Notes: For undirected graphs each edge is produced twice, once for each edge\nrepresentation (u, v) and (v, u), with the exception of self-loop edges\nwhich only appear once.\nExamples: G=nx.DiGraph()\nG.add_node(1,color=\"red\")\nG.add_node(2,color=\"blue\")\nG.add_edge(1,2)\nlist(nx.node_attribute_xy(G,\"color\"))\n# [('red', 'blue')]",
    "Section ID: watts_strogatz_graph\nDescription: [Returns a Watts–Strogatz small-world graph.]\nField List: Parameters:: n : int: The number of nodes\nk : int: Each node is joined with itsknearest neighbors in a ring\ntopology.\np : float: The probability of rewiring each edge\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: Notes: First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is joined\nto its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).\nThen shortcuts are created by replacing some edges as follows: for each\nedge \\((u, v)\\) in the underlying “ \\(n\\) -ring with \\(k\\) nearest neighbors”\nwith probability \\(p\\) replace it with a new edge \\((u, w)\\) with uniformly\nrandom choice of existing node \\(w\\) . In contrast with newman_watts_strogatz_graph() , the random rewiring\ndoes not increase the number of edges. The rewired graph is not guaranteed\nto be connected as in connected_watts_strogatz_graph() .\nReferences: [1]Duncan J. Watts and Steven H. Strogatz,\nCollective dynamics of small-world networks,\nNature, 393, pp. 440–442, 1998.",
    "Section ID: current_flow_betweenness_centrality_subset\nDescription: [Compute current-flow betweenness centrality for subsets of nodes., Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths., Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] .]\nField List: Parameters:: G : graph: A NetworkX graph\nsources: list of nodes: Nodes to use as sources for current\ntargets: list of nodes: Nodes to use as sinks for current\nnormalized : bool, optional (default=True): If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.\nweight : string or None, optional (default=None): Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.\ndtype: data type (float): Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.\nsolver: string (default=’lu’): Type of linear solver to use for computing the flow matrix.\nOptions are “full” (uses most memory), “lu” (recommended), and\n“cg” (uses least memory).\nReturns:: nodes : dictionary: Dictionary of nodes with betweenness centrality as the value.\nMethods: []\nRubrics: Notes: Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a ‘weight’ attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\nReferences: [1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS ‘05).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005).",
    "Section ID: create_random_state\nDescription: [Returns a numpy.random.RandomState or numpy.random.Generator instance\ndepending on input.]\nField List: Parameters:: random_state : int or NumPy RandomState or Generator instance, optional (default=None): If int, return a numpy.random.RandomState instance set with seed=int.\nifnumpy.random.RandomStateinstance, return it.\nifnumpy.random.Generatorinstance, return it.\nif None or numpy.random, return the global random number generator used\nby numpy.random.\nMethods: []\nRubrics:",
    "Section ID: bfs_predecessors\nDescription: [Returns an iterator of predecessors in breadth-first-search from source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Specify starting node for breadth-first search\ndepth_limit : int, optional(default=len(G)): Specify the maximum search depth\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: pred: iterator: (node, predecessor) iterator wherepredecessoris the predecessor ofnodein a breadth first search starting fromsource.\nMethods: []\nRubrics: Notes: Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004. The modifications\nto allow depth limits based on the Wikipedia article\n“ Depth-limited-search ”.\nExamples: G=nx.path_graph(3)\ndict(nx.bfs_predecessors(G,0))\n# {1: 0, 2: 1}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(nx.bfs_predecessors(H,0))\n# {1: 0, 2: 0, 3: 1, 4: 1, 5: 2, 6: 2}\nM=nx.Graph()\nnx.add_path(M,[0,1,2,3,4,5,6])\nnx.add_path(M,[2,7,8,9,10])\nsorted(nx.bfs_predecessors(M,source=1,depth_limit=3))\n# [(0, 1), (2, 1), (3, 2), (4, 3), (7, 2), (8, 7)]\nN=nx.DiGraph()\nnx.add_path(N,[0,1,2,3,4,7])\nnx.add_path(N,[3,5,6,7])\nsorted(nx.bfs_predecessors(N,source=2))\n# [(3, 2), (4, 3), (5, 3), (6, 5), (7, 4)]",
    "Section ID: pydot_layout\nDescription: [Create node positions using pydot and Graphviz.]\nField List: Parameters:: G : Graph: NetworkX graph to be laid out.\nprog : string  (default: ‘neato’): Name of the GraphViz command to use for layout.\nOptions depend on GraphViz version but may include:\n‘dot’, ‘twopi’, ‘fdp’, ‘sfdp’, ‘circo’\nroot : Node from G or None (default: None): The node of G from which to start some layout algorithms.\nReturns:: dict: Dictionary of positions keyed by node.\nMethods: []\nRubrics: Notes: If you use complex node objects, they may have the same string\nrepresentation and GraphViz could treat them as the same node.\nThe layout may assign both nodes a single location. See Issue #1568\nIf this occurs in your case, consider relabeling the nodes just\nfor the layout computation using something similar to:\nExamples: G=nx.complete_graph(4)\npos=nx.nx_pydot.pydot_layout(G)\npos=nx.nx_pydot.pydot_layout(G,prog=\"dot\")",
    "Section ID: power\nDescription: [Returns the specified power of a graph., The \\(k`th power of a simple graph :math:`G\\) , denoted \\(G^k\\) , is a\ngraph on the same set of nodes in which two distinct nodes \\(u\\) and \\(v\\) are adjacent in \\(G^k\\) if and only if the shortest path\ndistance between \\(u\\) and \\(v\\) in \\(G\\) is at most \\(k\\) .]\nField List: Parameters:: G : graph: A NetworkX simple graph object.\nk : positive integer: The power to which to raise the graphG.\nReturns:: NetworkX simple graph: Gto the powerk.\nRaises:: ValueError: If the exponentkis not positive.\nNetworkXNotImplemented: IfGis not a simple graph.\nMethods: []\nRubrics: Notes: This definition of “power graph” comes from Exercise 3.1.6 of Graph Theory by Bondy and Murty [1] .\nReferences: [1]Bondy, U. S. R. Murty,Graph Theory. Springer, 2008.\nExamples: The number of edges will never decrease when taking successive\npowers:\nG=nx.path_graph(4)\nlist(nx.power(G,2).edges)\n# [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3)]\nlist(nx.power(G,3).edges)\n# [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\nThekth power of a cycle graph onnnodes is the complete graph\nonnnodes, ifkis at leastn//2:\nG=nx.cycle_graph(5)\nH=nx.complete_graph(5)\nnx.is_isomorphic(nx.power(G,2),H)\n# True\nG=nx.cycle_graph(8)\nH=nx.complete_graph(8)\nnx.is_isomorphic(nx.power(G,4),H)\n# True",
    "Section ID: cuthill_mckee_ordering\nDescription: [Generate an ordering (permutation) of the graph nodes to make\na sparse matrix., Uses the Cuthill-McKee heuristic (based on breadth-first search) [1] .]\nField List: Parameters:: G : graph: A NetworkX graph\nheuristic : function, optional: Function to choose starting node for RCM algorithm.  If None\na node from a pseudo-peripheral pair is used.  A user-defined function\ncan be supplied that takes a graph object and returns a single node.\nReturns:: nodes : generator: Generator of nodes in Cuthill-McKee ordering.\nMethods: []\nRubrics: Notes: The optimal solution the bandwidth reduction is NP-complete [2] .\nReferences: [1]E. Cuthill and J. McKee.\nReducing the bandwidth of sparse symmetric matrices,\nIn Proc. 24th Nat. Conf. ACM, pages 157-172, 1969.http://doi.acm.org/10.1145/800195.805928  [2]Steven S. Skiena. 1997. The Algorithm Design Manual.\nSpringer-Verlag New York, Inc., New York, NY, USA.\nExamples: fromnetworkx.utilsimportcuthill_mckee_ordering\nG=nx.path_graph(4)\nrcm=list(cuthill_mckee_ordering(G))\nA=nx.adjacency_matrix(G,nodelist=rcm)\nSmallest degree node as heuristic function:\ndefsmallest_degree(G):\nreturnmin(G,key=G.degree)\nrcm=list(cuthill_mckee_ordering(G,heuristic=smallest_degree))",
    "Section ID: expected_degree_graph\nDescription: [Returns a random graph with given expected degrees., Given a sequence of expected degrees \\(W=(w_0,w_1,\\ldots,w_{n-1})\\) of length \\(n\\) this algorithm assigns an edge between node \\(u\\) and\nnode \\(v\\) with probability]\nField List: Parameters:: w : list: The list of expected degrees.\nselfloops: bool (default=True): Set to False to remove the possibility of self-loop edges.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: Graph:\nMethods: []\nRubrics: Notes: The nodes have integer labels corresponding to index of expected degrees\ninput sequence. The complexity of this algorithm is \\(\\mathcal{O}(n+m)\\) where \\(n\\) is the\nnumber of nodes and \\(m\\) is the expected number of edges. The model in [1] includes the possibility of self-loop edges.\nSet selfloops=False to produce a graph without self loops. For finite graphs this model doesn’t produce exactly the given\nexpected degree sequence.  Instead the expected degrees are as\nfollows. For the case without self loops (selfloops=False),\nReferences: [1]Fan Chung and L. Lu, Connected components in random graphs with\ngiven expected degree sequences, Ann. Combinatorics, 6,\npp. 125-145, 2002.  [2]Joel Miller and Aric Hagberg,\nEfficient generation of networks with given expected degrees,\nin Algorithms and Models for the Web-Graph (WAW 2011),\nAlan Frieze, Paul Horn, and Paweł Prałat (Eds), LNCS 6732,\npp. 115-126, 2011.\nExamples: z=[10foriinrange(100)]\nG=nx.expected_degree_graph(z)",
    "Section ID: hamiltonian_path\nDescription: [Returns a Hamiltonian path in the given tournament graph., Each tournament has a Hamiltonian path. If furthermore, the\ntournament is strongly connected, then the returned Hamiltonian path\nis a Hamiltonian cycle (by joining the endpoints of the path).]\nField List: Parameters:: G : NetworkX graph: A directed graph representing a tournament.\nReturns:: path : list: A list of nodes which form a Hamiltonian path inG.\nMethods: []\nRubrics: Notes: This is a recursive implementation with an asymptotic running time\nof \\(O(n^2)\\) , ignoring multiplicative polylogarithmic factors, where \\(n\\) is the number of nodes in the graph.\nExamples: G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)])\nnx.is_tournament(G)\n# True\nnx.tournament.hamiltonian_path(G)\n# [0, 1, 2, 3]",
    "Section ID: trophic_differences\nDescription: [Compute the trophic differences of the edges of a directed graph., The trophic difference \\(x_ij\\) for each edge is defined in Johnson et al. [1] as:, Where \\(s_i\\) is the trophic level of node \\(i\\) .]\nField List: Parameters:: G : DiGraph: A directed networkx graph\nReturns:: diffs : dict: Dictionary of edges with trophic differences as the value.\nMethods: []\nRubrics: References: [1]Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\nMunoz (2014) PNAS “Trophic coherence determines food-web stability”",
    "Section ID: tetrahedral_graph\nDescription: [Returns the 3-regular Platonic Tetrahedral graph., Tetrahedral graph has 4 nodes and 6 edges. It is a\nspecial case of the complete graph, K4, and wheel graph, W4.\nIt is one of the 5 platonic graphs [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Tetrahedral Graph\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Tetrahedron#Tetrahedral_graph",
    "Section ID: is_eulerian\nDescription: [Returns True if and only if G is Eulerian., A graph is Eulerian if it has an Eulerian circuit. An Eulerian\ncircuit is a closed walk that includes each edge of a graph exactly\nonce., Graphs with isolated vertices (i.e. vertices with zero degree) are not\nconsidered to have Eulerian circuits. Therefore, if the graph is not\nconnected (or not strongly connected, for directed graphs), this function\nreturns False.]\nField List: Parameters:: G : NetworkX graph: A graph, either directed or undirected.\nMethods: []\nRubrics: Examples: nx.is_eulerian(nx.DiGraph({0:[3],1:[2],2:[3],3:[0,1]}))\n# True\nnx.is_eulerian(nx.complete_graph(5))\n# True\nnx.is_eulerian(nx.petersen_graph())\n# False\nIf you prefer to allow graphs with isolated vertices to have Eulerian circuits,\nyou can first remove such vertices and then callis_eulerianas below example shows.\nG=nx.Graph([(0,1),(1,2),(0,2)])\nG.add_node(3)\nnx.is_eulerian(G)\n# False\nG.remove_nodes_from(list(nx.isolates(G)))\nnx.is_eulerian(G)\n# True",
    "Section ID: triad_graph\nDescription: [Returns the triad graph with the given name., Each string in the following tuple is a valid triad name:, Each triad name corresponds to one of the possible valid digraph on\nthree nodes.]\nField List: Parameters:: triad_name : string: The name of a triad, as described above.\nReturns:: DiGraph: The digraph on three nodes with the given name. The nodes of the\ngraph are the single-character strings ‘a’, ‘b’, and ‘c’.\nRaises:: ValueError: Iftriad_nameis not the name of a triad.\nMethods: []\nRubrics:",
    "Section ID: minimum_weight_full_matching\nDescription: [Returns a minimum weight full matching of the bipartite graph G ., Let \\(G = ((U, V), E)\\) be a weighted bipartite graph with real weights \\(w : E \\to \\mathbb{R}\\) . This function then produces a matching \\(M \\subseteq E\\) with cardinality, which minimizes the sum of the weights of the edges included in the\nmatching, \\(\\sum_{e \\in M} w(e)\\) , or raises an error if no such\nmatching exists., When \\(\\lvert U \\rvert = \\lvert V \\rvert\\) , this is commonly\nreferred to as a perfect matching; here, since we allow \\(\\lvert U \\rvert\\) and \\(\\lvert V \\rvert\\) to differ, we\nfollow Karp [1] and refer to the matching as full .]\nField List: Parameters:: G : NetworkX graph: Undirected bipartite graph\ntop_nodes : container: Container with all nodes in one bipartite node set. If not supplied\nit will be computed.\nweight : string, optional (default=’weight’): The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1.\nReturns:: matches : dictionary: The matching is returned as a dictionary,matches, such thatmatches[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatches.\nRaises:: ValueError: Raised if no full matching exists.\nImportError: Raised if SciPy is not available.\nMethods: []\nRubrics: Notes: The problem of determining a minimum weight full matching is also known as\nthe rectangular linear assignment problem. This implementation defers the\ncalculation of the assignment to SciPy.\nReferences: [1]Richard Manning Karp:\nAn algorithm to Solve the m x n Assignment Problem in Expected Time\nO(mn log n).\nNetworks, 10(2):143–152, 1980.",
    "Section ID: load_centrality\nDescription: [Compute load centrality for nodes., The load centrality of a node is the fraction of all shortest\npaths that pass through that node.]\nField List: Parameters:: G : graph: A networkx graph.\nnormalized : bool, optional (default=True): If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.\nweight : None or string, optional (default=None): If None, edge weights are ignored.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.\ncutoff : bool, optional (default=None): If specified, only consider paths of length <= cutoff.\nReturns:: nodes : dictionary: Dictionary of nodes with centrality as the value.\nMethods: []\nRubrics: Notes: Load centrality is slightly different than betweenness. It was originally\nintroduced by [2] . For this load algorithm see [1] .\nReferences: [1]Mark E. J. Newman:\nScientific collaboration networks. II.\nShortest paths, weighted networks, and centrality.\nPhysical Review E 64, 016132, 2001.http://journals.aps.org/pre/abstract/10.1103/PhysRevE.64.016132  [2]Kwang-Il Goh, Byungnam Kahng and Doochul Kim\nUniversal behavior of Load Distribution in Scale-Free Networks.\nPhysical Review Letters 87(27):1–4, 2001.https://doi.org/10.1103/PhysRevLett.87.278701",
    "Section ID: girvan_newman\nDescription: [Finds communities in a graph using the Girvan–Newman method.]\nField List: Parameters:: G : NetworkX graph: \nmost_valuable_edge : function: Function that takes a graph as input and outputs an edge. The\nedge returned by this function will be recomputed and removed at\neach iteration of the algorithm.If not specified, the edge with the highestnetworkx.edge_betweenness_centrality()will be used.\nReturns:: iterator: Iterator over tuples of sets of nodes inG. Each set of node\nis a community, each tuple is a sequence of communities at a\nparticular level of the algorithm.\nMethods: []\nRubrics: Notes: The Girvan–Newman algorithm detects communities by progressively\nremoving edges from the original graph. The algorithm removes the\n“most valuable” edge, traditionally the edge with the highest\nbetweenness centrality, at each step. As the graph breaks down into\npieces, the tightly knit community structure is exposed and the\nresult can be depicted as a dendrogram.\nExamples: To get the first pair of communities:\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])\nTo get only the firstktuples of communities, useitertools.islice():\nimportitertools\nG=nx.path_graph(8)\nk=2\ncomp=nx.community.girvan_newman(G)\nforcommunitiesinitertools.islice(comp,k):\nprint(tuple(sorted(c)forcincommunities))\n\n# ([0, 1, 2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5, 6, 7])\nTo stop getting tuples of communities once the number of communities\nis greater thank, useitertools.takewhile():\nimportitertools\nG=nx.path_graph(8)\nk=4\ncomp=nx.community.girvan_newman(G)\nlimited=itertools.takewhile(lambdac:len(c)<=k,comp)\nforcommunitiesinlimited:\nprint(tuple(sorted(c)forcincommunities))\n\n# ([0, 1, 2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5], [6, 7])\nTo just choose an edge to remove based on the weight:\nfromoperatorimportitemgetter\nG=nx.path_graph(10)\nedges=G.edges()\nnx.set_edge_attributes(G,{(u,v):vforu,vinedges},\"weight\")\ndefheaviest(G):\nu,v,w=max(G.edges(data=\"weight\"),key=itemgetter(2))\nreturn(u,v)\n\ncomp=nx.community.girvan_newman(G,most_valuable_edge=heaviest)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4, 5, 6, 7, 8], [9])\nTo utilize edge weights when choosing an edge with, for example, the\nhighest betweenness centrality:\nfromnetworkximportedge_betweenness_centralityasbetweenness\ndefmost_central_edge(G):\ncentrality=betweenness(G,weight=\"weight\")\nreturnmax(centrality,key=centrality.get)\n\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G,most_valuable_edge=most_central_edge)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])\nTo specify a different ranking algorithm for edges, use themost_valuable_edgekeyword argument:\nfromnetworkximportedge_betweenness_centrality\nfromrandomimportrandom\ndefmost_central_edge(G):\ncentrality=edge_betweenness_centrality(G)\nmax_cent=max(centrality.values())\n# Scale the centrality values so they are between 0 and 1,\n# and add some random noise.\ncentrality={e:c/max_centfore,cincentrality.items()}\n# Add some random noise.\ncentrality={e:c+random()fore,cincentrality.items()}\nreturnmax(centrality,key=centrality.get)\n\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G,most_valuable_edge=most_central_edge)",
    "Section ID: edge_bfs\nDescription: [A directed, breadth-first-search of edges in G , beginning at source ., Yield the edges of G in a breadth-first-search order continuing until\nall edges are generated.]\nField List: Parameters:: G : graph: A directed/undirected graph/multigraph.\nsource : node, list of nodes: The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.\norientation : None | ‘original’ | ‘reverse’ | ‘ignore’ (default: None): For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to ‘reverse’ every edge is traversed in the reverse direction.\nWhen set to ‘ignore’, every edge is treated as undirected.\nWhen set to ‘original’, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported.\nYields:: edge : directed edge: A directed edge indicating the path taken by the breadth-first-search.\nFor graphs,edgeis of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs,edgeis of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (‘forward’ or ‘reverse’) on that edge.\nMethods: []\nRubrics: Notes: The goal of this function is to visit edges. It differs from the more\nfamiliar breadth-first-search of nodes, as provided by networkx.algorithms.traversal.breadth_first_search.bfs_edges() , in\nthat it does not stop once every node has been visited. In a directed graph\nwith edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\nif not for the functionality provided by this function. The naming of this function is very similar to bfs_edges. The difference\nis that ‘edge_bfs’ yields edges even if they extend back to an already\nexplored node while ‘bfs_edges’ yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means ‘edge_bfs’ reports all edges while\n‘bfs_edges’ only report those traversed by a node-based BFS. Yet another\ndescription is that ‘bfs_edges’ reports the edges traversed during BFS\nwhile ‘edge_bfs’ reports all edges in the order they are explored.\nExamples: nodes=[0,1,2,3]\nedges=[(0,1),(1,0),(1,0),(2,0),(2,1),(3,1)]\nlist(nx.edge_bfs(nx.Graph(edges),nodes))\n# [(0, 1), (0, 2), (1, 2), (1, 3)]\nlist(nx.edge_bfs(nx.DiGraph(edges),nodes))\n# [(0, 1), (1, 0), (2, 0), (2, 1), (3, 1)]\nlist(nx.edge_bfs(nx.MultiGraph(edges),nodes))\n# [(0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 2, 0), (1, 2, 0), (1, 3, 0)]\nlist(nx.edge_bfs(nx.MultiDiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 0, 0), (2, 1, 0), (3, 1, 0)]\nlist(nx.edge_bfs(nx.DiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 0, 'reverse'), (2, 0, 'reverse'), (2, 1, 'reverse'), (3, 1, 'reverse')]\nlist(nx.edge_bfs(nx.MultiDiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 0, 'forward'), (1, 0, 0, 'reverse'), (1, 0, 1, 'reverse'), (2, 0, 0, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]",
    "Section ID: strategy_random_sequential\nDescription: [Returns a random permutation of the nodes of G as a list., G is a NetworkX graph. colors is ignored.]\nField List: Methods: []\nRubrics:",
    "Section ID: number_of_nodes\nDescription: [Returns the number of nodes in the graph., This function wraps the G.number_of_nodes function.]\nField List: Methods: []\nRubrics:",
    "Section ID: strategy_largest_first\nDescription: [Returns a list of the nodes of G in decreasing order by\ndegree., G is a NetworkX graph. colors is ignored.]\nField List: Methods: []\nRubrics:",
    "Section ID: moral_graph\nDescription: [Return the Moral Graph, Returns the moralized graph of a given directed graph.]\nField List: Parameters:: G : NetworkX graph: Directed graph\nReturns:: H : NetworkX graph: The undirected moralized graph of G\nRaises:: NetworkXNotImplemented: IfGis undirected.\nMethods: []\nRubrics: Notes: A moral graph is an undirected graph H = (V, E) generated from a\ndirected Graph, where if a node has more than one parent node, edges\nbetween these parent nodes are inserted and all directed edges become\nundirected. https://en.wikipedia.org/wiki/Moral_graph\nReferences: [1]Wray L. Buntine. 1995. Chain graphs for learning.\nIn Proceedings of the Eleventh conference on Uncertainty\nin artificial intelligence (UAI’95)\nExamples: G=nx.DiGraph([(1,2),(2,3),(2,5),(3,4),(4,3)])\nG_moral=nx.moral_graph(G)\nG_moral.edges()\n# EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])",
    "Section ID: strategy_smallest_last\nDescription: [Returns a deque of the nodes of G , “smallest” last., Specifically, the degrees of each node are tracked in a bucket queue.\nFrom this, the node of minimum degree is repeatedly popped from the\ngraph, updating its neighbors’ degrees., G is a NetworkX graph. colors is ignored., This implementation of the strategy runs in \\(O(n + m)\\) time\n(ignoring polylogarithmic factors), where \\(n\\) is the number of nodes\nand \\(m\\) is the number of edges., This strategy is related to strategy_independent_set() : if we\ninterpret each node removed as an independent set of size one, then\nthis strategy chooses an independent set of size one instead of a\nmaximal independent set.]\nField List: Methods: []\nRubrics:",
    "Section ID: minimum_branching\nDescription: [Returns a minimum branching from G.]\nField List: Parameters:: G : (multi)digraph-like: The graph to be searched.\nattr : str: The edge attribute used to in determining optimality.\ndefault : float: The value of the edge attribute used if an edge does not have\nthe attributeattr.\npreserve_attrs : bool: If True, preserve the other attributes of the original graph (that are not\npassed toattr)\npartition : str: The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum.\nReturns:: B : (multi)digraph-like: A minimum branching.\nMethods: []\nRubrics:",
    "Section ID: configuration_model\nDescription: [Returns a random graph with the given degree sequence., The configuration model generates a random pseudograph (graph with\nparallel edges and self loops) by randomly assigning edges to\nmatch the given degree sequence.]\nField List: Parameters:: deg_sequence : list of nonnegative integers: Each list entry corresponds to the degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph): Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : MultiGraph: A graph with the specified degree sequence.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence.\nRaises:: NetworkXError: If the degree sequence does not have an even sum.\nMethods: []\nRubrics: Notes: As described by Newman [1] . A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the degree\nsequence does not have an even sum. This configuration model construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn’t have the exact degree sequence specified. The density of self-loops and parallel edges tends to decrease as\nthe number of nodes increases. However, typically the number of\nself-loops will approach a Poisson distribution with a nonzero mean,\nand similarly for the number of parallel edges.  Consider a node\nwith k stubs. The probability of being joined to another stub of\nthe same node is basically ( k - 1 ) / N , where k is the\ndegree and N is the number of nodes. So the probability of a\nself-loop scales like c / N for some constant c . As N grows,\nthis means we expect c self-loops. Similarly for parallel edges.\nReferences: [1]M.E.J. Newman, “The structure and function of complex networks”,\nSIAM REVIEW 45-2, pp 167-256, 2003.\nExamples: You can create a degree sequence following a particular distribution\nby using the one of the distribution functions inrandom_sequence(or one of your own). For\nexample, to create an undirected multigraph on one hundred nodes\nwith degree sequence chosen from the power law distribution:\nsequence=nx.random_powerlaw_tree_sequence(100,tries=5000)\nG=nx.configuration_model(sequence)\nlen(G)\n# 100\nactual_degrees=[dforv,dinG.degree()]\nactual_degrees==sequence\n# True\nThe returned graph is a multigraph, which may have parallel\nedges. To remove any parallel edges from the returned graph:\nG=nx.Graph(G)\nSimilarly, to remove self-loops:\nG.remove_edges_from(nx.selfloop_edges(G))",
    "Section ID: asyn_lpa_communities\nDescription: [Returns communities in G as detected by asynchronous label\npropagation., The asynchronous label propagation algorithm is described in [1] . The algorithm is probabilistic and the found communities may\nvary on different executions., The algorithm proceeds as follows. After initializing each node with\na unique label, the algorithm repeatedly sets the label of a node to\nbe the label that appears most frequently among that nodes\nneighbors. The algorithm halts when each node has the label that\nappears most frequently among its neighbors. The algorithm is\nasynchronous because each node is updated without waiting for\nupdates on the remaining nodes., This generalized version of the algorithm in [1] accepts edge\nweights.]\nField List: Parameters:: G : Graph: \nweight : string: The edge attribute representing the weight of an edge.\nIf None, each edge is assumed to have weight one. In this\nalgorithm, the weight of an edge is used in determining the\nfrequency with which a label appears among the neighbors of a\nnode: a higher weight means the label appears more often.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: communities : iterable: Iterable of communities given as sets of nodes.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nReferences: [1](1,2)Raghavan, Usha Nandini, Réka Albert, and Soundar Kumara. “Near\nlinear time algorithm to detect community structures in large-scale\nnetworks.” Physical Review E 76.3 (2007): 036106.",
    "Section ID: edge_connectivity\nDescription: [Returns the edge connectivity of the graph or digraph G., The edge connectivity is equal to the minimum number of edges that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local edge\nconnectivity: the minimum number of edges that must be removed to\nbreak all paths from source to target in G.]\nField List: Parameters:: G : NetworkX graph: Undirected or directed graph\ns : node: Source node. Optional. Default value: None.\nt : node: Target node. Optional. Default value: None.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.\ncutoff : integer, float, or None (default: None): If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise.\nReturns:: K : integer: Edge connectivity for G, or local edge connectivity if source\nand target were provided\nMethods: []\nRubrics: Notes: This is a flow based implementation of global edge connectivity.\nFor undirected graphs the algorithm works by finding a ‘small’\ndominating set of nodes of G (see algorithm 7 in [1] ) and\ncomputing local maximum flow (see local_edge_connectivity() )\nbetween an arbitrary node in the dominating set and the rest of\nnodes in it. This is an implementation of algorithm 6 in [1] .\nFor directed graphs, the algorithm does n calls to the maximum\nflow function. This is an implementation of algorithm 8 in [1] .\nReferences: [1](1,2,3)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\nExamples: # Platonic icosahedral graph is 5-edge-connected\nG=nx.icosahedral_graph()\nnx.edge_connectivity(G)\n# 5\nYou can use alternative flow algorithms for the underlying\nmaximum flow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions.\nAlternative flow functions have to be explicitly imported\nfrom the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnx.edge_connectivity(G,flow_func=shortest_augmenting_path)\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local edge connectivity.\nnx.edge_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_edge_connectivity()for details.",
    "Section ID: latapy_clustering\nDescription: [Compute a bipartite clustering coefficient for nodes., The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :, where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v ., The mode selects the function for c_{uv} which can be:, dot :, min :, max :]\nField List: Parameters:: G : graph: A bipartite graph\nnodes : list or iterable (optional): Compute bipartite clustering for these nodes. The default\nis all nodes in G.\nmode : string: The pairwise bipartite clustering method to be used in the computation.\nIt must be “dot”, “max”, or “min”.\nReturns:: clustering : dictionary: A dictionary keyed by node with the clustering coefficient value.\nMethods: []\nRubrics: References: [1]Latapy, Matthieu, Clémence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31–48.\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0",
    "Section ID: topological_generations\nDescription: [Stratifies a DAG into generations., A topological generation is node collection in which ancestors of a node in each\ngeneration are guaranteed to be in a previous generation, and any descendants of\na node are guaranteed to be in a following generation. Nodes are guaranteed to\nbe in the earliest possible generation that they can belong to.]\nField List: Parameters:: G : NetworkX digraph: A directed acyclic graph (DAG)\nYields:: sets of nodes: Yields sets of nodes representing each generation.\nRaises:: NetworkXError: Generations are defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.\nNetworkXUnfeasible: IfGis not a directed acyclic graph (DAG) no topological generations\nexist and aNetworkXUnfeasibleexception is raised.  This can also\nbe raised ifGis changed while the returned iterator is being processed\nRuntimeError: IfGis changed while the returned iterator is being processed.\nMethods: []\nRubrics: Notes: The generation in which a node resides can also be determined by taking the\nmax-path-distance from the node to the farthest leaf node. That value can\nbe obtained with this function using enumerate(topological_generations(G)) .\nExamples: DG=nx.DiGraph([(2,1),(3,1)])\n[sorted(generation)forgenerationinnx.topological_generations(DG)]\n# [[2, 3], [1]]",
    "Section ID: FilterAdjacency\nDescription: [A read-only Mapping of Mappings with filtering criteria for nodes and edges., It is a view into a dict-of-dict-of-dict data structure, and it selects nodes\nand edges that satisfy specific criteria defined by NODE_OK and EDGE_OK ,\nrespectively.]\nField List: Methods: []\nRubrics:",
    "Section ID: attr_sparse_matrix\nDescription: [Returns a SciPy sparse array using attributes from G., If only G is passed in, then the adjacency matrix is constructed., Let A be a discrete set of values for the node attribute node_attr . Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in G and consider the value\nof the edge attribute edge_attr .  If ua and va are the values of the\nnode attribute node_attr for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va).]\nField List: Parameters:: G : graph: The NetworkX graph used to construct the NumPy matrix.\nedge_attr : str, optional: Each element of the matrix represents a running total of the\nspecified edge attribute for edges whose node attributes correspond\nto the rows/cols of the matrix. The attribute must be present for\nall edges in the graph. If no attribute is specified, then we\njust count the number of edges whose node attributes correspond\nto the matrix element.\nnode_attr : str, optional: Each row and column in the matrix represents a particular value\nof the node attribute.  The attribute must be present for all nodes\nin the graph. Note, the values of this attribute should be reliably\nhashable. So, float values are not recommended. If no attribute is\nspecified, then the rows and columns will be the nodes of the graph.\nnormalized : bool, optional: If True, then each row is normalized by the summation of its values.\nrc_order : list, optional: A list of the node attribute values. This list specifies the ordering\nof rows and columns of the array. If no ordering is provided, then\nthe ordering will be random (and also, a return value).\nReturns:: M : SciPy sparse array: The attribute matrix.\nordering : list: Ifrc_orderwas specified, then only the matrix is returned.\nHowever, ifrc_orderwas None, then the ordering used to construct\nthe matrix is returned as well.\nOther Parameters:: dtype : NumPy data-type, optional: A valid NumPy dtype used to initialize the array. Keep in mind certain\ndtypes can yield unexpected results if the array is to be normalized.\nThe parameter is passed to numpy.zeros(). If unspecified, the NumPy\ndefault is used.\nMethods: []\nRubrics: Examples: Construct an adjacency matrix:\nG=nx.Graph()\nG.add_edge(0,1,thickness=1,weight=3)\nG.add_edge(0,2,thickness=2)\nG.add_edge(1,2,thickness=3)\nM=nx.attr_sparse_matrix(G,rc_order=[0,1,2])\nM.toarray()\n# array([[0., 1., 1.],\n#        [1., 0., 1.],\n#        [1., 1., 0.]])\nAlternatively, we can obtain the matrix describing edge thickness.\nM=nx.attr_sparse_matrix(G,edge_attr=\"thickness\",rc_order=[0,1,2])\nM.toarray()\n# array([[0., 1., 2.],\n#        [1., 0., 3.],\n#        [2., 3., 0.]])\nWe can also color the nodes and ask for the probability distribution over\nall edges (u,v) describing:",
    "Section ID: eulerian_circuit\nDescription: [Returns an iterator over the edges of an Eulerian circuit in G ., An Eulerian circuit is a closed walk that includes each edge of a\ngraph exactly once.]\nField List: Parameters:: G : NetworkX graph: A graph, either directed or undirected.\nsource : node, optional: Starting node for circuit.\nkeys : bool: If False, edges generated by this function will be of the form(u,v). Otherwise, edges will be of the form(u,v,k).\nThis option is ignored unlessGis a multigraph.\nReturns:: edges : iterator: An iterator over edges in the Eulerian circuit.\nRaises:: NetworkXError: If the graph is not Eulerian.\nMethods: []\nRubrics: Notes: This is a linear time implementation of an algorithm adapted from [1] . For general information about Euler tours, see [2] .\nReferences: [1]J. Edmonds, E. L. Johnson.\nMatching, Euler tours and the Chinese postman.\nMathematical programming, Volume 5, Issue 1 (1973), 111-114.  [2]https://en.wikipedia.org/wiki/Eulerian_path\nExamples: To get an Eulerian circuit in an undirected graph:\nG=nx.complete_graph(3)\nlist(nx.eulerian_circuit(G))\n# [(0, 2), (2, 1), (1, 0)]\nlist(nx.eulerian_circuit(G,source=1))\n# [(1, 2), (2, 0), (0, 1)]\nTo get the sequence of vertices in an Eulerian circuit:\n[uforu,vinnx.eulerian_circuit(G)]\n# [0, 2, 1]",
    "Section ID: is_regular\nDescription: [Determines whether the graph G is a regular graph., A regular graph is a graph where each vertex has the same degree. A\nregular digraph is a graph where the indegree and outdegree of each\nvertex are equal.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: bool: Whether the given graph or digraph is regular.\nMethods: []\nRubrics: Examples: G=nx.DiGraph([(1,2),(2,3),(3,4),(4,1)])\nnx.is_regular(G)\n# True",
    "Section ID: random_lobster\nDescription: [Returns a random lobster graph., A lobster is a tree that reduces to a caterpillar when pruning all\nleaf nodes. A caterpillar is a tree that reduces to a path graph\nwhen pruning all leaf nodes; setting p2 to zero produces a caterpillar., This implementation iterates on the probabilities p1 and p2 to add\nedges at levels 1 and 2, respectively. Graphs are therefore constructed\niteratively with uniform randomness at each level rather than being selected\nuniformly at random from the set of all possible lobsters.]\nField List: Parameters:: n : int: The expected number of nodes in the backbone\np1 : float: Probability of adding an edge to the backbone\np2 : float: Probability of adding an edge one level beyond backbone\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nRaises:: NetworkXError: Ifp1orp2parameters are >= 1 because the while loops would never finish.\nMethods: []\nRubrics:",
    "Section ID: maximal_matching\nDescription: [Find a maximal matching in the graph., A matching is a subset of edges in which no node occurs more than once.\nA maximal matching cannot add more edges and still be a matching.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nReturns:: matching : set: A maximal matching of the graph.\nMethods: []\nRubrics: Notes: The algorithm greedily selects a maximal matching M of the graph G\n(i.e. no superset of M exists). It runs in \\(O(|E|)\\) time.\nExamples: G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5)])\nsorted(nx.maximal_matching(G))\n# [(1, 2), (3, 5)]",
    "Section ID: local_bridges\nDescription: [Iterate over local bridges of G optionally computing the span, A local bridge is an edge whose endpoints have no common neighbors.\nThat is, the edge is not part of a triangle in the graph., The span of a local bridge is the shortest path length between\nthe endpoints if the local bridge is removed.]\nField List: Parameters:: G : undirected graph: \nwith_span : bool: If True, yield a 3-tuple(u,v,span)\nweight : function, string or None (default: None): If function, used to compute edge weights for the span.\nIf string, the edge data attribute used in calculating span.\nIf None, all edges have weight 1.\nYields:: e : edge: The local bridges as an edge 2-tuple of nodes(u,v)or\nas a 3-tuple(u,v,span)whenwith_spanisTrue.\nRaises:: NetworkXNotImplemented: IfGis a directed graph or multigraph.\nMethods: []\nRubrics: Examples: A cycle graph has every edge a local bridge with span N-1.\nG=nx.cycle_graph(9)\n(0,8,8)inset(nx.local_bridges(G))\n# True",
    "Section ID: is_strongly_connected\nDescription: [Decides whether the given tournament is strongly connected., This function is more theoretically efficient than the is_strongly_connected() function., The given graph must be a tournament, otherwise this function’s\nbehavior is undefined.]\nField List: Parameters:: G : NetworkX graph: A directed graph representing a tournament.\nReturns:: bool: Whether the tournament is strongly connected.\nMethods: []\nRubrics: Notes: Although this function is more theoretically efficient than the\ngeneric strong connectivity function, a speedup requires the use of\nparallelism. Though it may in the future, the current implementation\ndoes not use parallelism, thus you may not see much of a speedup. This algorithm comes from [1].\nReferences: [1]Tantau, Till.\n“A note on the complexity of the reachability problem for\ntournaments.”Electronic Colloquium on Computational Complexity. 2001.\n<http://eccc.hpi-web.de/report/2001/092/>\nExamples: G=nx.DiGraph([(0,1),(0,2),(1,2),(1,3),(2,3),(3,0)])\nnx.is_tournament(G)\n# True\nnx.tournament.is_strongly_connected(G)\n# True\nG.remove_edge(3,0)\nG.add_edge(0,3)\nnx.is_tournament(G)\n# True\nnx.tournament.is_strongly_connected(G)\n# False",
    "Section ID: pairwise\nDescription: [s -> (s0, s1), (s1, s2), (s2, s3), …]\nField List: Methods: []\nRubrics:",
    "Section ID: random_regular_expander_graph\nDescription: [Returns a random regular expander graph on \\(n\\) nodes with degree \\(d\\) ., An expander graph is a sparse graph with strong connectivity properties. [1], More precisely the returned graph is a \\((n, d, \\lambda)\\) -expander with \\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\) , close to the Alon-Boppana bound. [2], In the case where \\(\\epsilon = 0\\) it returns a Ramanujan graph.\nA Ramanujan graph has spectral gap almost as large as possible,\nwhich makes them excellent expanders. [3]]\nField List: Parameters:: n : int: The number of nodes.\nd : int: The degree of each node.\nepsilon : int, float, default=0: \nmax_tries : int, (default: 100): The number of allowed loops, also used in the maybe_regular_expander utility\nseed : (default: None): Seed used to set random number generation state. See :ref`Randomness<randomness>`.\nRaises:: NetworkXError: If max_tries is reached\nMethods: []\nRubrics: Notes: This loops over maybe_regular_expander and can be slow when \\(n\\) is too big or \\(\\epsilon\\) too small.\nReferences: [1]Expander graph,https://en.wikipedia.org/wiki/Expander_graph  [2]Alon-Boppana bound,https://en.wikipedia.org/wiki/Alon%E2%80%93Boppana_bound  [3]Ramanujan graphs,https://en.wikipedia.org/wiki/Ramanujan_graph\nExamples: G=nx.random_regular_expander_graph(20,4)\nnx.is_regular_expander(G)\n# True",
    "Section ID: edge_current_flow_betweenness_partition\nDescription: [Partition created by removing the highest edge current flow betweenness edge., This algorithm works by calculating the edge current flow\nbetweenness for all edges and removing the edge with the\nhighest value. It is then determined whether the graph has\nbeen broken into at least number_of_sets connected\ncomponents. If not the process is repeated.]\nField List: Parameters:: G : NetworkX Graph, DiGraph or MultiGraph: Graph to be partitioned\nnumber_of_sets : int: Number of sets in the desired partition of the graph\nweight : key, optional (default=None): The edge attribute key to use as weights for\nedge current flow betweenness calculations\nReturns:: C : list of sets: Partition of G\nRaises:: NetworkXError: If number_of_sets is <= 0 or number_of_sets > len(G)\nMethods: []\nRubrics: Notes: This algorithm is extremely slow, as the recalculation of the edge\ncurrent flow betweenness is extremely slow.\nReferences: [1]Santo Fortunato ‘Community Detection in Graphs’ Physical Reports\nVolume 486, Issue 3-5 p. 75-174http://arxiv.org/abs/0906.0612\nExamples: G=nx.karate_club_graph()\npart=nx.community.edge_current_flow_betweenness_partition(G,2)\n{0,1,2,3,4,5,6,7,9,10,11,12,13,16,17,19,21}inpart\n# True\n{8,14,15,18,20,22,23,24,25,26,27,28,29,30,31,32,33}inpart\n# True",
    "Section ID: connected_caveman_graph\nDescription: [Returns a connected caveman graph of l cliques of size k ., The connected caveman graph is formed by creating n cliques of size k , then a single edge in each clique is rewired to a node in an\nadjacent clique.]\nField List: Parameters:: l : int: number of cliques\nk : int: size of cliques (k at least 2 or NetworkXError is raised)\nReturns:: G : NetworkX Graph: connected caveman graph\nRaises:: NetworkXError: If the size of cliqueskis smaller than 2.\nMethods: []\nRubrics: Notes: This returns an undirected graph, it can be converted to a directed\ngraph using nx.to_directed() , or a multigraph using nx.MultiGraph(nx.caveman_graph(l,k)) . Only the undirected version is\ndescribed in [1] and it is unclear which of the directed\ngeneralizations is most useful.\nReferences: [1]Watts, D. J. ‘Networks, Dynamics, and the Small-World Phenomenon.’\nAmer. J. Soc. 105, 493-527, 1999.\nExamples: G=nx.connected_caveman_graph(3,3)",
    "Section ID: single_source_shortest_path\nDescription: [Compute shortest path between source\nand all other nodes reachable from source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: Starting node for path\ncutoff : integer, optional: Depth to stop the search. Only paths of length <= cutoff are returned.\nReturns:: paths : dictionary: Dictionary, keyed by target, of shortest paths.\nMethods: []\nRubrics: Notes: The shortest path is not necessarily unique. So there can be multiple\npaths between the source and each target node, all of which have the\nsame ‘shortest’ length. For each target node, this function returns\nonly one of those paths.\nExamples: G=nx.path_graph(5)\npath=nx.single_source_shortest_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]",
    "Section ID: to_numpy_array\nDescription: [Returns the graph adjacency matrix as a NumPy array.]\nField List: Parameters:: G : graph: The NetworkX graph used to construct the NumPy array.\nnodelist : list, optional: The rows and columns are ordered according to the nodes innodelist.\nIfnodelistisNone, then the ordering is produced byG.nodes().\ndtype : NumPy data type, optional: A NumPy data type used to initialize the array. If None, then the NumPy\ndefault is used. The dtype can be structured ifweight=None, in which\ncase the dtype field names are used to look up edge attributes. The\nresult is a structured array where each named field in the dtype\ncorresponds to the adjacency for that edge attribute. See examples for\ndetails.\norder : {‘C’, ‘F’}, optional: Whether to store multidimensional data in C- or Fortran-contiguous\n(row- or column-wise) order in memory. If None, then the NumPy default\nis used.\nmultigraph_weight : callable, optional: An function that determines how weights in multigraphs are handled.\nThe function should accept a sequence of weights and return a single\nvalue. The default is to sum the weights of the multiple edges.\nweight : string or None optional (default = ‘weight’): The edge attribute that holds the numerical value used for\nthe edge weight. If an edge does not have that attribute, then the\nvalue 1 is used instead.weightmust beNoneif a structured\ndtype is used.\nnonedge : array_like (default = 0.0): The value used to represent non-edges in the adjacency matrix.\nThe array values corresponding to nonedges are typically set to zero.\nHowever, this could be undesirable if there are array values\ncorresponding to actual edges that also have the value zero. If so,\none might prefer nonedges to have some other value, such asnan.\nReturns:: A : NumPy ndarray: Graph adjacency matrix\nRaises:: NetworkXError: Ifdtypeis a structured dtype andGis a multigraph\nValueError: Ifdtypeis a structured dtype andweightis notNone\nMethods: []\nRubrics: Notes: For directed graphs, entry i,j corresponds to an edge from i to j . Entries in the adjacency matrix are given by the weight edge attribute.\nWhen an edge does not have a weight attribute, the value of the entry is\nset to the number 1.  For multiple (parallel) edges, the values of the\nentries are determined by the multigraph_weight parameter. The default is\nto sum the weight attributes for each of the parallel edges. When nodelist does not contain every node in G , the adjacency matrix is\nbuilt from the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal array entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute). If the\nalternate convention of doubling the edge weight is desired the\nresulting NumPy array can be modified as follows:\nExamples: G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nnx.to_numpy_array(G,nodelist=[0,1,2])\n# array([[0., 2., 0.],\n#        [1., 0., 0.],\n#        [0., 0., 4.]])\nWhennodelistargument is used, nodes ofGwhich do not appear in thenodelistand their edges are not included in the adjacency matrix. Here is an example:\nG=nx.Graph()\nG.add_edge(3,1)\nG.add_edge(2,0)\nG.add_edge(2,1)\nG.add_edge(3,0)\nnx.to_numpy_array(G,nodelist=[1,2,3])\n# array([[0., 1., 1.],\n#        [1., 0., 0.],\n#        [1., 0., 0.]])\nThis function can also be used to create adjacency matrices for multiple\nedge attributes with structured dtypes:\nG=nx.Graph()\nG.add_edge(0,1,weight=10)\nG.add_edge(1,2,cost=5)\nG.add_edge(2,3,weight=3,cost=-4.0)\ndtype=np.dtype([(\"weight\",int),(\"cost\",float)])\nA=nx.to_numpy_array(G,dtype=dtype,weight=None)\nA[\"weight\"]\n# array([[ 0, 10,  0,  0],\n#        [10,  0,  1,  0],\n#        [ 0,  1,  0,  3],\n#        [ 0,  0,  3,  0]])\nA[\"cost\"]\n# array([[ 0.,  1.,  0.,  0.],\n#        [ 1.,  0.,  5.,  0.],\n#        [ 0.,  5.,  0., -4.],\n#        [ 0.,  0., -4.,  0.]])\nAs stated above, the argument “nonedge” is useful especially when there are\nactually edges with weight 0 in the graph. Setting a nonedge value different than 0,\nmakes it much clearer to differentiate such 0-weighted edges and actual nonedge values.\nG=nx.Graph()\nG.add_edge(3,1,weight=2)\nG.add_edge(2,0,weight=0)\nG.add_edge(2,1,weight=0)\nG.add_edge(3,0,weight=1)\nnx.to_numpy_array(G,nonedge=-1.0)\n# array([[-1.,  2., -1.,  1.],\n#        [ 2., -1.,  0., -1.],\n#        [-1.,  0., -1.,  0.],\n#        [ 1., -1.,  0., -1.]])",
    "Section ID: write_adjlist\nDescription: [Write graph G in single-line adjacency-list format to path.]\nField List: Parameters:: G : NetworkX graph: \npath : string or file: Filename or file handle for data output.\nFilenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional: Marker for comment lines\ndelimiter : string, optional: Separator for node labels\nencoding : string, optional: Text encoding.\nMethods: []\nRubrics: Notes: The default delimiter=\"\" will result in unexpected results if node names contain\nwhitespace characters. To avoid this problem, specify an alternate delimiter when spaces are\nvalid in node names.\nNB: This option is not available for data that isn’t user-generated. This format does not store graph, node, or edge data.\nExamples: G=nx.path_graph(4)\nnx.write_adjlist(G,\"test.adjlist\")\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in ‘wb’ mode.\nfh=open(\"test.adjlist\",\"wb\")\nnx.write_adjlist(G,fh)",
    "Section ID: make_list_of_ints\nDescription: [Return list of ints from sequence of integral numbers., All elements of the sequence must satisfy int(element) == element\nor a ValueError is raised. Sequence is iterated through once., If sequence is a list, the non-int values are replaced with ints.\nSo, no new list is created]\nField List: Methods: []\nRubrics:",
    "Section ID: triangular_lattice_graph\nDescription: [Returns the \\(m\\) by \\(n\\) triangular lattice graph., The triangular lattice graph is a two-dimensional grid graph in\nwhich each square unit has a diagonal edge (each grid unit has a chord)., The returned graph has \\(m\\) rows and \\(n\\) columns of triangles. Rows and\ncolumns include both triangles pointing up and down. Rows form a strip\nof constant height. Columns form a series of diamond shapes, staggered\nwith the columns on either side. Another way to state the size is that\nthe nodes form a grid of m+1 rows and (n+1)//2 columns.\nThe odd row nodes are shifted horizontally relative to the even rows., Directed graph types have edges pointed up or right., Positions of nodes are computed by default or with_positionsisTrue .\nThe position of each node (embedded in a euclidean plane) is stored in\nthe graph using equilateral triangles with sidelength 1.\nThe height between rows of nodes is thus \\(\\sqrt(3)/2\\) .\nNodes lie in the first quadrant with the node \\((0, 0)\\) at the origin.]\nField List: Parameters:: m : int: The number of rows in the lattice.\nn : int: The number of columns in the lattice.\nperiodic : bool (default: False): If True, join the boundary vertices of the grid using periodic\nboundary conditions. The join between boundaries is the final row\nand column of triangles. This means there is one row and one column\nfewer nodes for the periodic lattice. Periodic lattices requirem>=3,n>=5and are allowed but misaligned ifmornare odd\nwith_positions : bool (default: True): Store the coordinates of each node in the graph node attribute ‘pos’.\nThe coordinates provide a lattice with equilateral triangles.\nPeriodic positions shift the nodes vertically in a nonlinear way so\nthe edges don’t overlap so much.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: NetworkX graph: Thembyntriangular lattice graph.\nMethods: []\nRubrics:",
    "Section ID: random_partition_graph\nDescription: [Returns the random partition graph with a partition of sizes., A partition graph is a graph of communities with sizes defined by\ns in sizes. Nodes in the same group are connected with probability\np_in and nodes of different groups are connected with probability\np_out.]\nField List: Parameters:: sizes : list of ints: Sizes of groups\np_in : float: probability of edges with in groups\np_out : float: probability of edges between groups\ndirected : boolean optional, default=False: Whether to create a directed graph\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : NetworkX Graph or DiGraph: random partition graph of size sum(gs)\nRaises:: NetworkXError: If p_in or p_out is not in [0,1]\nMethods: []\nRubrics: Notes: This is a generalization of the planted-l-partition described in [1] .  It allows for the creation of groups of any size. The partition is store as a graph attribute ‘partition’.\nReferences: [1]Santo Fortunato ‘Community Detection in Graphs’ Physical Reports\nVolume 486, Issue 3-5 p. 75-174.https://arxiv.org/abs/0906.0612\nExamples: G=nx.random_partition_graph([10,10,10],0.25,0.01)\nlen(G)\n# 30\npartition=G.graph[\"partition\"]\nlen(partition)\n# 3",
    "Section ID: edge_boundary\nDescription: [Returns the edge boundary of nbunch1 ., The edge boundary of a set S with respect to a set T is the\nset of edges ( u , v ) such that u is in S and v is in T .\nIf T is not specified, it is assumed to be the set of all nodes\nnot in S .]\nField List: Parameters:: G : NetworkX graph: \nnbunch1 : iterable: Iterable of nodes in the graph representing the set of nodes\nwhose edge boundary will be returned. (This is the setSfrom\nthe definition above.)\nnbunch2 : iterable: Iterable of nodes representing the target (or “exterior”) set of\nnodes. (This is the setTfrom the definition above.) If not\nspecified, this is assumed to be the set of all nodes inGnot innbunch1.\nkeys : bool: This parameter has the same meaning as inMultiGraph.edges().\ndata : bool or object: This parameter has the same meaning as inMultiGraph.edges().\ndefault : object: This parameter has the same meaning as inMultiGraph.edges().\nReturns:: iterator: An iterator over the edges in the boundary ofnbunch1with\nrespect tonbunch2. Ifkeys,data, ordefaultare specified andGis a multigraph, then edges are returned\nwith keys and/or data, as inMultiGraph.edges().\nMethods: []\nRubrics: Notes: Any element of nbunch that is not in the graph G will be\nignored. nbunch1 and nbunch2 are usually meant to be disjoint, but in\nthe interest of speed and generality, that is not required here.\nExamples: G=nx.wheel_graph(6)\nWhen nbunch2=None:\nlist(nx.edge_boundary(G,(1,3)))\n# [(1, 0), (1, 2), (1, 5), (3, 0), (3, 2), (3, 4)]\nWhen nbunch2 is given:\nlist(nx.edge_boundary(G,(1,3),(2,0)))\n# [(1, 0), (1, 2), (3, 0), (3, 2)]",
    "Section ID: read_edgelist\nDescription: [Read a bipartite graph from a list of edges.]\nField List: Parameters:: path : file or string: File or filename to read. If a file is provided, it must be\nopened in ‘rb’ mode.\nFilenames ending in .gz or .bz2 will be uncompressed.\ncomments : string, optional: The character used to indicate the start of a comment.\ndelimiter : string, optional: The string used to separate values.  The default is whitespace.\ncreate_using : Graph container, optional,: Use specified container to build graph.  The default is networkx.Graph,\nan undirected graph.\nnodetype : int, float, str, Python type, optional: Convert node data from strings to specified type\ndata : bool or list of (label,type) tuples: Tuples specifying dictionary key names and types for edge data\nedgetype : int, float, str, Python type, optional OBSOLETE: Convert edge data from strings to specified type and use as ‘weight’\nencoding: string, optional: Specify which encoding to use when reading file.\nReturns:: G : graph: A networkx Graph or other type specified with create_using\nMethods: []\nRubrics: Notes: Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nbipartite.write_edgelist(G,\"test.edgelist\")\nG=bipartite.read_edgelist(\"test.edgelist\")\nfh=open(\"test.edgelist\",\"rb\")\nG=bipartite.read_edgelist(fh)\nfh.close()\nG=bipartite.read_edgelist(\"test.edgelist\",nodetype=int)\nEdgelist with data in a list:\ntextline=\"1 2 3\"\nfh=open(\"test.edgelist\",\"w\")\nd=fh.write(textline)\nfh.close()\nG=bipartite.read_edgelist(\n\"test.edgelist\",nodetype=int,data=((\"weight\",float),)\n)\nlist(G)\n# [1, 2]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0})]\nSee parse_edgelist() for more examples of formatting.",
    "Section ID: random_labeled_rooted_forest\nDescription: [Returns a labeled rooted forest with n nodes., The returned forest is chosen uniformly at random using a\ngeneralization of Prüfer sequences [1] in the form described in [2] .]\nField List: Parameters:: n : int: The number of nodes.\nseed : random_state: SeeRandomness.\nReturns:: networkx.Graph: Anetworkx.Graphwith integer nodes 0 <= node <=n- 1.\nThe “roots” graph attribute is a set of integers containing the roots.\nMethods: []\nRubrics: References: [1]Knuth, Donald E. “Another Enumeration of Trees.”\nCanadian Journal of Mathematics, 20 (1968): 1077-1086.https://doi.org/10.4153/CJM-1968-104-8  [2]Rubey, Martin. “Counting Spanning Trees”. Diplomarbeit\nzur Erlangung des akademischen Grades Magister der\nNaturwissenschaften an der Formal- und Naturwissenschaftlichen\nFakultät der Universität Wien. Wien, May 2000.",
    "Section ID: omega\nDescription: [Returns the small-world coefficient (omega) of a graph, The small-world coefficient of a graph G is:, omega = Lr/L - C/Cl, where C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Lr is the average shortest path length\nof an equivalent random graph and Cl is the average clustering coefficient\nof an equivalent lattice graph., The small-world coefficient (omega) measures how much G is like a lattice\nor a random graph. Negative values mean G is similar to a lattice whereas\npositive values mean G is a random graph.\nValues close to 0 mean that G has small-world characteristics.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nniter: integer (optional, default=5): Approximate number of rewiring per edge to compute the equivalent\nrandom graph.\nnrand: integer (optional, default=10): Number of random graphs generated to compute the maximal clustering\ncoefficient (Cr) and average shortest path length (Lr).\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: omega : float: The small-world coefficient (omega)\nMethods: []\nRubrics: Notes: The implementation is adapted from the algorithm by Telesford et al. [1] .\nReferences: [1]Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\n“The Ubiquity of Small-World Networks”.\nBrain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\ndoi:10.1089/brain.2011.0038.",
    "Section ID: minimum_spanning_tree\nDescription: [Returns a minimum spanning tree or forest on an undirected graph G .]\nField List: Parameters:: G : undirected graph: An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.\nweight : str: Data key to use for edge weights.\nalgorithm : string: The algorithm to use when finding a minimum spanning tree. Valid\nchoices are ‘kruskal’, ‘prim’, or ‘boruvka’. The default is\n‘kruskal’.\nignore_nan : bool (default: False): If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead.\nReturns:: G : NetworkX Graph: A minimum spanning tree or forest.\nMethods: []\nRubrics: Notes: For Borůvka’s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. There may be more than one tree with the same minimum or maximum weight.\nSee networkx.tree.recognition for more detailed definitions. Isolated nodes with self-loops are in the tree as edgeless isolated nodes.\nExamples: G=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nT=nx.minimum_spanning_tree(G)\nsorted(T.edges(data=True))\n# [(0, 1, {}), (1, 2, {}), (2, 3, {})]",
    "Section ID: is_forest\nDescription: [Returns True if G is a forest., A forest is a graph with no undirected cycles., For directed graphs, G is a forest if the underlying graph is a forest.\nThe underlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph.]\nField List: Parameters:: G : graph: The graph to test.\nReturns:: b : bool: A boolean that is True ifGis a forest.\nRaises:: NetworkXPointlessConcept: IfGis empty.\nMethods: []\nRubrics: Notes: In another convention, a directed forest is known as a polyforest and\nthen forest corresponds to a branching .\nExamples: G=nx.Graph()\nG.add_edges_from([(1,2),(1,3),(2,4),(2,5)])\nnx.is_forest(G)\n# True\nG.add_edge(4,1)\nnx.is_forest(G)\n# False",
    "Section ID: group_closeness_centrality\nDescription: [Compute the group closeness centrality for a group of nodes., Group closeness centrality of a group of nodes \\(S\\) is a measure\nof how close the group is to the other nodes in the graph., where \\(V\\) is the set of nodes, \\(d_{S, v}\\) is the distance of\nthe group \\(S\\) from \\(v\\) defined as above. ( \\(V-S\\) is the set of nodes\nin \\(V\\) that are not in \\(S\\) ).]\nField List: Parameters:: G : graph: A NetworkX graph.\nS : list or set: S is a group of nodes which belong to G, for which group closeness\ncentrality is to be calculated.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.\nReturns:: closeness : float: Group closeness centrality of the group S.\nRaises:: NodeNotFound: If node(s) in S are not present in G.\nMethods: []\nRubrics: Notes: The measure was introduced in [1] .\nThe formula implemented here is described in [2] . Higher values of closeness indicate greater centrality. It is assumed that 1 / 0 is 0 (required in the case of directed graphs,\nor when a shortest path length is 0). The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. For directed graphs, the incoming distance is utilized here. To use the\noutward distance, act on G.reverse() . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\nReferences: [1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]J. Zhao et. al.:\nMeasuring and Maximizing Group Closeness Centrality over\nDisk Resident Graphs.\nWWWConference Proceedings, 2014. 689-694.https://doi.org/10.1145/2567948.2579356",
    "Section ID: volume\nDescription: [Returns the volume of a set of nodes., The volume of a set S is the sum of the (out-)degrees of nodes\nin S (taking into account parallel edges in multigraphs). [1]]\nField List: Parameters:: G : NetworkX graph: \nS : collection: A collection of nodes inG.\nweight : object: Edge attribute key to use as weight. If not specified, edges\nhave weight one.\nReturns:: number: The volume of the set of nodes represented bySin the graphG.\nMethods: []\nRubrics: References: [1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>",
    "Section ID: harmonic_centrality\nDescription: [Compute harmonic centrality for nodes., Harmonic centrality [1] of a node u is the sum of the reciprocal\nof the shortest path distances from all other nodes to u, where d(v,u) is the shortest-path distance between v and u ., If sources is given as an argument, the returned harmonic centrality\nvalues are calculated as the sum of the reciprocals of the shortest\npath distances from the nodes specified in sources to u instead\nof from all nodes to u ., Notice that higher values indicate higher centrality.]\nField List: Parameters:: G : graph: A NetworkX graph\nnbunch : container (default: all nodes in G): Container of nodes for which harmonic centrality values are calculated.\nsources : container (default: all nodes in G): Container of nodesvover which reciprocal distances are computed.\nNodes not inGare silently ignored.\ndistance : edge attribute key, optional (default=None): Use the specified edge attribute as the edge distance in shortest\npath calculations.  IfNone, then each edge will have distance equal to 1.\nReturns:: nodes : dictionary: Dictionary of nodes with harmonic centrality as the value.\nMethods: []\nRubrics: Notes: If the ‘distance’ keyword is set to an edge attribute key then the\nshortest-path length will be computed using Dijkstra’s algorithm with\nthat edge attribute as the edge weight.\nReferences: [1]Boldi, Paolo, and Sebastiano Vigna. “Axioms for centrality.”\nInternet Mathematics 10.3-4 (2014): 222-262.",
    "Section ID: pygraphviz_layout\nDescription: [Create node positions for G using Graphviz.]\nField List: Parameters:: G : NetworkX graph: A graph created with NetworkX\nprog : string: Name of Graphviz layout program\nroot : string, optional: Root node for twopi layout\nargs : string, optional: Extra arguments to Graphviz layout program\nReturns:: node_pos : dict: Dictionary of x, y, positions keyed by node.\nMethods: []\nRubrics: Notes: If you use complex node objects, they may have the same string\nrepresentation and GraphViz could treat them as the same node.\nThe layout may assign both nodes a single location. See Issue #1568\nIf this occurs in your case, consider relabeling the nodes just\nfor the layout computation using something similar to:\nExamples: G=nx.petersen_graph()\npos=nx.nx_agraph.graphviz_layout(G)\npos=nx.nx_agraph.graphviz_layout(G,prog=\"dot\")",
    "Section ID: average_clustering\nDescription: [Estimates the average clustering coefficient of G., The local clustering of each node in G is the fraction of triangles\nthat actually exist over all possible triangles in its neighborhood.\nThe average clustering coefficient of a graph G is the mean of\nlocal clusterings., This function finds an approximate average clustering coefficient\nfor G by repeating n times (defined in trials ) the following\nexperiment: choose a node at random, choose two of its neighbors\nat random, and check if they are connected. The approximate\ncoefficient is the fraction of triangles found over the number\nof trials [1] .]\nField List: Parameters:: G : NetworkX graph: \ntrials : integer: Number of trials to perform (default 1000).\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: c : float: Approximated average clustering coefficient.\nRaises:: NetworkXNotImplemented: If G is directed.\nMethods: []\nRubrics: References: [1]Schank, Thomas, and Dorothea Wagner. Approximating clustering\ncoefficient and transitivity. Universität Karlsruhe, Fakultät für\nInformatik, 2004.https://doi.org/10.5445/IR/1000001239\nExamples: fromnetworkx.algorithmsimportapproximation\nG=nx.erdos_renyi_graph(10,0.2,seed=10)\napproximation.average_clustering(G,trials=1000,seed=10)\n# 0.214",
    "Section ID: circulant_graph\nDescription: [Returns the circulant graph \\(Ci_n(x_1, x_2, ..., x_m)\\) with \\(n\\) nodes., The circulant graph \\(Ci_n(x_1, ..., x_m)\\) consists of \\(n\\) nodes \\(0, ..., n-1\\) such that node \\(i\\) is connected to nodes \\((i + x) \\mod n\\) and \\((i - x) \\mod n\\) for all \\(x\\) in \\(x_1, ..., x_m\\) . Thus \\(Ci_n(1)\\) is a cycle graph., ( Sourcecode , png )]\nField List: Parameters:: n : integer: The number of nodes in the graph.\noffsets : list of integers: A list of node offsets,\\(x_1\\)up to\\(x_m\\), as described above.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: NetworkX Graph of type create_using:\nMethods: []\nRubrics: Examples: Many well-known graph families are subfamilies of the circulant graphs;\nfor example, to create the cycle graph on n points, we connect every\nnode to nodes on either side (with offset plus or minus one). For n = 10,\nG=nx.circulant_graph(10,[1])\nedges=[\n(0,9),\n(0,1),\n(1,2),\n(2,3),\n(3,4),\n(4,5),\n(5,6),\n(6,7),\n(7,8),\n(8,9),\n]\nsorted(edges)==sorted(G.edges())\n# True\nSimilarly, we can create the complete graph\non 5 points with the set of offsets [1, 2]:\nG=nx.circulant_graph(5,[1,2])\nedges=[\n(0,1),\n(0,2),\n(0,3),\n(0,4),\n(1,2),\n(1,3),\n(1,4),\n(2,3),\n(2,4),\n(3,4),\n]\nsorted(edges)==sorted(G.edges())\n# True",
    "Section ID: strategy_saturation_largest_first\nDescription: [Iterates over all the nodes of G in “saturation order” (also\nknown as “DSATUR”)., G is a NetworkX graph. colors is a dictionary mapping nodes of G to colors, for those nodes that have already been colored.]\nField List: Methods: []\nRubrics:",
    "Section ID: parse_leda\nDescription: [Read graph in LEDA format from string or iterable.]\nField List: Parameters:: lines : string or iterable: Data in LEDA format.\nReturns:: G : NetworkX graph:\nMethods: []\nRubrics: References: [1]http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html\nExamples: G=nx.parse_leda(string)",
    "Section ID: draw_networkx_nodes\nDescription: [Draw the nodes of the graph G., This draws only the nodes of the graph G.]\nField List: Parameters:: G : graph: A networkx graph\npos : dictionary: A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.\nax : Matplotlib Axes object, optional: Draw the graph in the specified Matplotlib axes.\nnodelist : list (default list(G)): Draw only specified nodes\nnode_size : scalar or array (default=300): Size of nodes.  If an array it must be the same length as nodelist.\nnode_color : color or array of colors (default=’#1f78b4’): Node color. Can be a single color or a sequence of colors with the same\nlength as nodelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the cmap and vmin,vmax parameters. See\nmatplotlib.scatter for more details.\nnode_shape : string (default=’o’): The shape of the node.  Specification is as matplotlib.scatter\nmarker, one of ‘so^>v<dph8’.\nalpha : float or array of floats (default=None): The node transparency.  This can be a single alpha value,\nin which case it will be applied to all the nodes of color. Otherwise,\nif it is an array, the elements of alpha will be applied to the colors\nin order (cycling through alpha multiple times if necessary).\ncmap : Matplotlib colormap (default=None): Colormap for mapping intensities of nodes\nvmin,vmax : floats or None (default=None): Minimum and maximum for node colormap scaling\nlinewidths : [None | scalar | sequence] (default=1.0): Line width of symbol border\nedgecolors : [None | scalar | sequence] (default = node_color): Colors of node borders. Can be a single color or a sequence of colors with the\nsame length as nodelist. Color can be string or rgb (or rgba) tuple of floats\nfrom 0-1. If numeric values are specified they will be mapped to colors\nusing the cmap and vmin,vmax parameters. Seescatterfor more details.\nlabel : [None | string]: Label for legend\nmargins : float or 2-tuple, optional: Sets the padding for axis autoscaling. Increase margin to prevent\nclipping for nodes that are near the edges of an image. Values should\nbe in the range[0,1]. Seematplotlib.axes.Axes.margins()for details. The default isNone, which uses the Matplotlib default.\nhide_ticks : bool, optional: Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False.\nReturns:: matplotlib.collections.PathCollection: PathCollectionof the nodes.\nMethods: []\nRubrics: Examples: G=nx.dodecahedral_graph()\nnodes=nx.draw_networkx_nodes(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html",
    "Section ID: is_semieulerian\nDescription: [Return True iff G is semi-Eulerian., G is semi-Eulerian if it has an Eulerian path but no Eulerian circuit.]\nField List: Methods: []\nRubrics:",
    "Section ID: equitable_color\nDescription: [Provides an equitable coloring for nodes of G ., Attempts to color a graph using num_colors colors, where no neighbors of\na node can have same color as the node itself and the number of nodes with\neach color differ by at most 1. num_colors must be greater than the\nmaximum degree of G . The algorithm is described in [1] and has\ncomplexity O(num_colors * n**2).]\nField List: Parameters:: G : networkX graph: The nodes of this graph will be colored.\nnum_colors : number of colors to use: This number must be at least one more than the maximum degree of nodes\nin the graph.\nReturns:: A dictionary with keys representing nodes and values representing: \ncorresponding coloring.:\nRaises:: NetworkXAlgorithmError: Ifnum_colorsis not at least the maximum degree of the graphG\nMethods: []\nRubrics: References: [1]Kierstead, H. A., Kostochka, A. V., Mydlarz, M., & Szemerédi, E.\n(2010). A fast algorithm for equitable coloring. Combinatorica, 30(2),\n217-224.\nExamples: G=nx.cycle_graph(4)\nnx.coloring.equitable_color(G,num_colors=3)\n# {0: 2, 1: 1, 2: 2, 3: 0}",
    "Section ID: parse_adjlist\nDescription: [Parse lines of a graph adjacency list representation.]\nField List: Parameters:: lines : list or iterator of strings: Input data in adjlist format\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nnodetype : Python type, optional: Convert nodes to this type.\ncomments : string, optional: Marker for comment lines\ndelimiter : string, optional: Separator for node labels.  The default is whitespace.\nReturns:: G: NetworkX graph: The graph corresponding to the lines in adjacency list format.\nMethods: []\nRubrics: Examples: lines=[\"1 2 5\",\"2 3 4\",\"3 5\",\"4\",\"5\"]\nG=nx.parse_adjlist(lines,nodetype=int)\nnodes=[1,2,3,4,5]\nall(nodeinGfornodeinnodes)\n# True\nedges=[(1,2),(1,5),(2,3),(2,4),(3,5)]\nall((u,v)inG.edges()or(v,u)inG.edges()for(u,v)inedges)\n# True",
    "Section ID: connected_watts_strogatz_graph\nDescription: [Returns a connected Watts–Strogatz small-world graph., Attempts to generate a connected graph by repeated generation of\nWatts–Strogatz small-world graphs.  An exception is raised if the maximum\nnumber of tries is exceeded.]\nField List: Parameters:: n : int: The number of nodes\nk : int: Each node is joined with itsknearest neighbors in a ring\ntopology.\np : float: The probability of rewiring each edge\ntries : int: Number of attempts to generate a connected graph.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: Notes: First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is joined\nto its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).\nThen shortcuts are created by replacing some edges as follows: for each\nedge \\((u, v)\\) in the underlying “ \\(n\\) -ring with \\(k\\) nearest neighbors”\nwith probability \\(p\\) replace it with a new edge \\((u, w)\\) with uniformly\nrandom choice of existing node \\(w\\) .\nThe entire process is repeated until a connected graph results.\nReferences: [1]Duncan J. Watts and Steven H. Strogatz,\nCollective dynamics of small-world networks,\nNature, 393, pp. 440–442, 1998.",
    "Section ID: intersection_all\nDescription: [Returns a new graph that contains only the nodes and the edges that exist in\nall graphs.]\nField List: Parameters:: graphs : iterable: Iterable of NetworkX graphs\nReturns:: R : A new graph with the same type as the first graph in list:\nRaises:: ValueError: Ifgraphsis an empty list.\nNetworkXError: In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\nMethods: []\nRubrics: Notes: For operating on mixed type graphs, they should be converted to the same type. Attributes from the graph, nodes, and edges are not copied to the new\ngraph. The resulting graph can be updated with attributes if desired. For example, code which adds the minimum attribute for each node across all graphs could work.\n>>> g = nx.Graph()\n>>> g.add_node(0, capacity=4)\n>>> g.add_node(1, capacity=3)\n>>> g.add_edge(0, 1)\nExamples: G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(2,3),(3,4)])\nR=nx.intersection_all([G1,G2])\nlist(R.nodes())\n# [2, 3]\nlist(R.edges())\n# [(2, 3)]",
    "Section ID: conductance\nDescription: [Returns the conductance of two sets of nodes., The conductance is the quotient of the cut size and the smaller of\nthe volumes of the two sets. [1]]\nField List: Parameters:: G : NetworkX graph: \nS : collection: A collection of nodes inG.\nT : collection: A collection of nodes inG.\nweight : object: Edge attribute key to use as weight. If not specified, edges\nhave weight one.\nReturns:: number: The conductance between the two setsSandT.\nMethods: []\nRubrics: References: [1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>",
    "Section ID: random_triad\nDescription: [Returns a random triad from a directed graph.]\nField List: Parameters:: G : digraph: A NetworkX DiGraph\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G2 : subgraph: A randomly selected triad (order-3 NetworkX DiGraph)\nRaises:: NetworkXError: If the input Graph has less than 3 nodes.\nMethods: []\nRubrics: Examples: G=nx.DiGraph([(1,2),(1,3),(2,3),(3,1),(5,6),(5,4),(6,7)])\ntriad=nx.random_triad(G,seed=1)\ntriad.edges\n# OutEdgeView([(1, 2)])",
    "Section ID: local_edge_connectivity\nDescription: [Returns local edge connectivity for nodes s and t in G., Local edge connectivity for two nodes s and t is the minimum number\nof edges that must be removed to disconnect them., This is a flow based implementation of edge connectivity. We compute the\nmaximum flow on an auxiliary digraph build from the original\nnetwork (see below for details). This is equal to the local edge\nconnectivity because the value of a maximum s-t-flow is equal to the\ncapacity of a minimum s-t-cut (Ford and Fulkerson theorem) [1] .]\nField List: Parameters:: G : NetworkX graph: Undirected or directed graph\ns : node: Source node\nt : node: Target node\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.\nauxiliary : NetworkX DiGraph: Auxiliary digraph for computing flow based edge connectivity. If\nprovided it will be reused instead of recreated. Default value: None.\nresidual : NetworkX DiGraph: Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.\ncutoff : integer, float, or None (default: None): If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise.\nReturns:: K : integer: local edge connectivity for nodes s and t.\nMethods: []\nRubrics: Notes: This is a flow based implementation of edge connectivity. We compute the\nmaximum flow using, by default, the edmonds_karp() algorithm on an\nauxiliary digraph build from the original input graph: If the input graph is undirected, we replace each edge ( u ,`v`) with\ntwo reciprocal arcs ( u , v ) and ( v , u ) and then we set the attribute\n‘capacity’ for each arc to 1. If the input graph is directed we simply\nadd the ‘capacity’ attribute. This is an implementation of algorithm 1\nin [1] . The maximum flow in the auxiliary network is equal to the local edge\nconnectivity because the value of a maximum s-t-flow is equal to the\ncapacity of a minimum s-t-cut (Ford and Fulkerson theorem).\nReferences: [1](1,2)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\nExamples: This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportlocal_edge_connectivity\nWe use in this example the platonic icosahedral graph, which has edge\nconnectivity 5.\nG=nx.icosahedral_graph()\nlocal_edge_connectivity(G,0,6)\n# 5\nIf you need to compute local connectivity on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local edge connectivity among\nall pairs of nodes of the platonic icosahedral graph reusing\nthe data structures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=local_edge_connectivity(G,u,v,auxiliary=H,residual=R)\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge\nconnectivity. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlocal_edge_connectivity(G,0,6,flow_func=shortest_augmenting_path)\n# 5",
    "Section ID: snap_aggregation\nDescription: [Creates a summary graph based on attributes and connectivity., This function uses the Summarization by Grouping Nodes on Attributes\nand Pairwise edges (SNAP) algorithm for summarizing a given\ngraph by grouping nodes by node attributes and their edge attributes\ninto supernodes in a summary graph.  This name SNAP should not be\nconfused with the Stanford Network Analysis Project (SNAP)., Here is a high-level view of how this algorithm works:, 2) Iteratively split groups until all nodes in each group have edges\nto nodes in the same groups. That is, until all the groups are homogeneous\nin their member nodes’ edges to other groups.  For example,\nif all the nodes in group A only have edge to nodes in group B, then the\ngroup is homogeneous and does not need to be split. If all nodes in group B\nhave edges with nodes in groups {A, C}, but some also have edges with other\nnodes in B, then group B is not homogeneous and needs to be split into\ngroups have edges with {A, C} and a group of nodes having\nedges with {A, B, C}.  This way, viewers of the summary graph can\nassume that all nodes in the group have the exact same node attributes and\nthe exact same edges., 3) Build the output summary graph, where the groups are represented by\nsuper-nodes. Edges represent the edges shared between all the nodes in each\nrespective groups., A SNAP summary graph can be used to visualize graphs that are too large to display\nor visually analyze, or to efficiently identify sets of similar nodes with similar connectivity\npatterns to other sets of similar nodes based on specified node and/or edge attributes in a graph.]\nField List: Parameters:: G: graph: Networkx Graph to be summarized\nnode_attributes: iterable, required: An iterable of the node attributes used to group nodes in the summarization process. Nodes\nwith the same values for these attributes will be grouped together in the summary graph.\nedge_attributes: iterable, optional: An iterable of the edge attributes considered in the summarization process.  If provided, unique\ncombinations of the attribute values found in the graph are used to\ndetermine the edge types in the graph.  If not provided, all edges\nare considered to be of the same type.\nprefix: str: The prefix used to denote supernodes in the summary graph. Defaults to ‘Supernode-‘.\nsupernode_attribute: str: The node attribute for recording the supernode groupings of nodes. Defaults to ‘group’.\nsuperedge_attribute: str: The edge attribute for recording the edge types of multiple edges. Defaults to ‘types’.\nReturns:: networkx.Graph: summary graph:\nMethods: []\nRubrics: Notes: The summary graph produced is called a maximum Attribute-edge\ncompatible (AR-compatible) grouping.  According to [1] , an\nAR-compatible grouping means that all nodes in each group have the same\nexact node attribute values and the same exact edges and\nedge types to one or more nodes in the same groups.  The maximal\nAR-compatible grouping is the grouping with the minimal cardinality. The AR-compatible grouping is the most detailed grouping provided by\nany of the SNAP algorithms.\nReferences: [1]Y. Tian, R. A. Hankins, and J. M. Patel. Efficient aggregation\nfor graph summarization. In Proc. 2008 ACM-SIGMOD Int. Conf.\nManagement of Data (SIGMOD’08), pages 567–580, Vancouver, Canada,\nJune 2008.\nExamples: SNAP aggregation takes a graph and summarizes it in the context of user-provided\nnode and edge attributes such that a viewer can more easily extract and\nanalyze the information represented by the graph\nnodes={\n\"A\":dict(color=\"Red\"),\n\"B\":dict(color=\"Red\"),\n\"C\":dict(color=\"Red\"),\n\"D\":dict(color=\"Red\"),\n\"E\":dict(color=\"Blue\"),\n\"F\":dict(color=\"Blue\"),\n}\nedges=[\n(\"A\",\"E\",\"Strong\"),\n(\"B\",\"F\",\"Strong\"),\n(\"C\",\"E\",\"Weak\"),\n(\"D\",\"F\",\"Weak\"),\n]\nG=nx.Graph()\nfornodeinnodes:\nattributes=nodes[node]\nG.add_node(node,**attributes)\nforsource,target,typeinedges:\nG.add_edge(source,target,type=type)\nnode_attributes=(\"color\",)\nedge_attributes=(\"type\",)\nsummary_graph=nx.snap_aggregation(\nG,node_attributes=node_attributes,edge_attributes=edge_attributes\n)",
    "Section ID: average_clustering\nDescription: [Compute the average clustering coefficient for the graph G., The clustering coefficient for the graph is the average,, where \\(n\\) is the number of nodes in G .]\nField List: Parameters:: G : graph: \nnodes : container of nodes, optional (default=all nodes in G): Compute average clustering for nodes in this container.\nweight : string or None, optional (default=None): The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.\ncount_zeros : bool: If False include only the nodes with nonzero clustering in the average.\nReturns:: avg : float: Average clustering\nMethods: []\nRubrics: Notes: This is a space saving routine; it might be faster\nto use the clustering function to get a list and then take the average. Self loops are ignored.\nReferences: [1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saramäki, M. Kivelä, J.-P. Onnela,\nK. Kaski, and J. Kertész, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Marcus Kaiser,  Mean clustering coefficients: the role of isolated\nnodes and leafs on clustering measures for small-world networks.https://arxiv.org/abs/0802.2512\nExamples: G=nx.complete_graph(5)\nprint(nx.average_clustering(G))\n# 1.0",
    "Section ID: is_connected\nDescription: [Returns True if the graph is connected, False otherwise.]\nField List: Parameters:: G : NetworkX Graph: An undirected graph.\nReturns:: connected : bool: True if the graph is connected, false otherwise.\nRaises:: NetworkXNotImplemented: If G is directed.\nMethods: []\nRubrics: Notes: For undirected graphs only.\nExamples: G=nx.path_graph(4)\nprint(nx.is_connected(G))\n# True",
    "Section ID: soft_random_geometric_graph\nDescription: [Returns a soft random geometric graph in the unit cube., The soft random geometric graph [1] model places n nodes uniformly at\nrandom in the unit cube in dimension dim . Two nodes of distance, dist ,\ncomputed by the p -Minkowski distance metric are joined by an edge with\nprobability p_dist if the computed distance metric value of the nodes\nis at most radius , otherwise they are not joined., Edges within radius of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) .]\nField List: Parameters:: n : int or iterable: Number of nodes or iterable of nodes\nradius: float: Distance threshold value\ndim : int, optional: Dimension of graph\npos : dict, optional: A dictionary keyed by node with node positions as values.\np : float, optional: Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.This should not be confused with thepof an Erdős-Rényi random\ngraph, which represents probability.\np_dist : function, optional: A probability density function computing the probability of\nconnecting two nodes that are of distance, dist, computed by the\nMinkowski distance metric. The probability density function,p_dist,\nmust be any function that takes the metric value as input\nand outputs a single probability value between 0-1. The scipy.stats\npackage has many probability distribution functions implemented and\ntools for custom probability distribution definitions [2], and passing\nthe .pdf method of scipy.stats distributions can be used here.  If the\nprobability function,p_dist, is not supplied, the default function\nis an exponential distribution with rate parameter\\(\\lambda=1\\).\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\npos_name : string, default=”pos”: The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.\nReturns:: Graph: A soft random geometric graph, undirected and without self-loops.\nEach node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function.\nMethods: []\nRubrics: Notes: This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2 The scipy.stats package can be used to define the probability distribution\nwith the .pdf method used as p_dist .\nReferences: [1]Penrose, Mathew D. “Connectivity of soft random geometric graphs.”\nThe Annals of Applied Probability 26.2 (2016): 986-1028.  [2]scipy.stats -https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html\nExamples: Default Graph:\nG = nx.soft_random_geometric_graph(50, 0.2)\nCustom Graph:\nCreate a soft random geometric graph on 100 uniformly distributed nodes\nwhere nodes are joined by an edge with probability computed from an\nexponential distribution with rate parameter\\(\\lambda=1\\)if their\nEuclidean distance is at most 0.2.",
    "Section ID: k_clique_communities\nDescription: [Find k-clique communities in graph using the percolation method., A k-clique community is the union of all cliques of size k that\ncan be reached through adjacent (sharing k-1 nodes) k-cliques.]\nField List: Parameters:: G : NetworkX graph: \nk : int: Size of smallest clique\ncliques: list or generator: Precomputed cliques (use networkx.find_cliques(G))\nReturns:: Yields sets of nodes, one for each k-clique community.:\nMethods: []\nRubrics: References: [1]Gergely Palla, Imre Derényi, Illés Farkas1, and Tamás Vicsek,\nUncovering the overlapping community structure of complex networks\nin nature and society Nature 435, 814-818, 2005,\ndoi:10.1038/nature03607\nExamples: G=nx.complete_graph(5)\nK5=nx.convert_node_labels_to_integers(G,first_label=2)\nG.add_edges_from(K5.edges())\nc=list(nx.community.k_clique_communities(G,4))\nsorted(list(c[0]))\n# [0, 1, 2, 3, 4, 5, 6]\nlist(nx.community.k_clique_communities(G,6))\n# []",
    "Section ID: junction_tree\nDescription: [Returns a junction tree of a given graph., A junction tree (or clique tree) is constructed from a (un)directed graph G.\nThe tree is constructed based on a moralized and triangulated version of G.\nThe tree’s nodes consist of maximal cliques and sepsets of the revised graph.\nThe sepset of two cliques is the intersection of the nodes of these cliques,\ne.g. the sepset of (A,B,C) and (A,C,E,F) is (A,C). These nodes are often called\n“variables” in this literature. The tree is bipartite with each sepset\nconnected to its two cliques., Junction Trees are not unique as the order of clique consideration determines\nwhich sepsets are included., The junction tree algorithm consists of five steps [1] :]\nField List: Parameters:: G : networkx.Graph: Directed or undirected graph.\nReturns:: junction_tree : networkx.Graph: The corresponding junction tree ofG.\nRaises:: NetworkXNotImplemented: Raised ifGis an instance ofMultiGraphorMultiDiGraph.\nMethods: []\nRubrics: References: [1]Junction tree algorithm:https://en.wikipedia.org/wiki/Junction_tree_algorithm  [2]Finn V. Jensen and Frank Jensen. 1994. Optimal\njunction trees. In Proceedings of the Tenth international\nconference on Uncertainty in artificial intelligence (UAI’94).\nMorgan Kaufmann Publishers Inc., San Francisco, CA, USA, 360–366.",
    "Section ID: read_multiline_adjlist\nDescription: [Read graph in multi-line adjacency list format from path.]\nField List: Parameters:: path : string or file: Filename or file handle to read.\nFilenames ending in .gz or .bz2 will be uncompressed.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nnodetype : Python type, optional: Convert nodes to this type.\nedgetype : Python type, optional: Convert edge data to this type.\ncomments : string, optional: Marker for comment lines\ndelimiter : string, optional: Separator for node labels.  The default is whitespace.\nReturns:: G: NetworkX graph:\nMethods: []\nRubrics: Notes: This format does not store graph, node, or edge data.\nExamples: G=nx.path_graph(4)\nnx.write_multiline_adjlist(G,\"test.adjlist\")\nG=nx.read_multiline_adjlist(\"test.adjlist\")\nThe path can be a file or a string with the name of the file. If a\nfile s provided, it has to be opened in ‘rb’ mode.\nfh=open(\"test.adjlist\",\"rb\")\nG=nx.read_multiline_adjlist(fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_multiline_adjlist(G,\"test.adjlist.gz\")\nG=nx.read_multiline_adjlist(\"test.adjlist.gz\")\nThe optional nodetype is a function to convert node strings to nodetype.\nFor example\nG=nx.read_multiline_adjlist(\"test.adjlist\",nodetype=int)\nwill attempt to convert all nodes to integer type.\nThe optional edgetype is a function to convert edge data strings to\nedgetype.\nG=nx.read_multiline_adjlist(\"test.adjlist\")\nThe optional create_using parameter is a NetworkX graph container.\nThe default is Graph(), an undirected graph.  To read the data as\na directed graph use\nG=nx.read_multiline_adjlist(\"test.adjlist\",create_using=nx.DiGraph)",
    "Section ID: incidence_matrix\nDescription: [Returns incidence matrix of G., The incidence matrix assigns each row to a node and each column to an edge.\nFor a standard incidence matrix a 1 appears wherever a row’s node is\nincident on the column’s edge.  For an oriented incidence matrix each\nedge is assigned an orientation (arbitrarily for undirected and aligning to\ndirection for directed).  A -1 appears for the source (tail) of an edge and\n1 for the destination (head) of the edge.  The elements are zero otherwise.]\nField List: Parameters:: G : graph: A NetworkX graph\nnodelist : list, optional   (default= all nodes in G): The rows are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nedgelist : list, optional (default= all edges in G): The columns are ordered according to the edges in edgelist.\nIf edgelist is None, then the ordering is produced by G.edges().\noriented: bool, optional (default=False): If True, matrix elements are +1 or -1 for the head or tail node\nrespectively of each edge.  If False, +1 occurs at both nodes.\nweight : string or None, optional (default=None): The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1.  Edge weights, if used,\nshould be positive so that the orientation can provide the sign.\ndtype : a NumPy dtype or None (default=None): The dtype of the output sparse array. This type should be a compatible\ntype of the weight argument, eg. if weight would return a float this\nargument should also be a float.\nIf None, then the default for SciPy is used.\nReturns:: A : SciPy sparse array: The incidence matrix of G.\nMethods: []\nRubrics: Notes: For MultiGraph/MultiDiGraph, the edges in edgelist should be\n(u,v,key) 3-tuples. “Networks are the best discrete model for so many problems in\napplied mathematics” [1] .\nReferences: [1]Gil Strang, Network applications: A = incidence matrix,http://videolectures.net/mit18085f07_strang_lec03/",
    "Section ID: build_auxiliary_node_connectivity\nDescription: [Creates a directed graph D from an undirected graph G to compute flow\nbased node connectivity., For an undirected graph G having n nodes and m edges we derive a\ndirected graph D with 2n nodes and 2m+n arcs by replacing each\noriginal node v with two nodes vA , vB linked by an (internal)\narc in D. Then for each edge ( u , v ) in G we add two arcs ( uB , vA )\nand ( vB , uA ) in D. Finally we set the attribute capacity = 1 for each\narc in D [1] ., For a directed graph having n nodes and m arcs we derive a\ndirected graph D with 2n nodes and m+n arcs by replacing each\noriginal node v with two nodes vA , vB linked by an (internal)\narc ( vA , vB ) in D. Then for each arc ( u , v ) in G we add one\narc ( uB , vA ) in D. Finally we set the attribute capacity = 1 for\neach arc in D., A dictionary with a mapping between nodes in the original graph and the\nauxiliary digraph is stored as a graph attribute: D.graph[‘mapping’]., References]\nField List: Methods: []\nRubrics: References: [1]Kammer, Frank and Hanjo Taubig. Graph Connectivity. in Brandes and\nErlebach, ‘Network Analysis: Methodological Foundations’, Lecture\nNotes in Computer Science, Volume 3418, Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31955-9_7",
    "Section ID: chordal_cycle_graph\nDescription: [Returns the chordal cycle graph on p nodes., The returned graph is a cycle graph on p nodes with chords joining each\nvertex x to its inverse modulo p . This graph is a (mildly explicit)\n3-regular expander [1] ., p  must be a prime number.]\nField List: Parameters:: p : a prime number: The number of vertices in the graph. This also indicates where the\nchordal edges in the cycle will be created.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : graph: The constructed undirected multigraph.\nRaises:: NetworkXError: Ifcreate_usingindicates directed or not a multigraph.\nMethods: []\nRubrics: References: [1]Theorem 4.4.2 in A. Lubotzky. “Discrete groups, expanding graphs and\ninvariant measures”, volume 125 of Progress in Mathematics.\nBirkhäuser Verlag, Basel, 1994.",
    "Section ID: ArborescenceIterator\nDescription: [Iterate over all spanning arborescences of a graph in either increasing or\ndecreasing cost., Notes, This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges). It generates minimum spanning\narborescences using a modified Edmonds’ Algorithm which respects the\npartition of edges. For arborescences with the same weight, ties are\nbroken arbitrarily., References]\nField List: Parameters:: G : nx.DiGraph: The directed graph which we need to iterate trees over\nweight : String, default = “weight”: The edge attribute used to store the weight of the edge\nminimum : bool, default = True: Return the trees in increasing order while true and decreasing order\nwhile false.\ninit_partition : tuple, default = None: In the case that certain edges have to be included or excluded from\nthe arborescences,init_partitionshould be in the form(included_edges,excluded_edges)where each edges is a(u,v)-tuple inside an iterable such as a list or set.\nMethods: []\nRubrics: Notes: This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges). It generates minimum spanning\narborescences using a modified Edmonds’ Algorithm which respects the\npartition of edges. For arborescences with the same weight, ties are\nbroken arbitrarily.\nReferences: [1]G.K. Janssens, K. Sörensen, An algorithm to generate all spanning\ntrees in order of increasing cost, Pesquisa Operacional, 2005-08,\nVol. 25 (2), p. 219-229,https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en",
    "Section ID: make_max_clique_graph\nDescription: [Returns the maximal clique graph of the given graph., The nodes of the maximal clique graph of G are the cliques of G and an edge joins two cliques if the cliques are not disjoint.]\nField List: Parameters:: G : NetworkX graph: \ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: NetworkX graph: A graph whose nodes are the cliques ofGand whose edges\njoin two cliques if they are not disjoint.\nMethods: []\nRubrics: Notes: This function behaves like the following code:",
    "Section ID: is_valid_directed_joint_degree\nDescription: [Checks whether the given directed joint degree input is realizable]\nField List: Parameters:: in_degrees : list of integers: in degree sequence contains the in degrees of nodes.\nout_degrees : list of integers: out degree sequence contains the out degrees of nodes.\nnkk : dictionary of dictionary of integers: directed joint degree dictionary. for nodes of out degree k (first\nlevel of dict) and nodes of in degree l (second level of dict)\ndescribes the number of edges.\nReturns:: boolean: returns true if given input is realizable, else returns false.\nMethods: []\nRubrics: Notes: Here is the list of conditions that the inputs (in/out degree sequences,\nnkk) need to satisfy for simple directed graph realizability:\nReferences: [1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka, “Construction of Directed 2K Graphs”. In Proc. of KDD 2017.",
    "Section ID: common_neighbor_centrality\nDescription: [Return the CCPA score for each pair of nodes., Compute the Common Neighbor and Centrality based Parameterized Algorithm(CCPA)\nscore of all node pairs in ebunch., CCPA score of u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) , \\(\\Gamma(v)\\) denotes the\nset of neighbors of \\(v\\) , \\(\\alpha\\) is  parameter varies between [0,1], \\(N\\) denotes\ntotal number of nodes in the Graph and \\({d}_{uv}\\) denotes shortest distance\nbetween \\(u\\) and \\(v\\) ., This algorithm is based on two vital properties of nodes, namely the number\nof common neighbors and their centrality. Common neighbor refers to the common\nnodes between two nodes. Centrality refers to the prestige that a node enjoys\nin a network.]\nField List: Parameters:: G : graph: NetworkX undirected graph.\nebunch : iterable of node pairs, optional (default = None): Preferential attachment score will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None.\nalpha : Parameter defined for participation of Common Neighbor: and Centrality Algorithm share. Values for alpha should\nnormally be between 0 and 1. Default value set to 0.8\nbecause author found better performance at 0.8 for all the\ndataset.\nDefault value: 0.8\nReturns:: piter : iterator: An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Common Neighbor and Centrality based\nParameterized Algorithm(CCPA) score.\nRaises:: NetworkXNotImplemented: IfGis aDiGraph, aMultigraphor aMultiDiGraph.\nNetworkXAlgorithmError: If self loops exsists inebunchor inG(ifebunchisNone).\nNodeNotFound: Ifebunchhas a node that is not inG.\nMethods: []\nRubrics: References: [1]Ahmad, I., Akhtar, M.U., Noor, S. et al.\nMissing Link Prediction using Common Neighbor and Centrality based Parameterized Algorithm.\nSci Rep 10, 364 (2020).https://doi.org/10.1038/s41598-019-57304-y\nExamples: G=nx.complete_graph(5)\npreds=nx.common_neighbor_centrality(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 1) -> 3.4000000000000004\n# (2, 3) -> 3.4000000000000004",
    "Section ID: rescale_layout\nDescription: [Returns scaled position array to (-scale, scale) in all axes., The function acts on NumPy arrays which hold position information.\nEach position is one row of the array. The dimension of the space\nequals the number of columns. Each coordinate in one column., To rescale, the mean (center) is subtracted from each axis separately.\nThen all values are scaled so that the largest magnitude value\nfrom all axes equals scale (thus, the aspect ratio is preserved).\nThe resulting NumPy Array is returned (order of rows unchanged).]\nField List: Parameters:: pos : numpy array: positions to be scaled. Each row is a position.\nscale : number (default: 1): The size of the resulting extent in all directions.\nReturns:: pos : numpy array: scaled positions. Each row is a position.\nMethods: []\nRubrics:",
    "Section ID: single_source_dijkstra\nDescription: [Find shortest weighted paths and lengths from a source node., Compute the shortest path length between source and all other\nreachable nodes for a weighted graph., Uses Dijkstra’s algorithm to compute shortest paths and lengths\nbetween a source and all other reachable nodes in a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: Starting node for path\ntarget : node label, optional: Ending node for path\ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: distance, path : pair of dictionaries, or numeric and list.: If target is None, paths and lengths to all nodes are computed.\nThe return value is a tuple of two dictionaries keyed by target nodes.\nThe first dictionary stores distance to each target node.\nThe second stores the path to each target node.\nIf target is not None, returns a tuple (distance, path), where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target.\nRaises:: NodeNotFound: Ifsourceis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. Based on the Python cookbook recipe (119466) at https://code.activestate.com/recipes/119466/ This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).\nExamples: G=nx.path_graph(5)\nlength,path=nx.single_source_dijkstra(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4\npath[4]\n# [0, 1, 2, 3, 4]\nlength,path=nx.single_source_dijkstra(G,0,1)\nlength\n# 1\npath\n# [0, 1]",
    "Section ID: les_miserables_graph\nDescription: [Returns coappearance network of characters in the novel Les Miserables., References]\nField List: Methods: []\nRubrics: References: [1]D. E. Knuth, 1993.\nThe Stanford GraphBase: a platform for combinatorial computing,\npp. 74-87. New York: AcM Press.",
    "Section ID: visibility_graph\nDescription: [Return a Visibility Graph of an input Time Series., A visibility graph converts a time series into a graph. The constructed graph\nuses integer nodes to indicate which event in the series the node represents.\nEdges are formed as follows: consider a bar plot of the series and view that\nas a side view of a landscape with a node at the top of each bar. An edge\nmeans that the nodes can be connected by a straight “line-of-sight” without\nbeing obscured by any bars between the nodes., The resulting graph inherits several properties of the series in its structure.\nThereby, periodic series convert into regular graphs, random series convert\ninto random graphs, and fractal series convert into scale-free networks [1] .]\nField List: Parameters:: series : Sequence[Number]: A Time Series sequence (iterable and sliceable) of numeric values\nrepresenting times.\nReturns:: NetworkX Graph: The Visibility Graph of the input series\nMethods: []\nRubrics: References: [1]Lacasa, Lucas, Bartolo Luque, Fernando Ballesteros, Jordi Luque, and Juan Carlos Nuno.\n“From time series to complex networks: The visibility graph.” Proceedings of the\nNational Academy of Sciences 105, no. 13 (2008): 4972-4975.https://www.pnas.org/doi/10.1073/pnas.0709247105\nExamples: series_list=[range(10),[2,1,3,2,1,3,2,1,3,2,1,3]]\nforsinseries_list:\ng=nx.visibility_graph(s)\nprint(g)\n# Graph with 10 nodes and 9 edges\n# Graph with 12 nodes and 18 edges",
    "Section ID: is_maximal_matching\nDescription: [Return True if matching is a maximal matching of G, A maximal matching in a graph is a matching in which adding any\nedge would cause the set to no longer be a valid matching.]\nField List: Parameters:: G : NetworkX graph: \nmatching : dict or set: A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching.\nReturns:: bool: Whether the given set or dictionary represents a valid maximal\nmatching in the graph.\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nnx.is_maximal_matching(G,{(1,2),(3,4)})\n# True",
    "Section ID: spectral_bipartivity\nDescription: [Returns the spectral bipartivity.]\nField List: Parameters:: G : NetworkX graph: \nnodes : list or container  optional(default is all nodes): Nodes to return value of spectral bipartivity contribution.\nweight : string or None  optional (default = ‘weight’): Edge data key to use for edge weights. If None, weights set to 1.\nReturns:: sb : float or dict: A single number if the keyword nodes is not specified, or\na dictionary keyed by node with the spectral bipartivity contribution\nof that node as the value.\nMethods: []\nRubrics: Notes: This implementation uses Numpy (dense) matrices which are not efficient\nfor storing large sparse graphs.\nReferences: [1]E. Estrada and J. A. Rodríguez-Velázquez, “Spectral measures of\nbipartivity in complex networks”, PhysRev E 72, 046105 (2005)\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nbipartite.spectral_bipartivity(G)\n# 1.0",
    "Section ID: louvain_partitions\nDescription: [Yields partitions for each level of the Louvain Community Detection Algorithm, Louvain Community Detection Algorithm is a simple method to extract the community\nstructure of a network. This is a heuristic method based on modularity optimization. [1], The partitions at each level (step of the algorithm) form a dendrogram of communities.\nA dendrogram is a diagram representing a tree and each level represents\na partition of the G graph. The top level contains the smallest communities\nand as you traverse to the bottom of the tree the communities get bigger\nand the overall modularity increases making the partition better., Each level is generated by executing the two phases of the Louvain Community\nDetection Algorithm., Be careful with self-loops in the input graph. These are treated as\npreviously reduced communities – as if the process had been started\nin the middle of the algorithm. Large self-loop edge weights thus\nrepresent strong communities and in practice may be hard to add\nother nodes to.  If your input graph edge weights for self-loops\ndo not represent already reduced communities you may want to remove\nthe self-loops before inputting that graph.]\nField List: Parameters:: G : NetworkX graph: \nweight : string or None, optional (default=”weight”): The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.\nresolution : float, optional (default=1): If resolution is less than 1, the algorithm favors larger communities.\nGreater than 1 favors smaller communities\nthreshold : float, optional (default=0.0000001): Modularity gain threshold for each level. If the gain of modularity\nbetween 2 levels of the algorithm is less than the given threshold\nthen the algorithm stops and returns the resulting communities.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nYields:: list: A list of sets (partition ofG). Each set represents one community and contains\nall the nodes that constitute it.\nMethods: []\nRubrics: References: [1]Blondel, V.D. et al. Fast unfolding of communities in\nlarge networks. J. Stat. Mech 10008, 1-12(2008)",
    "Section ID: find_cycle\nDescription: [Returns a cycle found via depth-first traversal., The cycle is a list of edges indicating the cyclic path.\nOrientation of directed edges is controlled by orientation .]\nField List: Parameters:: G : graph: A directed/undirected graph/multigraph.\nsource : node, list of nodes: The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.\norientation : None | ‘original’ | ‘reverse’ | ‘ignore’ (default: None): For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to ‘reverse’ every edge is traversed in the reverse direction.\nWhen set to ‘ignore’, every edge is treated as undirected.\nWhen set to ‘original’, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported.\nReturns:: edges : directed edges: A list of directed edges indicating the path taken for the loop.\nIf no cycle is found, then an exception is raised.\nFor graphs, an edge is of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs, an edge is of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (‘forward’ or ‘reverse’) on that edge.\nRaises:: NetworkXNoCycle: If no cycle was found.\nMethods: []\nRubrics: Examples: In this example, we construct a DAG and find, in the first call, that there\nare no directed cycles, and so an exception is raised. In the second call,\nwe ignore edge orientations and find that there is an undirected cycle.\nNote that the second call finds a directed cycle while effectively\ntraversing an undirected graph, and so, we found an “undirected cycle”.\nThis means that this DAG structure does not form a directed tree (which\nis also known as a polytree).\nG=nx.DiGraph([(0,1),(0,2),(1,2)])\nnx.find_cycle(G,orientation=\"original\")Traceback (most recent call last):    ...networkx.exception.NetworkXNoCycleNo cycle found.\nlist(nx.find_cycle(G,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 2, 'forward'), (0, 2, 'reverse')]",
    "Section ID: is_frozen\nDescription: [Returns True if graph is frozen.]\nField List: Parameters:: G : graph: A NetworkX graph\nMethods: []\nRubrics:",
    "Section ID: ladder_graph\nDescription: [Returns the Ladder graph of length n., This is two paths of n nodes, with\neach pair connected by a single edge., Node labels are the integers 0 to 2*n - 1., ( Sourcecode , png )]\nField List: Methods: []\nRubrics:",
    "Section ID: within_inter_cluster\nDescription: [Compute the ratio of within- and inter-cluster common neighbors\nof all node pairs in ebunch., For two nodes u and v , if a common neighbor w belongs to the\nsame community as them, w is considered as within-cluster common\nneighbor of u and v . Otherwise, it is considered as\ninter-cluster common neighbor of u and v . The ratio between the\nsize of the set of within- and inter-cluster common neighbors is\ndefined as the WIC measure. [1]]\nField List: Parameters:: G : graph: A NetworkX undirected graph.\nebunch : iterable of node pairs, optional (default = None): The WIC measure will be computed for each pair of nodes given in\nthe iterable. The pairs must be given as 2-tuples (u, v) where\nu and v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.\ndelta : float, optional (default = 0.001): Value to prevent division by zero in case there is no\ninter-cluster common neighbor between two nodes. See[1]for\ndetails. Default value: 0.001.\ncommunity : string, optional (default = ‘community’): Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: ‘community’.\nReturns:: piter : iterator: An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their WIC measure.\nRaises:: NetworkXNotImplemented: IfGis aDiGraph, aMultigraphor aMultiDiGraph.\nNetworkXAlgorithmError: Ifdeltais less than or equal to zero.If no community information is available for a node inebunchor inG(ifebunchisNone).\nNodeNotFound: Ifebunchhas a node that is not inG.\nMethods: []\nRubrics: References: [1](1,2)Jorge Carlos Valverde-Rebaza and Alneu de Andrade Lopes.\nLink prediction in complex networks based on cluster information.\nIn Proceedings of the 21st Brazilian conference on Advances in\nArtificial Intelligence (SBIA’12)https://doi.org/10.1007/978-3-642-34459-6_10\nExamples: G=nx.Graph()\nG.add_edges_from([(0,1),(0,2),(0,3),(1,4),(2,4),(3,4)])\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=1\nG.nodes[2][\"community\"]=0\nG.nodes[3][\"community\"]=0\nG.nodes[4][\"community\"]=0\npreds=nx.within_inter_cluster(G,[(0,4)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 4) -> 1.99800200\npreds=nx.within_inter_cluster(G,[(0,4)],delta=0.5)\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 4) -> 1.33333333",
    "Section ID: random_k_out_graph\nDescription: [Returns a random k -out graph with preferential attachment., A random k -out graph with preferential attachment is a\nmultidigraph generated by the following algorithm., For more information on this model of random graph, see [1].]\nField List: Parameters:: n : int: The number of nodes in the returned graph.\nk : int: The out-degree of each node in the returned graph.\nalpha : float: A positivefloatrepresenting the initial weight of\neach vertex. A higher number means that in step 3 above, nodes\nwill be chosen more like a true uniformly random sample, and a\nlower number means that nodes are more likely to be chosen as\ntheir in-degree increases. If this parameter is not positive, aValueErroris raised.\nself_loops : bool: If True, self-loops are allowed when generating the graph.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: MultiDiGraph: Ak-out-regular multidigraph generated according to the above\nalgorithm.\nRaises:: ValueError: Ifalphais not positive.\nMethods: []\nRubrics: Notes: The returned multidigraph may not be strongly connected, or even\nweakly connected.\nReferences: [1]: Peterson, Nicholas R., and Boris Pittel. “Distance between two randomk-out digraphs, with and without\npreferential attachment.”\narXiv preprint arXiv:1311.5961 (2013).\n<https://arxiv.org/abs/1311.5961>",
    "Section ID: LCF_graph\nDescription: [Return the cubic graph specified in LCF notation., LCF (Lederberg-Coxeter-Fruchte) notation[R8553aaaa836a-1]_ is a compressed\nnotation used in the generation of various cubic Hamiltonian\ngraphs of high symmetry. See, for example, dodecahedral_graph , desargues_graph , heawood_graph and pappus_graph ., Nodes are drawn from range(n) . Each node n_i is connected with\nnode n_i+shift%n where shift is given by cycling through\nthe input shift_list  repeat s times.]\nField List: Parameters:: n : int: The starting graph is then-cycle with nodes0,...,n-1.\nThe null graph is returned ifn< 1.\nshift_list : list: A list of integer shifts modn,[s1,s2,..,sk]\nrepeats : int: Integer specifying the number of times that shifts inshift_listare successively applied to each current node in the n-cycle\nto generate an edge betweenn_currentandn_current+shiftmodn.\nReturns:: G : Graph: A graph instance created from the specified LCF notation.\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/LCF_notation\nExamples: The utility graph\\(K_{3,3}\\)\nG=nx.LCF_graph(6,[3,-3],3)\nG.edges()\n# EdgeView([(0, 1), (0, 5), (0, 3), (1, 2), (1, 4), (2, 3), (2, 5), (3, 4), (4, 5)])\nThe Heawood graph:\nG=nx.LCF_graph(14,[5,-5],7)\nnx.is_isomorphic(G,nx.heawood_graph())\n# True",
    "Section ID: to_dict_of_dicts\nDescription: [Returns adjacency representation of graph as a dictionary of dictionaries.]\nField List: Parameters:: G : graph: A NetworkX graph\nnodelist : list: Use only nodes specified in nodelist\nedge_data : scalar, optional: If provided, the value of the dictionary will be set toedge_datafor\nall edges. Usual values could be1orTrue. Ifedge_dataisNone(the default), the edgedata inGis used, resulting in a\ndict-of-dict-of-dicts. IfGis a MultiGraph, the result will be a\ndict-of-dict-of-dict-of-dicts. See Notes for an approach to customize\nhandling edge data.edge_datashouldnotbe a container.\nReturns:: dod : dict: A nested dictionary representation ofG. Note that the level of\nnesting depends on the type ofGand the value ofedge_data(see Examples).\nMethods: []\nRubrics: Notes: For a more custom approach to handling edge data, try:\nExamples: G=nx.path_graph(3)\nnx.to_dict_of_dicts(G)\n# {0: {1: {}}, 1: {0: {}, 2: {}}, 2: {1: {}}}\nEdge data is preserved by default (edge_data=None), resulting\nin dict-of-dict-of-dicts where the innermost dictionary contains the\nedge data:\nG=nx.Graph()\nG.add_edges_from(\n[\n(0,1,{\"weight\":1.0}),\n(1,2,{\"weight\":2.0}),\n(2,0,{\"weight\":1.0}),\n]\n)\nd=nx.to_dict_of_dicts(G)\nd\n# {0: {1: {'weight': 1.0}, 2: {'weight': 1.0}},\n#  1: {0: {'weight': 1.0}, 2: {'weight': 2.0}},\n#  2: {1: {'weight': 2.0}, 0: {'weight': 1.0}}}\nd[1][2][\"weight\"]\n# 2.0\nIfedge_datais notNone, edge data in the original graph (if any) is\nreplaced:\nd=nx.to_dict_of_dicts(G,edge_data=1)\nd\n# {0: {1: 1, 2: 1}, 1: {0: 1, 2: 1}, 2: {1: 1, 0: 1}}\nd[1][2]\n# 1\nThis also applies to MultiGraphs: edge data is preserved by default:\nG=nx.MultiGraph()\nG.add_edge(0,1,key=\"a\",weight=1.0)\n# 'a'\nG.add_edge(0,1,key=\"b\",weight=5.0)\n# 'b'\nd=nx.to_dict_of_dicts(G)\nd\n# {0: {1: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}},\n#  1: {0: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}}}\nd[0][1][\"b\"][\"weight\"]\n# 5.0\nBut multi edge data is lost ifedge_datais notNone:\nd=nx.to_dict_of_dicts(G,edge_data=10)\nd\n# {0: {1: 10}, 1: {0: 10}}",
    "Section ID: create_py_random_state\nDescription: [Returns a random.Random instance depending on input.]\nField List: Parameters:: random_state : int or random number generator or None (default=None): If int, return arandom.Randominstance set with seed=int.Ifrandom.Randominstance, return it.If None or thenp.randompackage, return the global random number\ngenerator used bynp.random.If annp.random.Generatorinstance, or thenp.randompackage, or\nthe global numpy random number generator, then return it.\nwrapped in aPythonRandomViaNumpyBitsclass.If aPythonRandomViaNumpyBitsinstance, return it.If aPythonRandomInterfaceinstance, return it.If anp.random.RandomStateinstance and not the global numpy default,\nreturn it wrapped inPythonRandomInterfacefor backward bit-stream\nmatching with legacy code.\nMethods: []\nRubrics: Notes:",
    "Section ID: shortest_path_length\nDescription: [Compute shortest path lengths in the graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Starting node for path.\nIf not specified, compute shortest path lengths using all nodes as\nsource nodes.\ntarget : node, optional: Ending node for path.\nIf not specified, compute shortest path lengths using all nodes as\ntarget nodes.\nweight : None, string or function, optional (default = None): If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.\nmethod : string, optional (default = ‘dijkstra’): The algorithm to use to compute the path length.\nSupported options: ‘dijkstra’, ‘bellman-ford’.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored.\nReturns:: length: int or iterator: If the source and target are both specified, return the length of\nthe shortest path from the source to the target.If only the source is specified, return a dict keyed by target\nto the shortest path length from the source to that target.If only the target is specified, return a dict keyed by source\nto the shortest path length from that source to the target.If neither the source nor target are specified, return an iterator\nover (source, dictionary) where dictionary is keyed by target to\nshortest path length from source to that target.\nRaises:: NodeNotFound: Ifsourceis not inG.\nNetworkXNoPath: If no path exists between source and target.\nValueError: Ifmethodis not among the supported options.\nMethods: []\nRubrics: Notes: The length of the path is always 1 less than the number of nodes involved\nin the path since the length measures the number of edges followed. For digraphs this returns the shortest directed path length. To find path\nlengths in the reverse direction use G.reverse(copy=False) first to flip\nthe edge orientation.\nExamples: G=nx.path_graph(5)\nnx.shortest_path_length(G,source=0,target=4)\n# 4\np=nx.shortest_path_length(G,source=0)# target not specified\np[4]\n# 4\np=nx.shortest_path_length(G,target=4)# source not specified\np[0]\n# 4\np=dict(nx.shortest_path_length(G))# source,target not specified\np[0][4]\n# 4",
    "Section ID: mixing_dict\nDescription: [Returns a dictionary representation of mixing matrix.]\nField List: Parameters:: xy : list or container of two-tuples: Pairs of (x,y) items.\nattribute : string: Node attribute key\nnormalized : bool (default=False): Return counts if False or probabilities if True.\nReturns:: d: dictionary: Counts or Joint probability of occurrence of values in xy.\nMethods: []\nRubrics:",
    "Section ID: out_degree_centrality\nDescription: [Compute the out-degree centrality for nodes., The out-degree centrality for a node v is the fraction of nodes its\noutgoing edges are connected to.]\nField List: Parameters:: G : graph: A NetworkX graph\nReturns:: nodes : dictionary: Dictionary of nodes with out-degree centrality as values.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.\nExamples: G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.out_degree_centrality(G)\n# {0: 1.0, 1: 0.6666666666666666, 2: 0.0, 3: 0.0}",
    "Section ID: read_edgelist\nDescription: [Read a graph from a list of edges.]\nField List: Parameters:: path : file or string: File or filename to read. If a file is provided, it must be\nopened in ‘rb’ mode.\nFilenames ending in .gz or .bz2 will be uncompressed.\ncomments : string, optional: The character used to indicate the start of a comment. To specify that\nno character should be treated as a comment, usecomments=None.\ndelimiter : string, optional: The string used to separate values.  The default is whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nnodetype : int, float, str, Python type, optional: Convert node data from strings to specified type\ndata : bool or list of (label,type) tuples: Tuples specifying dictionary key names and types for edge data\nedgetype : int, float, str, Python type, optional OBSOLETE: Convert edge data from strings to specified type and use as ‘weight’\nencoding: string, optional: Specify which encoding to use when reading file.\nReturns:: G : graph: A networkx Graph or other type specified with create_using\nMethods: []\nRubrics: Notes: Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)\nExamples: nx.write_edgelist(nx.path_graph(4),\"test.edgelist\")\nG=nx.read_edgelist(\"test.edgelist\")\nfh=open(\"test.edgelist\",\"rb\")\nG=nx.read_edgelist(fh)\nfh.close()\nG=nx.read_edgelist(\"test.edgelist\",nodetype=int)\nG=nx.read_edgelist(\"test.edgelist\",create_using=nx.DiGraph)\nEdgelist with data in a list:\ntextline=\"1 2 3\"\nfh=open(\"test.edgelist\",\"w\")\nd=fh.write(textline)\nfh.close()\nG=nx.read_edgelist(\"test.edgelist\",nodetype=int,data=((\"weight\",float),))\nlist(G)\n# [1, 2]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0})]\nSee parse_edgelist() for more examples of formatting.",
    "Section ID: tutte_polynomial\nDescription: [Returns the Tutte polynomial of G, This function computes the Tutte polynomial via an iterative version of\nthe deletion-contraction algorithm., The Tutte polynomial T_G(x,y) is a fundamental graph polynomial invariant in\ntwo variables. It encodes a wide array of information related to the\nedge-connectivity of a graph; “Many problems about graphs can be reduced to\nproblems of finding and evaluating the Tutte polynomial at certain values” [1] .\nIn fact, every deletion-contraction-expressible feature of a graph is a\nspecialization of the Tutte polynomial [2] (see Notes for examples)., There are several equivalent definitions; here are three:, Def 1 (rank-nullity expansion): For G an undirected graph, n(G) the\nnumber of vertices of G , E the edge set of G , V the vertex set of G , and c(A) the number of connected components of the graph with vertex\nset V and edge set A  [3] :, Def 2 (spanning tree expansion): Let G be an undirected graph, T a spanning\ntree of G , and E the edge set of G . Let E have an arbitrary strict\nlinear order L . Let B_e be the unique minimal nonempty edge cut of \\(E \\setminus T \\cup {e}\\) . An edge e is internally active with respect to T and L if e is the least edge in B_e according to the linear order L . The internal activity of T (denoted i(T) ) is the number of edges\nin \\(E \\setminus T\\) that are internally active with respect to T and L .\nLet P_e be the unique path in \\(T \\cup {e}\\) whose source and target vertex\nare the same. An edge e is externally active with respect to T and L if e is the least edge in P_e according to the linear order L . The\nexternal activity of T (denoted e(T) ) is the number of edges in \\(E \\setminus T\\) that are externally active with respect to T and L .\nThen [4]  [5] :, Def 3 (deletion-contraction recurrence): For G an undirected graph, G-e the graph obtained from G by deleting edge e , G/e the graph obtained\nfrom G by contracting edge e , k(G) the number of cut-edges of G ,\nand l(G) the number of self-loops of G :]\nField List: Parameters:: G : NetworkX graph:\nReturns:: instance of : sympy.core.add.Add: A Sympy expression representing the Tutte polynomial forG.\nMethods: []\nRubrics: Notes: Some specializations of the Tutte polynomial:\nReferences: [1]M. Brandt,\n“The Tutte Polynomial.”\nTalking About Combinatorial Objects Seminar, 2015https://math.berkeley.edu/~brandtm/talks/tutte.pdf  [2]A. Björklund, T. Husfeldt, P. Kaski, M. Koivisto,\n“Computing the Tutte polynomial in vertex-exponential time”\n49th Annual IEEE Symposium on Foundations of Computer Science, 2008https://ieeexplore.ieee.org/abstract/document/4691000  [3]Y. Shi, M. Dehmer, X. Li, I. Gutman,\n“Graph Polynomials,” p. 14  [4]Y. Shi, M. Dehmer, X. Li, I. Gutman,\n“Graph Polynomials,” p. 46  [5]A. Nešetril, J. Goodall,\n“Graph invariants, homomorphisms, and the Tutte polynomial”https://iuuk.mff.cuni.cz/~andrew/Tutte.pdf  [6]D. B. West,\n“Introduction to Graph Theory,” p. 84  [7]G. Coutinho,\n“A brief introduction to the Tutte polynomial”\nStructural Analysis of Complex Networks, 2011https://homepages.dcc.ufmg.br/~gabriel/seminars/coutinho_tuttepolynomial_seminar.pdf  [8]J. A. Ellis-Monaghan, C. Merino,\n“Graph polynomials and their applications I: The Tutte polynomial”\nStructural Analysis of Complex Networks, 2011https://arxiv.org/pdf/0803.3079.pdf\nExamples: C=nx.cycle_graph(5)\nnx.tutte_polynomial(C)\n# x**4 + x**3 + x**2 + x + y\nD=nx.diamond_graph()\nnx.tutte_polynomial(D)\n# x**3 + 2*x**2 + 2*x*y + x + y**2 + y",
    "Section ID: is_path\nDescription: [Returns whether or not the specified path exists., For it to return True, every node on the path must exist and\neach consecutive pair must be connected via one or more edges.]\nField List: Parameters:: G : graph: A NetworkX graph.\npath : list: A list of nodes which defines the path to traverse\nReturns:: bool: True ifpathis a valid path inG\nMethods: []\nRubrics:",
    "Section ID: random_regular_graph\nDescription: [Returns a random \\(d\\) -regular graph on \\(n\\) nodes., A regular graph is a graph where each node has the same number of neighbors., The resulting graph has no self-loops or parallel edges.]\nField List: Parameters:: d : int: The degree of each node.\nn : integer: The number of nodes. The value of\\(n \\times d\\)must be even.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nRaises:: NetworkXError: If\\(n \\times d\\)is odd or\\(d\\)is greater than or equal to\\(n\\).\nMethods: []\nRubrics: Notes: The nodes are numbered from \\(0\\) to \\(n - 1\\) . Kim and Vu’s paper [2] shows that this algorithm samples in an\nasymptotically uniform way from the space of random graphs when \\(d = O(n^{1 / 3 - \\epsilon})\\) .\nReferences: [1]A. Steger and N. Wormald,\nGenerating random regular graphs quickly,\nProbability and Computing 8 (1999), 377-396, 1999.https://doi.org/10.1017/S0963548399003867  [2]Jeong Han Kim and Van H. Vu,\nGenerating random regular graphs,\nProceedings of the thirty-fifth ACM symposium on Theory of computing,\nSan Diego, CA, USA, pp 213–222, 2003.http://portal.acm.org/citation.cfm?id=780542.780576",
    "Section ID: radius\nDescription: [Returns the radius of the graph G., The radius is the minimum eccentricity.]\nField List: Parameters:: G : NetworkX graph: A graph\ne : eccentricity dictionary, optional: A precomputed dictionary of eccentricities.\nweight : string, function, or None: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances.\nReturns:: r : integer: Radius of graph\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.radius(G)\n# 2",
    "Section ID: normalized_cut_size\nDescription: [Returns the normalized size of the cut between two sets of nodes., The normalized cut size is the cut size times the sum of the\nreciprocal sizes of the volumes of the two sets. [1]]\nField List: Parameters:: G : NetworkX graph: \nS : collection: A collection of nodes inG.\nT : collection: A collection of nodes inG.\nweight : object: Edge attribute key to use as weight. If not specified, edges\nhave weight one.\nReturns:: number: The normalized cut size between the two setsSandT.\nMethods: []\nRubrics: Notes: In a multigraph, the cut size is the total weight of edges including\nmultiplicity.\nReferences: [1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>",
    "Section ID: generic_graph_view\nDescription: [Returns a read-only view of G ., The graph G and its attributes are not copied but viewed through the new graph object\nof the same class as G (or of the class specified in create_using ).]\nField List: Parameters:: G : graph: A directed/undirected graph/multigraph.\ncreate_using : NetworkX graph constructor, optional (default=None): Graph type to create. If graph instance, then cleared before populated.\nIfNone, then the appropriate Graph type is inferred fromG.\nReturns:: newG : graph: A view of the input graphGand its attributes as viewed through\nthecreate_usingclass.\nRaises:: NetworkXError: IfGis a multigraph (or multidigraph) butcreate_usingis not, or vice versa.\nMethods: []\nRubrics: Notes: The returned graph view is read-only (cannot modify the graph).\nYet the view reflects any changes in G . The intent is to mimic dict views.\nExamples: G=nx.Graph()\nG.add_edge(1,2,weight=0.3)\nG.add_edge(2,3,weight=0.5)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3}), (2, 3, {'weight': 0.5})])\nThe view exposes the attributes from the original graph.\nviewG=nx.graphviews.generic_graph_view(G)\nviewG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3}), (2, 3, {'weight': 0.5})])\nChanges toGare reflected inviewG.\nG.remove_edge(2,3)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3})])\nviewG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3})])\nWe can change the graph type with thecreate_usingparameter.\ntype(G)\n# <class 'networkx.classes.graph.Graph'>\nviewDG=nx.graphviews.generic_graph_view(G,create_using=nx.DiGraph)\ntype(viewDG)\n# <class 'networkx.classes.digraph.DiGraph'>",
    "Section ID: UnionAdjacency\nDescription: [A read-only union of dict Adjacencies as a Map of Maps of Maps., The two input dict-of-dict-of-dicts represent the union of G.succ and G.pred . Return values are UnionAtlas\nThe inner level of dict is read-write. But the\nmiddle and outer levels are read-only., succ : a dict-of-dict-of-dict {node: nbrdict}\npred : a dict-of-dict-of-dict {node: nbrdict}\nThe keys for the two dicts should be the same]\nField List: Methods: []\nRubrics:",
    "Section ID: create_empty_copy\nDescription: [Returns a copy of the graph G with all of the edges removed.]\nField List: Parameters:: G : graph: A NetworkX graph\nwith_data : bool (default=True): Propagate Graph and Nodes data to the new graph.\nMethods: []\nRubrics:",
    "Section ID: dense_gnm_random_graph\nDescription: [Returns a \\(G_{n,m}\\) random graph., In the \\(G_{n,m}\\) model, a graph is chosen uniformly at random from the set\nof all graphs with \\(n\\) nodes and \\(m\\) edges., This algorithm should be faster than gnm_random_graph() for dense\ngraphs.]\nField List: Parameters:: n : int: The number of nodes.\nm : int: The number of edges.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: Notes: Algorithm by Keith M. Briggs Mar 31, 2006.\nInspired by Knuth’s Algorithm S (Selection sampling technique),\nin section 3.4.2 of [1] .\nReferences: [1]Donald E. Knuth, The Art of Computer Programming,\nVolume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997.",
    "Section ID: could_be_isomorphic\nDescription: [Returns False if graphs are definitely not isomorphic.\nTrue does NOT guarantee isomorphism.]\nField List: Parameters:: G1, G2 : graphs: The two graphs G1 and G2 must be the same type.\nMethods: []\nRubrics: Notes: Checks for matching degree, triangle, and number of cliques sequences.\nThe triangle sequence contains the number of triangles each node is part of.\nThe clique sequence contains for each node the number of maximal cliques\ninvolving that node.",
    "Section ID: average_shortest_path_length\nDescription: [Returns the average shortest path length., The average shortest path length is, where V is the set of nodes in G , d(s,t) is the shortest path from s to t ,\nand n is the number of nodes in G .]\nField List: Parameters:: G : NetworkX graph: \nweight : None, string or function, optional (default = None): If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.\nmethod : string, optional (default = ‘unweighted’ or ‘dijkstra’): The algorithm to use to compute the path lengths.\nSupported options are ‘unweighted’, ‘dijkstra’, ‘bellman-ford’,\n‘floyd-warshall’ and ‘floyd-warshall-numpy’.\nOther method values produce a ValueError.\nThe default method is ‘unweighted’ ifweightis None,\notherwise the default method is ‘dijkstra’.\nRaises:: NetworkXPointlessConcept: IfGis the null graph (that is, the graph on zero nodes).\nNetworkXError: IfGis not connected (or not strongly connected, in the case\nof a directed graph).\nValueError: Ifmethodis not among the supported options.\nMethods: []\nRubrics: Examples: G=nx.path_graph(5)\nnx.average_shortest_path_length(G)\n# 2.0\nFor disconnected graphs, you can compute the average shortest path\nlength for each component\nG=nx.Graph([(1,2),(3,4)])\nforCin(G.subgraph(c).copy()forcinnx.connected_components(G)):\nprint(nx.average_shortest_path_length(C))\n# 1.0\n# 1.0",
    "Section ID: number_of_spanning_trees\nDescription: [Returns the number of spanning trees in G ., A spanning tree for an undirected graph is a tree that connects\nall nodes in the graph. For a directed graph, the analog of a\nspanning tree is called a (spanning) arborescence. The arborescence\nincludes a unique directed path from the root node to each other node.\nThe graph must be weakly connected, and the root must be a node\nthat includes all nodes as successors [3] . Note that to avoid\ndiscussing sink-roots and reverse-arborescences, we have reversed\nthe edge orientation from [3] and use the in-degree laplacian., This function (when weight is None ) returns the number of\nspanning trees for an undirected graph and the number of\narborescences from a single root node for a directed graph.\nWhen weight is the name of an edge attribute which holds the\nweight value of each edge, the function returns the sum over\nall trees of the multiplicative weight of each tree. That is,\nthe weight of the tree is the product of its edge weights., Kirchoff’s Tree Matrix Theorem states that any cofactor of the\nLaplacian matrix of a graph is the number of spanning trees in the\ngraph. (Here we use cofactors for a diagonal entry so that the\ncofactor becomes the determinant of the matrix with one row\nand its matching column removed.) For a weighted Laplacian matrix,\nthe cofactor is the sum across all spanning trees of the\nmultiplicative weight of each tree. That is, the weight of each\ntree is the product of its edge weights. The theorem is also\nknown as Kirchhoff’s theorem [1] and the Matrix-Tree theorem [2] ., For directed graphs, a similar theorem (Tutte’s Theorem) holds with\nthe cofactor chosen to be the one with row and column removed that\ncorrespond to the root. The cofactor is the number of arborescences\nwith the specified node as root. And the weighted version gives the\nsum of the arborescence weights with root root . The arborescence\nweight is the product of its edge weights.]\nField List: Parameters:: G : NetworkX graph: \nroot : node: A node in the directed graphGthat has all nodes as descendants.\n(This is ignored for undirected graphs.)\nweight : string or None, optional (default=None): The name of the edge attribute holding the edge weight.\nIfNone, then each edge is assumed to have a weight of 1.\nReturns:: Number: Undirected graphs:The number of spanning trees of the graphG.\nOr the sum of all spanning tree weights of the graphGwhere the weight of a tree is the product of its edge weights.Directed graphs:The number of arborescences ofGrooted at noderoot.\nOr the sum of all arborescence weights of the graphGwith\nspecified root where the weight of an arborescence is the product\nof its edge weights.\nUndirected graphs:: The number of spanning trees of the graphG.\nOr the sum of all spanning tree weights of the graphGwhere the weight of a tree is the product of its edge weights.\nDirected graphs:: The number of arborescences ofGrooted at noderoot.\nOr the sum of all arborescence weights of the graphGwith\nspecified root where the weight of an arborescence is the product\nof its edge weights.\nRaises:: NetworkXPointlessConcept: IfGdoes not contain any nodes.\nNetworkXError: If the graphGis directed and the root node\nis not specified or is not in G.\nMethods: []\nRubrics: Notes: Self-loops are excluded. Multi-edges are contracted in one edge\nequal to the sum of the weights.\nReferences: [1]Wikipedia\n“Kirchhoff’s theorem.”https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem  [2]Kirchhoff, G. R.\nÜber die Auflösung der Gleichungen, auf welche man\nbei der Untersuchung der linearen Vertheilung\nGalvanischer Ströme geführt wird\nAnnalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.  [3](1,2)Margoliash, J.\n“Matrix-Tree Theorem for Directed Graphs”https://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf\nExamples: G=nx.complete_graph(5)\nround(nx.number_of_spanning_trees(G))\n# 125\nG=nx.Graph()\nG.add_edge(1,2,weight=2)\nG.add_edge(1,3,weight=1)\nG.add_edge(2,3,weight=1)\nround(nx.number_of_spanning_trees(G,weight=\"weight\"))\n# 5",
    "Section ID: random_geometric_graph\nDescription: [Returns a random geometric graph in the unit cube of dimensions dim ., The random geometric graph model places n nodes uniformly at\nrandom in the unit cube. Two nodes are joined by an edge if the\ndistance between the nodes is at most radius ., Edges are determined using a KDTree when SciPy is available.\nThis reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) .]\nField List: Parameters:: n : int or iterable: Number of nodes or iterable of nodes\nradius: float: Distance threshold value\ndim : int, optional: Dimension of graph\npos : dict, optional: A dictionary keyed by node with node positions as values.\np : float, optional: Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.\nThis should not be confused with thepof an Erdős-Rényi random\ngraph, which represents probability.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\npos_name : string, default=”pos”: The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.\nReturns:: Graph: A random geometric graph, undirected and without self-loops.\nEach node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function.\nMethods: []\nRubrics: Notes: This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2:\nReferences: [1]Penrose, Mathew,Random Geometric Graphs,\nOxford Studies in Probability, 5, 2003.\nExamples: Create a random geometric graph on twenty nodes where nodes are joined by\nan edge if their distance is at most 0.1:\nG=nx.random_geometric_graph(20,0.1)",
    "Section ID: wiener_index\nDescription: [Returns the Wiener index of the given graph., The Wiener index of a graph is the sum of the shortest-path\n(weighted) distances between each pair of reachable nodes.\nFor pairs of nodes in undirected graphs, only one orientation\nof the pair is counted.]\nField List: Parameters:: G : NetworkX graph: \nweight : string or None, optional (default: None): If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances.\nReturns:: number: The Wiener index of the graphG.\nRaises:: NetworkXError: If the graphGis not connected.\nMethods: []\nRubrics: Notes: If a pair of nodes is not reachable, the distance is assumed to be\ninfinity. This means that for graphs that are not\nstrongly-connected, this function returns inf . The Wiener index is not usually defined for directed graphs, however\nthis function uses the natural generalization of the Wiener index to\ndirected graphs.\nReferences: [1]Wikipedia: Wiener Index\nExamples: The Wiener index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes, since each pair of\nnodes is at distance one:\nn=10\nG=nx.complete_graph(n)\nnx.wiener_index(G)==n*(n-1)/2\n# True\nGraphs that are not strongly-connected have infinite Wiener index:\nG=nx.empty_graph(2)\nnx.wiener_index(G)\n# inf",
    "Section ID: symmetric_difference\nDescription: [Returns new graph with edges that exist in either G or H but not both., The node sets of H and G must be the same.]\nField List: Parameters:: G,H : graph: A NetworkX graph.  G and H must have the same node sets.\nReturns:: D : A new graph with the same type as G.:\nMethods: []\nRubrics: Notes: Attributes from the graph, nodes, and edges are not copied to the new\ngraph.\nExamples: G=nx.Graph([(0,1),(0,2),(1,2),(1,3)])\nH=nx.Graph([(0,1),(1,2),(0,3)])\nR=nx.symmetric_difference(G,H)\nR.nodes\n# NodeView((0, 1, 2, 3))\nR.edges\n# EdgeView([(0, 2), (0, 3), (1, 3)])",
    "Section ID: MappedQueue\nDescription: [The MappedQueue class implements a min-heap with removal and update-priority., The min heap uses heapq as well as custom written _siftup and _siftdown\nmethods to allow the heap positions to be tracked by an additional dict\nkeyed by element to position. The smallest element can be popped in O(1) time,\nnew elements can be pushed in O(log n) time, and any element can be removed\nor updated in O(log n) time. The queue cannot contain duplicate elements\nand an attempt to push an element already in the queue will have no effect., MappedQueue complements the heapq package from the python standard\nlibrary. While MappedQueue is designed for maximum compatibility with\nheapq, it adds element removal, lookup, and priority update.]\nField List: Parameters:: data : dict or iterable:\nMethods: []\nRubrics: References: [1]Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2001).\nIntroduction to algorithms second edition.  [2]Knuth, D. E. (1997). The art of computer programming (Vol. 3).\nPearson Education.\nExamples: AMappedQueuecan be created empty, or optionally, given a dictionary\nof initial elements and priorities.  The methodspush,pop,remove, andupdateoperate on the queue.\ncolors_nm={\"red\":665,\"blue\":470,\"green\":550}\nq=MappedQueue(colors_nm)\nq.remove(\"red\")\nq.update(\"green\",\"violet\",400)\nq.push(\"indigo\",425)\n# True\n[q.pop().elementforiinrange(len(q.heap))]\n# ['violet', 'indigo', 'blue']\nAMappedQueuecan also be initialized with a list or other iterable. The priority is assumed\nto be the sort order of the items in the list.\nq=MappedQueue([916,50,4609,493,237])\nq.remove(493)\nq.update(237,1117)\n[q.pop()foriinrange(len(q.heap))]\n# [50, 916, 1117, 4609]\nAn exception is raised if the elements are not comparable.\nq=MappedQueue([100,\"a\"])Traceback (most recent call last):...TypeError'<' not supported between instances of 'int' and 'str'\nTo avoid the exception, use a dictionary to assign priorities to the elements.\nq=MappedQueue({100:0,\"a\":1})",
    "Section ID: spring_layout\nDescription: [Position nodes using Fruchterman-Reingold force-directed algorithm., The algorithm simulates a force-directed representation of the network\ntreating edges as springs holding nodes close, while treating nodes\nas repelling objects, sometimes called an anti-gravity force.\nSimulation continues until the positions are close to an equilibrium., There are some hard-coded values: minimal distance between\nnodes (0.01) and “temperature” of 0.1 to ensure nodes don’t fly away.\nDuring the simulation, k helps determine the distance between nodes,\nthough scale and center determine the size and place after\nrescaling occurs at the end of the simulation., Fixing some nodes doesn’t allow them to move in the simulation.\nIt also turns off the rescaling feature at the simulation’s end.\nIn addition, setting scale to None turns off rescaling.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\nk : float (default=None): Optimal distance between nodes.  If None the distance is set to\n1/sqrt(n) where n is the number of nodes.  Increase this value\nto move nodes farther apart.\npos : dict or None  optional (default=None): Initial positions for nodes as a dictionary with node as keys\nand values as a coordinate list or tuple.  If None, then use\nrandom initial positions.\nfixed : list or None  optional (default=None): Nodes to keep fixed at initial position.\nNodes not inG.nodesare ignored.\nValueError raised iffixedspecified andposnot.\niterations : int  optional (default=50): Maximum number of iterations taken\nthreshold: float optional (default = 1e-4): Threshold for relative error in node position changes.\nThe iteration stops if the error is below this threshold.\nweight : string or None   optional (default=’weight’): The edge attribute that holds the numerical value used for\nthe edge weight.  Larger means a stronger attractive force.\nIf None, then all edge weights are 1.\nscale : number or None (default: 1): Scale factor for positions. Not used unlessfixedisNone.\nIf scale is None, no rescaling is performed.\ncenter : array-like or None: Coordinate pair around which to center the layout.\nNot used unlessfixedisNone.\ndim : int: Dimension of layout.\nseed : int, RandomState instance or None  optional (default=None): Set the random state for deterministic node layouts.\nIf int,seedis the seed used by the random number generator,\nif numpy.random.RandomState instance,seedis the random\nnumber generator,\nif None, the random number generator is the RandomState instance used\nby numpy.random.\nReturns:: pos : dict: A dictionary of positions keyed by node\nMethods: []\nRubrics: Examples: G=nx.path_graph(4)\npos=nx.spring_layout(G)\n# The same using longer but equivalent function name\n>>> pos = nx.fruchterman_reingold_layout(G)",
    "Section ID: number_of_nonisomorphic_trees\nDescription: [Returns the number of nonisomorphic trees]\nField List: Parameters:: order : int: order of the desired tree(s)\nReturns:: length : Number of nonisomorphic graphs for the given order:\nMethods: []\nRubrics:",
    "Section ID: degree_histogram\nDescription: [Returns a list of the frequency of each degree value.]\nField List: Parameters:: G : Networkx graph: A graph\nReturns:: hist : list: A list of frequencies of degrees.\nThe degree values are the index in the list.\nMethods: []\nRubrics: Notes: Note: the bins are width one, hence len(list) can be large\n(Order(number_of_edges))",
    "Section ID: local_efficiency\nDescription: [Returns the average local efficiency of the graph., The efficiency of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The local\nefficiency of a node in the graph is the average global efficiency of the\nsubgraph induced by the neighbors of the node. The average local\nefficiency is the average of the local efficiencies of each node [1] .]\nField List: Parameters:: G : networkx.Graph: An undirected graph for which to compute the average local efficiency.\nReturns:: float: The average local efficiency of the graph.\nMethods: []\nRubrics: Notes: Edge weights are ignored when computing the shortest path distances.\nReferences: [1]Latora, Vito, and Massimo Marchiori.\n“Efficient behavior of small-world networks.”Physical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>\nExamples: G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.local_efficiency(G)\n# 0.9166666666666667",
    "Section ID: capacity_scaling\nDescription: [Find a minimum cost flow satisfying all demands in digraph G., This is a capacity scaling successive shortest augmenting path algorithm., G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.]\nField List: Parameters:: G : NetworkX graph: DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\ndemands is to be found.\ndemand : string: Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: ‘demand’.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nweight : string: Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: ‘weight’.\nheap : class: Type of heap to be used in the algorithm. It should be a subclass ofMinHeapor implement a compatible interface.If a stock heap implementation is to be used,BinaryHeapis\nrecommended overPairingHeapfor Python implementations without\noptimized attribute accesses (e.g., CPython) despite a slower\nasymptotic running time. For Python implementations with optimized\nattribute accesses (e.g., PyPy),PairingHeapprovides better\nperformance. Default value:BinaryHeap.\nReturns:: flowCost : integer: Cost of a minimum cost flow satisfying all demands.\nflowDict : dictionary: If G is a digraph, a dict-of-dicts keyed by nodes such that\nflowDict[u][v] is the flow on edge (u, v).\nIf G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\nso that flowDict[u][v][key] is the flow on edge (u, v, key).\nRaises:: NetworkXError: This exception is raised if the input graph is not directed,\nnot connected.\nNetworkXUnfeasible: This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.\nNetworkXUnbounded: This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below.\nMethods: []\nRubrics: Notes: This algorithm does not work if edge weights are floating-point numbers.\nExamples: A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost,flowDict=nx.capacity_scaling(G)\nflowCost\n# 24\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nIt is possible to change the name of the attributes used for the\nalgorithm.\nG=nx.DiGraph()\nG.add_node(\"p\",spam=-4)\nG.add_node(\"q\",spam=2)\nG.add_node(\"a\",spam=-2)\nG.add_node(\"d\",spam=-1)\nG.add_node(\"t\",spam=2)\nG.add_node(\"w\",spam=3)\nG.add_edge(\"p\",\"q\",cost=7,vacancies=5)\nG.add_edge(\"p\",\"a\",cost=1,vacancies=4)\nG.add_edge(\"q\",\"d\",cost=2,vacancies=3)\nG.add_edge(\"t\",\"q\",cost=1,vacancies=2)\nG.add_edge(\"a\",\"t\",cost=2,vacancies=4)\nG.add_edge(\"d\",\"w\",cost=3,vacancies=4)\nG.add_edge(\"t\",\"w\",cost=4,vacancies=1)\nflowCost,flowDict=nx.capacity_scaling(\nG,demand=\"spam\",capacity=\"vacancies\",weight=\"cost\"\n)\nflowCost\n# 37\nflowDict\n# {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}",
    "Section ID: vf2pp_is_isomorphic\nDescription: [Examines whether G1 and G2 are isomorphic.]\nField List: Parameters:: G1, G2 : NetworkX Graph or MultiGraph instances.: The two graphs to check for isomorphism.\nnode_label : str, optional: The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn’t have thenode_labelattribute usesdefault_labelinstead.\ndefault_label : scalar: Default value to use when a node doesn’t have an attribute\nnamednode_label. Default isNone.\nReturns:: bool: True if the two graphs are isomorphic, False otherwise.\nMethods: []\nRubrics:",
    "Section ID: draw_spectral\nDescription: [Draw the graph G with a spectral 2D layout., This is a convenience function equivalent to:, For more information about how node positions are determined, see spectral_layout .]\nField List: Parameters:: G : graph: A networkx graph\nkwargs : optional keywords: Seedraw_networkxfor a description of optional keywords.\nMethods: []\nRubrics: Notes: The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call spectral_layout directly and reuse the result:\nExamples: G=nx.path_graph(5)\nnx.draw_spectral(G)",
    "Section ID: parse_graphml\nDescription: [Read graph in GraphML format from string.]\nField List: Parameters:: graphml_string : string: String containing graphml information\n(e.g., contents of a graphml file).\nnode_type: Python type (default: str): Convert node ids to this type\nedge_key_type: Python type (default: int): Convert graphml edge ids to this type. Multigraphs use id as edge key.\nNon-multigraphs add to edge attribute dict with name “id”.\nforce_multigraph : bool (default: False): If True, return a multigraph with edge keys. If False (the default)\nreturn a multigraph when multiedges are in the graph.\nReturns:: graph: NetworkX graph: If no parallel edges are found a Graph or DiGraph is returned.\nOtherwise a MultiGraph or MultiDiGraph is returned.\nMethods: []\nRubrics: Notes: Default node and edge attributes are not propagated to each node and edge.\nThey can be obtained from G.graph and applied to node and edge attributes\nif desired using something like this:\nExamples: G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed =\ns=linefeed.join(nx.generate_graphml(G))\nH=nx.parse_graphml(s)",
    "Section ID: bellman_ford_path_length\nDescription: [Returns the shortest path length from source to target\nin a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: starting node for path\ntarget : node label: ending node for path\nweight : string or function (default=”weight”): If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: length : number: Shortest path length.\nRaises:: NodeNotFound: Ifsourceis not inG.\nNetworkXNoPath: If no path exists between source and target.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\nExamples: G=nx.path_graph(5)\nnx.bellman_ford_path_length(G,0,4)\n# 4",
    "Section ID: build_auxiliary_edge_connectivity\nDescription: [Auxiliary digraph for computing flow based edge connectivity, If the input graph is undirected, we replace each edge ( u ,`v`) with\ntwo reciprocal arcs ( u , v ) and ( v , u ) and then we set the attribute\n‘capacity’ for each arc to 1. If the input graph is directed we simply\nadd the ‘capacity’ attribute. Part of algorithm 1 in [1] ., References]\nField List: Methods: []\nRubrics: References: [1]Abdol-Hossein Esfahanian. Connectivity Algorithms. (this is a\nchapter, look for the reference of the book).http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
    "Section ID: show_multidiedges\nDescription: [Returns a filter function that shows specific multi-directed edges.]\nField List: Methods: []\nRubrics:",
    "Section ID: to_scipy_sparse_array\nDescription: [Returns the graph adjacency matrix as a SciPy sparse array.]\nField List: Parameters:: G : graph: The NetworkX graph used to construct the sparse matrix.\nnodelist : list, optional: The rows and columns are ordered according to the nodes innodelist.\nIfnodelistis None, then the ordering is produced by G.nodes().\ndtype : NumPy data-type, optional: A valid NumPy dtype used to initialize the array. If None, then the\nNumPy default is used.\nweight : string or None   optional (default=’weight’): The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1.\nformat : str in {‘bsr’, ‘csr’, ‘csc’, ‘coo’, ‘lil’, ‘dia’, ‘dok’}: The type of the matrix to be returned (default ‘csr’).  For\nsome algorithms different implementations of sparse matrices\ncan perform better.  See[1]for details.\nReturns:: A : SciPy sparse array: Graph adjacency matrix.\nMethods: []\nRubrics: Notes: For directed graphs, matrix entry i,j corresponds to an edge from i to j. The matrix entries are populated using the edge attribute held in\nparameter weight. When an edge does not have that attribute, the\nvalue of the entry is 1. For multiple edges the matrix values are the sums of the edge weights. When nodelist does not contain every node in G , the adjacency matrix\nis built from the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting SciPy sparse array can be modified as follows:\nReferences: [1]Scipy Dev. References, “Sparse Matrices”,https://docs.scipy.org/doc/scipy/reference/sparse.html\nExamples: G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nS=nx.to_scipy_sparse_array(G,nodelist=[0,1,2])\nprint(S.toarray())\n# [[0 2 0]\n#  [1 0 0]\n#  [0 0 4]]",
    "Section ID: krackhardt_kite_graph\nDescription: [Returns the Krackhardt Kite Social Network., A 10 actor social network introduced by David Krackhardt\nto illustrate different centrality measures [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Krackhardt Kite graph with 10 nodes and 18 edges\nMethods: []\nRubrics: Notes: The traditional labeling is:\nAndre=1, Beverley=2, Carol=3, Diane=4,\nEd=5, Fernando=6, Garth=7, Heather=8, Ike=9, Jane=10.\nReferences: [1]Krackhardt, David. “Assessing the Political Landscape: Structure,\nCognition, and Power in Organizations”. Administrative Science Quarterly.\n35 (2): 342–369. doi:10.2307/2393394. JSTOR 2393394. June 1990.",
    "Section ID: bidirectional_shortest_path\nDescription: [Returns a list of nodes in a shortest path between source and target.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: starting node for path\ntarget : node label: ending node for path\nReturns:: path: list: List of nodes in a path from source to target.\nRaises:: NetworkXNoPath: If no path exists between source and target.\nMethods: []\nRubrics: Notes: This algorithm is used by shortest_path(G, source, target).\nExamples: G=nx.Graph()\nnx.add_path(G,[0,1,2,3,0,4,5,6,7,4])\nnx.bidirectional_shortest_path(G,2,6)\n# [2, 1, 0, 4, 5, 6]",
    "Section ID: geometric_soft_configuration_graph\nDescription: [Returns a random graph from the geometric soft configuration model., The \\(\\mathbb{S}^1\\) model [1] is the geometric soft configuration model\nwhich is able to explain many fundamental features of real networks such as\nsmall-world property, heteregenous degree distributions, high level of\nclustering, and self-similarity., In the geometric soft configuration model, a node \\(i\\) is assigned two hidden\nvariables: a hidden degree \\(\\kappa_i\\) , quantifying its popularity, influence,\nor importance, and an angular position \\(\\theta_i\\) in a circle abstracting the\nsimilarity space, where angular distances between nodes are a proxy for their\nsimilarity. Focusing on the angular position, this model is often called\nthe \\(\\mathbb{S}^1\\) model (a one-dimensional sphere). The circle’s radius is\nadjusted to \\(R = N/2\\pi\\) , where \\(N\\) is the number of nodes, so that the density\nis set to 1 without loss of generality., The connection probability between any pair of nodes increases with\nthe product of their hidden degrees (i.e., their combined popularities),\nand decreases with the angular distance between the two nodes.\nSpecifically, nodes \\(i\\) and \\(j\\) are connected with the probability, \\(p_{ij} = \\frac{1}{1 + \\frac{d_{ij}^\\beta}{\\left(\\mu \\kappa_i \\kappa_j\\right)^{\\max(1, \\beta)}}}\\), where \\(d_{ij} = R\\Delta\\theta_{ij}\\) is the arc length of the circle between\nnodes \\(i\\) and \\(j\\) separated by an angular distance \\(\\Delta\\theta_{ij}\\) .\nParameters \\(\\mu\\) and \\(\\beta\\) (also called inverse temperature) control the\naverage degree and the clustering coefficient, respectively., It can be shown [2] that the model undergoes a structural phase transition\nat \\(\\beta=1\\) so that for \\(\\beta<1\\) networks are unclustered in the thermodynamic\nlimit (when \\(N\\to \\infty\\) ) whereas for \\(\\beta>1\\) the ensemble generates\nnetworks with finite clustering coefficient., The \\(\\mathbb{S}^1\\) model can be expressed as a purely geometric model \\(\\mathbb{H}^2\\) in the hyperbolic plane [3] by mapping the hidden degree of\neach node into a radial coordinate as, \\(r_i = \\hat{R} - \\frac{2 \\max(1, \\beta)}{\\beta \\zeta} \\ln \\left(\\frac{\\kappa_i}{\\kappa_0}\\right)\\), where \\(\\hat{R}\\) is the radius of the hyperbolic disk and \\(\\zeta\\) is the curvature,, \\(\\hat{R} = \\frac{2}{\\zeta} \\ln \\left(\\frac{N}{\\pi}\\right)\n- \\frac{2\\max(1, \\beta)}{\\beta \\zeta} \\ln (\\mu \\kappa_0^2)\\), The connection probability then reads, \\(p_{ij} = \\frac{1}{1 + \\exp\\left({\\frac{\\beta\\zeta}{2} (x_{ij} - \\hat{R})}\\right)}\\), where, \\(x_{ij} = r_i + r_j + \\frac{2}{\\zeta} \\ln \\frac{\\Delta\\theta_{ij}}{2}\\), is a good approximation of the hyperbolic distance between two nodes separated\nby an angular distance \\(\\Delta\\theta_{ij}\\) with radial coordinates \\(r_i\\) and \\(r_j\\) .\nFor \\(\\beta > 1\\) , the curvature \\(\\zeta = 1\\) , for \\(\\beta < 1\\) , \\(\\zeta = \\beta^{-1}\\) .]\nField List: Parameters:: Either `n`, `gamma`, `mean_degree` are provided or `kappas`. The values of: \n`n`, `gamma`, `mean_degree` (if provided) are used to construct a random: \nkappa-dict keyed by node with values sampled from a power-law distribution.: \nbeta : positive number: Inverse temperature, controlling the clustering coefficient.\nn : int (default: None): Size of the network (number of nodes).\nIf not provided,kappasmust be provided and holds the nodes.\ngamma : float (default: None): Exponent of the power-law distribution for hidden degreeskappas.\nIf not provided,kappasmust be provided directly.\nmean_degree : float (default: None): The mean degree in the network.\nIf not provided,kappasmust be provided directly.\nkappas : dict (default: None): A dict keyed by node to its hidden degree value.\nIf not provided, random values are computed based on a power-law\ndistribution usingn,gammaandmean_degree.\nseed : int, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: Graph: A random geometric soft configuration graph (undirected with no self-loops).\nEach node has three node-attributes:kappathat represents the hidden degree.thetathe position in the similarity space (\\(\\mathbb{S}^1\\)) which is\nalso the angular position in the hyperbolic plane.radiusthe radial position in the hyperbolic plane\n(based on the hidden degree).\nMethods: []\nRubrics: References: [1]Serrano, M. Á., Krioukov, D., & Boguñá, M. (2008). Self-similarity\nof complex networks and hidden metric spaces. Physical review letters, 100(7), 078701.  [2]van der Kolk, J., Serrano, M. Á., & Boguñá, M. (2022). An anomalous\ntopological phase transition in spatial random graphs. Communications Physics, 5(1), 245.  [3]Krioukov, D., Papadopoulos, F., Kitsak, M., Vahdat, A., & Boguná, M. (2010).\nHyperbolic geometry of complex networks. Physical Review E, 82(3), 036106.\nExamples: Generate a network with specified parameters:\nG=nx.geometric_soft_configuration_graph(beta=1.5,n=100,gamma=2.7,mean_degree=5)\nCreate a geometric soft configuration graph with 100 nodes. The\\(\\beta\\)parameter\nis set to 1.5 and the exponent of the powerlaw distribution of the hidden\ndegrees is 2.7 with mean value of 5.\nGenerate a network with predefined hidden degrees:\nkappas={i:10foriinrange(100)}\nG=nx.geometric_soft_configuration_graph(beta=2.5,kappas=kappas)\nCreate a geometric soft configuration graph with 100 nodes. The\\(\\beta\\)parameter\nis set to 2.5 and all nodes with hidden degree\\(\\kappa=10\\).",
    "Section ID: min_weighted_dominating_set\nDescription: [Returns a dominating set that approximates the minimum weight node\ndominating set.]\nField List: Parameters:: G : NetworkX graph: Undirected graph.\nweight : string: The node attribute storing the weight of an node. If provided,\nthe node attribute with this key must be a number for each\nnode. If not provided, each node is assumed to have weight one.\nReturns:: min_weight_dominating_set : set: A set of nodes, the sum of whose weights is no more than(logw(V))w(V^*), wherew(V)denotes the sum of the weights of\neach node in the graph andw(V^*)denotes the sum of the\nweights of each node in the minimum weight dominating set.\nRaises:: NetworkXNotImplemented: If G is directed.\nMethods: []\nRubrics: Notes: This algorithm computes an approximate minimum weighted dominating\nset for the graph G . The returned solution has weight (logw(V))w(V^*) , where w(V) denotes the sum of the weights of each\nnode in the graph and w(V^*) denotes the sum of the weights of\neach node in the minimum weight dominating set for the graph. This implementation of the algorithm runs in \\(O(m)\\) time, where \\(m\\) is the number of edges in the graph.\nReferences: [1]Vazirani, Vijay V.Approximation Algorithms.\nSpringer Science & Business Media, 2001.\nExamples: G=nx.Graph([(0,1),(0,4),(1,4),(1,2),(2,3),(3,4),(2,5)])\nnx.approximation.min_weighted_dominating_set(G)\n# {1, 2, 4}",
    "Section ID: circular_layout\nDescription: [Position nodes on a circle.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\nscale : number (default: 1): Scale factor for positions.\ncenter : array-like or None: Coordinate pair around which to center the layout.\ndim : int: Dimension of layout.\nIf dim>2, the remaining dimensions are set to zero\nin the returned positions.\nIf dim<2, a ValueError is raised.\nReturns:: pos : dict: A dictionary of positions keyed by node\nRaises:: ValueError: If dim < 2\nMethods: []\nRubrics: Notes: This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.\nExamples: G=nx.path_graph(4)\npos=nx.circular_layout(G)",
    "Section ID: EdgeComponentAuxGraph\nDescription: [A simple algorithm to find all k-edge-connected components in a graph., Constructing the auxiliary graph (which may take some time) allows for the\nk-edge-ccs to be found in linear time for arbitrary k., Notes, This implementation is based on [1] . The idea is to construct an auxiliary\ngraph from which the k-edge-ccs can be extracted in linear time. The\nauxiliary graph is constructed in \\(O(|V|\\cdot F)\\) operations, where F is the\ncomplexity of max flow. Querying the components takes an additional \\(O(|V|)\\) operations. This algorithm can be slow for large graphs, but it handles an\narbitrary k and works for both directed and undirected inputs., The undirected case for k=1 is exactly connected components.\nThe undirected case for k=2 is exactly bridge connected components.\nThe directed case for k=1 is exactly strongly connected components., References, Examples, The auxiliary graph is primarily used for k-edge-ccs but it\ncan also speed up the queries of k-edge-subgraphs by refining the\nsearch space.]\nField List: Methods: []\nRubrics: Notes: This implementation is based on [1] . The idea is to construct an auxiliary\ngraph from which the k-edge-ccs can be extracted in linear time. The\nauxiliary graph is constructed in \\(O(|V|\\cdot F)\\) operations, where F is the\ncomplexity of max flow. Querying the components takes an additional \\(O(|V|)\\) operations. This algorithm can be slow for large graphs, but it handles an\narbitrary k and works for both directed and undirected inputs. The undirected case for k=1 is exactly connected components.\nThe undirected case for k=2 is exactly bridge connected components.\nThe directed case for k=1 is exactly strongly connected components.\nReferences: [1]Wang, Tianhao, et al. (2015) A simple algorithm for finding all\nk-edge-connected components.http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264\nExamples: importitertoolsasit\nfromnetworkx.utilsimportpairwise\nfromnetworkx.algorithms.connectivityimportEdgeComponentAuxGraph\n# Build an interesting graph with multiple levels of k-edge-ccs\npaths=[\n(1,2,3,4,1,3,4,2),# a 3-edge-cc (a 4 clique)\n(5,6,7,5),# a 2-edge-cc (a 3 clique)\n(1,5),# combine first two ccs into a 1-edge-cc\n(0,),# add an additional disconnected 1-edge-cc\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# Constructing the AuxGraph takes about O(n ** 4)\naux_graph=EdgeComponentAuxGraph.construct(G)\n# Once constructed, querying takes O(n)\nsorted(map(sorted,aux_graph.k_edge_components(k=1)))\n# [[0], [1, 2, 3, 4, 5, 6, 7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=2)))\n# [[0], [1, 2, 3, 4], [5, 6, 7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=3)))\n# [[0], [1, 2, 3, 4], [5], [6], [7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=4)))\n# [[0], [1], [2], [3], [4], [5], [6], [7]]\nThe auxiliary graph is primarily used for k-edge-ccs but it\ncan also speed up the queries of k-edge-subgraphs by refining the\nsearch space.\nimportitertoolsasit\nfromnetworkx.utilsimportpairwise\nfromnetworkx.algorithms.connectivityimportEdgeComponentAuxGraph\npaths=[\n(1,2,4,3,1,4),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\naux_graph=EdgeComponentAuxGraph.construct(G)\nsorted(map(sorted,aux_graph.k_edge_subgraphs(k=3)))\n# [[1], [2], [3], [4]]\nsorted(map(sorted,aux_graph.k_edge_components(k=3)))\n# [[1, 4], [2], [3]]",
    "Section ID: dfs_tree\nDescription: [Returns oriented tree constructed from a depth-first-search from source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Specify starting node for depth-first search.\ndepth_limit : int, optional (default=len(G)): Specify the maximum search depth.\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: T : NetworkX DiGraph: An oriented tree\nMethods: []\nRubrics: Examples: G=nx.path_graph(5)\nT=nx.dfs_tree(G,source=0,depth_limit=2)\nlist(T.edges())\n# [(0, 1), (1, 2)]\nT=nx.dfs_tree(G,source=0)\nlist(T.edges())\n# [(0, 1), (1, 2), (2, 3), (3, 4)]",
    "Section ID: attr_matrix\nDescription: [Returns the attribute matrix using attributes from G as a numpy array., If only G is passed in, then the adjacency matrix is constructed., Let A be a discrete set of values for the node attribute node_attr . Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in G and consider the value\nof the edge attribute edge_attr .  If ua and va are the values of the\nnode attribute node_attr for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va).]\nField List: Parameters:: G : graph: The NetworkX graph used to construct the attribute matrix.\nedge_attr : str, optional: Each element of the matrix represents a running total of the\nspecified edge attribute for edges whose node attributes correspond\nto the rows/cols of the matrix. The attribute must be present for\nall edges in the graph. If no attribute is specified, then we\njust count the number of edges whose node attributes correspond\nto the matrix element.\nnode_attr : str, optional: Each row and column in the matrix represents a particular value\nof the node attribute.  The attribute must be present for all nodes\nin the graph. Note, the values of this attribute should be reliably\nhashable. So, float values are not recommended. If no attribute is\nspecified, then the rows and columns will be the nodes of the graph.\nnormalized : bool, optional: If True, then each row is normalized by the summation of its values.\nrc_order : list, optional: A list of the node attribute values. This list specifies the ordering\nof rows and columns of the array. If no ordering is provided, then\nthe ordering will be random (and also, a return value).\nReturns:: M : 2D NumPy ndarray: The attribute matrix.\nordering : list: Ifrc_orderwas specified, then only the attribute matrix is returned.\nHowever, ifrc_orderwas None, then the ordering used to construct\nthe matrix is returned as well.\nOther Parameters:: dtype : NumPy data-type, optional: A valid NumPy dtype used to initialize the array. Keep in mind certain\ndtypes can yield unexpected results if the array is to be normalized.\nThe parameter is passed to numpy.zeros(). If unspecified, the NumPy\ndefault is used.\norder : {‘C’, ‘F’}, optional: Whether to store multidimensional data in C- or Fortran-contiguous\n(row- or column-wise) order in memory. This parameter is passed to\nnumpy.zeros(). If unspecified, the NumPy default is used.\nMethods: []\nRubrics: Examples: Construct an adjacency matrix:\nG=nx.Graph()\nG.add_edge(0,1,thickness=1,weight=3)\nG.add_edge(0,2,thickness=2)\nG.add_edge(1,2,thickness=3)\nnx.attr_matrix(G,rc_order=[0,1,2])\n# array([[0., 1., 1.],\n#        [1., 0., 1.],\n#        [1., 1., 0.]])\nAlternatively, we can obtain the matrix describing edge thickness.\nnx.attr_matrix(G,edge_attr=\"thickness\",rc_order=[0,1,2])\n# array([[0., 1., 2.],\n#        [1., 0., 3.],\n#        [2., 3., 0.]])\nWe can also color the nodes and ask for the probability distribution over\nall edges (u,v) describing:",
    "Section ID: is_regular_expander\nDescription: [Determines whether the graph G is a regular expander. [1], An expander graph is a sparse graph with strong connectivity properties., More precisely, this helper checks whether the graph is a\nregular \\((n, d, \\lambda)\\) -expander with \\(\\lambda\\) close to\nthe Alon-Boppana bound and given by \\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\) . [2], In the case where \\(\\epsilon = 0\\) then if the graph successfully passes the test\nit is a Ramanujan graph. [3], A Ramanujan graph has spectral gap almost as large as possible, which makes them\nexcellent expanders.]\nField List: Parameters:: G : NetworkX graph: \nepsilon : int, float, default=0:\nReturns:: bool: Whether the given graph is a regular\\((n, d, \\lambda)\\)-expander\nwhere\\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\).\nMethods: []\nRubrics: References: [1]Expander graph,https://en.wikipedia.org/wiki/Expander_graph  [2]Alon-Boppana bound,https://en.wikipedia.org/wiki/Alon%E2%80%93Boppana_bound  [3]Ramanujan graphs,https://en.wikipedia.org/wiki/Ramanujan_graph\nExamples: G=nx.random_regular_expander_graph(20,4)\nnx.is_regular_expander(G)\n# True",
    "Section ID: barycenter\nDescription: [Calculate barycenter of a connected graph, optionally with edge weights., The barycenter a connected graph \\(G\\) is the subgraph induced by the set of its nodes \\(v\\) minimizing the objective function, where \\(d_G\\) is the (possibly weighted) pathlength .\nThe barycenter is also called the median . See [West01] , p. 78.]\nField List: Parameters:: G : networkx.Graph: The connected graph\\(G\\).\nweight : str, optional: Passed through toshortest_path_length().\nattr : str, optional: If given, write the value of the objective function to each node’sattrattribute. Otherwise do not store the value.\nsp : dict of dicts, optional: All pairs shortest path lengths as a dictionary of dictionaries\nReturns:: list: Nodes ofGthat induce the barycenter ofG.\nRaises:: NetworkXNoPath: IfGis disconnected.Gmay appear disconnected tobarycenter()ifspis given but is missing shortest path\nlengths for any pairs.\nValueError: Ifspandweightare both given.\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.barycenter(G)\n# [1, 3, 4]",
    "Section ID: k_factor\nDescription: [Compute a k-factor of G, A k-factor of a graph is a spanning k-regular subgraph.\nA spanning k-regular subgraph of G is a subgraph that contains\neach vertex of G and a subset of the edges of G such that each\nvertex has degree k.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nmatching_weight: string, optional (default=’weight’): Edge data key corresponding to the edge weight.\nUsed for finding the max-weighted perfect matching.\nIf key not found, uses 1 as weight.\nReturns:: G2 : NetworkX graph: A k-factor of G\nMethods: []\nRubrics: References: [1]“An algorithm for computing simple k-factors.”,\nMeijer, Henk, Yurai Núñez-Rodríguez, and David Rappaport,\nInformation processing letters, 2009.\nExamples: G=nx.Graph([(1,2),(2,3),(3,4),(4,1)])\nG2=nx.k_factor(G,k=1)\nG2.edges()\n# EdgeView([(1, 2), (3, 4)])",
    "Section ID: spiral_layout\nDescription: [Position nodes in a spiral layout.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\nscale : number (default: 1): Scale factor for positions.\ncenter : array-like or None: Coordinate pair around which to center the layout.\ndim : int, default=2: Dimension of layout, currently only dim=2 is supported.\nOther dimension values result in a ValueError.\nresolution : float, default=0.35: The compactness of the spiral layout returned.\nLower values result in more compressed spiral layouts.\nequidistant : bool, default=False: If True, nodes will be positioned equidistant from each other\nby decreasing angle further from center.\nIf False, nodes will be positioned at equal angles\nfrom each other by increasing separation further from center.\nReturns:: pos : dict: A dictionary of positions keyed by node\nRaises:: ValueError: If dim != 2\nMethods: []\nRubrics: Notes: This algorithm currently only works in two dimensions.\nExamples: G=nx.path_graph(4)\npos=nx.spiral_layout(G)\nnx.draw(G,pos=pos)",
    "Section ID: one_exchange\nDescription: [Compute a partitioning of the graphs nodes and the corresponding cut value., Use a greedy one exchange strategy to find a locally maximal cut\nand its value, it works by finding the best node (one that gives\nthe highest gain to the cut value) to add to the current cut\nand repeats this process until no improvement can be made.]\nField List: Parameters:: G : networkx Graph: Graph to find a maximum cut for.\ninitial_cut : set: Cut to use as a starting point. If not supplied the algorithm\nstarts with an empty cut.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nweight : object: Edge attribute key to use as weight. If not specified, edges\nhave weight one.\nReturns:: cut_value : scalar: Value of the maximum cut.\npartition : pair of node sets: A partitioning of the nodes that defines a maximum cut.\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics: Examples: G=nx.complete_graph(5)\ncurr_cut_size,partition=nx.approximation.one_exchange(G,seed=1)\ncurr_cut_size\n# 6\npartition\n# ({0, 2}, {1, 3, 4})",
    "Section ID: draw_spring\nDescription: [Draw the graph G with a spring layout., This is a convenience function equivalent to:]\nField List: Parameters:: G : graph: A networkx graph\nkwargs : optional keywords: Seedraw_networkxfor a description of optional keywords.\nMethods: []\nRubrics: Notes: spring_layout is also the default layout for draw , so this function is equivalent to draw . The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call spring_layout directly and reuse the result:\nExamples: G=nx.path_graph(20)\nnx.draw_spring(G)",
    "Section ID: node_connectivity\nDescription: [Returns an approximation for node connectivity for a graph or digraph G., Node connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. By Menger’s theorem,\nthis is equal to the number of node independent paths (paths that\nshare no nodes other than source and target)., If source and target nodes are provided, this function returns the\nlocal node connectivity: the minimum number of nodes that must be\nremoved to break all paths from source to target in G., This algorithm is based on a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\ns : node: Source node. Optional. Default value: None.\nt : node: Target node. Optional. Default value: None.\nReturns:: K : integer: Node connectivity of G, or local node connectivity if source\nand target are provided.\nMethods: []\nRubrics: Notes: This algorithm [1] finds node independents paths between two nodes by\ncomputing their shortest path using BFS, marking the nodes of the path\nfound as ‘used’ and then searching other shortest paths excluding the\nnodes marked as used until no more paths exist. It is not exact because\na shortest path could use nodes that, if the path were longer, may belong\nto two different node independent paths. Thus it only guarantees an\nstrict lower bound on node connectivity.\nReferences: [1](1,2)White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf\nExamples: # Platonic octahedral graph is 4-node-connected\nfromnetworkx.algorithmsimportapproximationasapprox\nG=nx.octahedral_graph()\napprox.node_connectivity(G)\n# 4",
    "Section ID: local_node_connectivity\nDescription: [Computes local node connectivity for nodes s and t., Local node connectivity for two non adjacent nodes s and t is the\nminimum number of nodes that must be removed (along with their incident\nedges) to disconnect them., This is a flow based implementation of node connectivity. We compute the\nmaximum flow on an auxiliary digraph build from the original input\ngraph (see below for details).]\nField List: Parameters:: G : NetworkX graph: Undirected graph\ns : node: Source node\nt : node: Target node\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.\nauxiliary : NetworkX DiGraph: Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.\nresidual : NetworkX DiGraph: Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.\ncutoff : integer, float, or None (default: None): If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise.\nReturns:: K : integer: local node connectivity for nodes s and t\nMethods: []\nRubrics: Notes: This is a flow based implementation of node connectivity. We compute the\nmaximum flow using, by default, the edmonds_karp() algorithm (see: maximum_flow() ) on an auxiliary digraph build from the original\ninput graph: For an undirected graph G having n nodes and m edges we derive a\ndirected graph H with 2n nodes and 2m+n arcs by replacing each\noriginal node v with two nodes v_A , v_B linked by an (internal)\narc in H. Then for each edge ( u , v ) in G we add two arcs\n( u_B , v_A ) and ( v_B , u_A ) in H. Finally we set the attribute\ncapacity = 1 for each arc in H [1] . For a directed graph G having n nodes and m arcs we derive a\ndirected graph H with 2n nodes and m+n arcs by replacing each\noriginal node v with two nodes v_A , v_B linked by an (internal)\narc ( v_A , v_B ) in H. Then for each arc ( u , v ) in G we add one arc\n( u_B , v_A ) in H. Finally we set the attribute capacity = 1 for\neach arc in H. This is equal to the local node connectivity because the value of\na maximum s-t-flow is equal to the capacity of a minimum s-t-cut.\nReferences: [1]Kammer, Frank and Hanjo Taubig. Graph Connectivity. in Brandes and\nErlebach, ‘Network Analysis: Methodological Foundations’, Lecture\nNotes in Computer Science, Volume 3418, Springer-Verlag, 2005.http://www.informatik.uni-augsburg.de/thi/personen/kammer/Graph_Connectivity.pdf\nExamples: This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportlocal_node_connectivity\nWe use in this example the platonic icosahedral graph, which has node\nconnectivity 5.\nG=nx.icosahedral_graph()\nlocal_node_connectivity(G,0,6)\n# 5\nIf you need to compute local connectivity on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local node connectivity among\nall pairs of nodes of the platonic icosahedral graph reusing\nthe data structures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=local_node_connectivity(G,u,v,auxiliary=H,residual=R)\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing node\nconnectivity. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlocal_node_connectivity(G,0,6,flow_func=shortest_augmenting_path)\n# 5",
    "Section ID: davis_southern_women_graph\nDescription: [Returns Davis Southern women social network., This is a bipartite graph., References]\nField List: Methods: []\nRubrics: References: [1]A. Davis, Gardner, B. B., Gardner, M. R., 1941. Deep South.\nUniversity of Chicago Press, Chicago, IL.",
    "Section ID: bfs_layout\nDescription: [Position nodes according to breadth-first search algorithm.]\nField List: Parameters:: G : NetworkX graph: A position will be assigned to every node in G.\nstart : node inG: Starting node for bfs\ncenter : array-like or None: Coordinate pair around which to center the layout.\nReturns:: pos : dict: A dictionary of positions keyed by node.\nMethods: []\nRubrics: Notes: This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.\nExamples: G=nx.path_graph(4)\npos=nx.bfs_layout(G,0)",
    "Section ID: chromatic_polynomial\nDescription: [Returns the chromatic polynomial of G, This function computes the chromatic polynomial via an iterative version of\nthe deletion-contraction algorithm., The chromatic polynomial X_G(x) is a fundamental graph polynomial\ninvariant in one variable. Evaluating X_G(k) for an natural number k enumerates the proper k-colorings of G ., There are several equivalent definitions; here are three:, Def 1 (explicit formula):\nFor G an undirected graph, c(G) the number of connected components of G , E the edge set of G , and G(S) the spanning subgraph of G with\nedge set S  [1] :, Def 2 (interpolating polynomial):\nFor G an undirected graph, n(G) the number of vertices of G , k_0=0 ,\nand k_i the number of distinct ways to color the vertices of G with i unique colors (for i a natural number at most n(G) ), X_G(x) is the\nunique Lagrange interpolating polynomial of degree n(G) through the points (0,k_0),(1,k_1),dots,(n(G),k_{n(G)})  [2] ., Def 3 (chromatic recurrence):\nFor G an undirected graph, G-e the graph obtained from G by deleting\nedge e , G/e the graph obtained from G by contracting edge e , n(G) the number of vertices of G , and e(G) the number of edges of G  [3] :, This formulation is also known as the Fundamental Reduction Theorem [4] .]\nField List: Parameters:: G : NetworkX graph:\nReturns:: instance of : sympy.core.add.Add: A Sympy expression representing the chromatic polynomial forG.\nMethods: []\nRubrics: Notes: Interpretation of the coefficients is discussed in [5] . Several special\ncases are listed in [2] . The chromatic polynomial is a specialization of the Tutte polynomial; in\nparticular, X_G(x)=T_G(x,0)  [6] . The chromatic polynomial may take negative arguments, though evaluations\nmay not have chromatic interpretations. For instance, X_G(-1) enumerates\nthe acyclic orientations of G  [7] .\nReferences: [1]D. B. West,\n“Introduction to Graph Theory,” p. 222  [2](1,2)E. W. Weisstein\n“Chromatic Polynomial”\nMathWorld–A Wolfram Web Resourcehttps://mathworld.wolfram.com/ChromaticPolynomial.html  [3]D. B. West,\n“Introduction to Graph Theory,” p. 221  [4]J. Zhang, J. Goodall,\n“An Introduction to Chromatic Polynomials”https://math.mit.edu/~apost/courses/18.204_2018/Julie_Zhang_paper.pdf  [5]R. C. Read,\n“An Introduction to Chromatic Polynomials”\nJournal of Combinatorial Theory, 1968https://math.berkeley.edu/~mrklug/ReadChromatic.pdf  [6]W. T. Tutte,\n“Graph-polynomials”\nAdvances in Applied Mathematics, 2004https://www.sciencedirect.com/science/article/pii/S0196885803000411  [7]R. P. Stanley,\n“Acyclic orientations of graphs”\nDiscrete Mathematics, 2006https://math.mit.edu/~rstan/pubs/pubfiles/18.pdf\nExamples: C=nx.cycle_graph(5)\nnx.chromatic_polynomial(C)\n# x**5 - 5*x**4 + 10*x**3 - 10*x**2 + 4*x\nG=nx.complete_graph(4)\nnx.chromatic_polynomial(G)\n# x**4 - 6*x**3 + 11*x**2 - 6*x",
    "Section ID: parse_gml\nDescription: [Parse GML graph from a string or iterable.]\nField List: Parameters:: lines : string or iterable of strings: Data in GML format.\nlabel : string, optional: If not None, the parsed nodes will be renamed according to node\nattributes indicated bylabel. Default value: ‘label’.\ndestringizer : callable, optional: Adestringizerthat recovers values stored as strings in GML. If it\ncannot convert a string to a value, aValueErroris raised. Default\nvalue : None.\nReturns:: G : NetworkX graph: The parsed graph.\nRaises:: NetworkXError: If the input cannot be parsed.\nMethods: []\nRubrics: Notes: This stores nested GML attributes as dictionaries in the NetworkX graph,\nnode, and edge attribute structures. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.",
    "Section ID: directed_combinatorial_laplacian_matrix\nDescription: [Return the directed combinatorial Laplacian matrix of G., The graph directed combinatorial Laplacian is the matrix, where P is the transition matrix of the graph and Phi a matrix\nwith the Perron vector of P in the diagonal and zeros elsewhere [1] ., Depending on the value of walk_type, P can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank).]\nField List: Parameters:: G : DiGraph: A NetworkX graph\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nweight : string or None, optional (default=’weight’): The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.\nwalk_type : string or None, optional (default=None): One of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.\nalpha : real: (1 - alpha) is the teleportation probability used with pagerank\nReturns:: L : NumPy matrix: Combinatorial Laplacian of G.\nMethods: []\nRubrics: Notes: Only implemented for DiGraphs The result is always a symmetric matrix. This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.\nReferences: [1]Fan Chung (2005).\nLaplacians and the Cheeger inequality for directed graphs.\nAnnals of Combinatorics, 9(1), 2005",
    "Section ID: parse_edgelist\nDescription: [Parse lines of an edge list representation of a bipartite graph.]\nField List: Parameters:: lines : list or iterator of strings: Input data in edgelist format\ncomments : string, optional: Marker for comment lines\ndelimiter : string, optional: Separator for node labels\ncreate_using: NetworkX graph container, optional: Use given NetworkX graph for holding nodes or edges.\nnodetype : Python type, optional: Convert nodes to this type.\ndata : bool or list of (label,type) tuples: If False generate no edge data or if True use a dictionary\nrepresentation of edge data or a list tuples specifying dictionary\nkey names and types for edge data.\nReturns:: G: NetworkX Graph: The bipartite graph corresponding to lines\nMethods: []\nRubrics: Examples: Edgelist with no data:\nfromnetworkx.algorithmsimportbipartite\nlines=[\"1 2\",\"2 3\",\"3 4\"]\nG=bipartite.parse_edgelist(lines,nodetype=int)\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.nodes(data=True))\n# [(1, {'bipartite': 0}), (2, {'bipartite': 0}), (3, {'bipartite': 0}), (4, {'bipartite': 1})]\nsorted(G.edges())\n# [(1, 2), (2, 3), (3, 4)]\nEdgelist with data in Python dictionary representation:\nlines=[\"1 2 {'weight':3}\",\"2 3 {'weight':27}\",\"3 4 {'weight':3.0}\"]\nG=bipartite.parse_edgelist(lines,nodetype=int)\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.edges(data=True))\n# [(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]\nEdgelist with data in a list:\nlines=[\"1 2 3\",\"2 3 27\",\"3 4 3.0\"]\nG=bipartite.parse_edgelist(lines,nodetype=int,data=((\"weight\",float),))\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.edges(data=True))\n# [(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]",
    "Section ID: resistance_distance\nDescription: [Returns the resistance distance between pairs of nodes in graph G., The resistance distance between two nodes of a graph is akin to treating\nthe graph as a grid of resistors with a resistance equal to the provided\nweight [1] , [2] ., If weight is not provided, then a weight of 1 is used for all edges., If two nodes are the same, the resistance distance is zero.]\nField List: Parameters:: G : NetworkX graph: A graph\nnodeA : node or None, optional (default=None): A node within graph G.\nIf None, compute resistance distance using all nodes as source nodes.\nnodeB : node or None, optional (default=None): A node within graph G.\nIf None, compute resistance distance using all nodes as target nodes.\nweight : string or None, optional (default=None): The edge data key used to compute the resistance distance.\nIf None, then each edge has weight 1.\ninvert_weight : boolean (default=True): Proper calculation of resistance distance requires building the\nLaplacian matrix with the reciprocal of the weight. Not required\nif the weight is already inverted. Weight cannot be zero.\nReturns:: rd : dict or float: IfnodeAandnodeBare given, resistance distance betweennodeAandnodeB. IfnodeAornodeBis unspecified (the default), a\ndictionary of nodes with resistance distances as the value.\nRaises:: NetworkXNotImplemented: IfGis a directed graph.\nNetworkXError: IfGis not connected, or contains no nodes,\nornodeAis not inGornodeBis not inG.\nMethods: []\nRubrics: Notes: The implementation is based on Theorem A in [2] . Self-loops are ignored.\nMulti-edges are contracted in one edge with weight equal to the harmonic sum of the weights.\nReferences: [1]Wikipedia\n“Resistance distance.”https://en.wikipedia.org/wiki/Resistance_distance  [2](1,2)D. J. Klein and M. Randic.\nResistance distance.\nJ. of Math. Chem. 12:81-95, 1993.\nExamples: G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nround(nx.resistance_distance(G,1,3),10)\n# 0.625",
    "Section ID: inverse_line_graph\nDescription: [Returns the inverse line graph of graph G., If H is a graph, and G is the line graph of H, such that G = L(H).\nThen H is the inverse line graph of G., Not all graphs are line graphs and these do not have an inverse line graph.\nIn these cases this function raises a NetworkXError.]\nField List: Parameters:: G : graph: A NetworkX Graph\nReturns:: H : graph: The inverse line graph of G.\nRaises:: NetworkXNotImplemented: If G is directed or a multigraph\nNetworkXError: If G is not a line graph\nMethods: []\nRubrics: Notes: This is an implementation of the Roussopoulos algorithm[R90abc5507a69-1]_. If G consists of multiple components, then the algorithm doesn’t work.\nYou should invert every component separately:\nReferences: [1]Roussopoulos, N.D. , “A max {m, n} algorithm for determining the graph H from\nits line graph G”, Information Processing Letters 2, (1973), 108–112, ISSN 0020-0190,DOI link",
    "Section ID: dodecahedral_graph\nDescription: [Returns the Platonic Dodecahedral graph., The dodecahedral graph has 20 nodes and 30 edges. The skeleton of the\ndodecahedron forms a graph. It is one of 5 Platonic graphs [1] .\nIt can be described in LCF notation as: [10,7,4,-4,-7,10,-4,7,-7,4]^2  [2] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Dodecahedral Graph with 20 nodes and 30 edges\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Regular_dodecahedron#Dodecahedral_graph  [2]https://mathworld.wolfram.com/DodecahedralGraph.html",
    "Section ID: to_sparse6_bytes\nDescription: [Convert an undirected graph to bytes in sparse6 format.]\nField List: Parameters:: G : Graph (undirected): \nnodes: list or iterable: Nodes are labeled 0…n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.\nheader: bool: If True add ‘>>sparse6<<’ bytes to head of data.\nRaises:: NetworkXNotImplemented: If the graph is directed.\nValueError: If the graph has at least2**36nodes; the sparse6 format\nis only defined for graphs of order less than2**36.\nMethods: []\nRubrics: Notes: The returned bytes end with a newline character. The format does not support edge or node labels.\nReferences: [1]Graph6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>\nExamples: nx.to_sparse6_bytes(nx.path_graph(2))\n# b'>>sparse6<<:An\\n'",
    "Section ID: faster_could_be_isomorphic\nDescription: [Returns False if graphs are definitely not isomorphic., True does NOT guarantee isomorphism.]\nField List: Parameters:: G1, G2 : graphs: The two graphs G1 and G2 must be the same type.\nMethods: []\nRubrics: Notes: Checks for matching degree sequences.",
    "Section ID: to_vertex_cover\nDescription: [Returns the minimum vertex cover corresponding to the given maximum\nmatching of the bipartite graph G .]\nField List: Parameters:: G : NetworkX graph: Undirected bipartite graph\nmatching : dictionary: A dictionary whose keys are vertices inGand whose values are the\ndistinct neighbors comprising the maximum matching forG, as returned\nby, for example,maximum_matching(). The dictionarymustrepresent the maximum matching.\ntop_nodes : container: Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised.\nReturns:: vertex_cover : set: The minimum vertex cover inG.\nRaises:: AmbiguousSolution: Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected.\nMethods: []\nRubrics: Notes: This function is implemented using the procedure guaranteed by Konig’s\ntheorem ,\nwhich proves an equivalence between a maximum matching and a minimum vertex\ncover in bipartite graphs. Since a minimum vertex cover is the complement of a maximum independent set\nfor any graph, one can compute the maximum independent set of a bipartite\ngraph this way:",
    "Section ID: prominent_group\nDescription: [Find the prominent group of size \\(k\\) in graph \\(G\\) . The prominence of the\ngroup is evaluated by the group betweenness centrality., Group betweenness centrality of a group of nodes \\(C\\) is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in \\(C\\), where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|C)\\) is the number of\nthose paths passing through some node in group \\(C\\) . Note that \\((s, t)\\) are not members of the group ( \\(V-C\\) is the set of nodes\nin \\(V\\) that are not in \\(C\\) ).]\nField List: Parameters:: G : graph: A NetworkX graph.\nk : int: The number of nodes in the group.\nnormalized : bool, optional (default=True): If True, group betweenness is normalized by1/((|V|-|C|)(|V|-|C|-1))where|V|is the number of nodes in G and|C|is the number of\nnodes in C.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.\nendpoints : bool, optional (default=False): If True include the endpoints in the shortest path counts.\nC : list or set, optional (default=None): list of nodes which won’t be candidates of the prominent group.\ngreedy : bool, optional (default=False): Using a naive greedy algorithm in order to find non-optimal prominent\ngroup. For scale free networks the results are negligibly below the optimal\nresults.\nReturns:: max_GBC : float: The group betweenness centrality of the prominent group.\nmax_group : list: The list of nodes in the prominent group.\nRaises:: NodeNotFound: If node(s) in C are not present in G.\nMethods: []\nRubrics: Notes: Group betweenness centrality is described in [1] and its importance discussed in [3] .\nThe algorithm is described in [2] and is based on techniques mentioned in [4] . The number of nodes in the group must be a maximum of n-2 where n is the total number of nodes in the graph. For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nbetween “u” and “v” are counted as two possible paths (one each\ndirection) while undirected paths between “u” and “v” are counted\nas one path. Said another way, the sum in the expression above is\nover all s!=t for directed graphs and for s<t for undirected graphs.\nReferences: [1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]Rami Puzis, Yuval Elovici, and Shlomi Dolev:\n“Finding the Most Prominent Group in Complex Networks”\nAI communications 20(4): 287-296, 2007.https://www.researchgate.net/profile/Rami_Puzis2/publication/220308855  [3]Sourav Medya et. al.:\nGroup Centrality Maximization via Network Design.\nSIAM International Conference on Data Mining, SDM 2018, 126–134.https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf  [4]Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n“Fast algorithm for successive computation of group betweenness centrality.”https://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709",
    "Section ID: edge_load_centrality\nDescription: [Compute edge load., WARNING: This concept of edge load has not been analysed\nor discussed outside of NetworkX that we know of.\nIt is based loosely on load_centrality in the sense that\nit counts the number of shortest paths which cross each edge.\nThis function is for demonstration and testing purposes.]\nField List: Parameters:: G : graph: A networkx graph\ncutoff : bool, optional (default=False): If specified, only consider paths of length <= cutoff.\nReturns:: A dict keyed by edge 2-tuple to the number of shortest paths: \nwhich use that edge. Where more than one path is shortest: \nthe count is divided equally among paths.:\nMethods: []\nRubrics:",
    "Section ID: intersection_array\nDescription: [Returns the intersection array of a distance-regular graph., Given a distance-regular graph G with integers b_i, c_i,i = 0,….,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x., A distance regular graph’s intersection array is given by,\n[b_0,b_1,…..b_{d-1};c_1,c_2,…..c_d]]\nField List: Parameters:: G: Networkx graph (undirected):\nReturns:: b,c: tuple of lists:\nMethods: []\nRubrics: References: [1]Weisstein, Eric W. “Intersection Array.”\nFrom MathWorld–A Wolfram Web Resource.http://mathworld.wolfram.com/IntersectionArray.html\nExamples: G=nx.icosahedral_graph()\nnx.intersection_array(G)\n# ([5, 2, 1], [1, 2, 5])",
    "Section ID: random_layout\nDescription: [Position nodes uniformly at random in the unit square., For every node, a position is generated by choosing each of dim\ncoordinates uniformly at random on the interval [0.0, 1.0)., NumPy ( http://scipy.org ) is required for this function.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\ncenter : array-like or None: Coordinate pair around which to center the layout.\ndim : int: Dimension of layout.\nseed : int, RandomState instance or None  optional (default=None): Set the random state for deterministic node layouts.\nIf int,seedis the seed used by the random number generator,\nif numpy.random.RandomState instance,seedis the random\nnumber generator,\nif None, the random number generator is the RandomState instance used\nby numpy.random.\nReturns:: pos : dict: A dictionary of positions keyed by node\nMethods: []\nRubrics: Examples: G=nx.lollipop_graph(4,3)\npos=nx.random_layout(G)",
    "Section ID: line_graph\nDescription: [Returns the line graph of the graph or digraph G ., The line graph of a graph G has a node for each edge in G and an\nedge joining those nodes if the two edges in G share a common node. For\ndirected graphs, nodes are adjacent exactly when the edges they represent\nform a directed path of length two., The nodes of the line graph are 2-tuples of nodes in the original graph (or\n3-tuples for multigraphs, with the key of the edge as the third element)., For information about self-loops and more discussion, see the Notes section below.]\nField List: Parameters:: G : graph: A NetworkX Graph, DiGraph, MultiGraph, or MultiDigraph.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: L : graph: The line graph of G.\nMethods: []\nRubrics: Notes: Graph, node, and edge data are not propagated to the new graph. For\nundirected graphs, the nodes in G must be sortable, otherwise the\nconstructed line graph may not be correct. Self-loops in undirected graphs For an undirected graph G without multiple edges, each edge can be\nwritten as a set {u,v} .  Its line graph L has the edges of G as\nits nodes. If x and y are two nodes in L , then {x,y} is an edge\nin L if and only if the intersection of x and y is nonempty. Thus,\nthe set of all edges is determined by the set of all pairwise intersections\nof edges in G . Trivially, every edge in G would have a nonzero intersection with itself,\nand so every node in L should have a self-loop. This is not so\ninteresting, and the original context of line graphs was with simple\ngraphs, which had no self-loops or multiple edges. The line graph was also\nmeant to be a simple graph and thus, self-loops in L are not part of the\nstandard definition of a line graph. In a pairwise intersection matrix,\nthis is analogous to excluding the diagonal entries from the line graph\ndefinition. Self-loops and multiple edges in G add nodes to L in a natural way, and\ndo not require any fundamental changes to the definition. It might be\nargued that the self-loops we excluded before should now be included.\nHowever, the self-loops are still “trivial” in some sense and thus, are\nusually excluded. Self-loops in directed graphs For a directed graph G without multiple edges, each edge can be written\nas a tuple (u,v) . Its line graph L has the edges of G as its\nnodes. If x and y are two nodes in L , then (x,y) is an edge in L if and only if the tail of x matches the head of y , for example, if x=(a,b) and y=(b,c) for some vertices a , b , and c in G . Due to the directed nature of the edges, it is no longer the case that\nevery edge in G should have a self-loop in L . Now, the only time\nself-loops arise is if a node in G itself has a self-loop.  So such\nself-loops are no longer “trivial” but instead, represent essential\nfeatures of the topology of G . For this reason, the historical\ndevelopment of line digraphs is such that self-loops are included. When the\ngraph G has multiple edges, once again only superficial changes are\nrequired to the definition.\nReferences: Harary, Frank, and Norman, Robert Z., “Some properties of line digraphs”,\nRend. Circ. Mat. Palermo, II. Ser. 9 (1960), 161–168.  Hemminger, R. L.; Beineke, L. W. (1978), “Line graphs and line digraphs”,\nin Beineke, L. W.; Wilson, R. J., Selected Topics in Graph Theory,\nAcademic Press Inc., pp. 271–305.\nExamples: G=nx.star_graph(3)\nL=nx.line_graph(G)\nprint(sorted(map(sorted,L.edges())))# makes a 3-clique, K3\n# [[(0, 1), (0, 2)], [(0, 1), (0, 3)], [(0, 2), (0, 3)]]\nEdge attributes fromGare not copied over as node attributes inL, but\nattributes can be copied manually:\nG=nx.path_graph(4)\nG.add_edges_from((u,v,{\"tot\":u+v})foru,vinG.edges)\nG.edges(data=True)\n# EdgeDataView([(0, 1, {'tot': 1}), (1, 2, {'tot': 3}), (2, 3, {'tot': 5})])\nH=nx.line_graph(G)\nH.add_nodes_from((node,G.edges[node])fornodeinH)\nH.nodes(data=True)\n# NodeDataView({(0, 1): {'tot': 1}, (2, 3): {'tot': 5}, (1, 2): {'tot': 3}})",
    "Section ID: number_weakly_connected_components\nDescription: [Returns the number of weakly connected components in G.]\nField List: Parameters:: G : NetworkX graph: A directed graph.\nReturns:: n : integer: Number of weakly connected components\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: For directed graphs only.\nExamples: G=nx.DiGraph([(0,1),(2,1),(3,4)])\nnx.number_weakly_connected_components(G)\n# 2",
    "Section ID: non_randomness\nDescription: [Compute the non-randomness of graph G., The first returned value nr is the sum of non-randomness values of all\nedges within the graph (where the non-randomness of an edge tends to be\nsmall when the two nodes linked by that edge are from two different\ncommunities)., The second computed value nr_rd is a relative measure that indicates\nto what extent graph G is different from random graphs in terms\nof probability. When it is close to 0, the graph tends to be more\nlikely generated by an Erdos Renyi model.]\nField List: Parameters:: G : NetworkX graph: Graph must be symmetric, connected, and without self-loops.\nk : int: The number of communities in G.\nIf k is not set, the function will use a default community\ndetection algorithm to set it.\nweight : string or None, optional (default=None): The name of an edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1, i.e., the graph is\nbinary.\nReturns:: non-randomness : (float, float) tuple: Non-randomness, Relative non-randomness w.r.t.\nErdos Renyi random graphs.\nRaises:: NetworkXException: if the input graph is not connected.\nNetworkXError: if the input graph contains self-loops.\nMethods: []\nRubrics: Notes: This computes Eq. (4.4) and (4.5) in Ref. [1] . If a weight field is passed, this algorithm will use the eigenvalues\nof the weighted adjacency matrix to compute Eq. (4.4) and (4.5).\nReferences: [1]Xiaowei Ying and Xintao Wu,\nOn Randomness Measures for Social Networks,\nSIAM International Conference on Data Mining. 2009\nExamples: G=nx.karate_club_graph()\nnr,nr_rd=nx.non_randomness(G,2)\nnr,nr_rd=nx.non_randomness(G,2,\"weight\")",
    "Section ID: draw_networkx_edges\nDescription: [Draw the edges of the graph G., This draws only the edges of the graph G.]\nField List: Parameters:: G : graph: A networkx graph\npos : dictionary: A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.\nedgelist : collection of edge tuples (default=G.edges()): Draw only specified edges\nwidth : float or array of floats (default=1.0): Line width of edges\nedge_color : color or array of colors (default=’k’): Edge color. Can be a single color or a sequence of colors with the same\nlength as edgelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.\nstyle : string or array of strings (default=’solid’): Edge line style e.g.: ‘-’, ‘–’, ‘-.’, ‘:’\nor words like ‘solid’ or ‘dashed’.\nCan be a single style or a sequence of styles with the same\nlength as the edge list.\nIf less styles than edges are given the styles will cycle.\nIf more styles than edges are given the styles will be used sequentially\nand not be exhausted.\nAlso,(offset,onoffseq)tuples can be used as style instead of a strings.\n(Seematplotlib.patches.FancyArrowPatch:linestyle)\nalpha : float or array of floats (default=None): The edge transparency.  This can be a single alpha value,\nin which case it will be applied to all specified edges. Otherwise,\nif it is an array, the elements of alpha will be applied to the colors\nin order (cycling through alpha multiple times if necessary).\nedge_cmap : Matplotlib colormap, optional: Colormap for mapping intensities of edges\nedge_vmin,edge_vmax : floats, optional: Minimum and maximum for edge colormap scaling\nax : Matplotlib Axes object, optional: Draw the graph in the specified Matplotlib axes.\narrows : bool or None, optional (default=None): IfNone, directed graphs draw arrowheads withFancyArrowPatch, while undirected graphs draw edges\nviaLineCollectionfor speed.\nIfTrue, draw arrowheads with FancyArrowPatches (bendable and stylish).\nIfFalse, draw edges using LineCollection (linear and fast).Note: Arrowheads will be the same color as edges.\narrowstyle : str (default=’-|>’ for directed graphs): For directed graphs andarrows==Truedefaults to ‘-|>’,\nFor undirected graphs default to ‘-‘.Seematplotlib.patches.ArrowStylefor more options.\narrowsize : int (default=10): For directed graphs, choose the size of the arrow head’s length and\nwidth. Seematplotlib.patches.FancyArrowPatchfor attributemutation_scalefor more info.\nconnectionstyle : string or iterable of strings (default=”arc3”): Pass the connectionstyle parameter to create curved arc of rounding\nradius rad. For example, connectionstyle=’arc3,rad=0.2’.\nSeematplotlib.patches.ConnectionStyleandmatplotlib.patches.FancyArrowPatchfor more info.\nIf Iterable, index indicates i’th edge key of MultiGraph\nnode_size : scalar or array (default=300): Size of nodes. Though the nodes are not drawn with this function, the\nnode size is used in determining edge positioning.\nnodelist : list, optional (default=G.nodes()): This provides the node order for thenode_sizearray (if it is an array).\nnode_shape : string (default=’o’): The marker used for nodes, used in determining edge positioning.\nSpecification is as amatplotlib.markersmarker, e.g. one of ‘so^>v<dph8’.\nlabel : None or string: Label for legend\nmin_source_margin : int (default=0): The minimum margin (gap) at the beginning of the edge at the source.\nmin_target_margin : int (default=0): The minimum margin (gap) at the end of the edge at the target.\nhide_ticks : bool, optional: Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False.\nReturns:: matplotlib.collections.LineCollection or a list of matplotlib.patches.FancyArrowPatch: Ifarrows=True, a list of FancyArrowPatches is returned.\nIfarrows=False, a LineCollection is returned.\nIfarrows=None(the default), then a LineCollection is returned ifGis undirected, otherwise returns a list of FancyArrowPatches.\nMethods: []\nRubrics: Notes: For directed graphs, arrows are drawn at the head end.  Arrows can be\nturned off with keyword arrows=False or by passing an arrowstyle without\nan arrow on the end. Be sure to include node_size as a keyword argument; arrows are\ndrawn considering the size of nodes. Self-loops are always drawn with FancyArrowPatch regardless of the value of arrows or whether G is directed.\nWhen arrows=False or arrows=None and G is undirected, the\nFancyArrowPatches corresponding to the self-loops are not explicitly\nreturned. They should instead be accessed via the Axes.patches attribute (see examples).\nExamples: G=nx.dodecahedral_graph()\nedges=nx.draw_networkx_edges(G,pos=nx.spring_layout(G))\nG=nx.DiGraph()\nG.add_edges_from([(1,2),(1,3),(2,3)])\narcs=nx.draw_networkx_edges(G,pos=nx.spring_layout(G))\nalphas=[0.3,0.4,0.5]\nfori,arcinenumerate(arcs):# change alpha values of arcs\narc.set_alpha(alphas[i])\nThe FancyArrowPatches corresponding to self-loops are not always\nreturned, but can always be accessed via thepatchesattribute of thematplotlib.Axesobject.\nimportmatplotlib.pyplotasplt\nfig,ax=plt.subplots()\nG=nx.Graph([(0,1),(0,0)])# Self-loop at node 0\nedge_collection=nx.draw_networkx_edges(G,pos=nx.circular_layout(G),ax=ax)\nself_loop_fap=ax.patches[0]\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html",
    "Section ID: all_pairs_shortest_path\nDescription: [Compute shortest paths between all nodes.]\nField List: Parameters:: G : NetworkX graph: \ncutoff : integer, optional: Depth at which to stop the search. Only paths of length at mostcutoffare returned.\nReturns:: paths : iterator: Dictionary, keyed by source and target, of shortest paths.\nMethods: []\nRubrics: Notes: There may be multiple shortest paths with the same length between\ntwo nodes. For each pair, this function returns only one of those paths.\nExamples: G=nx.path_graph(5)\npath=dict(nx.all_pairs_shortest_path(G))\nprint(path[0][4])\n# [0, 1, 2, 3, 4]",
    "Section ID: strongly_connected_components_recursive\nDescription: [Generate nodes in strongly connected components of graph., Recursive version of algorithm.]\nField List: Parameters:: G : NetworkX Graph: A directed graph.\nReturns:: comp : generator of sets: A generator of sets of nodes, one for each strongly connected\ncomponent of G.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: Uses Tarjan’s algorithm[Re7cb971df765-1]_ with Nuutila’s modifications[Re7cb971df765-2]_.\nReferences: [1]Depth-first search and linear graph algorithms, R. Tarjan\nSIAM Journal of Computing 1(2):146-160, (1972).  [2]On finding the strongly connected components in a directed graph.\nE. Nuutila and E. Soisalon-Soinen\nInformation Processing Letters 49(1): 9-14, (1994)..\nExamples: Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[\nlen(c)\nforcinsorted(\nnx.strongly_connected_components_recursive(G),key=len,reverse=True\n)\n]\n# [4, 3]\nIf you only want the largest component, it’s more efficient to\nuse max instead of sort.\nlargest=max(nx.strongly_connected_components_recursive(G),key=len)\nTo create the induced subgraph of the components use:\n>>> S = [G.subgraph(c).copy() for c in nx.weakly_connected_components(G)]",
    "Section ID: dag_longest_path_length\nDescription: [Returns the longest path length in a DAG]\nField List: Parameters:: G : NetworkX DiGraph: A directed acyclic graph (DAG)\nweight : string, optional: Edge data key to use for weight\ndefault_weight : int, optional: The weight of edges that do not have a weight attribute\nReturns:: int: Longest path length\nRaises:: NetworkXNotImplemented: IfGis not directed\nMethods: []\nRubrics: Examples: DG=nx.DiGraph([(0,1,{\"cost\":1}),(1,2,{\"cost\":1}),(0,2,{\"cost\":42})])\nlist(nx.all_simple_paths(DG,0,2))\n# [[0, 1, 2], [0, 2]]\nnx.dag_longest_path_length(DG)\n# 2\nnx.dag_longest_path_length(DG,weight=\"cost\")\n# 42",
    "Section ID: is_partition\nDescription: [Returns True if communities is a partition of the nodes of G ., A partition of a universe set is a family of pairwise disjoint sets\nwhose union is the entire universe set.]\nField List: Parameters:: G : NetworkX graph.: \ncommunities : list or iterable of sets of nodes: If not a list, the iterable is converted internally to a list.\nIf it is an iterator it is exhausted.\nMethods: []\nRubrics:",
    "Section ID: complete_to_chordal_graph\nDescription: [Return a copy of G completed to a chordal graph, Adds edges to a copy of G to create a chordal graph. A graph G=(V,E) is\ncalled chordal if for each cycle with length bigger than 3, there exist\ntwo non-adjacent nodes connected by an edge (called a chord).]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nReturns:: H : NetworkX graph: The chordal enhancement of G\nalpha : Dictionary: The elimination ordering of nodes of G\nMethods: []\nRubrics: Notes: There are different approaches to calculate the chordal\nenhancement of a graph. The algorithm used here is called\nMCS-M and gives at least minimal (local) triangulation of graph. Note\nthat this triangulation is not necessarily a global minimum. https://en.wikipedia.org/wiki/Chordal_graph\nReferences: [1]Berry, Anne & Blair, Jean & Heggernes, Pinar & Peyton, Barry. (2004)\nMaximum Cardinality Search for Computing Minimal Triangulations of\nGraphs.  Algorithmica. 39. 287-298. 10.1007/s00453-004-1084-3.\nExamples: fromnetworkx.algorithms.chordalimportcomplete_to_chordal_graph\nG=nx.wheel_graph(10)\nH,alpha=complete_to_chordal_graph(G)",
    "Section ID: double_edge_swap\nDescription: [Swap two edges in the graph while keeping the node degrees fixed., A double-edge swap removes two randomly chosen edges u-v and x-y\nand creates the new edges u-x and v-y:, If either the edge u-x or v-y already exist no swap is performed\nand another attempt is made to find a suitable edge pair.]\nField List: Parameters:: G : graph: An undirected graph\nnswap : integer (optional, default=1): Number of double-edge swaps to perform\nmax_tries : integer (optional): Maximum number of attempts to swap edges\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : graph: The graph after double edge swaps.\nRaises:: NetworkXError: IfGis directed, or\nIfnswap>max_tries, or\nIf there are fewer than 4 nodes or 2 edges inG.\nNetworkXAlgorithmError: If the number of swap attempts exceedsmax_triesbeforenswapswaps are made\nMethods: []\nRubrics: Notes: Does not enforce any connectivity constraints. The graph G is modified in place.",
    "Section ID: gnc_graph\nDescription: [Returns the growing network with copying (GNC) digraph with n nodes., The GNC graph is built by adding nodes one at a time with a link to one\npreviously added node (chosen uniformly at random) and to all of that\nnode’s successors.]\nField List: Parameters:: n : int: The number of nodes for the generated graph.\ncreate_using : NetworkX graph constructor, optional (default DiGraph): Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: References: [1]P. L. Krapivsky and S. Redner,\nNetwork Growth by Copying,\nPhys. Rev. E, 71, 036118, 2005k.},",
    "Section ID: min_weighted_vertex_cover\nDescription: [Returns an approximate minimum weighted vertex cover., The set of nodes returned by this function is guaranteed to be a\nvertex cover, and the total weight of the set is guaranteed to be at\nmost twice the total weight of the minimum weight vertex cover. In\nother words,, where \\(S\\) is the vertex cover returned by this function, \\(S^*\\) is the vertex cover of minimum weight out of all vertex\ncovers of the graph, and \\(w\\) is the function that computes the\nsum of the weights of each node in that given set.]\nField List: Parameters:: G : NetworkX graph: \nweight : string, optional (default = None): If None, every node has weight 1. If a string, use this node\nattribute as the node weight. A node without this attribute is\nassumed to have weight 1.\nReturns:: min_weighted_cover : set: Returns a set of nodes whose weight sum is no more than twice\nthe weight sum of the minimum weight vertex cover.\nMethods: []\nRubrics: Notes: For a directed graph, a vertex cover has the same definition: a set\nof nodes such that each edge in the graph is incident to at least\none node in the set. Whether the node is the head or tail of the\ndirected edge is ignored. This is the local-ratio algorithm for computing an approximate\nvertex cover. The algorithm greedily reduces the costs over edges,\niteratively building a cover. The worst-case runtime of this\nimplementation is \\(O(m \\log n)\\) , where \\(n\\) is the number\nof nodes and \\(m\\) the number of edges in the graph.\nReferences: [1]Bar-Yehuda, R., and Even, S. (1985). “A local-ratio theorem for\napproximating the weighted vertex cover problem.”Annals of Discrete Mathematics, 25, 27–46\n<http://www.cs.technion.ac.il/~reuven/PDF/vc_lr.pdf>",
    "Section ID: edge_disjoint_paths\nDescription: [Returns the edges disjoint paths between source and target., Edge disjoint paths are paths that do not share any edge. The\nnumber of edge disjoint paths between source and target is equal\nto their edge connectivity.]\nField List: Parameters:: G : NetworkX graph: \ns : node: Source node for the flow.\nt : node: Sink node for the flow.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. The choice of the default function\nmay change from version to version and should not be relied on.\nDefault value: None.\ncutoff : integer or None (default: None): Maximum number of paths to yield. If specified, the maximum flow\nalgorithm will terminate when the flow value reaches or exceeds the\ncutoff. This only works for flows that support the cutoff parameter\n(most do) and is ignored otherwise.\nauxiliary : NetworkX DiGraph: Auxiliary digraph to compute flow based edge connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.\nresidual : NetworkX DiGraph: Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.\nReturns:: paths : generator: A generator of edge independent paths.\nRaises:: NetworkXNoPath: If there is no path between source and target.\nNetworkXError: If source or target are not in the graph G.\nMethods: []\nRubrics: Notes: This is a flow based implementation of edge disjoint paths. We compute\nthe maximum flow between source and target on an auxiliary directed\nnetwork. The saturated edges in the residual network after running the\nmaximum flow algorithm correspond to edge disjoint paths between source\nand target in the original network. This function handles both directed\nand undirected graphs, and can use all flow algorithms from NetworkX flow\npackage.\nExamples: We use in this example the platonic icosahedral graph, which has node\nedge connectivity 5, thus there are 5 edge disjoint paths between any\npair of nodes.\nG=nx.icosahedral_graph()\nlen(list(nx.edge_disjoint_paths(G,0,6)))\n# 5\nIf you need to compute edge disjoint paths on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute edge disjoint paths among all pairs of\nnodes of the platonic icosahedral graph reusing the data\nstructures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult={n:{}forninG}\n# Reuse the auxiliary digraph and the residual network by passing them\n# as arguments\nforu,vinitertools.combinations(G,2):\nk=len(list(nx.edge_disjoint_paths(G,u,v,auxiliary=H,residual=R)))\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge disjoint\npaths. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(list(nx.edge_disjoint_paths(G,0,6,flow_func=shortest_augmenting_path)))\n# 5",
    "Section ID: write_weighted_edgelist\nDescription: [Write graph G as a list of edges with numeric weights.]\nField List: Parameters:: G : graph: A NetworkX graph\npath : file or string: File or filename to write. If a file is provided, it must be\nopened in ‘wb’ mode.\nFilenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional: The character used to indicate the start of a comment\ndelimiter : string, optional: The string used to separate values.  The default is whitespace.\nencoding: string, optional: Specify which encoding to use when writing file.\nMethods: []\nRubrics: Examples: G=nx.Graph()\nG.add_edge(1,2,weight=7)\nnx.write_weighted_edgelist(G,\"test.weighted.edgelist\")",
    "Section ID: shell_layout\nDescription: [Position nodes in concentric circles.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\nnlist : list of lists: List of node lists for each shell.\nrotate : angle in radians (default=pi/len(nlist)): Angle by which to rotate the starting position of each shell\nrelative to the starting position of the previous shell.\nTo recreate behavior before v2.5 use rotate=0.\nscale : number (default: 1): Scale factor for positions.\ncenter : array-like or None: Coordinate pair around which to center the layout.\ndim : int: Dimension of layout, currently only dim=2 is supported.\nOther dimension values result in a ValueError.\nReturns:: pos : dict: A dictionary of positions keyed by node\nRaises:: ValueError: If dim != 2\nMethods: []\nRubrics: Notes: This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.\nExamples: G=nx.path_graph(4)\nshells=[[0],[1,2,3]]\npos=nx.shell_layout(G,shells)",
    "Section ID: dinitz\nDescription: [Find a maximum single-commodity flow using Dinitz’ algorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has a running time of \\(O(n^2 m)\\) for \\(n\\) nodes and \\(m\\) edges [1] .]\nField List: Parameters:: G : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\ns : node: Source node for the flow.\nt : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nresidual : NetworkX graph: Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.\nvalue_only : bool: If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.\ncutoff : integer, float: If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None.\nReturns:: R : NetworkX DiGraph: Residual network after computing the maximum flow.\nRaises:: NetworkXError: The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.\nNetworkXUnbounded: If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded.\nMethods: []\nRubrics: Notes: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.\nReferences: [1]Dinitz’ Algorithm: The Original Version and Even’s Version.\n2006. Yefim Dinitz. In Theoretical Computer Science. Lecture\nNotes in Computer Science. Volume 3895. pp 218-240.https://doi.org/10.1007/11685654_10\nExamples: fromnetworkx.algorithms.flowimportdinitz\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=dinitz(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True",
    "Section ID: is_minimal_d_separator\nDescription: [Determine if z is a minimal d-separator for x and y ., A d-separator, z , in a DAG is a set of nodes that blocks\nall paths from nodes in set x to nodes in set y .\nA minimal d-separator is a d-separator z such that removing\nany subset of nodes makes it no longer a d-separator., Note: This function checks whether z is a d-separator AND is\nminimal. One can use the function is_d_separator to only check if z is a d-separator. See examples below.]\nField List: Parameters:: G : nx.DiGraph: A NetworkX DAG.\nx : node | set: A node or set of nodes in the graph.\ny : node | set: A node or set of nodes in the graph.\nz : node | set: The node or set of nodes to check if it is a minimal d-separating set.\nThe functionis_d_separator()is called inside this function\nto verify thatzis in fact a d-separator.\nincluded : set | node | None: A node or set of nodes which must be included in the found separating set,\ndefault isNone, which means the empty set.\nrestricted : set | node | None: Restricted node or set of nodes to consider. Only these nodes can be in\nthe found separating set, default isNonemeaning all nodes inG.\nReturns:: bool: Whether or not the setzis a minimal d-separator subject torestrictednodes andincludednode constraints.\nRaises:: NetworkXError: Raises aNetworkXErrorif the input graph is not a DAG.\nNodeNotFound: If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised.\nMethods: []\nRubrics: Notes: This function works on verifying that a set is minimal and\nd-separating between two nodes. Uses criterion (a), (b), (c) on\npage 4 of [1] . a) closure( x ) and y are disjoint. b) z contains\nall nodes from included and is contained in the restricted nodes and in the union of ancestors of x , y , and included .\nc) the nodes in z not in included are contained in both\nclosure(x) and closure(y). The closure of a set is the set of nodes\nconnected to the set by a directed path in G. The complexity is \\(O(m)\\) , where \\(m\\) stands for the\nnumber of edges in the subgraph of G consisting of only the\nancestors of x and y . For full details, see [1] .\nReferences: [1](1,2)van der Zander, Benito, and Maciej Liśkiewicz. “Finding\nminimal d-separators in linear time and applications.” In\nUncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.\nExamples: G=nx.path_graph([0,1,2,3],create_using=nx.DiGraph)\nG.add_node(4)\nnx.is_minimal_d_separator(G,0,2,{1})\n# True\n# since {1} is the minimal d-separator, {1, 3, 4} is not minimal\nnx.is_minimal_d_separator(G,0,2,{1,3,4})\n# False\n# alternatively, if we only want to check that {1, 3, 4} is a d-separator\nnx.is_d_separator(G,0,2,{1,3,4})\n# True",
    "Section ID: quotient_graph\nDescription: [Returns the quotient graph of G under the specified equivalence\nrelation on nodes.]\nField List: Parameters:: G : NetworkX graph: The graph for which to return the quotient graph with the\nspecified node relation.\npartition : function, or dict or list of lists, tuples or sets: If a function, this function must represent an equivalence\nrelation on the nodes ofG. It must take two argumentsuandvand return True exactly whenuandvare in the\nsame equivalence class. The equivalence classes form the nodes\nin the returned graph.If a dict of lists/tuples/sets, the keys can be any meaningful\nblock labels, but the values must be the block lists/tuples/sets\n(one list/tuple/set per block), and the blocks must form a valid\npartition of the nodes of the graph. That is, each node must be\nin exactly one block of the partition.If a list of sets, the list must form a valid partition of\nthe nodes of the graph. That is, each node must be in exactly\none block of the partition.\nedge_relation : Boolean function with two arguments: This function must represent an edge relation on theblocksof\nthepartitionofG. It must take two arguments,BandC,\neach one a set of nodes, and return True exactly when there should be\nan edge joining blockBto blockCin the returned graph.Ifedge_relationis not specified, it is assumed to be the\nfollowing relation. BlockBis related to blockCif and\nonly if some node inBis adjacent to some node inC,\naccording to the edge set ofG.\nnode_data : function: This function takes one argument,B, a set of nodes inG,\nand must return a dictionary representing the node data\nattributes to set on the node representingBin the quotient graph.\nIf None, the following node attributes will be set:‘graph’, the subgraph of the graphGthat this block\nrepresents,‘nnodes’, the number of nodes in this block,‘nedges’, the number of edges within this block,‘density’, the density of the subgraph ofGthat this\nblock represents.\nedge_data : function: This function takes two arguments,BandC, each one a set\nof nodes, and must return a dictionary representing the edge\ndata attributes to set on the edge joiningBandC, should\nthere be an edge joiningBandCin the quotient graph (if\nno such edge occurs in the quotient graph as determined byedge_relation, then the output of this function is ignored).If the quotient graph would be a multigraph, this function is\nnot applied, since the edge data from each edge in the graphGappears in the edges of the quotient graph.\nweight : string or None, optional (default=”weight”): The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.\nrelabel : bool: If True, relabel the nodes of the quotient graph to be\nnonnegative integers. Otherwise, the nodes are identified withfrozensetinstances representing the blocks given inpartition.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: NetworkX graph: The quotient graph ofGunder the equivalence relation\nspecified bypartition. If the partition were given as a\nlist ofsetinstances andrelabelis False,\neach node will be afrozensetcorresponding to the sameset.\nRaises:: NetworkXException: If the given partition is not a valid partition of the nodes ofG.\nMethods: []\nRubrics: References: [1]Patrick Doreian, Vladimir Batagelj, and Anuska Ferligoj.Generalized Blockmodeling.\nCambridge University Press, 2004.\nExamples: The quotient graph of the complete bipartite graph under the “same\nneighbors” equivalence relation isK_2. Under this relation, two nodes\nare equivalent if they are not adjacent but have the same neighbor set.\nG=nx.complete_bipartite_graph(2,3)\nsame_neighbors=lambdau,v:(unotinG[v]andvnotinG[u]andG[u]==G[v])\nQ=nx.quotient_graph(G,same_neighbors)\nK2=nx.complete_graph(2)\nnx.is_isomorphic(Q,K2)\n# True\nThe quotient graph of a directed graph under the “same strongly connected\ncomponent” equivalence relation is the condensation of the graph (seecondensation()). This example comes from the Wikipedia article`Strongly connected component`_.\nG=nx.DiGraph()\nedges=[\n\"ab\",\n\"be\",\n\"bf\",\n\"bc\",\n\"cg\",\n\"cd\",\n\"dc\",\n\"dh\",\n\"ea\",\n\"ef\",\n\"fg\",\n\"gf\",\n\"hd\",\n\"hf\",\n]\nG.add_edges_from(tuple(x)forxinedges)\ncomponents=list(nx.strongly_connected_components(G))\nsorted(sorted(component)forcomponentincomponents)\n# [['a', 'b', 'e'], ['c', 'd', 'h'], ['f', 'g']]\n\nC=nx.condensation(G,components)\ncomponent_of=C.graph[\"mapping\"]\nsame_component=lambdau,v:component_of[u]==component_of[v]\nQ=nx.quotient_graph(G,same_component)\nnx.is_isomorphic(C,Q)\n# True\nNode identification can be represented as the quotient of a graph under the\nequivalence relation that places the two nodes in one block and each other\nnode in its own singleton block.\nK24=nx.complete_bipartite_graph(2,4)\nK34=nx.complete_bipartite_graph(3,4)\nC=nx.contracted_nodes(K34,1,2)\nnodes={1,2}\nis_contracted=lambdau,v:uinnodesandvinnodes\nQ=nx.quotient_graph(K34,is_contracted)\nnx.is_isomorphic(Q,C)\n# True\nnx.is_isomorphic(Q,K24)\n# True\nThe blockmodeling technique described in[1]can be implemented as a\nquotient graph.\nG=nx.path_graph(6)\npartition=[{0,1},{2,3},{4,5}]\nM=nx.quotient_graph(G,partition,relabel=True)\nlist(M.edges())\n# [(0, 1), (1, 2)]\nHere is the sample example but using partition as a dict of block sets.\nG=nx.path_graph(6)\npartition={0:{0,1},2:{2,3},4:{4,5}}\nM=nx.quotient_graph(G,partition,relabel=True)\nlist(M.edges())\n# [(0, 1), (1, 2)]\nPartitions can be represented in various ways:",
    "Section ID: edge_betweenness_centrality\nDescription: [Compute betweenness centrality for edges., Betweenness centrality of an edge \\(e\\) is the sum of the\nfraction of all-pairs shortest paths that pass through \\(e\\), where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|e)\\) is the number of\nthose paths passing through edge \\(e\\)  [2] .]\nField List: Parameters:: G : graph: A NetworkX graph.\nk : int, optional (default=None): If k is not None use k node samples to estimate betweenness.\nThe value of k <= n where n is the number of nodes in the graph.\nHigher values give better approximation.\nnormalized : bool, optional: If True the betweenness values are normalized by\\(2/(n(n-1))\\)for graphs, and\\(1/(n(n-1))\\)for directed graphs where\\(n\\)is the number of nodes in G.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nNote that this is only used if k is not None.\nReturns:: edges : dictionary: Dictionary of edges with betweenness centrality as the value.\nMethods: []\nRubrics: Notes: The algorithm is from Ulrik Brandes [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\nReferences: [1]A Faster Algorithm for Betweenness Centrality. Ulrik Brandes,\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001",
    "Section ID: fast_label_propagation_communities\nDescription: [Returns communities in G as detected by fast label propagation., The fast label propagation algorithm is described in [1] . The algorithm is\nprobabilistic and the found communities may vary in different executions., The algorithm operates as follows. First, the community label of each node is\nset to a unique label. The algorithm then repeatedly updates the labels of\nthe nodes to the most frequent label in their neighborhood. In case of ties,\na random label is chosen from the most frequent labels., The algorithm maintains a queue of nodes that still need to be processed.\nInitially, all nodes are added to the queue in a random order. Then the nodes\nare removed from the queue one by one and processed. If a node updates its label,\nall its neighbors that have a different label are added to the queue (if not\nalready in the queue). The algorithm stops when the queue is empty.]\nField List: Parameters:: G : Graph, DiGraph, MultiGraph, or MultiDiGraph: Any NetworkX graph.\nweight : string, or None (default): The edge attribute representing a non-negative weight of an edge. If None,\neach edge is assumed to have weight one. The weight of an edge is used in\ndetermining the frequency with which a label appears among the neighbors of\na node (edge with weightwis equivalent towunweighted edges).\nseed : integer, random_state, or None (default): Indicator of random number generation state. SeeRandomness.\nReturns:: communities : iterable: Iterable of communities given as sets of nodes.\nMethods: []\nRubrics: Notes: Edge directions are ignored for directed graphs.\nEdge weights must be non-negative numbers.\nReferences: [1]Vincent A. Traag & Lovro Šubelj. “Large network community detection by\nfast label propagation.” Scientific Reports 13 (2023): 2701.https://doi.org/10.1038/s41598-023-29610-z",
    "Section ID: is_semiconnected\nDescription: [Returns True if the graph is semiconnected, False otherwise., A graph is semiconnected if and only if for any pair of nodes, either one\nis reachable from the other, or they are mutually reachable., This function uses a theorem that states that a DAG is semiconnected\nif for any topological sort, for node \\(v_n\\) in that sort, there is an\nedge \\((v_i, v_{i+1})\\) . That allows us to check if a non-DAG G is\nsemiconnected by condensing the graph: i.e. constructing a new graph H with nodes being the strongly connected components of G , and edges\n(scc_1, scc_2) if there is a edge \\((v_1, v_2)\\) in G for some \\(v_1 \\in scc_1\\) and \\(v_2 \\in scc_2\\) . That results in a DAG, so we compute\nthe topological sort of H and check if for every \\(n\\) there is an edge \\((scc_n, scc_{n+1})\\) .]\nField List: Parameters:: G : NetworkX graph: A directed graph.\nReturns:: semiconnected : bool: True if the graph is semiconnected, False otherwise.\nRaises:: NetworkXNotImplemented: If the input graph is undirected.\nNetworkXPointlessConcept: If the graph is empty.\nMethods: []\nRubrics: Examples: G=nx.path_graph(4,create_using=nx.DiGraph())\nprint(nx.is_semiconnected(G))\n# True\nG=nx.DiGraph([(1,2),(3,2)])\nprint(nx.is_semiconnected(G))\n# False",
    "Section ID: dominating_set\nDescription: [Finds a dominating set for the graph G., A dominating set for a graph with node set V is a subset D of V such that every node not in D is adjacent to at least one\nmember of D  [1] .]\nField List: Parameters:: G : NetworkX graph: \nstart_with : node (default=None): Node to use as a starting point for the algorithm.\nReturns:: D : set: A dominating set for G.\nMethods: []\nRubrics: Notes: This function is an implementation of algorithm 7 in [2] which\nfinds some dominating set, not necessarily the smallest one.\nReferences: [1]https://en.wikipedia.org/wiki/Dominating_set  [2]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
    "Section ID: caveman_graph\nDescription: [Returns a caveman graph of l cliques of size k .]\nField List: Parameters:: l : int: Number of cliques\nk : int: Size of cliques\nReturns:: G : NetworkX Graph: caveman graph\nMethods: []\nRubrics: Notes: This returns an undirected graph, it can be converted to a directed\ngraph using nx.to_directed() , or a multigraph using nx.MultiGraph(nx.caveman_graph(l,k)) . Only the undirected version is\ndescribed in [1] and it is unclear which of the directed\ngeneralizations is most useful.\nReferences: [1]Watts, D. J. ‘Networks, Dynamics, and the Small-World Phenomenon.’\nAmer. J. Soc. 105, 493-527, 1999.\nExamples: G=nx.caveman_graph(3,3)",
    "Section ID: random_unlabeled_rooted_tree\nDescription: [Returns a number of unlabeled rooted trees uniformly at random, Returns one or more (depending on number_of_trees )\nunlabeled rooted trees with n nodes drawn uniformly\nat random.]\nField List: Parameters:: n : int: The number of nodes\nnumber_of_trees : int or None (default): If not None, this number of trees is generated and returned.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: networkx.Graph : or list of : networkx.Graph: A singlenetworkx.Graph(or a list thereof, ifnumber_of_treesis specified) with nodes in the set {0, …,n- 1}.\nThe “root” graph attribute identifies the root of the tree.\nRaises:: NetworkXPointlessConcept: Ifnis zero (because the null graph is not a tree).\nMethods: []\nRubrics: Notes: The trees are generated using the “RANRUT” algorithm from [1] .\nThe algorithm needs to compute some counting functions\nthat are relatively expensive: in case several trees are needed,\nit is advisable to use the number_of_trees optional argument\nto reuse the counting functions.\nReferences: [1]Nijenhuis, Albert, and Wilf, Herbert S.\n“Combinatorial algorithms: for computers and calculators.”\nAcademic Press, 1978.https://doi.org/10.1016/C2013-0-11243-3",
    "Section ID: gnr_graph\nDescription: [Returns the growing network with redirection (GNR) digraph with n nodes and redirection probability p ., The GNR graph is built by adding nodes one at a time with a link to one\npreviously added node.  The previous target node is chosen uniformly at\nrandom.  With probability p the link is instead “redirected” to the\nsuccessor node of the target., The graph is always a (directed) tree.]\nField List: Parameters:: n : int: The number of nodes for the generated graph.\np : float: The redirection probability.\ncreate_using : NetworkX graph constructor, optional (default DiGraph): Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: References: [1]P. L. Krapivsky and S. Redner,\nOrganization of Growing Random Networks,\nPhys. Rev. E, 63, 066123, 2001.\nExamples: To create the undirected GNR graph, use theto_directed()method:\nD=nx.gnr_graph(10,0.5)# the GNR graph\nG=D.to_undirected()# the undirected version",
    "Section ID: random_graph\nDescription: [Returns a bipartite random graph., This is a bipartite version of the binomial (Erdős-Rényi) graph.\nThe graph is composed of two partitions. Set A has nodes 0 to\n(n - 1) and set B has nodes n to (n + m - 1).]\nField List: Parameters:: n : int: The number of nodes in the first bipartite set.\nm : int: The number of nodes in the second bipartite set.\np : float: Probability for edge creation.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : bool, optional (default=False): If True return a directed graph\nMethods: []\nRubrics: Notes: The bipartite random graph algorithm chooses each of the n*m (undirected)\nor 2*nm (directed) possible edges with probability p. This algorithm is \\(O(n+m)\\) where \\(m\\) is the expected number of edges. The nodes are assigned the attribute ‘bipartite’ with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.random_graph\nReferences: [1]Vladimir Batagelj and Ulrik Brandes,\n“Efficient generation of large random networks”,\nPhys. Rev. E, 71, 036113, 2005.",
    "Section ID: multipartite_layout\nDescription: [Position nodes in layers of straight lines.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\nsubset_key : string or dict (default=’subset’): If a string, the key of node data in G that holds the node subset.\nIf a dict, keyed by layer number to the nodes in that layer/subset.\nalign : string (default=’vertical’): The alignment of nodes. Vertical or horizontal.\nscale : number (default: 1): Scale factor for positions.\ncenter : array-like or None: Coordinate pair around which to center the layout.\nReturns:: pos : dict: A dictionary of positions keyed by node.\nMethods: []\nRubrics: Notes: This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings. Network does not need to be a complete multipartite graph. As long as nodes\nhave subset_key data, they will be placed in the corresponding layers.\nExamples: G=nx.complete_multipartite_graph(28,16,10)\npos=nx.multipartite_layout(G)\nor use a dict to provide the layers of the layout\nG=nx.Graph([(0,1),(1,2),(1,3),(3,4)])\nlayers={\"a\":[0],\"b\":[1],\"c\":[2,3],\"d\":[4]}\npos=nx.multipartite_layout(G,subset_key=layers)",
    "Section ID: rescale_layout_dict\nDescription: [Return a dictionary of scaled positions keyed by node]\nField List: Parameters:: pos : A dictionary of positions keyed by node: \nscale : number (default: 1): The size of the resulting extent in all directions.\nReturns:: pos : A dictionary of positions keyed by node:\nMethods: []\nRubrics: Examples: importnumpyasnp\npos={0:np.array((0,0)),1:np.array((1,1)),2:np.array((0.5,0.5))}\nnx.rescale_layout_dict(pos)\n# {0: array([-1., -1.]), 1: array([1., 1.]), 2: array([0., 0.])}\npos={0:np.array((0,0)),1:np.array((-1,1)),2:np.array((-0.5,0.5))}\nnx.rescale_layout_dict(pos,scale=2)\n# {0: array([ 2., -2.]), 1: array([-2.,  2.]), 2: array([0., 0.])}",
    "Section ID: is_empty\nDescription: [Returns True if G has no edges.]\nField List: Parameters:: G : graph: A NetworkX graph.\nReturns:: bool: True ifGhas no edges, and False otherwise.\nMethods: []\nRubrics: Notes: An empty graph can have nodes but not edges. The empty graph with zero\nnodes is known as the null graph. This is an \\(O(n)\\) operation where n\nis the number of nodes in the graph.",
    "Section ID: communicability\nDescription: [Returns communicability between all pairs of nodes in G., The communicability between pairs of nodes in G is the sum of\nwalks of different lengths starting at node u and ending at node v.]\nField List: Parameters:: G: graph:\nReturns:: comm: dictionary of dictionaries: Dictionary of dictionaries keyed by nodes with communicability\nas the value.\nRaises:: NetworkXError: If the graph is not undirected and simple.\nMethods: []\nRubrics: Notes: This algorithm uses a spectral decomposition of the adjacency matrix.\nLet G=(V,E) be a simple undirected graph.  Using the connection between\nthe powers  of the adjacency matrix and the number of walks in the graph,\nthe communicability  between nodes u and v based on the graph spectrum\nis [1]\nReferences: [1]Ernesto Estrada, Naomichi Hatano,\n“Communicability in complex networks”,\nPhys. Rev. E 77, 036111 (2008).https://arxiv.org/abs/0707.0756\nExamples: G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nc=nx.communicability(G)",
    "Section ID: generate_network_text\nDescription: [Generate lines in the “network text” format, This works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented., This notation is original to networkx, although it is simple enough that it\nmay be known in existing literature. See #5602 for details. The procedure\nis summarized as follows:, 1. Given a set of source nodes (which can be specified, or automatically\ndiscovered via finding the (strongly) connected components and choosing one\nnode with minimum degree from each), we traverse the graph in depth first\norder., 4. The children of each node (wrt the directed DFS tree) are drawn\nunderneath and to the right of it. In the case that a child node has already\nbeen drawn the connection is replaced with an ellipsis (”…”) to indicate\nthat there is one or more connections represented elsewhere., 5. If a maximum depth is specified, an edge to nodes past this maximum\ndepth will be represented by an ellipsis., 6. If a a node has a truthy “collapse” value, then we do not traverse past\nthat node.]\nField List: Parameters:: graph : nx.DiGraph | nx.Graph: Graph to represent\nwith_labels : bool | str: If True will use the “label” attribute of a node to display if it\nexists otherwise it will use the node value itself. If given as a\nstring, then that attribute name will be used instead of “label”.\nDefaults to True.\nsources : List: Specifies which nodes to start traversal from. Note: nodes that are not\nreachable from one of these sources may not be shown. If unspecified,\nthe minimal set of nodes needed to reach all others will be used.\nmax_depth : int | None: The maximum depth to traverse before stopping. Defaults to None.\nascii_only : Boolean: If True only ASCII characters are used to construct the visualization\nvertical_chains : Boolean: If True, chains of nodes will be drawn vertically when possible.\nYields:: str : a line of generated text:\nMethods: []\nRubrics: Examples: graph=nx.path_graph(10)\ngraph.add_node(\"A\")\ngraph.add_node(\"B\")\ngraph.add_node(\"C\")\ngraph.add_node(\"D\")\ngraph.add_edge(9,\"A\")\ngraph.add_edge(9,\"B\")\ngraph.add_edge(9,\"C\")\ngraph.add_edge(\"C\",\"D\")\ngraph.add_edge(\"C\",\"E\")\ngraph.add_edge(\"C\",\"F\")\nnx.write_network_text(graph)\n# ╙── 0\n#     └── 1\n#         └── 2\n#             └── 3\n#                 └── 4\n#                     └── 5\n#                         └── 6\n#                             └── 7\n#                                 └── 8\n#                                     └── 9\n#                                         ├── A\n#                                         ├── B\n#                                         └── C\n#                                             ├── D\n#                                             ├── E\n#                                             └── F\nnx.write_network_text(graph,vertical_chains=True)\n# ╙── 0\n#     │\n#     1\n#     │\n#     2\n#     │\n#     3\n#     │\n#     4\n#     │\n#     5\n#     │\n#     6\n#     │\n#     7\n#     │\n#     8\n#     │\n#     9\n#     ├── A\n#     ├── B\n#     └── C\n#         ├── D\n#         ├── E\n#         └── F",
    "Section ID: dfs_successors\nDescription: [Returns dictionary of successors in depth-first-search from source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Specify starting node for depth-first search.\nNote that you will get successors for all nodes in the\ncomponent containingsource. This input only specifies\nwhere the DFS starts.\ndepth_limit : int, optional (default=len(G)): Specify the maximum search depth.\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: succ: dict: A dictionary with nodes as keys and list of successor nodes as values.\nMethods: []\nRubrics: Notes: If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein’s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n“ Depth-limited search ”.\nExamples: G=nx.path_graph(5)\nnx.dfs_successors(G,source=0)\n# {0: [1], 1: [2], 2: [3], 3: [4]}\nnx.dfs_successors(G,source=0,depth_limit=2)\n# {0: [1], 1: [2]}",
    "Section ID: random_kernel_graph\nDescription: [Returns an random graph based on the specified kernel., The algorithm chooses each of the \\([n(n-1)]/2\\) possible edges with\nprobability specified by a kernel \\(\\kappa(x,y)\\)  [1] .  The kernel \\(\\kappa(x,y)\\) must be a symmetric (in \\(x,y\\) ), non-negative,\nbounded function.]\nField List: Parameters:: n : int: The number of nodes\nkernel_integral : function: Function that returns the definite integral of the kernel\\(\\kappa(x,y)\\),\\(F(y,a,b) := \\int_a^b \\kappa(x,y)dx\\)\nkernel_root: function (optional): Function that returns the root\\(b\\)of the equation\\(F(y,a,b) = r\\).\nIf None, the root is found usingscipy.optimize.brentq()(this requires SciPy).\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: Notes: The kernel is specified through its definite integral which must be\nprovided as one of the arguments. If the integral and root of the\nkernel integral can be found in \\(O(1)\\) time then this algorithm runs in\ntime \\(O(n+m)\\) where m is the expected number of edges [2] . The nodes are set to integers from \\(0\\) to \\(n-1\\) .\nReferences: [1]Bollobás, Béla,  Janson, S. and Riordan, O.\n“The phase transition in inhomogeneous random graphs”,Random Structures Algorithms, 31, 3–122, 2007.  [2]Hagberg A, Lemons N (2015),\n“Fast Generation of Sparse Random Kernel Graphs”.\nPLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177\nExamples: Generate an Erdős–Rényi random graph\\(G(n,c/n)\\), with kernel\\(\\kappa(x,y)=c\\)where\\(c\\)is the mean expected degree.\ndefintegral(u,w,z):\nreturnc*(z-w)\ndefroot(u,w,r):\nreturnr/c+w\nc=1\ngraph=nx.random_kernel_graph(1000,integral,root)",
    "Section ID: traveling_salesman_problem\nDescription: [Find the shortest path in G connecting specified nodes, This function allows approximate solution to the traveling salesman\nproblem on networks that are not complete graphs and/or where the\nsalesman does not need to visit all nodes., This function proceeds in two steps. First, it creates a complete\ngraph using the all-pairs shortest_paths between nodes in nodes .\nEdge weights in the new graph are the lengths of the paths\nbetween each pair of nodes in the original graph.\nSecond, an algorithm (default: christofides for undirected and asadpour_atsp for directed) is used to approximate the minimal Hamiltonian\ncycle on this new graph. The available algorithms are:, Once the Hamiltonian Cycle is found, this function post-processes to\naccommodate the structure of the original graph. If cycle is False ,\nthe biggest weight edge is removed to make a Hamiltonian path.\nThen each edge on the new complete graph used for that analysis is\nreplaced by the shortest_path between those nodes on the original graph.\nIf the input graph G includes edges with weights that do not adhere to\nthe triangle inequality, such as when G is not a complete graph (i.e\nlength of non-existent edges is infinity), then the returned path may\ncontain some repeating nodes (other than the starting node).]\nField List: Parameters:: G : NetworkX graph: A possibly weighted graph\nnodes : collection of nodes (default=G.nodes): collection (list, set, etc.) of nodes to visit\nweight : string, optional (default=”weight”): Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.\ncycle : bool (default: True): Indicates whether a cycle should be returned, or a path.\nNote: the cycle is the approximate minimal cycle.\nThe path simply removes the biggest edge in that cycle.\nmethod : function (default: None): A function that returns a cycle on all nodes and approximates\nthe solution to the traveling salesman problem on a complete\ngraph. The returned cycle is then used to find a corresponding\nsolution onG.methodshould be callable; take inputsG, andweight; and return a list of nodes along the cycle.Provided options includechristofides(),greedy_tsp(),simulated_annealing_tsp()andthreshold_accepting_tsp().IfmethodisNone: usechristofides()for undirectedGandasadpour_atsp()for directedG.\n**kwargs : dict: Other keyword arguments to be passed to themethodfunction passed in.\nReturns:: list: List of nodes inGalong a path with an approximation of the minimal\npath throughnodes.\nRaises:: NetworkXError: IfGis a directed graph it has to be strongly connected or the\ncomplete version cannot be generated.\nMethods: []\nRubrics: Examples: tsp=nx.approximation.traveling_salesman_problem\nG=nx.cycle_graph(9)\nG[4][5][\"weight\"]=5# all other weights are 1\ntsp(G,nodes=[3,6])\n# [3, 2, 1, 0, 8, 7, 6, 7, 8, 0, 1, 2, 3]\npath=tsp(G,cycle=False)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True\nWhile no longer required, you can still build (curry) your own function\nto provide parameter values to the methods.\nSA_tsp=nx.approximation.simulated_annealing_tsp\nmethod=lambdaG,weight:SA_tsp(G,\"greedy\",weight=weight,temp=500)\npath=tsp(G,cycle=False,method=method)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True\nOtherwise, pass other keyword arguments directly into the tsp function.\npath=tsp(\nG,\ncycle=False,\nmethod=nx.approximation.simulated_annealing_tsp,\ninit_cycle=\"greedy\",\ntemp=500,\n)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True",
    "Section ID: k_shell\nDescription: [Returns the k-shell of G., The k-shell is the subgraph induced by nodes with core number k.\nThat is, nodes in the k-core that are not in the (k+1)-core.]\nField List: Parameters:: G : NetworkX graph: A graph or directed graph.\nk : int, optional: The order of the shell. If not specified return the outer shell.\ncore_number : dictionary, optional: Precomputed core numbers for the graph G.\nReturns:: G : NetworkX graph: The k-shell subgraph\nRaises:: NetworkXNotImplemented: The k-shell is not implemented for multigraphs or graphs with self loops.\nMethods: []\nRubrics: Notes: This is similar to k_corona but in that case only neighbors in the\nk-core are considered. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.\nReferences: [1]A model of Internet topology using k-shell decomposition\nShai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\nand Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154http://www.pnas.org/content/104/27/11150.full\nExamples: degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_shell(H,k=1).nodes\n# NodeView((0, 4))",
    "Section ID: number_strongly_connected_components\nDescription: [Returns number of strongly connected components in graph.]\nField List: Parameters:: G : NetworkX graph: A directed graph.\nReturns:: n : integer: Number of strongly connected components\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: For directed graphs only.\nExamples: G=nx.DiGraph(\n[(0,1),(1,2),(2,0),(2,3),(4,5),(3,4),(5,6),(6,3),(6,7)]\n)\nnx.number_strongly_connected_components(G)\n# 3",
    "Section ID: directed_laplacian_matrix\nDescription: [Returns the directed Laplacian matrix of G., The graph directed Laplacian is the matrix, where I is the identity matrix, P is the transition matrix of the\ngraph, and Phi a matrix with the Perron vector of P in the diagonal and\nzeros elsewhere [1] ., Depending on the value of walk_type, P can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank).]\nField List: Parameters:: G : DiGraph: A NetworkX graph\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nweight : string or None, optional (default=’weight’): The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.\nwalk_type : string or None, optional (default=None): One of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.\nalpha : real: (1 - alpha) is the teleportation probability used with pagerank\nReturns:: L : NumPy matrix: Normalized Laplacian of G.\nMethods: []\nRubrics: Notes: Only implemented for DiGraphs The result is always a symmetric matrix. This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.\nReferences: [1]Fan Chung (2005).\nLaplacians and the Cheeger inequality for directed graphs.\nAnnals of Combinatorics, 9(1), 2005",
    "Section ID: shortest_simple_paths\nDescription: []\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path\ntarget : node: Ending node for path\nweight : string or function: If it is a string, it is the name of the edge attribute to be\nused as a weight.If it is a function, the weight of an edge is the value returned\nby the function. The function must accept exactly three positional\narguments: the two endpoints of an edge and the dictionary of edge\nattributes for that edge. The function must return a number.If None all edges are considered to have unit weight. Default\nvalue None.\nReturns:: path_generator: generator: A generator that produces lists of simple paths, in order from\nshortest to longest.\nRaises:: NetworkXNoPath: If no path exists between source and target.\nNetworkXError: If source or target nodes are not in the input graph.\nNetworkXNotImplemented: If the input graph is a Multi[Di]Graph.\nMethods: []\nRubrics: Notes: This procedure is based on algorithm by Jin Y. Yen [1] .  Finding\nthe first \\(K\\) paths requires \\(O(KN^3)\\) operations.\nReferences: [1]Jin Y. Yen, “Finding the K Shortest Loopless Paths in a\nNetwork”, Management Science, Vol. 17, No. 11, Theory Series\n(Jul., 1971), pp. 712-716.\nExamples: G=nx.cycle_graph(7)\npaths=list(nx.shortest_simple_paths(G,0,3))\nprint(paths)\n# [[0, 1, 2, 3], [0, 6, 5, 4, 3]]\nYou can use this function to efficiently compute the k shortest/best\npaths between two nodes.\nfromitertoolsimportislice\ndefk_shortest_paths(G,source,target,k,weight=None):\nreturnlist(\nislice(nx.shortest_simple_paths(G,source,target,weight=weight),k)\n)\nforpathink_shortest_paths(G,0,3,2):\nprint(path)\n# [0, 1, 2, 3]\n# [0, 6, 5, 4, 3]",
    "Section ID: christofides\nDescription: [Approximate a solution of the traveling salesman problem, Compute a 3/2-approximation of the traveling salesman problem\nin a complete undirected graph using Christofides [1] algorithm.]\nField List: Parameters:: G : Graph: Gshould be a complete weighted undirected graph.\nThe distance between all pairs of nodes should be included.\nweight : string, optional (default=”weight”): Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.\ntree : NetworkX graph or None (default: None): A minimum spanning tree of G. Or, if None, the minimum spanning\ntree is computed usingnetworkx.minimum_spanning_tree()\nReturns:: list: List of nodes inGalong a cycle with a 3/2-approximation of\nthe minimal Hamiltonian cycle.\nMethods: []\nRubrics: References: [1]Christofides, Nicos. “Worst-case analysis of a new heuristic for\nthe travelling salesman problem.” No. RR-388. Carnegie-Mellon Univ\nPittsburgh Pa Management Sciences Research Group, 1976.",
    "Section ID: icosahedral_graph\nDescription: [Returns the Platonic Icosahedral graph., The icosahedral graph has 12 nodes and 30 edges. It is a Platonic graph\nwhose nodes have the connectivity of the icosahedron. It is undirected,\nregular and Hamiltonian [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Icosahedral graph with 12 nodes and 30 edges.\nMethods: []\nRubrics: References: [1]https://mathworld.wolfram.com/IcosahedralGraph.html",
    "Section ID: is_locally_k_edge_connected\nDescription: [Tests to see if an edge in a graph is locally k-edge-connected., Is it impossible to disconnect s and t by removing fewer than k edges?\nIf so, then s and t are locally k-edge-connected in G.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\ns : node: Source node\nt : node: Target node\nk : integer: local edge connectivity for nodes s and t\nReturns:: boolean: True if s and t are locally k-edge-connected in G.\nMethods: []\nRubrics: Examples: fromnetworkx.algorithms.connectivityimportis_locally_k_edge_connected\nG=nx.barbell_graph(10,0)\nis_locally_k_edge_connected(G,5,15,k=1)\n# True\nis_locally_k_edge_connected(G,5,15,k=2)\n# False\nis_locally_k_edge_connected(G,1,5,k=2)\n# True",
    "Section ID: preflow_push\nDescription: [Find a maximum single-commodity flow using the highest-label\npreflow-push algorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has a running time of \\(O(n^2 \\sqrt{m})\\) for \\(n\\) nodes and \\(m\\) edges.]\nField List: Parameters:: G : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\ns : node: Source node for the flow.\nt : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nresidual : NetworkX graph: Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.\nglobal_relabel_freq : integer, float: Relative frequency of applying the global relabeling heuristic to speed\nup the algorithm. If it is None, the heuristic is disabled. Default\nvalue: 1.\nvalue_only : bool: If False, compute a maximum flow; otherwise, compute a maximum preflow\nwhich is enough for computing the maximum flow value. Default value:\nFalse.\nReturns:: R : NetworkX DiGraph: Residual network after computing the maximum flow.\nRaises:: NetworkXError: The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.\nNetworkXUnbounded: If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded.\nMethods: []\nRubrics: Notes: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each node u in R , R.nodes[u]['excess'] represents the difference between flow into u and flow out of u . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.\nExamples: fromnetworkx.algorithms.flowimportpreflow_push\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=preflow_push(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value==R.graph[\"flow_value\"]\n# True\n# preflow_push also stores the maximum flow value\n# in the excess attribute of the sink node t\nflow_value==R.nodes[\"y\"][\"excess\"]\n# True\n# For some problems, you might only want to compute a\n# maximum preflow.\nR=preflow_push(G,\"x\",\"y\",value_only=True)\nflow_value==R.graph[\"flow_value\"]\n# True\nflow_value==R.nodes[\"y\"][\"excess\"]\n# True",
    "Section ID: gnmk_random_graph\nDescription: [Returns a random bipartite graph G_{n,m,k}., Produces a bipartite graph chosen randomly out of the set of all graphs\nwith n top nodes, m bottom nodes, and k edges.\nThe graph is composed of two sets of nodes.\nSet A has nodes 0 to (n - 1) and set B has nodes n to (n + m - 1).]\nField List: Parameters:: n : int: The number of nodes in the first bipartite set.\nm : int: The number of nodes in the second bipartite set.\nk : int: The number of edges\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : bool, optional (default=False): If True return a directed graph\nMethods: []\nRubrics: Notes: If k > m * n then a complete bipartite graph is returned. This graph is a bipartite version of the G_{nm} random graph model. The nodes are assigned the attribute ‘bipartite’ with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.gnmk_random_graph\nExamples: from nx.algorithms import bipartite\nG = bipartite.gnmk_random_graph(10,20,50)",
    "Section ID: square_clustering\nDescription: [Compute the squares clustering coefficient for nodes., For each node return the fraction of possible squares that exist at\nthe node [1], where \\(q_v(u,w)\\) are the number of common neighbors of \\(u\\) and \\(w\\) other than \\(v\\) (ie squares), and \\(a_v(u,w) = (k_u -\n(1+q_v(u,w)+\\theta_{uv})) + (k_w - (1+q_v(u,w)+\\theta_{uw}))\\) , where \\(\\theta_{uw} = 1\\) if \\(u\\) and \\(w\\) are connected and 0\notherwise. [2]]\nField List: Parameters:: G : graph: \nnodes : container of nodes, optional (default=all nodes in G): Compute clustering for nodes in this container.\nReturns:: c4 : dictionary: A dictionary keyed by node with the square clustering coefficient value.\nMethods: []\nRubrics: Notes: While \\(C_3(v)\\) (triangle clustering) gives the probability that\ntwo neighbors of node v are connected with each other, \\(C_4(v)\\) is\nthe probability that two neighbors of node v share a common\nneighbor different from v. This algorithm can be applied to both\nbipartite and unipartite networks.\nReferences: [1]Pedro G. Lind, Marta C. González, and Hans J. Herrmann. 2005\nCycles and clustering in bipartite networks.\nPhysical Review E (72) 056127.  [2]Zhang, Peng et al. Clustering Coefficient and Community Structure of\nBipartite Networks. Physica A: Statistical Mechanics and its Applications 387.27 (2008): 6869–6875.https://arxiv.org/abs/0710.0117v1\nExamples: G=nx.complete_graph(5)\nprint(nx.square_clustering(G,0))\n# 1.0\nprint(nx.square_clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}",
    "Section ID: generate_graphml\nDescription: [Generate GraphML lines for G]\nField List: Parameters:: G : graph: A networkx graph\nencoding : string (optional): Encoding for text data.\nprettyprint : bool (optional): If True use line breaks and indenting in output XML.\nnamed_key_ids : bool (optional): If True use attr.name as value for key elements’ id attribute.\nedge_id_from_attribute : dict key (optional): If provided, the graphml edge id is set by looking up the corresponding\nedge data attribute keyed by this parameter. IfNoneor the key does not exist in edge data,\nthe edge id is set by the edge key ifGis a MultiGraph, else the edge id is left unset.\nMethods: []\nRubrics: Notes: This implementation does not support mixed graphs (directed and unidirected\nedges together) hyperedges, nested graphs, or ports.\nExamples: G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed =\ns=linefeed.join(nx.generate_graphml(G))\nforlineinnx.generate_graphml(G):\nprint(line)",
    "Section ID: is_multigraphical\nDescription: [Returns True if some multigraph can realize the sequence.]\nField List: Parameters:: sequence : list: A list of integers\nReturns:: valid : bool: True if deg_sequence is a multigraphic degree sequence and False if not.\nMethods: []\nRubrics: Notes: The worst-case run time is \\(O(n)\\) where \\(n\\) is the length of the sequence.\nReferences: [1]S. L. Hakimi. “On the realizability of a set of integers as\ndegrees of the vertices of a linear graph”, J. SIAM, 10, pp. 496-506\n(1962).\nExamples: G=nx.MultiGraph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_multigraphical(sequence)\n# True\nTo test a non-multigraphical sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_multigraphical(sequence_list)\nFalse",
    "Section ID: local_node_connectivity\nDescription: [Compute node connectivity between source and target., Pairwise or local node connectivity between two distinct and nonadjacent\nnodes is the minimum number of nodes that must be removed (minimum\nseparating cutset) to disconnect them. By Menger’s theorem, this is equal\nto the number of node independent paths (paths that share no nodes other\nthan source and target). Which is what we compute in this function., This algorithm is a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for node connectivity\ntarget : node: Ending node for node connectivity\ncutoff : integer: Maximum node connectivity to consider. If None, the minimum degree\nof source or target is used as a cutoff. Default value None.\nReturns:: k: integer: pairwise node connectivity\nMethods: []\nRubrics: Notes: This algorithm [1] finds node independents paths between two nodes by\ncomputing their shortest path using BFS, marking the nodes of the path\nfound as ‘used’ and then searching other shortest paths excluding the\nnodes marked as used until no more paths exist. It is not exact because\na shortest path could use nodes that, if the path were longer, may belong\nto two different node independent paths. Thus it only guarantees an\nstrict lower bound on node connectivity. Note that the authors propose a further refinement, losing accuracy and\ngaining speed, which is not implemented yet.\nReferences: [1](1,2)White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf\nExamples: # Platonic octahedral graph has node connectivity 4\n# for each non adjacent node pair\nfromnetworkx.algorithmsimportapproximationasapprox\nG=nx.octahedral_graph()\napprox.local_node_connectivity(G,0,5)\n# 4",
    "Section ID: directed_configuration_model\nDescription: [Returns a directed_random graph with the given degree sequences., The configuration model generates a random directed pseudograph\n(graph with parallel edges and self loops) by randomly assigning\nedges to match the given degree sequences.]\nField List: Parameters:: in_degree_sequence : list of nonnegative integers: Each list entry corresponds to the in-degree of a node.\nout_degree_sequence : list of nonnegative integers: Each list entry corresponds to the out-degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiDiGraph): Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : MultiDiGraph: A graph with the specified degree sequences.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence.\nRaises:: NetworkXError: If the degree sequences do not have the same sum.\nMethods: []\nRubrics: Notes: Algorithm as described by Newman [1] . A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the degree\nsequences does not have the same sum. This configuration model construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn’t have the exact degree sequence specified.  This\n“finite-size effect” decreases as the size of the graph increases.\nReferences: [1]Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\nRandom graphs with arbitrary degree distributions and their applications\nPhys. Rev. E, 64, 026118 (2001)\nExamples: One can modify the in- and out-degree sequences from an existing\ndirected graph in order to create a new directed graph. For example,\nhere we modify the directed path graph:\nD=nx.DiGraph([(0,1),(1,2),(2,3)])\ndin=list(dforn,dinD.in_degree())\ndout=list(dforn,dinD.out_degree())\ndin.append(1)\ndout[0]=2\n# We now expect an edge from node 0 to a new node, node 3.\nD=nx.directed_configuration_model(din,dout)\nThe returned graph is a directed multigraph, which may have parallel\nedges. To remove any parallel edges from the returned graph:\nD=nx.DiGraph(D)\nSimilarly, to remove self-loops:\nD.remove_edges_from(nx.selfloop_edges(D))",
    "Section ID: randomized_partitioning\nDescription: [Compute a random partitioning of the graph nodes and its cut value., A partitioning is calculated by observing each node\nand deciding to add it to the partition with probability p ,\nreturning a random cut and its corresponding value (the\nsum of weights of edges connecting different partitions).]\nField List: Parameters:: G : NetworkX graph: \nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\np : scalar: Probability for each node to be part of the first partition.\nShould be in [0,1]\nweight : object: Edge attribute key to use as weight. If not specified, edges\nhave weight one.\nReturns:: cut_size : scalar: Value of the minimum cut.\npartition : pair of node sets: A partitioning of the nodes that defines a minimum cut.\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics: Examples: G=nx.complete_graph(5)\ncut_size,partition=nx.approximation.randomized_partitioning(G,seed=1)\ncut_size\n# 6\npartition\n# ({0, 3, 4}, {1, 2})",
    "Section ID: to_pandas_adjacency\nDescription: [Returns the graph adjacency matrix as a Pandas DataFrame.]\nField List: Parameters:: G : graph: The NetworkX graph used to construct the Pandas DataFrame.\nnodelist : list, optional: The rows and columns are ordered according to the nodes innodelist.\nIfnodelistis None, then the ordering is produced by G.nodes().\nmultigraph_weight : {sum, min, max}, optional: An operator that determines how weights in multigraphs are handled.\nThe default is to sum the weights of the multiple edges.\nweight : string or None, optional: The edge attribute that holds the numerical value used for\nthe edge weight.  If an edge does not have that attribute, then the\nvalue 1 is used instead.\nnonedge : float, optional: The matrix values corresponding to nonedges are typically set to zero.\nHowever, this could be undesirable if there are matrix values\ncorresponding to actual edges that also have the value zero. If so,\none might prefer nonedges to have some other value, such as nan.\nReturns:: df : Pandas DataFrame: Graph adjacency matrix\nMethods: []\nRubrics: Notes: For directed graphs, entry i,j corresponds to an edge from i to j. The DataFrame entries are assigned to the weight edge attribute. When\nan edge does not have a weight attribute, the value of the entry is set to\nthe number 1.  For multiple (parallel) edges, the values of the entries\nare determined by the ‘multigraph_weight’ parameter.  The default is to\nsum the weight attributes for each of the parallel edges. When nodelist does not contain every node in G , the matrix is built\nfrom the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting Pandas DataFrame can be modified as follows:\nExamples: G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nnx.to_pandas_adjacency(G,nodelist=[0,1,2],dtype=int)\n#    0  1  2\n# 0  0  2  0\n# 1  1  0  0\n# 2  0  0  4",
    "Section ID: has_eulerian_path\nDescription: [Return True iff G has an Eulerian path., An Eulerian path is a path in a graph which uses each edge of a graph\nexactly once. If source is specified, then this function checks\nwhether an Eulerian path that starts at node source exists.]\nField List: Parameters:: G : NetworkX Graph: The graph to find an euler path in.\nsource : node, optional: Starting node for path.\nReturns:: Bool : True if G has an Eulerian path.:\nMethods: []\nRubrics: Examples: If you prefer to allow graphs with isolated vertices to have Eulerian path,\nyou can first remove such vertices and then callhas_eulerian_pathas below example shows.\nG=nx.Graph([(0,1),(1,2),(0,2)])\nG.add_node(3)\nnx.has_eulerian_path(G)\n# False\nG.remove_nodes_from(list(nx.isolates(G)))\nnx.has_eulerian_path(G)\n# True",
    "Section ID: is_branching\nDescription: [Returns True if G is a branching., A branching is a directed forest with maximum in-degree equal to 1.]\nField List: Parameters:: G : directed graph: The directed graph to test.\nReturns:: b : bool: A boolean that is True ifGis a branching.\nMethods: []\nRubrics: Notes: In another convention, a branching is also known as a forest .\nExamples: G=nx.DiGraph([(0,1),(1,2),(2,3),(3,4)])\nnx.is_branching(G)\n# True\nG.remove_edge(2,3)\nG.add_edge(3,1)# maximum in-degree is 2\nnx.is_branching(G)\n# False",
    "Section ID: gomory_hu_tree\nDescription: [Returns the Gomory-Hu tree of an undirected graph G., A Gomory-Hu tree of an undirected graph with capacities is a\nweighted tree that represents the minimum s-t cuts for all s-t\npairs in the graph., It only requires n-1 minimum cut computations instead of the\nobvious n(n-1)/2 . The tree represents all s-t cuts as the\nminimum cut value among any pair of nodes is the minimum edge\nweight in the shortest path between the two nodes in the\nGomory-Hu tree., The Gomory-Hu tree also has the property that removing the\nedge with the minimum weight in the shortest path between\nany two nodes leaves two connected components that form\na partition of the nodes in G that defines the minimum s-t\ncut., See Examples section below for details.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nflow_func : function: Function to perform the underlying flow computations. Default valueedmonds_karp(). This function performs better in sparse graphs\nwith right tailed degree distributions.shortest_augmenting_path()will perform better in denser\ngraphs.\nReturns:: Tree : NetworkX graph: A NetworkX graph representing the Gomory-Hu tree of the input graph.\nRaises:: NetworkXNotImplemented: Raised if the input graph is directed.\nNetworkXError: Raised if the input graph is an empty Graph.\nMethods: []\nRubrics: Notes: This implementation is based on Gusfield approach [1] to compute\nGomory-Hu trees, which does not require node contractions and has\nthe same computational complexity than the original method.\nReferences: [1]Gusfield D: Very simple methods for all pairs network flow analysis.\nSIAM J Comput 19(1):143-155, 1990.\nExamples: G=nx.karate_club_graph()\nnx.set_edge_attributes(G,1,\"capacity\")\nT=nx.gomory_hu_tree(G)\n# The value of the minimum cut between any pair\n# of nodes in G is the minimum edge weight in the\n# shortest path between the two nodes in the\n# Gomory-Hu tree.\ndefminimum_edge_weight_in_shortest_path(T,u,v):\npath=nx.shortest_path(T,u,v,weight=\"weight\")\nreturnmin((T[u][v][\"weight\"],(u,v))for(u,v)inzip(path,path[1:]))\nu,v=0,33\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\ncut_value\n# 10\nnx.minimum_cut_value(G,u,v)\n# 10\n# The Gomory-Hu tree also has the property that removing the\n# edge with the minimum weight in the shortest path between\n# any two nodes leaves two connected components that form\n# a partition of the nodes in G that defines the minimum s-t\n# cut.\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\nT.remove_edge(*edge)\nU,V=list(nx.connected_components(T))\n# Thus U and V form a partition that defines a minimum cut\n# between u and v in G. You can compute the edge cut set,\n# that is, the set of edges that if removed from G will\n# disconnect u from v in G, with this information:\ncutset=set()\nforx,nbrsin((n,G[n])forninU):\ncutset.update((x,y)foryinnbrsifyinV)\n# Because we have set the capacities of all edges to 1\n# the cutset contains ten edges\nlen(cutset)\n# 10\n# You can use any maximum flow algorithm for the underlying\n# flow computations using the argument flow_func\nfromnetworkx.algorithmsimportflow\nT=nx.gomory_hu_tree(G,flow_func=flow.boykov_kolmogorov)\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\ncut_value\n# 10\nnx.minimum_cut_value(G,u,v,flow_func=flow.boykov_kolmogorov)\n# 10",
    "Section ID: from_biadjacency_matrix\nDescription: [Creates a new bipartite graph from a biadjacency matrix given as a\nSciPy sparse array.]\nField List: Parameters:: A: scipy sparse array: A biadjacency matrix representation of a graph\ncreate_using: NetworkX graph: Use specified graph for result.  The default is Graph()\nedge_attribute: string: Name of edge attribute to store matrix numeric value. The data will\nhave the same type as the matrix entry (int, float, (real,imag)).\nMethods: []\nRubrics: Notes: The nodes are labeled with the attribute bipartite set to an integer\n0 or 1 representing membership in part 0 or part 1 of the bipartite graph. If create_using is an instance of networkx.MultiGraph or networkx.MultiDiGraph and the entries of A are of\ntype int , then this function returns a multigraph (of the same\ntype as create_using ) with parallel edges. In this case, edge_attribute will be ignored.\nReferences: [1] https://en.wikipedia.org/wiki/Adjacency_matrix#Adjacency_matrix_of_a_bipartite_graph",
    "Section ID: cartesian_product\nDescription: [Returns the Cartesian product of G and H., The Cartesian product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v),(x,y))\\) if and only if either \\(u\\) is equal to \\(x\\) and both \\(v\\) and \\(y\\) are adjacent in \\(H\\) or if \\(v\\) is equal to \\(y\\) and\nboth \\(u\\) and \\(x\\) are adjacent in \\(G\\) .]\nField List: Parameters:: G, H: graphs: Networkx graphs.\nReturns:: P: NetworkX graph: The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected.\nRaises:: NetworkXError: If G and H are not both directed or both undirected.\nMethods: []\nRubrics: Notes: Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.\nExamples: G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.cartesian_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph",
    "Section ID: transitivity\nDescription: [Compute graph transitivity, the fraction of all possible triangles\npresent in G., Possible triangles are identified by the number of “triads”\n(two edges with a shared vertex)., The transitivity is]\nField List: Parameters:: G : graph:\nReturns:: out : float: Transitivity\nMethods: []\nRubrics: Notes: Self loops are ignored.\nExamples: G=nx.complete_graph(5)\nprint(nx.transitivity(G))\n# 1.0",
    "Section ID: number_connected_components\nDescription: [Returns the number of connected components.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nReturns:: n : integer: Number of connected components\nRaises:: NetworkXNotImplemented: If G is directed.\nMethods: []\nRubrics: Notes: For undirected graphs only.\nExamples: G=nx.Graph([(0,1),(1,2),(5,6),(3,4)])\nnx.number_connected_components(G)\n# 3",
    "Section ID: random_reference\nDescription: [Compute a random graph by swapping edges of a given graph.]\nField List: Parameters:: G : graph: An undirected graph with 4 or more nodes.\nniter : integer (optional, default=1): An edge is rewired approximatelynitertimes.\nconnectivity : boolean (optional, default=True): When True, ensure connectivity for the randomized graph.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : graph: The randomized graph.\nRaises:: NetworkXError: If there are fewer than 4 nodes or 2 edges inG\nMethods: []\nRubrics: Notes: The implementation is adapted from the algorithm by Maslov and Sneppen\n(2002) [1] .\nReferences: [1]Maslov, Sergei, and Kim Sneppen.\n“Specificity and stability in topology of protein networks.”\nScience 296.5569 (2002): 910-913.",
    "Section ID: laplacian_centrality\nDescription: [Compute the Laplacian centrality for nodes in the graph G ., The Laplacian Centrality of a node i is measured by the drop in the\nLaplacian Energy after deleting node i from the graph. The Laplacian Energy\nis the sum of the squared eigenvalues of a graph’s Laplacian matrix., Where \\(E_L (G)\\) is the Laplacian energy of graph G ,\nE_L (G_i) is the Laplacian energy of graph G after deleting node i and \\(\\lambda_i\\) are the eigenvalues of G ’s Laplacian matrix.\nThis formula shows the normalized value. Without normalization,\nthe numerator on the right side is returned.]\nField List: Parameters:: G : graph: A networkx graph\nnormalized : bool (default = True): If True the centrality score is scaled so the sum over all nodes is 1.\nIf False the centrality score for each node is the drop in Laplacian\nenergy when that node is removed.\nnodelist : list, optional (default = None): The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nweight: string or None, optional (default=`weight`): Optional parameterweightto compute the Laplacian matrix.\nThe edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.\nwalk_type : string or None, optional (default=None): Optional parameterwalk_typeused when callingdirected_laplacian_matrix.\nOne of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.\nalpha : real (default = 0.95): Optional parameteralphaused when callingdirected_laplacian_matrix.\n(1 - alpha) is the teleportation probability used with pagerank.\nReturns:: nodes : dictionary: Dictionary of nodes with Laplacian centrality as the value.\nRaises:: NetworkXPointlessConcept: If the graphGis the null graph.\nZeroDivisionError: If the graphGhas no edges (is empty) and normalization is requested.\nMethods: []\nRubrics: Notes: The algorithm is implemented based on [1] with an extension to directed graphs\nusing the directed_laplacian_matrix function.\nReferences: [1]Qi, X., Fuller, E., Wu, Q., Wu, Y., and Zhang, C.-Q. (2012).\nLaplacian centrality: A new centrality measure for weighted networks.\nInformation Sciences, 194:240-253.https://math.wvu.edu/~cqzhang/Publication-files/my-paper/INS-2012-Laplacian-W.pdf\nExamples: G=nx.Graph()\nedges=[(0,1,4),(0,2,2),(2,1,1),(1,3,2),(1,4,2),(4,5,1)]\nG.add_weighted_edges_from(edges)\nsorted((v,f\"{c:0.2f}\")forv,cinlaplacian_centrality(G).items())\n# [(0, '0.70'), (1, '0.90'), (2, '0.28'), (3, '0.22'), (4, '0.26'), (5, '0.04')]",
    "Section ID: degree_pearson_correlation_coefficient\nDescription: [Compute degree assortativity of graph., Assortativity measures the similarity of connections\nin the graph with respect to the node degree., This is the same as degree_assortativity_coefficient but uses the\npotentially faster scipy.stats.pearsonr function.]\nField List: Parameters:: G : NetworkX graph: \nx: string (‘in’,’out’): The degree type for source node (directed graphs only).\ny: string (‘in’,’out’): The degree type for target node (directed graphs only).\nweight: string or None, optional (default=None): The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.\nnodes: list or iterable (optional): Compute pearson correlation of degrees only for specified nodes.\nThe default is all nodes.\nReturns:: r : float: Assortativity of graph by degree.\nMethods: []\nRubrics: Notes: This calls scipy.stats.pearsonr.\nReferences: [1]M. E. J. Newman, Mixing patterns in networks\nPhysical Review E, 67 026126, 2003  [2]Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\nEdge direction and the structure of networks, PNAS 107, 10815-20 (2010).\nExamples: G=nx.path_graph(4)\nr=nx.degree_pearson_correlation_coefficient(G)\nprint(f\"{r:3.1f}\")\n# -0.5",
    "Section ID: boykov_kolmogorov\nDescription: [Find a maximum single-commodity flow using Boykov-Kolmogorov algorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has worse case complexity \\(O(n^2 m |C|)\\) for \\(n\\) nodes, \\(m\\) edges, and \\(|C|\\) the cost of the minimum cut [1] . This implementation\nuses the marking heuristic defined in [2] which improves its running\ntime in many practical problems.]\nField List: Parameters:: G : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\ns : node: Source node for the flow.\nt : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nresidual : NetworkX graph: Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.\nvalue_only : bool: If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.\ncutoff : integer, float: If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None.\nReturns:: R : NetworkX DiGraph: Residual network after computing the maximum flow.\nRaises:: NetworkXError: The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.\nNetworkXUnbounded: If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded.\nMethods: []\nRubrics: Notes: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.\nReferences: [1]Boykov, Y., & Kolmogorov, V. (2004). An experimental comparison\nof min-cut/max-flow algorithms for energy minimization in vision.\nPattern Analysis and Machine Intelligence, IEEE Transactions on,\n26(9), 1124-1137.https://doi.org/10.1109/TPAMI.2004.60  [2]Vladimir Kolmogorov. Graph-based Algorithms for Multi-camera\nReconstruction Problem. PhD thesis, Cornell University, CS Department,\n2003. pp. 109-114.https://web.archive.org/web/20170809091249/https://pub.ist.ac.at/~vnk/papers/thesis.pdf\nExamples: fromnetworkx.algorithms.flowimportboykov_kolmogorov\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=boykov_kolmogorov(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True\nA nice feature of the Boykov-Kolmogorov algorithm is that a partition\nof the nodes that defines a minimum cut can be easily computed based\non the search trees used during the algorithm. These trees are stored\nin the graph attributetreesof the residual network.\nsource_tree,target_tree=R.graph[\"trees\"]\npartition=(set(source_tree),set(G)-set(source_tree))\nOr equivalently:\npartition=(set(G)-set(target_tree),set(target_tree))",
    "Section ID: bfs_beam_edges\nDescription: [Iterates over edges in a beam search., The beam search is a generalized breadth-first search in which only\nthe “best” w neighbors of the current node are enqueued, where w is the beam width and “best” is an application-specific\nheuristic. In general, a beam search with a small beam width might\nnot visit each node in the graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for the breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.\nvalue : function: A function that takes a node of the graph as input and returns a\nreal number indicating how “good” it is. A higher value means it\nis more likely to be visited sooner during the search. When\nvisiting a new node, only thewidthneighbors with the highestvalueare enqueued (in decreasing order ofvalue).\nwidth : int (default = None): The beam width for the search. This is the number of neighbors\n(ordered byvalue) to enqueue when visiting each new node.\nYields:: edge: Edges in the beam search starting fromsource, given as a pair\nof nodes.\nMethods: []\nRubrics: Examples: To give nodes with, for example, a higher centrality precedence\nduring the search, set thevaluefunction to return the centrality\nvalue of the node:\nG=nx.karate_club_graph()\ncentrality=nx.eigenvector_centrality(G)\nlist(nx.bfs_beam_edges(G,source=0,value=centrality.get,width=3))\n# [(0, 2), (0, 1), (0, 8), (2, 32), (1, 13), (8, 33)]",
    "Section ID: from_pandas_edgelist\nDescription: [Returns a graph from Pandas DataFrame containing an edge list., The Pandas DataFrame should contain at least two columns of node names and\nzero or more columns of edge attributes. Each row will be processed as one\nedge instance., Note: This function iterates over DataFrame.values, which is not\nguaranteed to retain the data type across columns in the row. This is only\na problem if your row is entirely numeric and a mix of ints and floats. In\nthat case, all values will be returned as floats. See the\nDataFrame.iterrows documentation for an example.]\nField List: Parameters:: df : Pandas DataFrame: An edge list representation of a graph\nsource : str or int: A valid column name (string or integer) for the source nodes (for the\ndirected case).\ntarget : str or int: A valid column name (string or integer) for the target nodes (for the\ndirected case).\nedge_attr : str or int, iterable, True, or None: A valid column name (str or int) or iterable of column names that are\nused to retrieve items and add them to the graph as edge attributes.\nIfTrue, all of the remaining columns will be added.\nIfNone, no edge attributes are added to the graph.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nedge_key : str or None, optional (default=None): A valid column name for the edge keys (for a MultiGraph). The values in\nthis column are used for the edge keys when adding edges if create_using\nis a multigraph.\nIf you have node attributes stored in a separate dataframe `df_nodes`,: \nyou can load those attributes to the graph `G` using the following code:: \n```: \ndf_nodes = pd.DataFrame({“node_id”: [1, 2, 3], “attribute1”: [“A”, “B”, “C”]}): \nG.add_nodes_from((n, dict(d)) for n, d in df_nodes.iterrows()):\nMethods: []\nRubrics: Examples: Simple integer weights on edges:\nimportpandasaspd\npd.options.display.max_columns=20\nimportnumpyasnp\nrng=np.random.RandomState(seed=5)\nints=rng.randint(1,11,size=(3,2))\na=[\"A\",\"B\",\"C\"]\nb=[\"D\",\"A\",\"E\"]\ndf=pd.DataFrame(ints,columns=[\"weight\",\"cost\"])\ndf[0]=a\ndf[\"b\"]=b\ndf[[\"weight\",\"cost\",0,\"b\"]]\n#    weight  cost  0  b\n# 0       4     7  A  D\n# 1       7     1  B  A\n# 2      10     9  C  E\nG=nx.from_pandas_edgelist(df,0,\"b\",[\"weight\",\"cost\"])\nG[\"E\"][\"C\"][\"weight\"]\n# 10\nG[\"E\"][\"C\"][\"cost\"]\n# 9\nedges=pd.DataFrame(\n{\n\"source\":[0,1,2],\n\"target\":[2,2,3],\n\"weight\":[3,4,5],\n\"color\":[\"red\",\"blue\",\"blue\"],\n}\n)\nG=nx.from_pandas_edgelist(edges,edge_attr=True)\nG[0][2][\"color\"]\n# 'red'\nBuild multigraph with custom keys:\nedges=pd.DataFrame(\n{\n\"source\":[0,1,2,0],\n\"target\":[2,2,3,2],\n\"my_edge_key\":[\"A\",\"B\",\"C\",\"D\"],\n\"weight\":[3,4,5,6],\n\"color\":[\"red\",\"blue\",\"blue\",\"blue\"],\n}\n)\nG=nx.from_pandas_edgelist(\nedges,\nedge_key=\"my_edge_key\",\nedge_attr=[\"weight\",\"color\"],\ncreate_using=nx.MultiGraph(),\n)\nG[0][2]\n# AtlasView({'A': {'weight': 3, 'color': 'red'}, 'D': {'weight': 6, 'color': 'blue'}})",
    "Section ID: union\nDescription: [Combine graphs G and H. The names of nodes must be unique., A name collision between the graphs will raise an exception., A renaming facility is provided to avoid name collisions.]\nField List: Parameters:: G, H : graph: A NetworkX graph\nrename : iterable , optional: Node names of G and H can be changed by specifying the tuple\nrename=(‘G-‘,’H-’) (for example).  Node “u” in G is then renamed\n“G-u” and “v” in H is renamed “H-v”.\nReturns:: U : A union graph with the same type as G.:\nMethods: []\nRubrics: Notes: To combine graphs that have common nodes, consider compose(G, H)\nor the method, Graph.update(). disjoint_union() is similar to union() except that it avoids name clashes\nby relabeling the nodes with sequential integers. Edge and node attributes are propagated from G and H to the union graph.\nGraph attributes are also propagated, but if they are present in both G and H,\nthen the value from H is used.\nExamples: G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,1),(0,3),(1,3),(1,2)])\nU=nx.union(G,H,rename=(\"G\",\"H\"))\nU.nodes\n# NodeView(('G0', 'G1', 'G2', 'H0', 'H1', 'H3', 'H2'))\nU.edges\n# EdgeView([('G0', 'G1'), ('G0', 'G2'), ('G1', 'G2'), ('H0', 'H1'), ('H0', 'H3'), ('H1', 'H3'), ('H1', 'H2')])",
    "Section ID: write_graphml\nDescription: [Write G in GraphML XML format to path, This function uses the LXML framework and should be faster than\nthe version using the xml library.]\nField List: Parameters:: G : graph: A networkx graph\npath : file or string: File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed.\nencoding : string (optional): Encoding for text data.\nprettyprint : bool (optional): If True use line breaks and indenting in output XML.\ninfer_numeric_types : boolean: Determine if numeric types should be generalized.\nFor example, if edges have both int and float ‘weight’ attributes,\nwe infer in GraphML that both are floats.\nnamed_key_ids : bool (optional): If True use attr.name as value for key elements’ id attribute.\nedge_id_from_attribute : dict key (optional): If provided, the graphml edge id is set by looking up the corresponding\nedge data attribute keyed by this parameter. IfNoneor the key does not exist in edge data,\nthe edge id is set by the edge key ifGis a MultiGraph, else the edge id is left unset.\nMethods: []\nRubrics: Notes: This implementation does not support mixed graphs (directed\nand unidirected edges together) hyperedges, nested graphs, or ports.\nExamples: G=nx.path_graph(4)\nnx.write_graphml_lxml(G,\"fourpath.graphml\")",
    "Section ID: minimum_st_node_cut\nDescription: [Returns a set of nodes of minimum cardinality that disconnect source\nfrom target in G., This function returns the set of nodes of minimum cardinality that,\nif removed, would destroy all paths among source and target in G.]\nField List: Parameters:: G : NetworkX graph: \ns : node: Source node.\nt : node: Target node.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.\nauxiliary : NetworkX DiGraph: Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.\nresidual : NetworkX DiGraph: Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.\nReturns:: cutset : set: Set of nodes that, if removed, would destroy all paths between\nsource and target in G.\nMethods: []\nRubrics: Notes: This is a flow based implementation of minimum node cut. The algorithm\nis based in solving a number of maximum flow computations to determine\nthe capacity of the minimum cut on an auxiliary directed network that\ncorresponds to the minimum node cut of G. It handles both directed\nand undirected graphs. This implementation is based on algorithm 11\nin [1] .\nReferences: [1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\nExamples: This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportminimum_st_node_cut\nWe use in this example the platonic icosahedral graph, which has node\nconnectivity 5.\nG=nx.icosahedral_graph()\nlen(minimum_st_node_cut(G,0,6))\n# 5\nIf you need to compute local st cuts between several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity and node cuts, and the\nresidual network for the underlying maximum flow computation.\nExample of how to compute local st node cuts reusing the data\nstructures:\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nlen(minimum_st_node_cut(G,0,6,auxiliary=H,residual=R))\n# 5\nYou can also use alternative flow algorithms for computing minimum st\nnode cuts. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(minimum_st_node_cut(G,0,6,flow_func=shortest_augmenting_path))\n# 5",
    "Section ID: maximum_flow\nDescription: [Find a maximum single-commodity flow.]\nField List: Parameters:: flowG : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\n_s : node: Source node for the flow.\n_t : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nflow_func : function: A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.\nkwargs : Any other keyword parameter is passed to the function that: computes the maximum flow.\nReturns:: flow_value : integer, float: Value of the maximum flow, i.e., net outflow from the source.\nflow_dict : dict: A dictionary containing the value of the flow that went through\neach edge.\nRaises:: NetworkXError: The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.\nNetworkXUnbounded: If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded.\nMethods: []\nRubrics: Notes: The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.\nExamples: G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow returns both the value of the maximum flow and a\ndictionary with all flows.\nflow_value,flow_dict=nx.maximum_flow(G,\"x\",\"y\")\nflow_value\n# 3.0\nprint(flow_dict[\"x\"][\"b\"])\n# 1.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True",
    "Section ID: to_prufer_sequence\nDescription: [Returns the Prüfer sequence of the given tree., A Prüfer sequence is a list of n - 2 numbers between 0 and n - 1, inclusive. The tree corresponding to a given Prüfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence.]\nField List: Parameters:: T : NetworkX graph: An undirected graph object representing a tree.\nReturns:: list: The Prüfer sequence of the given tree.\nRaises:: NetworkXPointlessConcept: If the number of nodes inTis less than two.\nNotATree: IfTis not a tree.\nKeyError: If the set of nodes inTis not {0, …,n- 1}.\nMethods: []\nRubrics: Notes: There is a bijection from labeled trees to Prüfer sequences. This\nfunction is the inverse of the from_prufer_sequence() function. Sometimes Prüfer sequences use nodes labeled from 1 to n instead\nof from 0 to n - 1. This function requires nodes to be labeled in\nthe latter form. You can use relabel_nodes() to\nrelabel the nodes of your tree to the appropriate format. This implementation is from [1] and has a running time of \\(O(n)\\) .\nReferences: [1]Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n“An optimal algorithm for Prufer codes.”Journal of Software Engineering and Applications2.02 (2009): 111.\n<https://doi.org/10.4236/jsea.2009.22016>\nExamples: There is a bijection between Prüfer sequences and labeled trees, so\nthis function is the inverse of thefrom_prufer_sequence()function:\nedges=[(0,3),(1,3),(2,3),(3,4),(4,5)]\ntree=nx.Graph(edges)\nsequence=nx.to_prufer_sequence(tree)\nsequence\n# [3, 3, 3, 4]\ntree2=nx.from_prufer_sequence(sequence)\nlist(tree2.edges())==edges\n# True",
    "Section ID: graphviz_layout\nDescription: [Create node positions for G using Graphviz.]\nField List: Parameters:: G : NetworkX graph: A graph created with NetworkX\nprog : string: Name of Graphviz layout program\nroot : string, optional: Root node for twopi layout\nargs : string, optional: Extra arguments to Graphviz layout program\nReturns:: Dictionary of x, y, positions keyed by node.:\nMethods: []\nRubrics: Notes: This is a wrapper for pygraphviz_layout. Note that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info.\nExamples: G=nx.petersen_graph()\npos=nx.nx_agraph.graphviz_layout(G)\npos=nx.nx_agraph.graphviz_layout(G,prog=\"dot\")",
    "Section ID: node_disjoint_paths\nDescription: [Computes node disjoint paths between source and target., Node disjoint paths are paths that only share their first and last\nnodes. The number of node independent paths between two nodes is\nequal to their local node connectivity.]\nField List: Parameters:: G : NetworkX graph: \ns : node: Source node.\nt : node: Target node.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.\ncutoff : integer or None (default: None): Maximum number of paths to yield. If specified, the maximum flow\nalgorithm will terminate when the flow value reaches or exceeds the\ncutoff. This only works for flows that support the cutoff parameter\n(most do) and is ignored otherwise.\nauxiliary : NetworkX DiGraph: Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.\nresidual : NetworkX DiGraph: Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.\nReturns:: paths : generator: Generator of node disjoint paths.\nRaises:: NetworkXNoPath: If there is no path between source and target.\nNetworkXError: If source or target are not in the graph G.\nMethods: []\nRubrics: Notes: This is a flow based implementation of node disjoint paths. We compute\nthe maximum flow between source and target on an auxiliary directed\nnetwork. The saturated edges in the residual network after running the\nmaximum flow algorithm correspond to node disjoint paths between source\nand target in the original network. This function handles both directed\nand undirected graphs, and can use all flow algorithms from NetworkX flow\npackage.\nExamples: We use in this example the platonic icosahedral graph, which has node\nconnectivity 5, thus there are 5 node disjoint paths between any pair\nof non neighbor nodes.\nG=nx.icosahedral_graph()\nlen(list(nx.node_disjoint_paths(G,0,6)))\n# 5\nIf you need to compute node disjoint paths between several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity and node cuts, and the\nresidual network for the underlying maximum flow computation.\nExample of how to compute node disjoint paths reusing the data\nstructures:\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\n# Reuse the auxiliary digraph and the residual network by passing them\n# as arguments\nlen(list(nx.node_disjoint_paths(G,0,6,auxiliary=H,residual=R)))\n# 5\nYou can also use alternative flow algorithms for computing node disjoint\npaths. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(list(nx.node_disjoint_paths(G,0,6,flow_func=shortest_augmenting_path)))\n# 5",
    "Section ID: connected_components\nDescription: [Generate connected components.]\nField List: Parameters:: G : NetworkX graph: An undirected graph\nReturns:: comp : generator of sets: A generator of sets of nodes, one for each component of G.\nRaises:: NetworkXNotImplemented: If G is directed.\nMethods: []\nRubrics: Notes: For undirected graphs only.\nExamples: Generate a sorted list of connected components, largest first.\nG=nx.path_graph(4)\nnx.add_path(G,[10,11,12])\n[len(c)forcinsorted(nx.connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest connected component, it’s more\nefficient to use max instead of sort.\nlargest_cc=max(nx.connected_components(G),key=len)\nTo create the induced subgraph of each component use:\nS=[G.subgraph(c).copy()forcinnx.connected_components(G)]",
    "Section ID: kneser_graph\nDescription: [Returns the Kneser Graph with parameters n and k ., The Kneser Graph has nodes that are k-tuples (subsets) of the integers\nbetween 0 and n-1 . Nodes are adjacent if their corresponding sets are disjoint.]\nField List: Parameters:: n: int: Number of integers from which to make node subsets.\nSubsets are drawn fromset(range(n)).\nk: int: Size of the subsets.\nReturns:: G : NetworkX Graph:\nMethods: []\nRubrics: Examples: G=nx.kneser_graph(5,2)\nG.number_of_nodes()\n# 10\nG.number_of_edges()\n# 15\nnx.is_isomorphic(G,nx.petersen_graph())\n# True",
    "Section ID: schultz_index\nDescription: [Returns the Schultz Index (of the first kind) of G, The Schultz Index  [3] of a graph is the sum over all node pairs of\ndistances times the sum of degrees. Consider an undirected graph G .\nFor each node pair (u,v) compute dist(u,v)*(deg(u)+deg(v) where dist is the shortest path length between two nodes and deg is the degree of a node., The Schultz Index is the sum of these quantities over all (unordered)\npairs of nodes.]\nField List: Parameters:: G : NetworkX graph: The undirected graph of interest.\nweight : string or None, optional (default: None): If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances.\nReturns:: number: The first kind of Schultz Index of the graphG.\nMethods: []\nRubrics: References: [1]I. Gutman, Selected properties of the Schultz molecular topological index,\nJ. Chem. Inf. Comput. Sci. 34 (1994), 1087–1089.https://doi.org/10.1021/ci00021a009  [2]M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\nCroatica Chemica Acta, 71 (1998), 21-51.https://hrcak.srce.hr/132323  [3]H. P. Schultz, Topological organic chemistry. 1.\nGraph theory and topological indices of alkanes,i\nJ. Chem. Inf. Comput. Sci. 29 (1989), 239–257.\nExamples: The Schultz Index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes times2*(n-1),\nsince each pair of nodes is at distance one and the sum of degree\nof two nodes is2*(n-1).\nn=10\nG=nx.complete_graph(n)\nnx.schultz_index(G)==(n*(n-1)/2)*(2*(n-1))\n# True\nGraph that is disconnected\nnx.schultz_index(nx.empty_graph(2))\n# inf",
    "Section ID: dfs_labeled_edges\nDescription: [Iterate over edges in a depth-first-search (DFS) labeled by type.]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Specify starting node for depth-first search and return edges in\nthe component reachable from source.\ndepth_limit : int, optional (default=len(G)): Specify the maximum search depth.\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: edges: generator: A generator of triples of the form (u,v,d), where (u,v) is the edge being explored in the depth-first search anddis one of the strings ‘forward’, ‘nontree’, ‘reverse’, or ‘reverse-depth_limit’.\nA ‘forward’ edge is one in whichuhas been visited butvhas\nnot. A ‘nontree’ edge is one in which bothuandvhave been\nvisited but the edge is not in the DFS tree. A ‘reverse’ edge is\none in which bothuandvhave been visited and the edge is in\nthe DFS tree. When thedepth_limitis reached via a ‘forward’ edge,\na ‘reverse’ edge is immediately generated rather than the subtree\nbeing explored. To indicate this flavor of ‘reverse’ edge, the string\nyielded is ‘reverse-depth_limit’.\nMethods: []\nRubrics: Notes: If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein’s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n“ Depth-limited search ”.\nExamples: The labels reveal the complete transcript of the depth-first search\nalgorithm in more detail than, for example,dfs_edges():\nfrompprintimportpprint\n\nG=nx.DiGraph([(0,1),(1,2),(2,1)])\npprint(list(nx.dfs_labeled_edges(G,source=0)))\n# [(0, 0, 'forward'),\n#  (0, 1, 'forward'),\n#  (1, 2, 'forward'),\n#  (2, 1, 'nontree'),\n#  (1, 2, 'reverse'),\n#  (0, 1, 'reverse'),\n#  (0, 0, 'reverse')]",
    "Section ID: write_gexf\nDescription: [Write G in GEXF format to path., “GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics” [1] ., Node attributes are checked according to the version of the GEXF\nschemas used for parameters which are not user defined,\ne.g. visualization ‘viz’ [2] . See example for usage.]\nField List: Parameters:: G : graph: A NetworkX graph\npath : file or string: File or file name to write.\nFile names ending in .gz or .bz2 will be compressed.\nencoding : string (optional, default: ‘utf-8’): Encoding for text data.\nprettyprint : bool (optional, default: True): If True use line breaks and indenting in output XML.\nversion: string (optional, default: ‘1.2draft’): The version of GEXF to be used for nodes attributes checking\nMethods: []\nRubrics: Notes: This implementation does not support mixed graphs (directed and undirected\nedges together). The node id attribute is set to be the string of the node label.\nIf you want to specify an id use set it as node data, e.g.\nnode[‘a’][‘id’]=1 to set the id of node ‘a’ to 1.\nReferences: [1]GEXF File Format,http://gexf.net/  [2]GEXF schema,http://gexf.net/schema.html\nExamples: G=nx.path_graph(4)\nnx.write_gexf(G,\"test.gexf\")\n# visualization data\n>>> G.nodes[0][“viz”] = {“size”: 54}\n>>> G.nodes[0][“viz”][“position”] = {“x”: 0, “y”: 1}\n>>> G.nodes[0][“viz”][“color”] = {“r”: 0, “g”: 0, “b”: 256}",
    "Section ID: write_dot\nDescription: [Write NetworkX graph G to Graphviz dot format on path.]\nField List: Parameters:: G : graph: A networkx graph\npath : filename: Filename or file handle to write\nMethods: []\nRubrics: Notes: To use a specific graph layout, call A.layout prior to write_dot .\nNote that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info.",
    "Section ID: windmill_graph\nDescription: [Generate a windmill graph.\nA windmill graph is a graph of n cliques each of size k that are all\njoined at one node.\nIt can be thought of as taking a disjoint union of n cliques of size k ,\nselecting one point from each, and contracting all of the selected points.\nAlternatively, one could generate n cliques of size k-1 and one node\nthat is connected to all other nodes in the graph.]\nField List: Parameters:: n : int: Number of cliques\nk : int: Size of cliques\nReturns:: G : NetworkX Graph: windmill graph with n cliques of size k\nRaises:: NetworkXError: If the number of cliques is less than two\nIf the size of the cliques are less than two\nMethods: []\nRubrics: Notes: The node labeled 0 will be the node connected to all other nodes.\nNote that windmill graphs are usually denoted Wd(k,n) , so the parameters\nare in the opposite order as the parameters of this method.\nExamples: G=nx.windmill_graph(4,5)",
    "Section ID: antichains\nDescription: [Generates antichains from a directed acyclic graph (DAG)., An antichain is a subset of a partially ordered set such that any\ntwo elements in the subset are incomparable.]\nField List: Parameters:: G : NetworkX DiGraph: A directed acyclic graph (DAG)\ntopo_order: list or tuple, optional: A topological order for G (if None, the function will compute one)\nYields:: antichain : list: a list of nodes inGrepresenting an antichain\nRaises:: NetworkXNotImplemented: IfGis not directed\nNetworkXUnfeasible: IfGcontains a cycle\nMethods: []\nRubrics: Notes: This function was originally developed by Peter Jipsen and Franco Saliola\nfor the SAGE project. It’s included in NetworkX with permission from the\nauthors. Original SAGE code at: sagemath/sage\nReferences: [1]Free Lattices, by R. Freese, J. Jezek and J. B. Nation,\nAMS, Vol 42, 1995, p. 226.\nExamples: DG=nx.DiGraph([(1,2),(1,3)])\nlist(nx.antichains(DG))\n# [[], [3], [2], [2, 3], [1]]",
    "Section ID: bfs_tree\nDescription: [Returns an oriented tree constructed from of a breadth-first-search\nstarting at source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Specify starting node for breadth-first search\nreverse : bool, optional: If True traverse a directed graph in the reverse direction\ndepth_limit : int, optional(default=len(G)): Specify the maximum search depth\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: T: NetworkX DiGraph: An oriented tree\nMethods: []\nRubrics: Notes: Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004. The modifications\nto allow depth limits based on the Wikipedia article\n“ Depth-limited-search ”.\nExamples: G=nx.path_graph(3)\nlist(nx.bfs_tree(G,1).edges())\n# [(1, 0), (1, 2)]\nH=nx.Graph()\nnx.add_path(H,[0,1,2,3,4,5,6])\nnx.add_path(H,[2,7,8,9,10])\nsorted(list(nx.bfs_tree(H,source=3,depth_limit=3).edges()))\n# [(1, 0), (2, 1), (2, 7), (3, 2), (3, 4), (4, 5), (5, 6), (7, 8)]",
    "Section ID: np_random_state\nDescription: [Decorator to generate a numpy RandomState or Generator instance., The decorator processes the argument indicated by random_state_argument using nx.utils.create_random_state() .\nThe argument value can be a seed (integer), or a numpy.random.RandomState or numpy.random.RandomState instance or ( None or numpy.random ).\nThe latter two options use the global random number generator for numpy.random ., The returned instance is a numpy.random.RandomState or numpy.random.Generator .]\nField List: Parameters:: random_state_argument : string or int: The name or index of the argument to be converted\nto anumpy.random.RandomStateinstance.\nReturns:: _random_state : function: Function whose random_state keyword argument is a RandomState instance.\nMethods: []\nRubrics: Examples: Decorate functions like this:\n@np_random_state(\"seed\")defrandom_float(seed=None):returnseed.rand()@np_random_state(0)defrandom_float(rng=None):returnrng.rand()@np_random_state(1)defrandom_array(dims,random_state=1):returnrandom_state.rand(*dims)",
    "Section ID: is_weighted\nDescription: [Returns True if G has weighted edges.]\nField List: Parameters:: G : graph: A NetworkX graph.\nedge : tuple, optional: A 2-tuple specifying the only edge inGthat will be tested. If\nNone, then every edge inGis tested.\nweight: string, optional: The attribute name used to query for edge weights.\nReturns:: bool: A boolean signifying ifG, or the specified edge, is weighted.\nRaises:: NetworkXError: If the specified edge does not exist.\nMethods: []\nRubrics: Examples: G=nx.path_graph(4)\nnx.is_weighted(G)\n# False\nnx.is_weighted(G,(2,3))\n# False\nG=nx.DiGraph()\nG.add_edge(1,2,weight=1)\nnx.is_weighted(G)\n# True",
    "Section ID: simulated_annealing_tsp\nDescription: [Returns an approximate solution to the traveling salesman problem., This function uses simulated annealing to approximate the minimal cost\ncycle through the nodes. Starting from a suboptimal solution, simulated\nannealing perturbs that solution, occasionally accepting changes that make\nthe solution worse to escape from a locally optimal solution. The chance\nof accepting such changes decreases over the iterations to encourage\nan optimal result.  In summary, the function returns a cycle starting\nat source for which the total cost is minimized. It also returns the cost., The chance of accepting a proposed change is related to a parameter called\nthe temperature (annealing has a physical analogue of steel hardening\nas it cools). As the temperature is reduced, the chance of moves that\nincrease cost goes down.]\nField List: Parameters:: G : Graph: Gshould be a complete weighted graph.\nThe distance between all pairs of nodes should be included.\ninit_cycle : list of all nodes or “greedy”: The initial solution (a cycle through all nodes returning to the start).\nThis argument has no default to make you think about it.\nIf “greedy”, usegreedy_tsp(G,weight).\nOther common starting cycles arelist(G)+[next(iter(G))]or the final\nresult ofsimulated_annealing_tspwhen doingthreshold_accepting_tsp.\nweight : string, optional (default=”weight”): Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.\nsource : node, optional (default: first node in list(G)): Starting node.  If None, defaults tonext(iter(G))\ntemp : int, optional (default=100): The algorithm’s temperature parameter. It represents the initial\nvalue of temperature\nmove : “1-1” or “1-0” or function, optional (default=”1-1”): Indicator of what move to use when finding new trial solutions.\nStrings indicate two special built-in moves:“1-1”: 1-1 exchange which transposes the position\nof two elements of the current solution.\nThe function called isswap_two_nodes().\nFor example if we apply 1-1 exchange in the solutionA=[3,2,1,4,3]we can get the following by the transposition of 1 and 4 elements:A'=[3,2,4,1,3]“1-0”: 1-0 exchange which moves an node in the solution\nto a new position.\nThe function called ismove_one_node().\nFor example if we apply 1-0 exchange in the solutionA=[3,2,1,4,3]we can transfer the fourth element to the second position:A'=[3,4,2,1,3]You may provide your own functions to enact a move from\none solution to a neighbor solution. The function must take\nthe solution as input along with aseedinput to control\nrandom number generation (see theseedinput here).\nYour function should maintain the solution as a cycle with\nequal first and last node and all others appearing once.\nYour function should return the new solution.\nmax_iterations : int, optional (default=10): Declared done when this number of consecutive iterations of\nthe outer loop occurs without any change in the best cost solution.\nN_inner : int, optional (default=100): The number of iterations of the inner loop.\nalpha : float between (0, 1), optional (default=0.01): Percentage of temperature decrease in each iteration\nof outer loop\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: cycle : list of nodes: Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip.\nRaises:: NetworkXError: IfGis not complete the algorithm raises an exception.\nMethods: []\nRubrics: Notes: Simulated Annealing is a metaheuristic local search algorithm.\nThe main characteristic of this algorithm is that it accepts\neven solutions which lead to the increase of the cost in order\nto escape from low quality local optimal solutions. This algorithm needs an initial solution. If not provided, it is\nconstructed by a simple greedy algorithm. At every iteration, the\nalgorithm selects thoughtfully a neighbor solution.\nConsider \\(c(x)\\) cost of current solution and \\(c(x')\\) cost of a\nneighbor solution.\nIf \\(c(x') - c(x) <= 0\\) then the neighbor solution becomes the current\nsolution for the next iteration. Otherwise, the algorithm accepts\nthe neighbor solution with probability \\(p = exp - ([c(x') - c(x)] / temp)\\) .\nOtherwise the current solution is retained. temp is a parameter of the algorithm and represents temperature. Time complexity:\nFor \\(N_i\\) iterations of the inner loop and \\(N_o\\) iterations of the\nouter loop, this algorithm has running time \\(O(N_i * N_o * |V|)\\) . For more information and how the algorithm is inspired see: http://en.wikipedia.org/wiki/Simulated_annealing\nExamples: fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.simulated_annealing_tsp(G,\"greedy\",source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31\nincycle=[\"D\",\"B\",\"A\",\"C\",\"D\"]\ncycle=approx.simulated_annealing_tsp(G,incycle,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31",
    "Section ID: communicability_exp\nDescription: [Returns communicability between all pairs of nodes in G., Communicability between pair of node (u,v) of node in G is the sum of\nwalks of different lengths starting at node u and ending at node v.]\nField List: Parameters:: G: graph:\nReturns:: comm: dictionary of dictionaries: Dictionary of dictionaries keyed by nodes with communicability\nas the value.\nRaises:: NetworkXError: If the graph is not undirected and simple.\nMethods: []\nRubrics: Notes: This algorithm uses matrix exponentiation of the adjacency matrix. Let G=(V,E) be a simple undirected graph.  Using the connection between\nthe powers  of the adjacency matrix and the number of walks in the graph,\nthe communicability between nodes u and v is [1] ,\nReferences: [1]Ernesto Estrada, Naomichi Hatano,\n“Communicability in complex networks”,\nPhys. Rev. E 77, 036111 (2008).https://arxiv.org/abs/0707.0756\nExamples: G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nc=nx.communicability_exp(G)",
    "Section ID: greedy_branching\nDescription: [Returns a branching obtained through a greedy algorithm., This algorithm is wrong, and cannot give a proper optimal branching.\nHowever, we include it for pedagogical reasons, as it can be helpful to\nsee what its outputs are., The output is a branching, and possibly, a spanning arborescence. However,\nit is not guaranteed to be optimal in either case.]\nField List: Parameters:: G : DiGraph: The directed graph to scan.\nattr : str: The attribute to use as weights. If None, then each edge will be\ntreated equally with a weight of 1.\ndefault : float: Whenattris not None, then if an edge does not have that attribute,defaultspecifies what value it should take.\nkind : str: The type of optimum to search for: ‘min’ or ‘max’ greedy branching.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: B : directed graph: The greedily obtained branching.\nMethods: []\nRubrics:",
    "Section ID: from_edgelist\nDescription: [Returns a graph from a list of edges.]\nField List: Parameters:: edgelist : list or iterator: Edge tuples\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nMethods: []\nRubrics: Examples: edgelist=[(0,1)]# single edge (0,1)\nG=nx.from_edgelist(edgelist)\nor\nG=nx.Graph(edgelist)# use Graph constructor",
    "Section ID: Edmonds\nDescription: [Edmonds algorithm [1] for finding optimal branchings and spanning\narborescences., This algorithm can find both minimum and maximum spanning arborescences and\nbranchings., Notes, While this algorithm can find a minimum branching, since it isn’t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs., References]\nField List: Methods: []\nRubrics: Notes: While this algorithm can find a minimum branching, since it isn’t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.\nReferences: [1]J. Edmonds, Optimum Branchings, Journal of Research of the National\nBureau of Standards, 1967, Vol. 71B, p.233-240,https://archive.org/details/jresv71Bn4p233",
    "Section ID: havel_hakimi_graph\nDescription: [Returns a bipartite graph from two given degree sequences using a\nHavel-Hakimi style construction., The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from the set A are connected to nodes in the set B by\nconnecting the highest degree nodes in set A to the highest degree\nnodes in set B until all stubs are connected.]\nField List: Parameters:: aseq : list: Degree sequence for node set A.\nbseq : list: Degree sequence for node set B.\ncreate_using : NetworkX graph instance, optional: Return graph of this type.\nMethods: []\nRubrics: Notes: The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute ‘bipartite’ with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.havel_hakimi_graph",
    "Section ID: zipf_rv\nDescription: [Returns a random value chosen from the Zipf distribution., The return value is an integer drawn from the probability distribution, where \\(\\zeta(\\alpha, x_{\\min})\\) is the Hurwitz zeta function.]\nField List: Parameters:: alpha : float: Exponent value of the distribution\nxmin : int: Minimum value\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: x : int: Random value from Zipf distribution\nRaises:: ValueError:: If xmin < 1 or\nIf alpha <= 1\nMethods: []\nRubrics: Notes: The rejection algorithm generates random values for a the power-law\ndistribution in uniformly bounded expected time dependent on\nparameters.  See [1] for details on its operation.\nReferences: [1]Luc Devroye, Non-Uniform Random Variate Generation,\nSpringer-Verlag, New York, 1986.\nExamples: nx.utils.zipf_rv(alpha=2,xmin=3,seed=42)\n# 8",
    "Section ID: random_cograph\nDescription: [Returns a random cograph with \\(2 ^ n\\) nodes., A cograph is a graph containing no path on four vertices.\nCographs or \\(P_4\\) -free graphs can be obtained from a single vertex\nby disjoint union and complementation operations., This generator starts off from a single vertex and performs disjoint\nunion and full join operations on itself.\nThe decision on which operation will take place is random.]\nField List: Parameters:: n : int: The order of the cograph.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : A random graph containing no path on four vertices.:\nMethods: []\nRubrics: References: [1]D.G. Corneil, H. Lerchs, L.Stewart Burlingham,\n“Complement reducible graphs”,\nDiscrete Applied Mathematics, Volume 3, Issue 3, 1981, Pages 163-174,\nISSN 0166-218X.",
    "Section ID: eulerian_path\nDescription: [Return an iterator over the edges of an Eulerian path in G .]\nField List: Parameters:: G : NetworkX Graph: The graph in which to look for an eulerian path.\nsource : node or None (default: None): The node at which to start the search. None means search over all\nstarting nodes.\nkeys : Bool (default: False): Indicates whether to yield edge 3-tuples (u, v, edge_key).\nThe default yields edge 2-tuples\nYields:: Edge tuples along the eulerian path.: \nWarning: If : source : provided is not the start node of an Euler path: \nwill raise error even if an Euler Path exists.:\nMethods: []\nRubrics:",
    "Section ID: arbitrary_element\nDescription: [Returns an arbitrary element of iterable without removing it., This is most useful for “peeking” at an arbitrary element of a set,\nbut can be used for any list, dictionary, etc., as well.]\nField List: Parameters:: iterable : abc.collections.Iterableinstance: Any object that implements__iter__, e.g. set, dict, list, tuple,\netc.\nReturns:: The object that results from : next(iter(iterable)):\nRaises:: ValueError: Ifiterableis an iterator (because the current implementation of\nthis function would consume an element from the iterator).\nMethods: []\nRubrics: Notes: This function does not return a random element. If iterable is\nordered, sequential calls will return the same value:\nExamples: Arbitrary elements from common Iterable objects:\nnx.utils.arbitrary_element([1,2,3])# list\n# 1\nnx.utils.arbitrary_element((1,2,3))# tuple\n# 1\nnx.utils.arbitrary_element({1,2,3})# set\n# 1\nd={k:vfork,vinzip([1,2,3],[3,2,1])}\nnx.utils.arbitrary_element(d)# dict_keys\n# 1\nnx.utils.arbitrary_element(d.values())# dict values\n# 3\nstris also an Iterable:\nnx.utils.arbitrary_element(\"hello\")\n# 'h'\nValueErroris raised ifiterableis an iterator:\niterator=iter([1,2,3])# Iterator, *not* Iterable\nnx.utils.arbitrary_element(iterator)Traceback (most recent call last):    ...ValueErrorcannot return an arbitrary item from an iterator",
    "Section ID: alternating_havel_hakimi_graph\nDescription: [Returns a bipartite graph from two given degree sequences using\nan alternating Havel-Hakimi style construction., The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from the set A are connected to nodes in the set B by\nconnecting the highest degree nodes in set A to alternatively the\nhighest and the lowest degree nodes in set B until all stubs are\nconnected.]\nField List: Parameters:: aseq : list: Degree sequence for node set A.\nbseq : list: Degree sequence for node set B.\ncreate_using : NetworkX graph instance, optional: Return graph of this type.\nMethods: []\nRubrics: Notes: The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute ‘bipartite’ with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.alternating_havel_hakimi_graph",
    "Section ID: geographical_threshold_graph\nDescription: [Returns a geographical threshold graph., The geographical threshold graph model places \\(n\\) nodes uniformly at\nrandom in a rectangular domain.  Each node \\(u\\) is assigned a weight \\(w_u\\) . Two nodes \\(u\\) and \\(v\\) are joined by an edge if, where r is the distance between u and v , p_dist is any function of r , and \\(\\theta\\) as the threshold parameter. p_dist is used to\ngive weight to the distance between nodes when deciding whether or not\nthey should be connected. The larger p_dist is, the more prone nodes\nseparated by r are to be connected, and vice versa.]\nField List: Parameters:: n : int or iterable: Number of nodes or iterable of nodes\ntheta: float: Threshold value\ndim : int, optional: Dimension of graph\npos : dict: Node positions as a dictionary of tuples keyed by node.\nweight : dict: Node weights as a dictionary of numbers keyed by node.\nmetric : function: A metric on vectors of numbers (represented as lists or\ntuples). This must be a function that accepts two lists (or\ntuples) as input and yields a number as output. The function\nmust also satisfy the four requirements of ametric.\nSpecifically, if\\(d\\)is the function and\\(x\\),\\(y\\),\nand\\(z\\)are vectors in the graph, then\\(d\\)must satisfy\\(d(x, y) \\ge 0\\),\\(d(x, y) = 0\\)if and only if\\(x = y\\),\\(d(x, y) = d(y, x)\\),\\(d(x, z) \\le d(x, y) + d(y, z)\\).If this argument is not specified, the Euclidean distance metric is\nused.\np_dist : function, optional: Any function used to give weight to the distance between nodes when\ndeciding whether or not they should be connected.p_distwas\noriginally conceived as a probability density function giving the\nprobability of connecting two nodes that are of metric distancerapart. The implementation here allows for more arbitrary definitions\nofp_distthat do not need to correspond to valid probability\ndensity functions. Thescipy.statspackage has many\nprobability density functions implemented and tools for custom\nprobability density definitions, and passing the.pdfmethod of\nscipy.stats distributions can be used here. Ifp_dist=None(the default), the exponential function\\(r^{-2}\\)is used.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\npos_name : string, default=”pos”: The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.\nweight_name : string, default=”weight”: The name of the node attribute which represents the weight\nof the node in the returned graph.\nReturns:: Graph: A random geographic threshold graph, undirected and without\nself-loops.Each node has a node attributeposthat stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function. Similarly, each node has a node\nattributeweightthat stores the weight of that node as\nprovided or as generated.\nMethods: []\nRubrics: Notes: If weights are not specified they are assigned to nodes by drawing randomly\nfrom the exponential distribution with rate parameter \\(\\lambda=1\\) .\nTo specify weights from a different distribution, use the weight keyword\nargument:\nReferences: [1]Masuda, N., Miwa, H., Konno, N.:\nGeographical threshold graphs with small-world and scale-free\nproperties.\nPhysical Review E 71, 036108 (2005)  [2]Milan Bradonjić, Aric Hagberg and Allon G. Percus,\nGiant component and connectivity in geographical threshold graphs,\nin Algorithms and Models for the Web-Graph (WAW 2007),\nAntony Bonato and Fan Chung (Eds), pp. 209–216, 2007\nExamples: Specify an alternate distance metric using themetrickeyword\nargument. For example, to use thetaxicab metricinstead of the\ndefaultEuclidean metric:\ndist=lambdax,y:sum(abs(a-b)fora,binzip(x,y))\nG=nx.geographical_threshold_graph(10,0.1,metric=dist)",
    "Section ID: minimum_edge_cut\nDescription: [Returns a set of edges of minimum cardinality that disconnects G., If source and target nodes are provided, this function returns the\nset of edges of minimum cardinality that, if removed, would break\nall paths among source and target in G. If not, it returns a set of\nedges of minimum cardinality that disconnects G.]\nField List: Parameters:: G : NetworkX graph: \ns : node: Source node. Optional. Default value: None.\nt : node: Target node. Optional. Default value: None.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.\nReturns:: cutset : set: Set of edges that, if removed, would disconnect G. If source\nand target nodes are provided, the set contains the edges that\nif removed, would destroy all paths between source and target.\nMethods: []\nRubrics: Notes: This is a flow based implementation of minimum edge cut. For\nundirected graphs the algorithm works by finding a ‘small’ dominating\nset of nodes of G (see algorithm 7 in [1] ) and computing the maximum\nflow between an arbitrary node in the dominating set and the rest of\nnodes in it. This is an implementation of algorithm 6 in [1] . For\ndirected graphs, the algorithm does n calls to the max flow function.\nThe function raises an error if the directed graph is not weakly\nconnected and returns an empty set if it is weakly connected.\nIt is an implementation of algorithm 8 in [1] .\nReferences: [1](1,2,3)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\nExamples: # Platonic icosahedral graph has edge connectivity 5\nG=nx.icosahedral_graph()\nlen(nx.minimum_edge_cut(G))\n# 5\nYou can use alternative flow algorithms for the underlying\nmaximum flow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions.\nAlternative flow functions have to be explicitly imported\nfrom the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(nx.minimum_edge_cut(G,flow_func=shortest_augmenting_path))\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local edge connectivity.\nnx.edge_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_edge_connectivity()for details.",
    "Section ID: is_reachable\nDescription: [Decides whether there is a path from s to t in the\ntournament., This function is more theoretically efficient than the reachability\nchecks than the shortest path algorithms in networkx.algorithms.shortest_paths ., The given graph must be a tournament, otherwise this function’s\nbehavior is undefined.]\nField List: Parameters:: G : NetworkX graph: A directed graph representing a tournament.\ns : node: A node in the graph.\nt : node: A node in the graph.\nReturns:: bool: Whether there is a path fromstotinG.\nMethods: []\nRubrics: Notes: Although this function is more theoretically efficient than the\ngeneric shortest path functions, a speedup requires the use of\nparallelism. Though it may in the future, the current implementation\ndoes not use parallelism, thus you may not see much of a speedup. This algorithm comes from [1].\nReferences: [1]Tantau, Till.\n“A note on the complexity of the reachability problem for\ntournaments.”Electronic Colloquium on Computational Complexity. 2001.\n<http://eccc.hpi-web.de/report/2001/092/>\nExamples: G=nx.DiGraph([(1,0),(1,3),(1,2),(2,3),(2,0),(3,0)])\nnx.is_tournament(G)\n# True\nnx.tournament.is_reachable(G,1,3)\n# True\nnx.tournament.is_reachable(G,3,2)\n# False",
    "Section ID: paley_graph\nDescription: [Returns the Paley \\(\\frac{(p-1)}{2}\\) -regular graph on \\(p\\) nodes., The returned graph is a graph on \\(\\mathbb{Z}/p\\mathbb{Z}\\) with edges between \\(x\\) and \\(y\\) if and only if \\(x-y\\) is a nonzero square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) ., If \\(p \\equiv 1  \\pmod 4\\) , \\(-1\\) is a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) and therefore \\(x-y\\) is a square if and\nonly if \\(y-x\\) is also a square, i.e the edges in the Paley graph are symmetric., If \\(p \\equiv 3 \\pmod 4\\) , \\(-1\\) is not a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) and therefore either \\(x-y\\) or \\(y-x\\) is a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) but not both., Note that a more general definition of Paley graphs extends this construction\nto graphs over \\(q=p^n\\) vertices, by using the finite field \\(F_q\\) instead of \\(\\mathbb{Z}/p\\mathbb{Z}\\) .\nThis construction requires to compute squares in general finite fields and is\nnot what is implemented here (i.e paley_graph(25) does not return the true\nPaley graph associated with \\(5^2\\) ).]\nField List: Parameters:: p : int, an odd prime number.: \ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : graph: The constructed directed graph.\nRaises:: NetworkXError: If the graph is a multigraph.\nMethods: []\nRubrics: References: Chapter 13 in B. Bollobas, Random Graphs. Second edition.\nCambridge Studies in Advanced Mathematics, 73.\nCambridge University Press, Cambridge (2001).",
    "Section ID: s_metric\nDescription: [Returns the s-metric [1] of graph., The s-metric is defined as the sum of the products deg(u)*deg(v) for every edge (u,v) in G .]\nField List: Parameters:: G : graph: The graph used to compute the s-metric.\nnormalized : bool (optional): Normalize the value.Deprecated since version 3.2:Thenormalizedkeyword argument is deprecated and will be removed\nin the future\nReturns:: s : float: The s-metric of the graph.\nMethods: []\nRubrics: References: [1]Lun Li, David Alderson, John C. Doyle, and Walter Willinger,\nTowards a Theory of Scale-Free Graphs:\nDefinition, Properties, and  Implications (Extended Version), 2005.https://arxiv.org/abs/cond-mat/0501169",
    "Section ID: dag_to_branching\nDescription: [Returns a branching representing all (overlapping) paths from\nroot nodes to leaf nodes in the given directed acyclic graph., As described in networkx.algorithms.tree.recognition , a branching is a directed forest in which each node has at most one\nparent. In other words, a branching is a disjoint union of arborescences . For this function, each node of in-degree zero in G becomes a root of one of the arborescences, and there will be\none leaf node for each distinct path from that root to a leaf node\nin G ., Each node v in G with k parents becomes k distinct nodes in\nthe returned branching, one for each parent, and the sub-DAG rooted\nat v is duplicated for each copy. The algorithm then recurses on\nthe children of each copy of v .]\nField List: Parameters:: G : NetworkX graph: A directed acyclic graph.\nReturns:: DiGraph: The branching in which there is a bijection between root-to-leaf\npaths inG(in which multiple paths may share the same leaf)\nand root-to-leaf paths in the branching (in which there is a\nunique path from a root to a leaf).Each node has an attribute ‘source’ whose value is the original\nnode to which this node corresponds. No other graph, node, or\nedge attributes are copied into this new graph.\nRaises:: NetworkXNotImplemented: IfGis not directed, or ifGis a multigraph.\nHasACycle: IfGis not acyclic.\nMethods: []\nRubrics: Notes: This function is not idempotent in the sense that the node labels in\nthe returned branching may be uniquely generated each time the\nfunction is invoked. In fact, the node labels may not be integers;\nin order to relabel the nodes to be more readable, you can use the networkx.convert_node_labels_to_integers() function. The current implementation of this function uses networkx.prefix_tree() , so it is subject to the limitations of\nthat function.\nExamples: To examine which nodes in the returned branching were produced by\nwhich original node in the directed acyclic graph, we can collect\nthe mapping from source node to new nodes into a dictionary. For\nexample, consider the directed diamond graph:\nfromcollectionsimportdefaultdict\nfromoperatorimportitemgetter\n\nG=nx.DiGraph(nx.utils.pairwise(\"abd\"))\nG.add_edges_from(nx.utils.pairwise(\"acd\"))\nB=nx.dag_to_branching(G)\n\nsources=defaultdict(set)\nforv,sourceinB.nodes(data=\"source\"):\nsources[source].add(v)\nlen(sources[\"a\"])\n# 1\nlen(sources[\"d\"])\n# 2\nTo copy node attributes from the original graph to the new graph,\nyou can use a dictionary like the one constructed in the above\nexample:\nforsource,nodesinsources.items():\nforvinnodes:\nB.nodes[v].update(G.nodes[source])",
    "Section ID: descendants\nDescription: [Returns all nodes reachable from source in G .]\nField List: Parameters:: G : NetworkX Graph: \nsource : node inG:\nReturns:: set(): The descendants ofsourceinG\nRaises:: NetworkXError: If nodesourceis not inG.\nMethods: []\nRubrics: Examples: DG=nx.path_graph(5,create_using=nx.DiGraph)\nsorted(nx.descendants(DG,2))\n# [3, 4]\nThesourcenode is not a descendant of itself, but can be included manually:\nsorted(nx.descendants(DG,2)|{2})\n# [2, 3, 4]",
    "Section ID: spectral_layout\nDescription: [Position nodes using the eigenvectors of the graph Laplacian., Using the unnormalized Laplacian, the layout shows possible clusters of\nnodes which are an approximation of the ratio cut. If dim is the number of\ndimensions then the positions are the entries of the dim eigenvectors\ncorresponding to the ascending eigenvalues starting from the second one.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G.\nweight : string or None   optional (default=’weight’): The edge attribute that holds the numerical value used for\nthe edge weight.  If None, then all edge weights are 1.\nscale : number (default: 1): Scale factor for positions.\ncenter : array-like or None: Coordinate pair around which to center the layout.\ndim : int: Dimension of layout.\nReturns:: pos : dict: A dictionary of positions keyed by node\nMethods: []\nRubrics: Notes: Directed graphs will be considered as undirected graphs when\npositioning the nodes. For larger graphs (>500 nodes) this will use the SciPy sparse\neigenvalue solver (ARPACK).\nExamples: G=nx.path_graph(4)\npos=nx.spectral_layout(G)",
    "Section ID: find_threshold_graph\nDescription: [Returns a threshold subgraph that is close to largest in G ., The threshold graph will contain the largest degree node in G.]\nField List: Parameters:: G : NetworkX graph instance: An instance ofGraph, orMultiDiGraph\ncreate_using : NetworkX graph class orNone(default), optional: Type of graph to use when constructing the threshold graph.\nIfNone, infer the appropriate graph type from the input.\nReturns:: graph: A graph instance representing the threshold graph\nMethods: []\nRubrics: References: [1]Threshold graphs:https://en.wikipedia.org/wiki/Threshold_graph\nExamples: fromnetworkx.algorithms.thresholdimportfind_threshold_graph\nG=nx.barbell_graph(3,3)\nT=find_threshold_graph(G)\nT.nodes# may vary\n# NodeView((7, 8, 5, 6))",
    "Section ID: number_of_selfloops\nDescription: [Returns the number of selfloop edges., A selfloop edge has the same node at both ends.]\nField List: Returns:: nloops : int: The number of selfloops.\nMethods: []\nRubrics: Examples: G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(1,1)\nG.add_edge(1,2)\nnx.number_of_selfloops(G)\n# 1",
    "Section ID: triad_type\nDescription: [Returns the sociological triad type for a triad.]\nField List: Parameters:: G : digraph: A NetworkX DiGraph with 3 nodes\nReturns:: triad_type : str: A string identifying the triad type\nMethods: []\nRubrics: Notes: There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\ntriads given 3 nodes). These 64 triads each display exactly 1 of 16\ntopologies of triads (topologies can be permuted). These topologies are\nidentified by the following notation: {m}{a}{n}{type} (for example: 111D, 210, 102) Here:\nReferences: [1]Snijders, T. (2012). “Transitivity and triads.” University of\nOxford.https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\nExamples: G=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.triad_type(G)\n# '030C'\nG.add_edge(1,3)\nnx.triad_type(G)\n# '120C'",
    "Section ID: is_threshold_graph\nDescription: [Returns True if G is a threshold graph.]\nField List: Parameters:: G : NetworkX graph instance: An instance ofGraph,DiGraph,MultiGraphorMultiDiGraph\nReturns:: bool: TrueifGis a threshold graph,Falseotherwise.\nMethods: []\nRubrics: References: [1]Threshold graphs:https://en.wikipedia.org/wiki/Threshold_graph\nExamples: fromnetworkx.algorithms.thresholdimportis_threshold_graph\nG=nx.path_graph(3)\nis_threshold_graph(G)\n# True\nG=nx.barbell_graph(3,3)\nis_threshold_graph(G)\n# False",
    "Section ID: cn_soundarajan_hopcroft\nDescription: []\nField List: Parameters:: G : graph: A NetworkX undirected graph.\nebunch : iterable of node pairs, optional (default = None): The score will be computed for each pair of nodes given in the\niterable. The pairs must be given as 2-tuples (u, v) where u\nand v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.\ncommunity : string, optional (default = ‘community’): Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: ‘community’.\nReturns:: piter : iterator: An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their score.\nRaises:: NetworkXNotImplemented: IfGis aDiGraph, aMultigraphor aMultiDiGraph.\nNetworkXAlgorithmError: If no community information is available for a node inebunchor inG(ifebunchisNone).\nNodeNotFound: Ifebunchhas a node that is not inG.\nMethods: []\nRubrics: References: [1]Sucheta Soundarajan and John Hopcroft.\nUsing community information to improve the precision of link\nprediction methods.\nIn Proceedings of the 21st international conference companion on\nWorld Wide Web (WWW ‘12 Companion). ACM, New York, NY, USA, 607-608.http://doi.acm.org/10.1145/2187980.2188150\nExamples: G=nx.path_graph(3)\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=0\nG.nodes[2][\"community\"]=0\npreds=nx.cn_soundarajan_hopcroft(G,[(0,2)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 2) -> 2",
    "Section ID: minimum_node_cut\nDescription: [Returns a set of nodes of minimum cardinality that disconnects G., If source and target nodes are provided, this function returns the\nset of nodes of minimum cardinality that, if removed, would destroy\nall paths among source and target in G. If not, it returns a set\nof nodes of minimum cardinality that disconnects G.]\nField List: Parameters:: G : NetworkX graph: \ns : node: Source node. Optional. Default value: None.\nt : node: Target node. Optional. Default value: None.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.\nReturns:: cutset : set: Set of nodes that, if removed, would disconnect G. If source\nand target nodes are provided, the set contains the nodes that\nif removed, would destroy all paths between source and target.\nMethods: []\nRubrics: Notes: This is a flow based implementation of minimum node cut. The algorithm\nis based in solving a number of maximum flow computations to determine\nthe capacity of the minimum cut on an auxiliary directed network that\ncorresponds to the minimum node cut of G. It handles both directed\nand undirected graphs. This implementation is based on algorithm 11\nin [1] .\nReferences: [1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf\nExamples: # Platonic icosahedral graph has node connectivity 5\nG=nx.icosahedral_graph()\nnode_cut=nx.minimum_node_cut(G)\nlen(node_cut)\n# 5\nYou can use alternative flow algorithms for the underlying maximum\nflow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions. Alternative\nflow functions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnode_cut==nx.minimum_node_cut(G,flow_func=shortest_augmenting_path)\n# True\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns a local st node cut.\nlen(nx.minimum_node_cut(G,3,7))\n# 5\nIf you need to perform several local st cuts among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seeminimum_st_node_cut()for details.",
    "Section ID: no_filter\nDescription: [Returns a filter function that always evaluates to True.]\nField List: Methods: []\nRubrics:",
    "Section ID: tutte_graph\nDescription: [Returns the Tutte graph., The Tutte graph is a cubic polyhedral, non-Hamiltonian graph. It has\n46 nodes and 69 edges.\nIt is a counterexample to Tait’s conjecture that every 3-regular polyhedron\nhas a Hamiltonian cycle.\nIt can be realized geometrically from a tetrahedron by multiply truncating\nthree of its vertices [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Tutte graph\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Tutte_graph",
    "Section ID: gutman_index\nDescription: [Returns the Gutman Index for the graph G ., The Gutman Index measures the topology of networks, especially for molecule\nnetworks of atoms connected by bonds [1] . It is also called the Schultz Index\nof the second kind [2] ., Consider an undirected graph G with node set V .\nThe Gutman Index of a graph is the sum over all (unordered) pairs of nodes\nof nodes (u,v) , with distance dist(u,v) and degrees deg(u) and deg(v) , of dist(u,v)*deg(u)*deg(v)]\nField List: Parameters:: G : NetworkX graph: \nweight : string or None, optional (default: None): If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances.\nReturns:: number: The Gutman Index of the graphG.\nMethods: []\nRubrics: References: [1]M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\nCroatica Chemica Acta, 71 (1998), 21-51.https://hrcak.srce.hr/132323  [2]I. Gutman, Selected properties of the Schultz molecular topological index,\nJ. Chem. Inf. Comput. Sci. 34 (1994), 1087–1089.https://doi.org/10.1021/ci00021a009\nExamples: The Gutman Index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes times(n-1)*(n-1),\nsince each pair of nodes is at distance one and the product of degree of two\nvertices is(n-1)*(n-1).\nn=10\nG=nx.complete_graph(n)\nnx.gutman_index(G)==(n*(n-1)/2)*((n-1)*(n-1))\n# True\nGraphs that are disconnected\nG=nx.empty_graph(2)\nnx.gutman_index(G)\n# inf",
    "Section ID: eppstein_matching\nDescription: [Returns the maximum cardinality matching of the bipartite graph G .]\nField List: Parameters:: G : NetworkX graph: Undirected bipartite graph\ntop_nodes : container: Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised.\nReturns:: matches : dictionary: The matching is returned as a dictionary,matching, such thatmatching[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatching.\nRaises:: AmbiguousSolution: Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected.\nMethods: []\nRubrics: Notes: This function is implemented with David Eppstein’s version of the algorithm\nHopcroft–Karp algorithm (see hopcroft_karp_matching() ), which\noriginally appeared in the Python Algorithms and Data Structures library\n(PADS) . See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
    "Section ID: min_cost_flow_cost\nDescription: [Find the cost of a minimum cost flow satisfying all demands in digraph G., G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.]\nField List: Parameters:: G : NetworkX graph: DiGraph on which a minimum cost flow satisfying all demands is\nto be found.\ndemand : string: Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: ‘demand’.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nweight : string: Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: ‘weight’.\nReturns:: flowCost : integer, float: Cost of a minimum cost flow satisfying all demands.\nRaises:: NetworkXError: This exception is raised if the input graph is not directed or\nnot connected.\nNetworkXUnfeasible: This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.\nNetworkXUnbounded: This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below.\nMethods: []\nRubrics: Notes: This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\nExamples: A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost=nx.min_cost_flow_cost(G)\nflowCost\n# 24",
    "Section ID: maximum_matching\nDescription: [Returns the maximum cardinality matching in the given bipartite graph., This function is simply an alias for hopcroft_karp_matching() .]\nField List: Methods: []\nRubrics:",
    "Section ID: to_networkx_graph\nDescription: [Make a NetworkX graph from a known data structure., The preferred way to call this is automatically\nfrom the class constructor, instead of the equivalent]\nField List: Parameters:: data : object to be converted: Current known types are:any NetworkX graph\ndict-of-dicts\ndict-of-lists\ncontainer (e.g. set, list, tuple) of edges\niterator (e.g. itertools.chain) that produces edges\ngenerator of edges\nPandas DataFrame (row per edge)\n2D numpy array\nscipy sparse array\npygraphviz agraph\nCurrent known types are:: any NetworkX graph\ndict-of-dicts\ndict-of-lists\ncontainer (e.g. set, list, tuple) of edges\niterator (e.g. itertools.chain) that produces edges\ngenerator of edges\nPandas DataFrame (row per edge)\n2D numpy array\nscipy sparse array\npygraphviz agraph\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nmultigraph_input : bool (default False): If True and  data is a dict_of_dicts,\ntry to create a multigraph assuming dict_of_dict_of_lists.\nIf data and create_using are both multigraphs then create\na multigraph from a multigraph.\nMethods: []\nRubrics:",
    "Section ID: heawood_graph\nDescription: [Returns the Heawood Graph, a (3,6) cage., The Heawood Graph is an undirected graph with 14 nodes and 21 edges,\nnamed after Percy John Heawood [1] .\nIt is cubic symmetric, nonplanar, Hamiltonian, and can be represented\nin LCF notation as [5,-5]^7  [2] .\nIt is the unique (3,6)-cage: the regular cubic graph of girth 6 with\nminimal number of vertices [3] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Heawood Graph with 14 nodes and 21 edges\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Heawood_graph  [2]https://mathworld.wolfram.com/HeawoodGraph.html  [3]https://www.win.tue.nl/~aeb/graphs/Heawood.html",
    "Section ID: rooted_tree_isomorphism\nDescription: [Given two rooted trees t1 and t2 ,\nwith roots root1 and root2 respectively\nthis routine will determine if they are isomorphic., These trees may be either directed or undirected,\nbut if they are directed, all edges should flow from the root., It returns the isomorphism, a mapping of the nodes of t1 onto the nodes\nof t2 , such that two trees are then identical., Note that two trees may have more than one isomorphism, and this\nroutine just returns one valid mapping.]\nField List: Parameters:: `t1` : NetworkX graph: One of the trees being compared\n`root1` : a node oft1which is the root of the tree: \n`t2` : undirected NetworkX graph: The other tree being compared\n`root2` : a node oft2which is the root of the tree: \nThis is a subroutine used to implement `tree_isomorphism`, but will: \nbe somewhat faster if you already have rooted trees.:\nReturns:: isomorphism : list: A list of pairs in which the left element is a node int1and the right element is a node int2.  The pairs are in\narbitrary order.  If the nodes in one tree is mapped to the names in\nthe other, then trees will be identical. Note that an isomorphism\nwill not necessarily be unique.Ift1andt2are not isomorphic, then it returns the empty list.\nMethods: []\nRubrics:",
    "Section ID: kosaraju_strongly_connected_components\nDescription: [Generate nodes in strongly connected components of graph.]\nField List: Parameters:: G : NetworkX Graph: A directed graph.\nReturns:: comp : generator of sets: A generator of sets of nodes, one for each strongly connected\ncomponent of G.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: Uses Kosaraju’s algorithm.\nExamples: Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[\nlen(c)\nforcinsorted(\nnx.kosaraju_strongly_connected_components(G),key=len,reverse=True\n)\n]\n# [4, 3]\nIf you only want the largest component, it’s more efficient to\nuse max instead of sort.\nlargest=max(nx.kosaraju_strongly_connected_components(G),key=len)",
    "Section ID: partition_quality\nDescription: [Returns the coverage and performance of a partition of G., The coverage of a partition is the ratio of the number of\nintra-community edges to the total number of edges in the graph., The performance of a partition is the number of\nintra-community edges plus inter-community non-edges divided by the total\nnumber of potential edges., This algorithm has complexity \\(O(C^2 + L)\\) where C is the number of communities and L is the number of links.]\nField List: Parameters:: G : NetworkX graph: \npartition : sequence: Partition of the nodes ofG, represented as a sequence of\nsets of nodes (blocks). Each block of the partition represents a\ncommunity.\nReturns:: (float, float): The (coverage, performance) tuple of the partition, as defined above.\nRaises:: NetworkXError: Ifpartitionis not a valid partition of the nodes ofG.\nMethods: []\nRubrics: Notes: \nReferences: [1]Santo Fortunato.\n“Community Detection in Graphs”.Physical Reports, Volume 486, Issue 3–5 pp. 75–174\n<https://arxiv.org/abs/0906.0612>",
    "Section ID: from_dict_of_dicts\nDescription: [Returns a graph from a dictionary of dictionaries.]\nField List: Parameters:: d : dictionary of dictionaries: A dictionary of dictionaries adjacency representation.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nmultigraph_input : bool (default False): When True, the dictdis assumed\nto be a dict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nOtherwise this routine assumes dict-of-dict-of-dict keyed by\nnode to neighbor to edge data.\nMethods: []\nRubrics: Examples: dod={0:{1:{\"weight\":1}}}# single edge (0,1)\nG=nx.from_dict_of_dicts(dod)\nor\nG=nx.Graph(dod)# use Graph constructor",
    "Section ID: max_weight_matching\nDescription: [Compute a maximum-weighted matching of G., A matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nmaxcardinality: bool, optional (default=False): If maxcardinality is True, compute the maximum-cardinality matching\nwith maximum weight among all maximum-cardinality matchings.\nweight: string, optional (default=’weight’): Edge data key corresponding to the edge weight.\nIf key not found, uses 1 as weight.\nReturns:: matching : set: A maximal matching of the graph.\nMethods: []\nRubrics: Notes: If G has edges with weight attributes the edge data are used as\nweight values else the weights are assumed to be 1. This function takes time O(number_of_nodes ** 3). If all edge weights are integers, the algorithm uses only integer\ncomputations.  If floating point weights are used, the algorithm\ncould return a slightly suboptimal matching due to numeric\nprecision errors. This method is based on the “blossom” method for finding augmenting\npaths and the “primal-dual” method for finding a matching of maximum\nweight, both methods invented by Jack Edmonds [1] . Bipartite graphs can also be matched using the functions present in networkx.algorithms.bipartite.matching .\nReferences: [1]“Efficient Algorithms for Finding Maximum Matching in Graphs”,\nZvi Galil, ACM Computing Surveys, 1986.\nExamples: G=nx.Graph()\nedges=[(1,2,6),(1,3,2),(2,3,1),(2,4,7),(3,5,9),(4,5,3)]\nG.add_weighted_edges_from(edges)\nsorted(nx.max_weight_matching(G))\n# [(2, 4), (5, 3)]",
    "Section ID: treewidth_min_fill_in\nDescription: [Returns a treewidth decomposition using the Minimum Fill-in heuristic., The heuristic chooses a node from the graph, where the number of edges\nadded turning the neighborhood of the chosen node into clique is as\nsmall as possible.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: Treewidth decomposition : (int, Graph) tuple: 2-tuple with treewidth and the corresponding decomposed tree.\nMethods: []\nRubrics:",
    "Section ID: is_tournament\nDescription: [Returns True if and only if G is a tournament., A tournament is a directed graph, with neither self-loops nor\nmulti-edges, in which there is exactly one directed edge joining\neach pair of distinct nodes.]\nField List: Parameters:: G : NetworkX graph: A directed graph representing a tournament.\nReturns:: bool: Whether the given graph is a tournament graph.\nMethods: []\nRubrics: Notes: Some definitions require a self-loop on each node, but that is not\nthe convention used here.\nExamples: G=nx.DiGraph([(0,1),(1,2),(2,0)])\nnx.is_tournament(G)\n# True",
    "Section ID: attracting_components\nDescription: [Generates the attracting components in G ., An attracting component in a directed graph G is a strongly connected\ncomponent with the property that a random walker on the graph will never\nleave the component, once it enters the component., The nodes in attracting components can also be thought of as recurrent\nnodes.  If a random walker enters the attractor containing the node, then\nthe node will be visited infinitely often., To obtain induced subgraphs on each component use: (G.subgraph(c).copy()forcinattracting_components(G))]\nField List: Parameters:: G : DiGraph, MultiDiGraph: The graph to be analyzed.\nReturns:: attractors : generator of sets: A generator of sets of nodes, one for each attracting component of G.\nRaises:: NetworkXNotImplemented: If the input graph is undirected.\nMethods: []\nRubrics:",
    "Section ID: connected_double_edge_swap\nDescription: [Attempts the specified number of double-edge swaps in the graph G ., A double-edge swap removes two randomly chosen edges (u,v) and (x,y) and creates the new edges (u,x) and (v,y) :, If either (u,x) or (v,y) already exist, then no swap is performed\nso the actual number of swapped edges is always at most  nswap .]\nField List: Parameters:: G : graph: An undirected graph\nnswap : integer (optional, default=1): Number of double-edge swaps to perform\n_window_threshold : integer: The window size below which connectedness of the graph will be checked\nafter each swap.The “window” in this function is a dynamically updated integer that\nrepresents the number of swap attempts to make before checking if the\ngraph remains connected. It is an optimization used to decrease the\nrunning time of the algorithm in exchange for increased complexity of\nimplementation.If the window size is below this threshold, then the algorithm checks\nafter each swap if the graph remains connected by checking if there is a\npath joining the two nodes whose edge was just removed. If the window\nsize is above this threshold, then the algorithm performs do all the\nswaps in the window and only then check if the graph is still connected.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: int: The number of successful swaps\nRaises:: NetworkXError: If the input graph is not connected, or if the graph has fewer than four\nnodes.\nMethods: []\nRubrics: Notes: The initial graph G must be connected, and the resulting graph is\nconnected. The graph G is modified in place.\nReferences: [1]C. Gkantsidis and M. Mihail and E. Zegura,\nThe Markov chain simulation method for generating connected\npower law random graphs, 2003.http://citeseer.ist.psu.edu/gkantsidis03markov.html",
    "Section ID: all_node_cuts\nDescription: [Returns all minimum k cutsets of an undirected graph G., This implementation is based on Kanevsky’s algorithm [1] for finding all\nminimum-size node cut-sets of an undirected graph G; ie the set (or sets)\nof nodes of cardinality equal to the node connectivity of G. Thus if\nremoved, would break G into two or more connected components.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nk : Integer: Node connectivity of the input graph. If k is None, then it is\ncomputed. Default value: None.\nflow_func : function: Function to perform the underlying flow computations. Default value isedmonds_karp(). This function performs\nbetter in sparse graphs with right tailed degree distributions.shortest_augmenting_path()will\nperform better in denser graphs.\nReturns:: cuts : a generator of node cutsets: Each node cutset has cardinality equal to the node connectivity of\nthe input graph.\nMethods: []\nRubrics: Notes: This implementation is based on the sequential algorithm for finding all\nminimum-size separating vertex sets in a graph [1] . The main idea is to\ncompute minimum cuts using local maximum flow computations among a set\nof nodes of highest degree and all other non-adjacent nodes in the Graph.\nOnce we find a minimum cut, we add an edge between the high degree\nnode and the target node of the local maximum flow computation to make\nsure that we will not find that minimum cut again.\nReferences: [1](1,2)Kanevsky, A. (1993). Finding all minimum-size separating vertex\nsets in a graph. Networks 23(6), 533–541.http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract\nExamples: # A two-dimensional grid graph has 4 cutsets of cardinality 2\nG=nx.grid_2d_graph(5,5)\ncutsets=list(nx.all_node_cuts(G))\nlen(cutsets)\n# 4\nall(2==len(cutset)forcutsetincutsets)\n# True\nnx.node_connectivity(G)\n# 2",
    "Section ID: karate_club_graph\nDescription: [Returns Zachary’s Karate Club graph., Each node in the returned graph has a node attribute ‘club’ that\nindicates the name of the club to which the member represented by that node\nbelongs, either ‘Mr. Hi’ or ‘Officer’. Each edge has a weight based on the\nnumber of contexts in which that edge’s incident node members interacted., References, Examples, To get the name of the club to which a node belongs:]\nField List: Methods: []\nRubrics: References: [1]Zachary, Wayne W.\n“An Information Flow Model for Conflict and Fission in Small Groups.”Journal of Anthropological Research, 33, 452–473, (1977).\nExamples: To get the name of the club to which a node belongs:\nG=nx.karate_club_graph()\nG.nodes[5][\"club\"]\n# 'Mr. Hi'\nG.nodes[9][\"club\"]\n# 'Officer'",
    "Section ID: is_dominating_set\nDescription: [Checks if nbunch is a dominating set for G ., A dominating set for a graph with node set V is a subset D of V such that every node not in D is adjacent to at least one\nmember of D  [1] .]\nField List: Parameters:: G : NetworkX graph: \nnbunch : iterable: An iterable of nodes in the graphG.\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Dominating_set",
    "Section ID: girth\nDescription: [Returns the girth of the graph., The girth of a graph is the length of its shortest cycle, or infinity if\nthe graph is acyclic. The algorithm follows the description given on the\nWikipedia page [1] , and runs in time O(mn) on a graph with m edges and n\nnodes.]\nField List: Parameters:: G : NetworkX Graph:\nReturns:: int or math.inf:\nMethods: []\nRubrics: References: [1]Wikipedia: Girth\nExamples: All examples below (except P_5) can easily be checked using Wikipedia,\nwhich has a page for each of these famous graphs.\nnx.girth(nx.chvatal_graph())\n# 4\nnx.girth(nx.tutte_graph())\n# 4\nnx.girth(nx.petersen_graph())\n# 5\nnx.girth(nx.heawood_graph())\n# 6\nnx.girth(nx.pappus_graph())\n# 6\nnx.girth(nx.path_graph(5))\n# inf",
    "Section ID: subgraph_view\nDescription: [View of G applying a filter on nodes and edges., subgraph_view provides a read-only view of the input graph that excludes\nnodes and edges based on the outcome of two filter functions filter_node and filter_edge ., The filter_node function takes one argument — the node — and returns True if the node should be included in the subgraph, and False if it\nshould not be included., The filter_edge function takes two (or three arguments if G is a\nmulti-graph) — the nodes describing an edge, plus the edge-key if\nparallel edges are possible — and returns True if the edge should be\nincluded in the subgraph, and False if it should not be included., Both node and edge filter functions are called on graph elements as they\nare queried, meaning there is no up-front cost to creating the view.]\nField List: Parameters:: G : networkx.Graph: A directed/undirected graph/multigraph\nfilter_node : callable, optional: A function taking a node as input, which returnsTrueif the node\nshould appear in the view.\nfilter_edge : callable, optional: A function taking as input the two nodes describing an edge (plus the\nedge-key ifGis a multi-graph), which returnsTrueif the edge\nshould appear in the view.\nReturns:: graph : networkx.Graph: A read-only graph view of the input graph.\nMethods: []\nRubrics: Examples: G=nx.path_graph(6)\nFilter functions operate on the node, and returnTrueif the node should\nappear in the view:\ndeffilter_node(n1):\nreturnn1!=5\nview=nx.subgraph_view(G,filter_node=filter_node)\nview.nodes()\n# NodeView((0, 1, 2, 3, 4))\nWe can use a closure pattern to filter graph elements based on additional\ndata — for example, filtering on edge data attached to the graph:\nG[3][4][\"cross_me\"]=False\ndeffilter_edge(n1,n2):\nreturnG[n1][n2].get(\"cross_me\",True)\nview=nx.subgraph_view(G,filter_edge=filter_edge)\nview.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3), (4, 5)])\nview=nx.subgraph_view(\nG,\nfilter_node=filter_node,\nfilter_edge=filter_edge,\n)\nview.nodes()\n# NodeView((0, 1, 2, 3, 4))\nview.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])",
    "Section ID: is_kl_connected\nDescription: [Returns True if and only if G is locally (k,l) -connected., A graph is locally (k,l) -connected if for each edge (u,v) in the\ngraph there are at least l edge-disjoint paths of length at most k joining u to v .]\nField List: Parameters:: G : NetworkX graph: The graph to test for local(k,l)-connectedness.\nk : integer: The maximum length of paths to consider. A higher number means a looser\nconnectivity requirement.\nl : integer: The number of edge-disjoint paths. A higher number means a stricter\nconnectivity requirement.\nlow_memory : bool: If this is True, this function uses an algorithm that uses slightly\nmore time but less memory.\nReturns:: bool: Whether the graph is locally(k,l)-connected subgraph.\nMethods: []\nRubrics: References: [1]Chung, Fan and Linyuan Lu. “The Small World Phenomenon in Hybrid\nPower Law Graphs.”Complex Networks. Springer Berlin Heidelberg,\n2004. 89–104.",
    "Section ID: pagerank\nDescription: [Returns the PageRank of the nodes in the graph., PageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages.]\nField List: Parameters:: G : graph: A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.\nalpha : float, optional: Damping parameter for PageRank, default=0.85.\npersonalization: dict, optional: The “personalization vector” consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.\nmax_iter : integer, optional: Maximum number of iterations in power method eigenvalue solver.\ntol : float, optional: Error tolerance used to check convergence in power method solver.\nThe iteration will stop after a tolerance oflen(G)*tolis reached.\nnstart : dictionary, optional: Starting value of PageRank iteration for each node.\nweight : key, optional: Edge data key to use as weight.  If None weights are set to 1.\ndangling: dict, optional: The outedges to be assigned to any “dangling” nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified). This must be selected to result in an irreducible transition\nmatrix (see notes under google_matrix). It may be common to have the\ndangling dict to be the same as the personalization dict.\nReturns:: pagerank : dictionary: Dictionary of nodes with PageRank as value\nRaises:: PowerIterationFailedConvergence: If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod.\nMethods: []\nRubrics: Notes: The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop after\nan error tolerance of len(G)*tol has been reached. If the\nnumber of iterations exceed max_iter , a networkx.exception.PowerIterationFailedConvergence exception\nis raised. The PageRank algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs by converting each edge in the\ndirected graph to two edges.\nReferences: [1]A. Langville and C. Meyer,\n“A survey of eigenvector methods of web information retrieval.”http://citeseer.ist.psu.edu/713792.html  [2]Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\nThe PageRank citation ranking: Bringing order to the Web. 1999http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf\nExamples: G=nx.DiGraph(nx.path_graph(4))\npr=nx.pagerank(G,alpha=0.9)",
    "Section ID: node_clique_number\nDescription: [Returns the size of the largest maximal clique containing each given node., Returns a single or list depending on input nodes.\nAn optional list of cliques can be input if already computed.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\ncliques : list, optional (default=None): A list of cliques, each of which is itself a list of nodes.\nIf not specified, the list of all cliques will be computed\nusingfind_cliques().\nReturns:: int or dict: Ifnodesis a single node, returns the size of the\nlargest maximal clique inGcontaining that node.\nOtherwise return a dict keyed by node to the size\nof the largest maximal clique containing that node.\nMethods: []\nRubrics:",
    "Section ID: barabasi_albert_graph\nDescription: [Returns a random graph using Barabási–Albert preferential attachment, A graph of \\(n\\) nodes is grown by attaching new nodes each with \\(m\\) edges that are preferentially attached to existing nodes with high degree.]\nField List: Parameters:: n : int: Number of nodes\nm : int: Number of edges to attach from a new node to existing nodes\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ninitial_graph : Graph or None (default): Initial network for Barabási–Albert algorithm.\nIt should be a connected graph for most use cases.\nA copy ofinitial_graphis used.\nIf None, starts from a star graph on (m+1) nodes.\nReturns:: G : Graph:\nRaises:: NetworkXError: Ifmdoes not satisfy1<=m<n, or\nthe initial graph number of nodes m0 does not satisfym<=m0<=n.\nMethods: []\nRubrics: References: [1]A. L. Barabási and R. Albert “Emergence of scaling in\nrandom networks”, Science 286, pp 509-512, 1999.",
    "Section ID: all_pairs_node_connectivity\nDescription: [Compute node connectivity between all pairs of nodes of G.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nnbunch: container: Container of nodes. If provided node connectivity will be computed\nonly over pairs of nodes in nbunch.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.\nReturns:: all_pairs : dict: A dictionary with node connectivity between all pairs of nodes\nin G, or in nbunch if provided.\nMethods: []\nRubrics:",
    "Section ID: read_gml\nDescription: [Read graph in GML format from path .]\nField List: Parameters:: path : filename or filehandle: The filename or filehandle to read from.\nlabel : string, optional: If not None, the parsed nodes will be renamed according to node\nattributes indicated bylabel. Default value: ‘label’.\ndestringizer : callable, optional: Adestringizerthat recovers values stored as strings in GML. If it\ncannot convert a string to a value, aValueErroris raised. Default\nvalue : None.\nReturns:: G : NetworkX graph: The parsed graph.\nRaises:: NetworkXError: If the input cannot be parsed.\nMethods: []\nRubrics: Notes: GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.\nExamples: G=nx.path_graph(4)\nnx.write_gml(G,\"test.gml\")\nGML values are interpreted as strings by default:\nH=nx.read_gml(\"test.gml\")\nH.nodes\n# NodeView(('0', '1', '2', '3'))\nWhen adestringizeris provided, GML values are converted to the provided type.\nFor example, integer nodes can be recovered as shown below:\nJ=nx.read_gml(\"test.gml\",destringizer=int)\nJ.nodes\n# NodeView((0, 1, 2, 3))",
    "Section ID: from_graph6_bytes\nDescription: [Read a simple undirected graph in graph6 format from bytes.]\nField List: Parameters:: bytes_in : bytes: Data in graph6 format, without a trailing newline.\nReturns:: G : Graph:\nRaises:: NetworkXError: If bytes_in is unable to be parsed in graph6 format\nValueError: If any charactercin bytes_in does not satisfy63<=ord(c)<127.\nMethods: []\nRubrics: References: [1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>\nExamples: G=nx.from_graph6_bytes(b\"A_\")\nsorted(G.edges())\n# [(0, 1)]",
    "Section ID: lowest_common_ancestor\nDescription: [Compute the lowest common ancestor of the given pair of nodes.]\nField List: Parameters:: G : NetworkX directed graph: \nnode1, node2 : nodes in the graph.: \ndefault : object: Returned if no common ancestor betweennode1andnode2\nReturns:: The lowest common ancestor of node1 and node2,: \nor default if they have no common ancestors.:\nMethods: []\nRubrics: Examples: G=nx.DiGraph()\nnx.add_path(G,(0,1,2,3))\nnx.add_path(G,(0,4,3))\nnx.lowest_common_ancestor(G,2,4)\n# 0",
    "Section ID: triangles\nDescription: [Compute the number of triangles., Finds the number of triangles that include a node as one vertex.]\nField List: Parameters:: G : graph: A networkx graph\nnodes : node, iterable of nodes, or None (default=None): If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG.\nReturns:: out : dict or int: Ifnodesis a container of nodes, returns number of triangles keyed by node (dict).\nIfnodesis a specific node, returns number of triangles for the node (int).\nMethods: []\nRubrics: Notes: Self loops are ignored.\nExamples: G=nx.complete_graph(5)\nprint(nx.triangles(G,0))\n# 6\nprint(nx.triangles(G))\n# {0: 6, 1: 6, 2: 6, 3: 6, 4: 6}\nprint(list(nx.triangles(G,[0,1]).values()))\n# [6, 6]",
    "Section ID: directed_modularity_matrix\nDescription: [Returns the directed modularity matrix of G., The modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the expected adjacency matrix, assuming that the graph\nis described by the configuration model., More specifically, the element B_ij of B is defined as, where \\(k_i^{in}\\) is the in degree of node i, and \\(k_j^{out}\\) is the out degree\nof node j, with m the number of edges in the graph. When weight is set\nto a name of an attribute edge, Aij, k_i, k_j and m are computed using\nits value.]\nField List: Parameters:: G : DiGraph: A NetworkX DiGraph\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nweight : string or None, optional (default=None): The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1.\nReturns:: B : Numpy array: The modularity matrix of G.\nMethods: []\nRubrics: Notes: NetworkX defines the element A_ij of the adjacency matrix as 1 if there\nis a link going from node i to node j. Leicht and Newman use the opposite\ndefinition. This explains the different expression for B_ij.\nReferences: [1]E. A. Leicht, M. E. J. Newman,\n“Community structure in directed networks”,\nPhys. Rev Lett., vol. 100, no. 11, p. 118703, 2008.\nExamples: G=nx.DiGraph()\nG.add_edges_from(\n(\n(1,2),\n(1,3),\n(3,1),\n(3,2),\n(3,5),\n(4,5),\n(4,6),\n(5,4),\n(5,6),\n(6,4),\n)\n)\nB=nx.directed_modularity_matrix(G)",
    "Section ID: multi_source_dijkstra\nDescription: [Find shortest weighted paths and lengths from a given set of\nsource nodes., Uses Dijkstra’s algorithm to compute the shortest paths and lengths\nbetween one of the source nodes and the given target , or all other\nreachable nodes if not specified, for a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsources : non-empty set of nodes: Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.\ntarget : node label, optional: Ending node for path\ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: distance, path : pair of dictionaries, or numeric and list: If target is None, returns a tuple of two dictionaries keyed by node.\nThe first dictionary stores distance from one of the source nodes.\nThe second stores the path from one of the sources to that node.\nIf target is not None, returns a tuple of (distance, path) where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target.\nRaises:: ValueError: Ifsourcesis empty.\nNodeNotFound: If any ofsourcesis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. Based on the Python cookbook recipe (119466) at https://code.activestate.com/recipes/119466/ This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).\nExamples: G=nx.path_graph(5)\nlength,path=nx.multi_source_dijkstra(G,{0,4})\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 1\n# 4: 0\npath[1]\n# [0, 1]\npath[3]\n# [4, 3]\nlength,path=nx.multi_source_dijkstra(G,{0,4},1)\nlength\n# 1\npath\n# [0, 1]",
    "Section ID: full_join\nDescription: [Returns the full join of graphs G and H., Full join is the union of G and H in which all edges between\nG and H are added.\nThe node sets of G and H must be disjoint,\notherwise an exception is raised.]\nField List: Parameters:: G, H : graph: A NetworkX graph\nrename : tuple , default=(None, None): Node names of G and H can be changed by specifying the tuple\nrename=(‘G-‘,’H-’) (for example).  Node “u” in G is then renamed\n“G-u” and “v” in H is renamed “H-v”.\nReturns:: U : The full join graph with the same type as G.:\nMethods: []\nRubrics: Notes: It is recommended that G and H be either both directed or both undirected. If G is directed, then edges from G to H are added as well as from H to G. Note that full_join() does not produce parallel edges for MultiGraphs. The full join operation of graphs G and H is the same as getting\ntheir complement, performing a disjoint union, and finally getting\nthe complement of the resulting graph. Graph, edge, and node attributes are propagated from G and H\nto the union graph.  If a graph attribute is present in both\nG and H the value from H is used.\nExamples: G=nx.Graph([(0,1),(0,2)])\nH=nx.Graph([(3,4)])\nR=nx.full_join(G,H,rename=(\"G\",\"H\"))\nR.nodes\n# NodeView(('G0', 'G1', 'G2', 'H3', 'H4'))\nR.edges\n# EdgeView([('G0', 'G1'), ('G0', 'G2'), ('G0', 'H3'), ('G0', 'H4'), ('G1', 'H3'), ('G1', 'H4'), ('G2', 'H3'), ('G2', 'H4'), ('H3', 'H4')])",
    "Section ID: simple_cycles\nDescription: [Find simple cycles (elementary circuits) of a graph., A simplecycle , or elementarycircuit , is a closed path where\nno node appears twice.  In a directed graph, two simple cycles are distinct\nif they are not cyclic permutations of each other.  In an undirected graph,\ntwo simple cycles are distinct if they are not cyclic permutations of each\nother nor of the other’s reversal., Optionally, the cycles are bounded in length.  In the unbounded case, we use\na nonrecursive, iterator/generator version of Johnson’s algorithm [1] .  In\nthe bounded case, we use a version of the algorithm of Gupta and\nSuzumura[R155c03fc9e2e-2]_. There may be better algorithms for some cases [3]  [4]  [5] ., The algorithms of Johnson, and Gupta and Suzumura, are enhanced by some\nwell-known preprocessing techniques.  When G is directed, we restrict our\nattention to strongly connected components of G, generate all simple cycles\ncontaining a certain node, remove that node, and further decompose the\nremainder into strongly connected components.  When G is undirected, we\nrestrict our attention to biconnected components, generate all simple cycles\ncontaining a particular edge, remove that edge, and further decompose the\nremainder into biconnected components., Note that multigraphs are supported by this function – and in undirected\nmultigraphs, a pair of parallel edges is considered a cycle of length 2.\nLikewise, self-loops are considered to be cycles of length 1.  We define\ncycles as sequences of nodes; so the presence of loops and parallel edges\ndoes not change the number of simple cycles in a graph.]\nField List: Parameters:: G : NetworkX DiGraph: A directed graph\nlength_bound : int or None, optional (default=None): If length_bound is an int, generate all simple cycles of G with length at\nmost length_bound.  Otherwise, generate all simple cycles of G.\nYields:: list of nodes: Each cycle is represented by a list of nodes along the cycle.\nRaises:: ValueError: when length_bound < 0.\nMethods: []\nRubrics: Notes: When length_bound is None, the time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) simple circuits.  Otherwise, when length_bound > 1,\nthe time complexity is \\(O((c+n)(k-1)d^k)\\) where \\(d\\) is the average degree of\nthe nodes of G and \\(k\\) = length_bound.\nReferences: [1]Finding all the elementary circuits of a directed graph.\nD. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.https://doi.org/10.1137/0204007  [2]Finding All Bounded-Length Simple Cycles in a Directed Graph\nA. Gupta and T. Suzumurahttps://arxiv.org/abs/2105.10094  [3]Enumerating the cycles of a digraph: a new preprocessing strategy.\nG. Loizou and P. Thanish, Information Sciences, v. 27, 163-182, 1982.  [4]A search strategy for the elementary cycles of a directed graph.\nJ.L. Szwarcfiter and P.E. Lauer, BIT NUMERICAL MATHEMATICS,\nv. 16, no. 2, 192-204, 1976.  [5]Optimal Listing of Cycles and st-Paths in Undirected Graphs\nR. Ferreira and R. Grossi and A. Marino and N. Pisanti and R. Rizzi and\nG. Sacomotohttps://arxiv.org/abs/1205.2766\nExamples: edges=[(0,0),(0,1),(0,2),(1,2),(2,0),(2,1),(2,2)]\nG=nx.DiGraph(edges)\nsorted(nx.simple_cycles(G))\n# [[0], [0, 1, 2], [0, 2], [1, 2], [2]]\nTo filter the cycles so that they don’t include certain nodes or edges,\ncopy your graph and eliminate those nodes or edges before calling.\nFor example, to exclude self-loops from the above example:\nH=G.copy()\nH.remove_edges_from(nx.selfloop_edges(G))\nsorted(nx.simple_cycles(H))\n# [[0, 1, 2], [0, 2], [1, 2]]",
    "Section ID: compute_v_structures\nDescription: [Iterate through the graph to compute all v-structures., V-structures are triples in the directed graph where\ntwo parent nodes point to the same child and the two parent nodes\nare not adjacent.]\nField List: Parameters:: G : graph: A networkx DiGraph.\nReturns:: vstructs : iterator of tuples: The v structures within the graph. Each v structure is a 3-tuple with the\nparent, collider, and other parent.\nMethods: []\nRubrics: Notes: Wikipedia: Collider in causal graphs\nExamples: G=nx.DiGraph()\nG.add_edges_from([(1,2),(0,5),(3,1),(2,4),(3,1),(4,5),(1,5)])\nsorted(nx.compute_v_structures(G))\n# [(0, 5, 1), (0, 5, 4), (1, 5, 4)]",
    "Section ID: path_weight\nDescription: [Returns total cost associated with specified path and weight]\nField List: Parameters:: G : graph: A NetworkX graph.\npath: list: A list of node labels which defines the path to traverse\nweight: string: A string indicating which edge attribute to use for path cost\nReturns:: cost: int or float: An integer or a float representing the total cost with respect to the\nspecified weight of the specified path\nRaises:: NetworkXNoPath: If the specified edge does not exist.\nMethods: []\nRubrics:",
    "Section ID: is_simple_path\nDescription: [Returns True if and only if nodes form a simple path in G ., A simple path in a graph is a nonempty sequence of nodes in which\nno node appears more than once in the sequence, and each adjacent\npair of nodes in the sequence is adjacent in the graph.]\nField List: Parameters:: G : graph: A NetworkX graph.\nnodes : list: A list of one or more nodes in the graphG.\nReturns:: bool: Whether the given list of nodes represents a simple path inG.\nMethods: []\nRubrics: Notes: An empty list of nodes is not a path but a list of one node is a\npath. Here’s an explanation why. This function operates on node paths . One could also consider edge paths . There is a bijection between node paths and edge\npaths. The length of a path is the number of edges in the path, so a list\nof nodes of length n corresponds to a path of length n - 1.\nThus the smallest edge path would be a list of zero edges, the empty\npath. This corresponds to a list of one node. To convert between a node path and an edge path, you can use code\nlike the following:\nExamples: G=nx.cycle_graph(4)\nnx.is_simple_path(G,[2,3,0])\n# True\nnx.is_simple_path(G,[0,2])\n# False",
    "Section ID: is_strongly_connected\nDescription: [Test directed graph for strong connectivity., A directed graph is strongly connected if and only if every vertex in\nthe graph is reachable from every other vertex.]\nField List: Parameters:: G : NetworkX Graph: A directed graph.\nReturns:: connected : bool: True if the graph is strongly connected, False otherwise.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: For directed graphs only.\nExamples: G=nx.DiGraph([(0,1),(1,2),(2,3),(3,0),(2,4),(4,2)])\nnx.is_strongly_connected(G)\n# True\nG.remove_edge(2,3)\nnx.is_strongly_connected(G)\n# False",
    "Section ID: multi_source_dijkstra_path\nDescription: [Find shortest weighted paths in G from a given set of source\nnodes., Compute shortest path between any of the source nodes and all other\nreachable nodes for a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsources : non-empty set of nodes: Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.\ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: paths : dictionary: Dictionary of shortest paths keyed by target.\nRaises:: ValueError: Ifsourcesis empty.\nNodeNotFound: If any ofsourcesis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.\nExamples: G=nx.path_graph(5)\npath=nx.multi_source_dijkstra_path(G,{0,4})\npath[1]\n# [0, 1]\npath[3]\n# [4, 3]",
    "Section ID: enumerate_all_cliques\nDescription: [Returns all cliques in an undirected graph., This function returns an iterator over cliques, each of which is a\nlist of nodes. The iteration is ordered by cardinality of the\ncliques: first all cliques of size one, then all cliques of size\ntwo, etc.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nReturns:: iterator: An iterator over cliques, each of which is a list of nodes inG. The cliques are ordered according to size.\nMethods: []\nRubrics: Notes: To obtain a list of all cliques, use list(enumerate_all_cliques(G)) . However, be aware that in the\nworst-case, the length of this list can be exponential in the number\nof nodes in the graph (for example, when the graph is the complete\ngraph). This function avoids storing all cliques in memory by only\nkeeping current candidate node lists in memory during its search. The implementation is adapted from the algorithm by Zhang, et\nal. (2005) [1] to output all cliques discovered. This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.\nReferences: [1]Yun Zhang, Abu-Khzam, F.N., Baldwin, N.E., Chesler, E.J.,\nLangston, M.A., Samatova, N.F.,\n“Genome-Scale Computational Approaches to Memory-Intensive\nApplications in Systems Biology”.Supercomputing, 2005. Proceedings of the ACM/IEEE SC 2005\nConference, pp. 12, 12–18 Nov. 2005.\n<https://doi.org/10.1109/SC.2005.29>.",
    "Section ID: weighted_choice\nDescription: [Returns a single element from a weighted sample., The input is a dictionary of items with weights as values.]\nField List: Methods: []\nRubrics:",
    "Section ID: contracted_edge\nDescription: [Returns the graph that results from contracting the specified edge., Edge contraction identifies the two endpoints of the edge as a single node\nincident to any edge that was incident to the original two nodes. A graph\nthat results from edge contraction is called a minor of the original\ngraph.]\nField List: Parameters:: G : NetworkX graph: The graph whose edge will be contracted.\nedge : tuple: Must be a pair of nodes inG.\nself_loops : Boolean: If this is True, any edges (includingedge) joining the\nendpoints ofedgeinGbecome self-loops on the new node in the\nreturned graph.\ncopy : Boolean (default True): If this is True, a the contraction will be performed on a copy ofG,\notherwise the contraction will happen in place.\nReturns:: Networkx graph: A new graph object of the same type asG(leavingGunmodified)\nwith endpoints ofedgeidentified in a single node. The right node\nofedgewill be merged into the left one, so only the left one will\nappear in the returned graph.\nRaises:: ValueError: Ifedgeis not an edge inG.\nMethods: []\nRubrics: Examples: Attempting to contract two nonadjacent nodes yields an error:\nG=nx.cycle_graph(4)\nnx.contracted_edge(G,(1,3))Traceback (most recent call last):  ...ValueErrorEdge (1, 3) does not exist in graph G; cannot contract it\nContracting two adjacent nodes in the cycle graph onnnodes yields the\ncycle graph onn - 1nodes:\nC5=nx.cycle_graph(5)\nC4=nx.cycle_graph(4)\nM=nx.contracted_edge(C5,(0,1),self_loops=False)\nnx.is_isomorphic(M,C4)\n# True",
    "Section ID: hopcroft_karp_matching\nDescription: [Returns the maximum cardinality matching of the bipartite graph G ., A matching is a set of edges that do not share any nodes. A maximum\ncardinality matching is a matching with the most edges possible. It\nis not always unique. Finding a matching in a bipartite graph can be\ntreated as a networkx flow problem., The functions hopcroft_karp_matching and maximum_matching are aliases of the same function.]\nField List: Parameters:: G : NetworkX graph: Undirected bipartite graph\ntop_nodes : container of nodes: Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised.\nReturns:: matches : dictionary: The matching is returned as a dictionary,matches, such thatmatches[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatches.\nRaises:: AmbiguousSolution: Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected.\nMethods: []\nRubrics: Notes: This function is implemented with the Hopcroft–Karp matching algorithm for\nbipartite graphs. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nReferences: [1]John E. Hopcroft and Richard M. Karp. “An n^{5 / 2} Algorithm for\nMaximum Matchings in Bipartite Graphs” In:SIAM Journal of Computing2.4 (1973), pp. 225–231. <https://doi.org/10.1137/0202019>.",
    "Section ID: lukes_partitioning\nDescription: [Optimal partitioning of a weighted tree using the Lukes algorithm., This algorithm partitions a connected, acyclic graph featuring integer\nnode weights and float edge weights. The resulting clusters are such\nthat the total weight of the nodes in each cluster does not exceed\nmax_size and that the weight of the edges that are cut by the partition\nis minimum. The algorithm is based on [1] .]\nField List: Parameters:: G : NetworkX graph: \nmax_size : int: Maximum weight a partition can have in terms of sum of\nnode_weight for all nodes in the partition\nedge_weight : key: Edge data key to use as weight. If None, the weights are all\nset to one.\nnode_weight : key: Node data key to use as weight. If None, the weights are all\nset to one. The data must be int.\nReturns:: partition : list: A list of sets of nodes representing the clusters of the\npartition.\nRaises:: NotATree: If G is not a tree.\nTypeError: If any of the values of node_weight is not int.\nMethods: []\nRubrics: References: [1]Lukes, J. A. (1974).\n“Efficient Algorithm for the Partitioning of Trees.”\nIBM Journal of Research and Development, 18(3), 217–224.",
    "Section ID: ring_of_cliques\nDescription: [Defines a “ring of cliques” graph., A ring of cliques graph is consisting of cliques, connected through single\nlinks. Each clique is a complete graph.]\nField List: Parameters:: num_cliques : int: Number of cliques\nclique_size : int: Size of cliques\nReturns:: G : NetworkX Graph: ring of cliques graph\nRaises:: NetworkXError: If the number of cliques is lower than 2 or\nif the size of cliques is smaller than 2.\nMethods: []\nRubrics: Notes: The connected_caveman_graph graph removes a link from each clique to\nconnect it with the next clique. Instead, the ring_of_cliques graph\nsimply adds the link without removing any link from the cliques.\nExamples: G=nx.ring_of_cliques(8,4)",
    "Section ID: all_shortest_paths\nDescription: [Compute all shortest simple paths in the graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path.\ntarget : node: Ending node for path.\nweight : None, string or function, optional (default = None): If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.\nmethod : string, optional (default = ‘dijkstra’): The algorithm to use to compute the path lengths.\nSupported options: ‘dijkstra’, ‘bellman-ford’.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored.\nReturns:: paths : generator of lists: A generator of all paths between source and target.\nRaises:: ValueError: Ifmethodis not among the supported options.\nNetworkXNoPath: Iftargetcannot be reached fromsource.\nMethods: []\nRubrics: Notes: There may be many shortest paths between the source and target.  If G\ncontains zero-weight cycles, this function will not produce all shortest\npaths because doing so would produce infinitely many paths of unbounded\nlength – instead, we only produce the shortest simple paths.\nExamples: G=nx.Graph()\nnx.add_path(G,[0,1,2])\nnx.add_path(G,[0,10,2])\nprint([pforpinnx.all_shortest_paths(G,source=0,target=2)])\n# [[0, 1, 2], [0, 10, 2]]",
    "Section ID: from_pydot\nDescription: [Returns a NetworkX graph from a Pydot graph.]\nField List: Parameters:: P : Pydot graph: A graph created with Pydot\nReturns:: G : NetworkX multigraph: A MultiGraph or MultiDiGraph.\nMethods: []\nRubrics: Examples: K5=nx.complete_graph(5)\nA=nx.nx_pydot.to_pydot(K5)\nG=nx.nx_pydot.from_pydot(A)# return MultiGraph\n# make a Graph instead of MultiGraph\n>>> G = nx.Graph(nx.nx_pydot.from_pydot(A))",
    "Section ID: nodes_or_number\nDescription: [Decorator to allow number of nodes or container of nodes., With this decorator, the specified argument can be either a number or a container\nof nodes. If it is a number, the nodes used are range(n) .\nThis allows nx.complete_graph(50) in place of nx.complete_graph(list(range(50))) .\nAnd it also allows nx.complete_graph(any_list_of_nodes) .]\nField List: Parameters:: which_args : string or int or sequence of strings or ints: If string, the name of the argument to be treated.\nIf int, the index of the argument to be treated.\nIf more than one node argument is allowed, can be a list of locations.\nReturns:: _nodes_or_numbers : function: Function which replaces int args with ranges.\nMethods: []\nRubrics: Examples: Decorate functions like this:\n@nodes_or_number(\"nodes\")defempty_graph(nodes):# nodes is converted to a list of nodes@nodes_or_number(0)defempty_graph(nodes):# nodes is converted to a list of nodes@nodes_or_number([\"m1\",\"m2\"])defgrid_2d_graph(m1,m2,periodic=False):# m1 and m2 are each converted to a list of nodes@nodes_or_number([0,1])defgrid_2d_graph(m1,m2,periodic=False):# m1 and m2 are each converted to a list of nodes@nodes_or_number(1)deffull_rary_tree(r,n)# presumably r is a number. It is not handled by this decorator.# n is converted to a list of nodes",
    "Section ID: all_simple_edge_paths\nDescription: [Generate lists of edges for all simple paths in G from source to target., A simple path is a path with no repeated nodes.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path\ntarget : nodes: Single node or iterable of nodes at which to end path\ncutoff : integer, optional: Depth to stop the search. Only paths of length <= cutoff are returned.\nReturns:: path_generator: generator: A generator that produces lists of simple paths.  If there are no paths\nbetween the source and target within the given cutoff the generator\nproduces no output.\nFor multigraphs, the list of edges have elements of the form(u,v,k).\nWherekcorresponds to the edge key.\nMethods: []\nRubrics: Notes: This algorithm uses a modified depth-first search to generate the\npaths [1] .  A single path can be found in \\(O(V+E)\\) time but the\nnumber of simple paths in a graph can be very large, e.g. \\(O(n!)\\) in\nthe complete graph of order \\(n\\) .\nReferences: [1]R. Sedgewick, “Algorithms in C, Part 5: Graph Algorithms”,\nAddison Wesley Professional, 3rd ed., 2001.\nExamples: Print the simple path edges of a Graph:\ng=nx.Graph([(1,2),(2,4),(1,3),(3,4)])\nforpathinsorted(nx.all_simple_edge_paths(g,1,4)):\nprint(path)\n# [(1, 2), (2, 4)]\n# [(1, 3), (3, 4)]\nPrint the simple path edges of a MultiGraph. Returned edges come with\ntheir associated keys:\nmg=nx.MultiGraph()\nmg.add_edge(1,2,key=\"k0\")\n# 'k0'\nmg.add_edge(1,2,key=\"k1\")\n# 'k1'\nmg.add_edge(2,3,key=\"k0\")\n# 'k0'\nforpathinsorted(nx.all_simple_edge_paths(mg,1,3)):\nprint(path)\n# [(1, 2, 'k0'), (2, 3, 'k0')]\n# [(1, 2, 'k1'), (2, 3, 'k0')]\nWhensourceis one of the targets, the empty path starting and ending atsourcewithout traversing any edge is considered a valid simple edge path\nand is included in the results:\nG=nx.Graph()\nG.add_node(0)\npaths=list(nx.all_simple_edge_paths(G,0,0))\nforpathinpaths:\nprint(path)\n# []\nlen(paths)\n# 1",
    "Section ID: convert_node_labels_to_integers\nDescription: [Returns a copy of the graph G with the nodes relabeled using\nconsecutive integers.]\nField List: Parameters:: G : graph: A NetworkX graph\nfirst_label : int, optional (default=0): An integer specifying the starting offset in numbering nodes.\nThe new integer labels are numbered first_label, …, n-1+first_label.\nordering : string: “default” : inherit node ordering from G.nodes()\n“sorted”  : inherit node ordering from sorted(G.nodes())\n“increasing degree” : nodes are sorted by increasing degree\n“decreasing degree” : nodes are sorted by decreasing degree\nlabel_attribute : string, optional (default=None): Name of node attribute to store old label.  If None no attribute\nis created.\nMethods: []\nRubrics: Notes: Node and edge attribute data are copied to the new (relabeled) graph. There is no guarantee that the relabeling of nodes to integers will\ngive the same two integers for two (even identical graphs).\nUse the ordering argument to try to preserve the order.",
    "Section ID: cut_size\nDescription: [Returns the size of the cut between two sets of nodes., A cut is a partition of the nodes of a graph into two sets. The cut size is the sum of the weights of the edges “between” the two\nsets of nodes.]\nField List: Parameters:: G : NetworkX graph: \nS : collection: A collection of nodes inG.\nT : collection: A collection of nodes inG. If not specified, this is taken to\nbe the set complement ofS.\nweight : object: Edge attribute key to use as weight. If not specified, edges\nhave weight one.\nReturns:: number: Total weight of all edges from nodes in setSto nodes in\nsetT(and, in the case of directed graphs, all edges from\nnodes inTto nodes inS).\nMethods: []\nRubrics: Notes: In a multigraph, the cut size is the total weight of edges including\nmultiplicity.\nExamples: In the graph with two cliques joined by a single edges, the natural\nbipartition of the graph into two blocks, one for each clique,\nyields a cut of weight one:\nG=nx.barbell_graph(3,0)\nS={0,1,2}\nT={3,4,5}\nnx.cut_size(G,S,T)\n# 1\nEach parallel edge in a multigraph is counted when determining the\ncut size:\nG=nx.MultiGraph([\"ab\",\"ab\"])\nS={\"a\"}\nT={\"b\"}\nnx.cut_size(G,S,T)\n# 2",
    "Section ID: node_degree_xy\nDescription: [Generate node degree-degree pairs for edges in G.]\nField List: Parameters:: G: NetworkX graph: \nx: string (‘in’,’out’): The degree type for source node (directed graphs only).\ny: string (‘in’,’out’): The degree type for target node (directed graphs only).\nweight: string or None, optional (default=None): The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.\nnodes: list or iterable (optional): Use only edges that are adjacency to specified nodes.\nThe default is all nodes.\nReturns:: (x, y): 2-tuple: Generates 2-tuple of (degree, degree) values.\nMethods: []\nRubrics: Notes: For undirected graphs each edge is produced twice, once for each edge\nrepresentation (u, v) and (v, u), with the exception of self-loop edges\nwhich only appear once.\nExamples: G=nx.DiGraph()\nG.add_edge(1,2)\nlist(nx.node_degree_xy(G,x=\"out\",y=\"in\"))\n# [(1, 1)]\nlist(nx.node_degree_xy(G,x=\"in\",y=\"out\"))\n# [(0, 0)]",
    "Section ID: not_implemented_for\nDescription: [Decorator to mark algorithms as not implemented]\nField List: Parameters:: graph_types : container of strings: Entries must be one of “directed”, “undirected”, “multigraph”, or “graph”.\nReturns:: _require : function: The decorated function.\nRaises:: NetworkXNotImplemented: \nIf any of the packages cannot be imported:\nMethods: []\nRubrics: Notes: Multiple types are joined logically with “and”.\nFor “or” use multiple @not_implemented_for() lines.\nExamples: Decorate functions like this:\n@not_implemented_for(\"directed\")defsp_function(G):pass# rule out MultiDiGraph@not_implemented_for(\"directed\",\"multigraph\")defsp_np_function(G):pass# rule out all except DiGraph@not_implemented_for(\"undirected\")@not_implemented_for(\"multigraph\")defsp_np_function(G):pass",
    "Section ID: single_target_shortest_path_length\nDescription: [Compute the shortest path lengths to target from all reachable nodes.]\nField List: Parameters:: G : NetworkX graph: \ntarget : node: Target node for path\ncutoff : integer, optional: Depth to stop the search. Only paths of length <= cutoff are returned.\nReturns:: lengths : iterator: (source, shortest path length) iterator\nMethods: []\nRubrics: Examples: G=nx.path_graph(5,create_using=nx.DiGraph())\nlength=dict(nx.single_target_shortest_path_length(G,4))\nlength[0]\n# 4\nfornodeinrange(5):\nprint(f\"{node}: {length[node]}\")\n# 0: 4\n# 1: 3\n# 2: 2\n# 3: 1\n# 4: 0",
    "Section ID: degree_mixing_dict\nDescription: [Returns dictionary representation of mixing matrix for degree.]\nField List: Parameters:: G : graph: NetworkX graph object.\nx: string (‘in’,’out’): The degree type for source node (directed graphs only).\ny: string (‘in’,’out’): The degree type for target node (directed graphs only).\nweight: string or None, optional (default=None): The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.\nnormalized : bool (default=False): Return counts if False or probabilities if True.\nReturns:: d: dictionary: Counts or joint probability of occurrence of degree pairs.\nMethods: []\nRubrics:",
    "Section ID: join_trees\nDescription: [Returns a new rooted tree made by joining rooted_trees, Constructs a new tree by joining each tree in rooted_trees .\nA new root node is added and connected to each of the roots\nof the input trees. While copying the nodes from the trees,\nrelabeling to integers occurs. If the label_attribute is provided,\nthe old node labels will be stored in the new tree under this attribute.]\nField List: Parameters:: rooted_trees : list: A list of pairs in which each left element is a NetworkX graph\nobject representing a tree and each right element is the root\nnode of that tree. The nodes of these trees will be relabeled to\nintegers.\nlabel_attribute : str: If provided, the old node labels will be stored in the new tree\nunder this node attribute. If not provided, the original labels\nof the nodes in the input trees are not stored.\nfirst_label : int, optional (default=0): Specifies the label for the new root node. If provided, the root node of the joined tree\nwill have this label. If not provided, the root node will default to a label of 0.\nReturns:: NetworkX graph: The rooted tree resulting from joining the providedrooted_trees. The new tree has a root node\nlabeled as specified byfirst_label(defaulting to 0 if not provided). Subtrees from the inputrooted_treesare attached to this new root node. Each non-root node, if thelabel_attributeis provided, has an attribute that indicates the original label of the node in the input tree.\nMethods: []\nRubrics: Notes: Trees are stored in NetworkX as NetworkX Graphs. There is no specific\nenforcement of the fact that these are trees. Testing for each tree\ncan be done using networkx.is_tree() . Graph, edge, and node attributes are propagated from the given\nrooted trees to the created tree. If there are any overlapping graph\nattributes, those from later trees will overwrite those from earlier\ntrees in the tuple of positional arguments.\nExamples: Join two full balanced binary trees of heighthto get a full\nbalanced binary tree of depthh+ 1:\nh=4\nleft=nx.balanced_tree(2,h)\nright=nx.balanced_tree(2,h)\njoined_tree=nx.join([(left,0),(right,0)])\nnx.is_isomorphic(joined_tree,nx.balanced_tree(2,h+1))\n# True",
    "Section ID: closeness_centrality\nDescription: [Compute the closeness centrality for nodes in a bipartite network., The closeness of a node is the distance to all other nodes in the\ngraph or in the case that the graph is not connected to all other nodes\nin the connected component containing that node.]\nField List: Parameters:: G : graph: A bipartite network\nnodes : list or container: Container with all nodes in one bipartite node set.\nnormalized : bool, optional: If True (default) normalize by connected component size.\nReturns:: closeness : dictionary: Dictionary keyed by node with bipartite closeness centrality\nas the value.\nMethods: []\nRubrics: Notes: The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both node sets.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX. Closeness centrality is normalized by the minimum distance possible.\nIn the bipartite case the minimum distance for a node in one bipartite\nnode set is 1 from all nodes in the other node set and 2 from all\nother nodes in its own set [1] . Thus the closeness centrality\nfor node v in the two bipartite sets U with n nodes and V with m nodes is\nReferences: [1]Borgatti, S.P. and Halgin, D. In press. “Analyzing Affiliation\nNetworks”. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28\nExamples: G=nx.wheel_graph(5)\ntop_nodes={0,1,2}\nnx.bipartite.closeness_centrality(G,nodes=top_nodes)\n# {0: 1.5, 1: 1.2, 2: 1.2, 3: 1.0, 4: 1.0}",
    "Section ID: weisfeiler_lehman_subgraph_hashes\nDescription: [Return a dictionary of subgraph hashes by node., Dictionary keys are nodes in G , and values are a list of hashes.\nEach hash corresponds to a subgraph rooted at a given node u in G .\nLists of subgraph hashes are sorted in increasing order of depth from\ntheir root node, with the hash at index i corresponding to a subgraph\nof nodes at most i edges distance from u. Thus, each list will contain iterations elements - a hash for a subgraph at each depth. If include_initial_labels is set to True , each list will additionally\nhave contain a hash of the initial node label (or equivalently a\nsubgraph of depth 0) prepended, totalling iterations+1 elements., The function iteratively aggregates and hashes neighborhoods of each node.\nThis is achieved for each step by replacing for each node its label from\nthe previous iteration with its hashed 1-hop neighborhood aggregate.\nThe new node label is then appended to a list of node labels for each\nnode., To aggregate neighborhoods for a node \\(u\\) at each step, all labels of\nnodes adjacent to \\(u\\) are concatenated. If the edge_attr parameter is set,\nlabels for each neighboring node are prefixed with the value of this attribute\nalong the connecting edge from this neighbor to node \\(u\\) . The resulting string\nis then hashed to compress this information into a fixed digest size., Thus, at the \\(i\\) -th iteration, nodes within \\(i\\) hops influence any given\nhashed node label. We can therefore say that at depth \\(i\\) for node \\(u\\) we have a hash for a subgraph induced by the \\(i\\) -hop neighborhood of \\(u\\) ., The output can be used to to create general Weisfeiler-Lehman graph kernels,\nor generate features for graphs or nodes - for example to generate ‘words’ in\na graph as seen in the ‘graph2vec’ algorithm.\nSee [1] & [2] respectively for details., Hashes are identical for isomorphic subgraphs and there exist strong\nguarantees that non-isomorphic graphs will get different hashes.\nSee [1] for details., If no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash.]\nField List: Parameters:: G : graph: The graph to be hashed.\nCan have node and/or edge attributes. Can also have no attributes.\nedge_attr : string, optional (default=None): The key in edge attribute dictionary to be used for hashing.\nIf None, edge labels are ignored.\nnode_attr : string, optional (default=None): The key in node attribute dictionary to be used for hashing.\nIf None, and no edge_attr given, use the degrees of the nodes as labels.\nIf None, and edge_attr is given, each node starts with an identical label.\niterations : int, optional (default=3): Number of neighbor aggregations to perform.\nShould be larger for larger graphs.\ndigest_size : int, optional (default=16): Size (in bits) of blake2b hash digest to use for hashing node labels.\nThe default size is 16 bits.\ninclude_initial_labels : bool, optional (default=False): If True, include the hashed initial node label as the first subgraph\nhash for each node.\nReturns:: node_subgraph_hashes : dict: A dictionary with each key given by a node in G, and each value given\nby the subgraph hashes in order of depth from the key node.\nMethods: []\nRubrics: Notes: To hash the full graph when subgraph hashes are not needed, use weisfeiler_lehman_graph_hash for efficiency. Similarity between hashes does not imply similarity between graphs.\nReferences: [1](1,2)Shervashidze, Nino, Pascal Schweitzer, Erik Jan Van Leeuwen,\nKurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler Lehman\nGraph Kernels. Journal of Machine Learning Research. 2011.http://www.jmlr.org/papers/volume12/shervashidze11a/shervashidze11a.pdf  [2]Annamalai Narayanan, Mahinthan Chandramohan, Rajasekar Venkatesan,\nLihui Chen, Yang Liu and Shantanu Jaiswa. graph2vec: Learning\nDistributed Representations of Graphs. arXiv. 2017https://arxiv.org/pdf/1707.05005.pdf\nExamples: Finding similar nodes in different graphs:\nG1=nx.Graph()\nG1.add_edges_from([(1,2),(2,3),(2,4),(3,5),(4,6),(5,7),(6,7)])\nG2=nx.Graph()\nG2.add_edges_from([(1,3),(2,3),(1,6),(1,5),(4,6)])\ng1_hashes=nx.weisfeiler_lehman_subgraph_hashes(G1,iterations=3,digest_size=8)\ng2_hashes=nx.weisfeiler_lehman_subgraph_hashes(G2,iterations=3,digest_size=8)\nEven though G1 and G2 are not isomorphic (they have different numbers of edges),\nthe hash sequence of depth 3 for node 1 in G1 and node 5 in G2 are similar:\ng1_hashes[1]\n# ['a93b64973cfc8897', 'db1b43ae35a1878f', '57872a7d2059c1c0']\ng2_hashes[5]\n# ['a93b64973cfc8897', 'db1b43ae35a1878f', '1716d2a4012fa4bc']\nThe first 2 WL subgraph hashes match. From this we can conclude that it’s very\nlikely the neighborhood of 2 hops around these nodes are isomorphic.\nHowever the 3-hop neighborhoods ofG1andG2are not isomorphic since the\n3rd hashes in the lists above are not equal.\nThese nodes may be candidates to be classified together since their local topology\nis similar.",
    "Section ID: dedensify\nDescription: [Compresses neighborhoods around high-degree nodes, Reduces the number of edges to high-degree nodes by adding compressor nodes\nthat summarize multiple edges of the same type to high-degree nodes (nodes\nwith a degree greater than a given threshold).  Dedensification also has\nthe added benefit of reducing the number of edges around high-degree nodes.\nThe implementation currently supports graphs with a single edge type.]\nField List: Parameters:: G: graph: A networkx graph\nthreshold: int: Minimum degree threshold of a node to be considered a high degree node.\nThe threshold must be greater than or equal to 2.\nprefix: str or None, optional (default: None): An optional prefix for denoting compressor nodes\ncopy: bool, optional (default: True): Indicates if dedensification should be done inplace\nReturns:: dedensified networkx graph : (graph, set): 2-tuple of the dedensified graph and set of compressor nodes\nMethods: []\nRubrics: Notes: According to the algorithm in [1] , removes edges in a graph by\ncompressing/decompressing the neighborhoods around high degree nodes by\nadding compressor nodes that summarize multiple edges of the same type\nto high-degree nodes.  Dedensification will only add a compressor node when\ndoing so will reduce the total number of edges in the given graph. This\nimplementation currently supports graphs with a single edge type.\nReferences: [1]Maccioni, A., & Abadi, D. J. (2016, August).\nScalable pattern matching over compressed graphs via dedensification.\nIn Proceedings of the 22nd ACM SIGKDD International Conference on\nKnowledge Discovery and Data Mining (pp. 1755-1764).http://www.cs.umd.edu/~abadi/papers/graph-dedense.pdf\nExamples: Dedensification will only add compressor nodes when doing so would result\nin fewer edges:\noriginal_graph=nx.DiGraph()\noriginal_graph.add_nodes_from(\n[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"A\",\"B\",\"C\"]\n)\noriginal_graph.add_edges_from(\n[\n(\"1\",\"C\"),(\"1\",\"B\"),\n(\"2\",\"C\"),(\"2\",\"B\"),(\"2\",\"A\"),\n(\"3\",\"B\"),(\"3\",\"A\"),(\"3\",\"6\"),\n(\"4\",\"C\"),(\"4\",\"B\"),(\"4\",\"A\"),\n(\"5\",\"B\"),(\"5\",\"A\"),\n(\"6\",\"5\"),\n(\"A\",\"6\")\n]\n)\nc_graph,c_nodes=nx.dedensify(original_graph,threshold=2)\noriginal_graph.number_of_edges()\n# 15\nc_graph.number_of_edges()\n# 14\nA dedensified, directed graph can be “densified” to reconstruct the\noriginal graph:\noriginal_graph=nx.DiGraph()\noriginal_graph.add_nodes_from(\n[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"A\",\"B\",\"C\"]\n)\noriginal_graph.add_edges_from(\n[\n(\"1\",\"C\"),(\"1\",\"B\"),\n(\"2\",\"C\"),(\"2\",\"B\"),(\"2\",\"A\"),\n(\"3\",\"B\"),(\"3\",\"A\"),(\"3\",\"6\"),\n(\"4\",\"C\"),(\"4\",\"B\"),(\"4\",\"A\"),\n(\"5\",\"B\"),(\"5\",\"A\"),\n(\"6\",\"5\"),\n(\"A\",\"6\")\n]\n)\nc_graph,c_nodes=nx.dedensify(original_graph,threshold=2)\n# re-densifies the compressed graph into the original graph\nforc_nodeinc_nodes:\nall_neighbors=set(nx.all_neighbors(c_graph,c_node))\nout_neighbors=set(c_graph.neighbors(c_node))\nforout_neighborinout_neighbors:\nc_graph.remove_edge(c_node,out_neighbor)\nin_neighbors=all_neighbors-out_neighbors\nforin_neighborinin_neighbors:\nc_graph.remove_edge(in_neighbor,c_node)\nforout_neighborinout_neighbors:\nc_graph.add_edge(in_neighbor,out_neighbor)\nc_graph.remove_node(c_node)\n\nnx.is_isomorphic(original_graph,c_graph)\n# True",
    "Section ID: non_neighbors\nDescription: [Returns the non-neighbors of the node in the graph.]\nField List: Parameters:: graph : NetworkX graph: Graph to find neighbors.\nnode : node: The node whose neighbors will be returned.\nReturns:: non_neighbors : set: Set of nodes in the graph that are not neighbors of the node.\nMethods: []\nRubrics:",
    "Section ID: balanced_tree\nDescription: [Returns the perfectly balanced r -ary tree of height h ., ( Sourcecode , png )]\nField List: Parameters:: r : int: Branching factor of the tree; each node will haverchildren.\nh : int: Height of the tree.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : NetworkX graph: A balancedr-ary tree of heighth.\nMethods: []\nRubrics: Notes: This is the rooted tree where all leaves are at distance h from\nthe root. The root has degree r and all other internal nodes\nhave degree r+1 . Node labels are integers, starting from zero. A balanced tree is also known as a complete r-ary tree .",
    "Section ID: dispersion\nDescription: [Calculate dispersion between u and v in G ., A link between two actors ( u and v ) has a high dispersion when their\nmutual ties ( s and t ) are not well connected with each other.]\nField List: Parameters:: G : graph: A NetworkX graph.\nu : node, optional: The source for the dispersion score (e.g. ego node of the network).\nv : node, optional: The target of the dispersion score if specified.\nnormalized : bool: If True (default) normalize by the embeddedness of the nodes (u and v).\nalpha, b, c : float: Parameters for the normalization procedure. Whennormalizedis True,\nthe dispersion value is normalized by:result=((dispersion+b)**alpha)/(embeddedness+c)as long as the denominator is nonzero.\nReturns:: nodes : dictionary: If u (v) is specified, returns a dictionary of nodes with dispersion\nscore for all “target” (“source”) nodes. If neither u nor v is\nspecified, returns a dictionary of dictionaries for all nodes ‘u’ in the\ngraph with a dispersion score for each node ‘v’.\nMethods: []\nRubrics: Notes: This implementation follows Lars Backstrom and Jon Kleinberg [1] . Typical\nusage would be to run dispersion on the ego network \\(G_u\\) if \\(u\\) were\nspecified.  Running dispersion() with neither \\(u\\) nor \\(v\\) specified\ncan take some time to complete.\nReferences: [1]Romantic Partnerships and the Dispersion of Social Ties:\nA Network Analysis of Relationship Status on Facebook.\nLars Backstrom, Jon Kleinberg.https://arxiv.org/pdf/1310.6753v1.pdf",
    "Section ID: normalized_laplacian_spectrum\nDescription: [Return eigenvalues of the normalized Laplacian of G]\nField List: Parameters:: G : graph: A NetworkX graph\nweight : string or None, optional (default=’weight’): The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.\nReturns:: evals : NumPy array: Eigenvalues\nMethods: []\nRubrics: Notes: For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array for other options.",
    "Section ID: single_source_bellman_ford\nDescription: [Compute shortest paths and lengths in a weighted graph G., Uses Bellman-Ford algorithm for shortest paths.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: Starting node for path\ntarget : node label, optional: Ending node for path\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: distance, path : pair of dictionaries, or numeric and list: If target is None, returns a tuple of two dictionaries keyed by node.\nThe first dictionary stores distance from one of the source nodes.\nThe second stores the path from one of the sources to that node.\nIf target is not None, returns a tuple of (distance, path) where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target.\nRaises:: NodeNotFound: Ifsourceis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\nExamples: G=nx.path_graph(5)\nlength,path=nx.single_source_bellman_ford(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4\npath[4]\n# [0, 1, 2, 3, 4]\nlength,path=nx.single_source_bellman_ford(G,0,1)\nlength\n# 1\npath\n# [0, 1]",
    "Section ID: overall_reciprocity\nDescription: [Compute the reciprocity for the whole graph., See the doc of reciprocity for the definition.]\nField List: Parameters:: G : graph: A networkx graph\nMethods: []\nRubrics:",
    "Section ID: random_powerlaw_tree\nDescription: [Returns a tree with a power law degree distribution.]\nField List: Parameters:: n : int: The number of nodes.\ngamma : float: Exponent of the power law.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ntries : int: Number of attempts to adjust the sequence to make it a tree.\nRaises:: NetworkXError: If no valid sequence is found within the maximum number of\nattempts.\nMethods: []\nRubrics: Notes: A trial power law degree sequence is chosen and then elements are\nswapped with new elements from a powerlaw distribution until the\nsequence makes a tree (by checking, for example, that the number of\nedges is one smaller than the number of nodes).",
    "Section ID: bridge_components\nDescription: [Finds all bridge-connected components G.]\nField List: Parameters:: G : NetworkX undirected graph:\nReturns:: bridge_components : a generator of 2-edge-connected components:\nRaises:: NetworkXNotImplemented: If the input graph is directed or a multigraph.\nMethods: []\nRubrics: Notes: Bridge-connected components are also known as 2-edge-connected components.\nExamples: # The barbell graph with parameter zero has a single bridge\nG=nx.barbell_graph(5,0)\nfromnetworkx.algorithms.connectivity.edge_kcomponentsimportbridge_components\nsorted(map(sorted,bridge_components(G)))\n# [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]",
    "Section ID: path_graph\nDescription: [Returns the Path graph P_n of linearly connected nodes., ( Sourcecode , png )]\nField List: Parameters:: n : int or iterable: If an integer, nodes are 0 to n - 1.\nIf an iterable of nodes, in the order they appear in the path.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nMethods: []\nRubrics:",
    "Section ID: complete_multipartite_graph\nDescription: [Returns the complete multipartite graph with the specified subset sizes., ( Sourcecode , png )]\nField List: Parameters:: subset_sizes : tuple of integers or tuple of node iterables: The arguments can either all be integer number of nodes or they\ncan all be iterables of nodes. If integers, they represent the\nnumber of nodes in each subset of the multipartite graph.\nIf iterables, each is used to create the nodes for that subset.\nThe length of subset_sizes is the number of subsets.\nReturns:: G : NetworkX Graph: Returns the complete multipartite graph with the specified subsets.For each node, the node attribute ‘subset’ is an integer\nindicating which subset contains the node.\nMethods: []\nRubrics: Notes: This function generalizes several other graph builder functions.\nExamples: Creating a complete tripartite graph, with subsets of one, two, and three\nnodes, respectively.\nG=nx.complete_multipartite_graph(1,2,3)\n[G.nodes[u][\"subset\"]foruinG]\n# [0, 1, 1, 2, 2, 2]\nlist(G.edges(0))\n# [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\nlist(G.edges(2))\n# [(2, 0), (2, 3), (2, 4), (2, 5)]\nlist(G.edges(4))\n# [(4, 0), (4, 1), (4, 2)]\nG=nx.complete_multipartite_graph(\"a\",\"bc\",\"def\")\n[G.nodes[u][\"subset\"]foruinsorted(G)]\n# [0, 1, 1, 2, 2, 2]",
    "Section ID: configuration_model\nDescription: [Returns a random bipartite graph from two given degree sequences.]\nField List: Parameters:: aseq : list: Degree sequence for node set A.\nbseq : list: Degree sequence for node set B.\ncreate_using : NetworkX graph instance, optional: Return graph of this type.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nThe graph is composed of two partitions. Set A has nodes 0 to: \n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).: \nNodes from set A are connected to nodes in set B by choosing: \nrandomly from the possible free stubs, one in A and one in B.:\nMethods: []\nRubrics: Notes: The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute ‘bipartite’ with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.configuration_model",
    "Section ID: compose\nDescription: [Compose graph G with H by combining nodes and edges into a single graph., The node sets and edges sets do not need to be disjoint., Composing preserves the attributes of nodes and edges.\nAttribute values from H take precedent over attribute values from G.]\nField List: Parameters:: G, H : graph: A NetworkX graph\nReturns:: C: A new graph with the same type as G:\nMethods: []\nRubrics: Notes: It is recommended that G and H be either both directed or both undirected. For MultiGraphs, the edges are identified by incident nodes AND edge-key.\nThis can cause surprises (i.e., edge (1,2) may or may not be the same\nin two graphs) if you use MultiGraph without keeping track of edge keys. If combining the attributes of common nodes is not desired, consider union(),\nwhich raises an exception for name collisions.\nExamples: G=nx.Graph([(0,1),(0,2)])\nH=nx.Graph([(0,1),(1,2)])\nR=nx.compose(G,H)\nR.nodes\n# NodeView((0, 1, 2))\nR.edges\n# EdgeView([(0, 1), (0, 2), (1, 2)])\nBy default, the attributes fromHtake precedent over attributes fromG.\nIf you prefer another way of combining attributes, you can update them after the compose operation:\nG=nx.Graph([(0,1,{\"weight\":2.0}),(3,0,{\"weight\":100.0})])\nH=nx.Graph([(0,1,{\"weight\":10.0}),(1,2,{\"weight\":-1.0})])\nnx.set_node_attributes(G,{0:\"dark\",1:\"light\",3:\"black\"},name=\"color\")\nnx.set_node_attributes(H,{0:\"green\",1:\"orange\",2:\"yellow\"},name=\"color\")\nGcomposeH=nx.compose(G,H)\nNormally, color attribute values of nodes of GcomposeH come from H. We can workaround this as follows:\nnode_data={\nn:G.nodes[n][\"color\"]+\" \"+H.nodes[n][\"color\"]forninG.nodes&H.nodes\n}\nnx.set_node_attributes(GcomposeH,node_data,\"color\")\nprint(GcomposeH.nodes[0][\"color\"])\n# dark green\nprint(GcomposeH.nodes[3][\"color\"])\n# black\nSimilarly, we can update edge attributes after the compose operation in a way we prefer:\nedge_data={\ne:G.edges[e][\"weight\"]*H.edges[e][\"weight\"]foreinG.edges&H.edges\n}\nnx.set_edge_attributes(GcomposeH,edge_data,\"weight\")\nprint(GcomposeH.edges[(0,1)][\"weight\"])\n# 20.0\nprint(GcomposeH.edges[(3,0)][\"weight\"])\n# 100.0",
    "Section ID: combinatorial_embedding_to_pos\nDescription: [Assigns every node a (x, y) position based on the given embedding, The algorithm iteratively inserts nodes of the input graph in a certain\norder and rearranges previously inserted nodes so that the planar drawing\nstays valid. This is done efficiently by only maintaining relative\npositions during the node placements and calculating the absolute positions\nat the end. For more information see [1] .]\nField List: Parameters:: embedding : nx.PlanarEmbedding: This defines the order of the edges\nfully_triangulate : bool: If set to True the algorithm adds edges to a copy of the input\nembedding and makes it chordal.\nReturns:: pos : dict: Maps each node to a tuple that defines the (x, y) position\nMethods: []\nRubrics: References: [1]M. Chrobak and T.H. Payne:\nA Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677",
    "Section ID: navigable_small_world_graph\nDescription: [Returns a navigable small-world graph., A navigable small-world graph is a directed grid with additional long-range\nconnections that are chosen randomly.]\nField List: Parameters:: n : int: The length of one side of the lattice; the number of nodes in\nthe graph is therefore\\(n^2\\).\np : int: The diameter of short range connections. Each node is joined with every\nother node within this lattice distance.\nq : int: The number of long-range connections for each node.\nr : float: Exponent for decaying probability of connections.  The probability of\nconnecting to a node at lattice distance\\(d\\)is\\(1/d^r\\).\ndim : int: Dimension of grid\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: References: [1]J. Kleinberg. The small-world phenomenon: An algorithmic\nperspective. Proc. 32nd ACM Symposium on Theory of Computing, 2000.",
    "Section ID: relaxed_caveman_graph\nDescription: [Returns a relaxed caveman graph., A relaxed caveman graph starts with l cliques of size k .  Edges are\nthen randomly rewired with probability p to link different cliques.]\nField List: Parameters:: l : int: Number of groups\nk : int: Size of cliques\np : float: Probability of rewiring each edge.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : NetworkX Graph: Relaxed Caveman Graph\nRaises:: NetworkXError: If p is not in [0,1]\nMethods: []\nRubrics: References: [1]Santo Fortunato, Community Detection in Graphs,\nPhysics Reports Volume 486, Issues 3-5, February 2010, Pages 75-174.https://arxiv.org/abs/0906.0612\nExamples: G=nx.relaxed_caveman_graph(2,3,0.1,seed=42)",
    "Section ID: house_graph\nDescription: [Returns the House graph (square with triangle on top), The house graph is a simple undirected graph with\n5 nodes and 6 edges [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: House graph in the form of a square with a triangle on top\nMethods: []\nRubrics: References: [1]https://mathworld.wolfram.com/HouseGraph.html",
    "Section ID: modular_product\nDescription: [Returns the Modular product of G and H., The modular product of G and H is the graph \\(M = G \\nabla H\\) ,\nconsisting of the node set \\(V(M) = V(G) \\times V(H)\\) that is the Cartesian\nproduct of the node sets of G and H . Further, M contains an edge ((u, v), (x, y)):, More formally:]\nField List: Parameters:: G, H: NetworkX graphs: The graphs to take the modular product of.\nReturns:: M: NetworkX graph: The Modular product ofGandH.\nRaises:: NetworkXNotImplemented: IfGis not a simple graph.\nMethods: []\nRubrics: Notes: The modular product is defined in [1] and was first\nintroduced as the weak modular product . The modular product reduces the problem of counting isomorphic subgraphs\nin G and H to the problem of counting cliques in M. The subgraphs of G and H that are induced by the nodes of a clique in M are\nisomorphic [2]  [3] .\nReferences: [1]R. Hammack, W. Imrich, and S. Klavžar,\n“Handbook of Product Graphs”, CRC Press, 2011.  [2]H. G. Barrow and R. M. Burstall,\n“Subgraph isomorphism, matching relational structures and maximal\ncliques”, Information Processing Letters, vol. 4, issue 4, pp. 83-84,\n1976,https://doi.org/10.1016/0020-0190(76)90049-1.  [3]V. G. Vizing, “Reduction of the problem of isomorphism and isomorphic\nentrance to the task of finding the nondensity of a graph.” Proc. Third\nAll-Union Conference on Problems of Theoretical Cybernetics. 1974.\nExamples: G=nx.cycle_graph(4)\nH=nx.path_graph(2)\nM=nx.modular_product(G,H)\nlist(M)\n# [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\nprint(M)\n# Graph with 8 nodes and 8 edges",
    "Section ID: dominance_frontiers\nDescription: [Returns the dominance frontiers of all nodes of a directed graph.]\nField List: Parameters:: G : a DiGraph or MultiDiGraph: The graph where dominance is to be computed.\nstart : node: The start node of dominance computation.\nReturns:: df : dict keyed by nodes: A dict containing the dominance frontiers of each node reachable fromstartas lists.\nRaises:: NetworkXNotImplemented: IfGis undirected.\nNetworkXError: Ifstartis not inG.\nMethods: []\nRubrics: References: [1]K. D. Cooper, T. J. Harvey, and K. Kennedy.\nA simple, fast dominance algorithm.\nSoftware Practice & Experience, 4:110, 2001.\nExamples: G=nx.DiGraph([(1,2),(1,3),(2,5),(3,4),(4,5)])\nsorted((u,sorted(df))foru,dfinnx.dominance_frontiers(G,1).items())\n# [(1, []), (2, [5]), (3, [5]), (4, [5]), (5, [])]",
    "Section ID: harmonic_function\nDescription: [Node classification by Harmonic function, Function for computing Harmonic function algorithm by Zhu et al.]\nField List: Parameters:: G : NetworkX Graph: \nmax_iter : int: maximum number of iterations allowed\nlabel_name : string: name of target labels to predict\nReturns:: predicted : list: List of lengthlen(G)with the predicted labels for each node.\nRaises:: NetworkXError: If no nodes inGhave attributelabel_name.\nMethods: []\nRubrics: References: Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\nSemi-supervised learning using gaussian fields and harmonic functions.\nIn ICML (Vol. 3, pp. 912-919).\nExamples: fromnetworkx.algorithmsimportnode_classification\nG=nx.path_graph(4)\nG.nodes[0][\"label\"]=\"A\"\nG.nodes[3][\"label\"]=\"B\"\nG.nodes(data=True)\n# NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\nG.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])\npredicted=node_classification.harmonic_function(G)\npredicted\n# ['A', 'A', 'B', 'B']",
    "Section ID: min_edge_dominating_set\nDescription: [Returns minimum cardinality edge dominating set.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nReturns:: min_edge_dominating_set : set: Returns a set of dominating edges whose size is no more than 2 * OPT.\nRaises:: ValueError: If the input graphGis empty.\nMethods: []\nRubrics: Notes: The algorithm computes an approximate solution to the edge dominating set\nproblem. The result is no more than 2 * OPT in terms of size of the set.\nRuntime of the algorithm is \\(O(|E|)\\) .\nExamples: G=nx.petersen_graph()\nnx.approximation.min_edge_dominating_set(G)\n# {(0, 1), (4, 9), (6, 8), (5, 7), (2, 3)}",
    "Section ID: triads_by_type\nDescription: [Returns a list of all triads for each triad type in a directed graph.\nThere are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\nnodes, they will be classified as a particular triad type if their connections\nare as follows:, Refer to the example gallery for visual examples of the triad types.]\nField List: Parameters:: G : digraph: A NetworkX DiGraph\nReturns:: tri_by_type : dict: Dictionary with triad types as keys and lists of triads as values.\nMethods: []\nRubrics: References: [1]Snijders, T. (2012). “Transitivity and triads.” University of\nOxford.https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\nExamples: G=nx.DiGraph([(1,2),(1,3),(2,3),(3,1),(5,6),(5,4),(6,7)])\ndict=nx.triads_by_type(G)\ndict[\"120C\"][0].edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\ndict[\"012\"][0].edges()\n# OutEdgeView([(1, 2)])",
    "Section ID: normalized_laplacian_matrix\nDescription: [Returns the normalized Laplacian matrix of G., The normalized graph Laplacian is the matrix, where L is the graph Laplacian and D is the diagonal matrix of\nnode degrees [1] .]\nField List: Parameters:: G : graph: A NetworkX graph\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nweight : string or None, optional (default=’weight’): The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.\nReturns:: N : SciPy sparse array: The normalized Laplacian matrix of G.\nMethods: []\nRubrics: Notes: For MultiGraph, the edges weights are summed.\nSee to_numpy_array() for other options. If the Graph contains selfloops, D is defined as diag(sum(A,1)) , where A is\nthe adjacency matrix [2] . This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose. For an unnormalized output, use laplacian_matrix .\nReferences: [1]Fan Chung-Graham, Spectral Graph Theory,\nCBMS Regional Conference Series in Mathematics, Number 92, 1997.  [2]Steve Butler, Interlacing For Weighted Graphs Using The Normalized\nLaplacian, Electronic Journal of Linear Algebra, Volume 16, pp. 90-98,\nMarch 2007.  [3]Langville, Amy N., and Carl D. Meyer. Google’s PageRank and Beyond:\nThe Science of Search Engine Rankings. Princeton University Press, 2006.\nExamples: importnumpyasnp\nedges=[\n(1,2),\n(2,1),\n(2,4),\n(4,3),\n(3,4),\n]\nDiG=nx.DiGraph(edges)\nprint(nx.normalized_laplacian_matrix(DiG).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.         -0.70710678  0.        ]\n#  [ 0.          0.          1.         -1.        ]\n#  [ 0.          0.         -1.          1.        ]]\nNotice that node 4 is represented by the third column and row. This is because\nby default the row/column order is the order ofG.nodes(i.e. the node added\norder – in the edgelist, 4 first appears in (2, 4), before node 3 in edge (4, 3).)\nTo control the node order of the matrix, use thenodelistargument.\nprint(nx.normalized_laplacian_matrix(DiG,nodelist=[1,2,3,4]).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.          0.         -0.70710678]\n#  [ 0.          0.          1.         -1.        ]\n#  [ 0.          0.         -1.          1.        ]]\nG=nx.Graph(edges)\nprint(nx.normalized_laplacian_matrix(G).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.         -0.5         0.        ]\n#  [ 0.         -0.5         1.         -0.70710678]\n#  [ 0.          0.         -0.70710678  1.        ]]",
    "Section ID: is_negatively_weighted\nDescription: [Returns True if G has negatively weighted edges.]\nField List: Parameters:: G : graph: A NetworkX graph.\nedge : tuple, optional: A 2-tuple specifying the only edge inGthat will be tested. If\nNone, then every edge inGis tested.\nweight: string, optional: The attribute name used to query for edge weights.\nReturns:: bool: A boolean signifying ifG, or the specified edge, is negatively\nweighted.\nRaises:: NetworkXError: If the specified edge does not exist.\nMethods: []\nRubrics: Examples: G=nx.Graph()\nG.add_edges_from([(1,3),(2,4),(2,6)])\nG.add_edge(1,2,weight=4)\nnx.is_negatively_weighted(G,(1,2))\n# False\nG[2][4][\"weight\"]=-2\nnx.is_negatively_weighted(G)\n# True\nG=nx.DiGraph()\nedges=[(\"0\",\"3\",3),(\"0\",\"1\",-5),(\"1\",\"0\",-2)]\nG.add_weighted_edges_from(edges)\nnx.is_negatively_weighted(G)\n# True",
    "Section ID: shortest_path\nDescription: [Compute shortest paths in the graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Starting node for path. If not specified, compute shortest\npaths for each possible starting node.\ntarget : node, optional: Ending node for path. If not specified, compute shortest\npaths to all possible nodes.\nweight : None, string or function, optional (default = None): If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.\nmethod : string, optional (default = ‘dijkstra’): The algorithm to use to compute the path.\nSupported options: ‘dijkstra’, ‘bellman-ford’.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored.\nReturns:: path: list or dictionary: All returned paths include both the source and target in the path.If the source and target are both specified, return a single list\nof nodes in a shortest path from the source to the target.If only the source is specified, return a dictionary keyed by\ntargets with a list of nodes in a shortest path from the source\nto one of the targets.If only the target is specified, return a dictionary keyed by\nsources with a list of nodes in a shortest path from one of the\nsources to the target.If neither the source nor target are specified return a dictionary\nof dictionaries with path[source][target]=[list of nodes in path].\nRaises:: NodeNotFound: Ifsourceis not inG.\nValueError: Ifmethodis not among the supported options.\nMethods: []\nRubrics: Notes: There may be more than one shortest path between a source and target.\nThis returns only one of them.\nExamples: G=nx.path_graph(5)\nprint(nx.shortest_path(G,source=0,target=4))\n# [0, 1, 2, 3, 4]\np=nx.shortest_path(G,source=0)# target not specified\np[3]# shortest path from source=0 to target=3\n# [0, 1, 2, 3]\np=nx.shortest_path(G,target=4)# source not specified\np[1]# shortest path from source=1 to target=4\n# [1, 2, 3, 4]\np=dict(nx.shortest_path(G))# source, target not specified\np[2][4]# shortest path from source=2 to target=4\n# [2, 3, 4]",
    "Section ID: barbell_graph\nDescription: [Returns the Barbell Graph: two complete graphs connected by a path., ( Sourcecode , png )]\nField List: Parameters:: m1 : int: Size of the left and right barbells, must be greater than 2.\nm2 : int: Length of the path connecting the barbells.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nOnly undirected Graphs are supported.\nReturns:: G : NetworkX graph: A barbell graph.\nMethods: []\nRubrics: Notes: Two identical complete graphs \\(K_{m1}\\) form the left and right bells,\nand are connected by a path \\(P_{m2}\\) .",
    "Section ID: discrete_sequence\nDescription: [Return sample sequence of length n from a given discrete distribution\nor discrete cumulative distribution., One of the following must be specified., distribution = histogram of values, will be normalized, cdistribution = normalized discrete cumulative distribution]\nField List: Methods: []\nRubrics:",
    "Section ID: is_weakly_connected\nDescription: [Test directed graph for weak connectivity., A directed graph is weakly connected if and only if the graph\nis connected when the direction of the edge between nodes is ignored., Note that if a graph is strongly connected (i.e. the graph is connected\neven when we account for directionality), it is by definition weakly\nconnected as well.]\nField List: Parameters:: G : NetworkX Graph: A directed graph.\nReturns:: connected : bool: True if the graph is weakly connected, False otherwise.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: For directed graphs only.\nExamples: G=nx.DiGraph([(0,1),(2,1)])\nG.add_node(3)\nnx.is_weakly_connected(G)# node 3 is not connected to the graph\n# False\nG.add_edge(2,3)\nnx.is_weakly_connected(G)\n# True",
    "Section ID: resource_allocation_index\nDescription: [Compute the resource allocation index of all node pairs in ebunch., Resource allocation index of u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .]\nField List: Parameters:: G : graph: A NetworkX undirected graph.\nebunch : iterable of node pairs, optional (default = None): Resource allocation index will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None.\nReturns:: piter : iterator: An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their resource allocation index.\nRaises:: NetworkXNotImplemented: IfGis aDiGraph, aMultigraphor aMultiDiGraph.\nNodeNotFound: Ifebunchhas a node that is not inG.\nMethods: []\nRubrics: References: [1]T. Zhou, L. Lu, Y.-C. Zhang.\nPredicting missing links via local information.\nEur. Phys. J. B 71 (2009) 623.https://arxiv.org/pdf/0901.0553.pdf\nExamples: G=nx.complete_graph(5)\npreds=nx.resource_allocation_index(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 0.75000000\n# (2, 3) -> 0.75000000",
    "Section ID: global_reaching_centrality\nDescription: [Returns the global reaching centrality of a directed graph., The global reaching centrality of a weighted directed graph is the\naverage over all nodes of the difference between the local reaching\ncentrality of the node and the greatest local reaching centrality of\nany node in the graph [1] . For more information on the local\nreaching centrality, see local_reaching_centrality() .\nInformally, the local reaching centrality is the proportion of the\ngraph that is reachable from the neighbors of the node.]\nField List: Parameters:: G : DiGraph: A networkx DiGraph.\nweight : None or string, optional (default=None): Attribute to use for edge weights. IfNone, each edge weight\nis assumed to be one. A higher weight implies a stronger\nconnection between nodes and ashorterpath length.\nnormalized : bool, optional (default=True): Whether to normalize the edge weights by the total sum of edge\nweights.\nReturns:: h : float: The global reaching centrality of the graph.\nMethods: []\nRubrics: References: [1]Mones, Enys, Lilla Vicsek, and Tamás Vicsek.\n“Hierarchy Measure for Complex Networks.”PLoS ONE7.3 (2012): e33799.https://doi.org/10.1371/journal.pone.0033799\nExamples: G=nx.DiGraph()\nG.add_edge(1,2)\nG.add_edge(1,3)\nnx.global_reaching_centrality(G)\n# 1.0\nG.add_edge(3,2)\nnx.global_reaching_centrality(G)\n# 0.75",
    "Section ID: difference\nDescription: [Returns a new graph that contains the edges that exist in G but not in H., The node sets of H and G must be the same.]\nField List: Parameters:: G,H : graph: A NetworkX graph. G and H must have the same node sets.\nReturns:: D : A new graph with the same type as G.:\nMethods: []\nRubrics: Notes: Attributes from the graph, nodes, and edges are not copied to the new\ngraph.  If you want a new graph of the difference of G and H with\nthe attributes (including edge data) from G use remove_nodes_from()\nas follows:\nExamples: G=nx.Graph([(0,1),(0,2),(1,2),(1,3)])\nH=nx.Graph([(0,1),(1,2),(0,3)])\nR=nx.difference(G,H)\nR.nodes\n# NodeView((0, 1, 2, 3))\nR.edges\n# EdgeView([(0, 2), (1, 3)])",
    "Section ID: boundary_expansion\nDescription: [Returns the boundary expansion of the set S ., The boundary expansion is the quotient of the size\nof the node boundary and the cardinality of S . [1]]\nField List: Parameters:: G : NetworkX graph: \nS : collection: A collection of nodes inG.\nReturns:: number: The boundary expansion of the setS.\nMethods: []\nRubrics: References: [1]Vadhan, Salil P.\n“Pseudorandomness.”Foundations and Trends in Theoretical Computer Science7.1–3 (2011): 1–336.\n<https://doi.org/10.1561/0400000010>",
    "Section ID: greedy_tsp\nDescription: [Return a low cost cycle starting at source and its cost., This approximates a solution to the traveling salesman problem.\nIt finds a cycle of all the nodes that a salesman can visit in order\nto visit many nodes while minimizing total distance.\nIt uses a simple greedy algorithm.\nIn essence, this function returns a large cycle given a source point\nfor which the total cost of the cycle is minimized.]\nField List: Parameters:: G : Graph: The Graph should be a complete weighted undirected graph.\nThe distance between all pairs of nodes should be included.\nweight : string, optional (default=”weight”): Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.\nsource : node, optional (default: first node in list(G)): Starting node.  If None, defaults tonext(iter(G))\nReturns:: cycle : list of nodes: Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip.\nRaises:: NetworkXError: IfGis not complete, the algorithm raises an exception.\nMethods: []\nRubrics: Notes: This implementation of a greedy algorithm is based on the following:\nExamples: fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.greedy_tsp(G,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31",
    "Section ID: add_path\nDescription: [Add a path to the Graph G_to_add_to.]\nField List: Parameters:: G_to_add_to : graph: A NetworkX graph\nnodes_for_path : iterable container: A container of nodes.  A path will be constructed from\nthe nodes (in order) and added to the graph.\nattr : keyword arguments, optional (default= no attributes): Attributes to add to every edge in path.\nMethods: []\nRubrics: Examples: G=nx.Graph()\nnx.add_path(G,[0,1,2,3])\nnx.add_path(G,[10,11,12],weight=7)",
    "Section ID: draw_kamada_kawai\nDescription: [Draw the graph G with a Kamada-Kawai force-directed layout., This is a convenience function equivalent to:]\nField List: Parameters:: G : graph: A networkx graph\nkwargs : optional keywords: Seedraw_networkxfor a description of optional keywords.\nMethods: []\nRubrics: Notes: The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call kamada_kawai_layout directly and reuse the\nresult:\nExamples: G=nx.path_graph(5)\nnx.draw_kamada_kawai(G)",
    "Section ID: dag_longest_path\nDescription: [Returns the longest path in a directed acyclic graph (DAG)., If G has edges with weight attribute the edge data are used as\nweight values.]\nField List: Parameters:: G : NetworkX DiGraph: A directed acyclic graph (DAG)\nweight : str, optional: Edge data key to use for weight\ndefault_weight : int, optional: The weight of edges that do not have a weight attribute\ntopo_order: list or tuple, optional: A topological order forG(if None, the function will compute one)\nReturns:: list: Longest path\nRaises:: NetworkXNotImplemented: IfGis not directed\nMethods: []\nRubrics: Examples: DG=nx.DiGraph([(0,1,{\"cost\":1}),(1,2,{\"cost\":1}),(0,2,{\"cost\":42})])\nlist(nx.all_simple_paths(DG,0,2))\n# [[0, 1, 2], [0, 2]]\nnx.dag_longest_path(DG)\n# [0, 1, 2]\nnx.dag_longest_path(DG,weight=\"cost\")\n# [0, 2]\nIn the case where multiple valid topological orderings exist,topo_ordercan be used to specify a specific ordering:\nDG=nx.DiGraph([(0,1),(0,2)])\nsorted(nx.all_topological_sorts(DG))# Valid topological orderings\n# [[0, 1, 2], [0, 2, 1]]\nnx.dag_longest_path(DG,topo_order=[0,1,2])\n# [0, 1]\nnx.dag_longest_path(DG,topo_order=[0,2,1])\n# [0, 2]",
    "Section ID: graphviz_layout\nDescription: [Create node positions using Pydot and Graphviz., Returns a dictionary of positions keyed by node.]\nField List: Parameters:: G : NetworkX Graph: The graph for which the layout is computed.\nprog : string (default: ‘neato’): The name of the GraphViz program to use for layout.\nOptions depend on GraphViz version but may include:\n‘dot’, ‘twopi’, ‘fdp’, ‘sfdp’, ‘circo’\nroot : Node from G or None (default: None): The node of G from which to start some layout algorithms.\nReturns:: Dictionary of (x, y) positions keyed by node.:\nMethods: []\nRubrics: Notes: This is a wrapper for pydot_layout.\nExamples: G=nx.complete_graph(4)\npos=nx.nx_pydot.graphviz_layout(G)\npos=nx.nx_pydot.graphviz_layout(G,prog=\"dot\")",
    "Section ID: truncated_tetrahedron_graph\nDescription: [Returns the skeleton of the truncated Platonic tetrahedron., The truncated tetrahedron is an Archimedean solid with 4 regular hexagonal faces,\n4 equilateral triangle faces, 12 nodes and 18 edges. It can be constructed by truncating\nall 4 vertices of a regular tetrahedron at one third of the original edge length [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Skeleton of the truncated tetrahedron\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Truncated_tetrahedron",
    "Section ID: union_all\nDescription: [Returns the union of all graphs., The graphs must be disjoint, otherwise an exception is raised.]\nField List: Parameters:: graphs : iterable: Iterable of NetworkX graphs\nrename : iterable , optional: Node names of graphs can be changed by specifying the tuple\nrename=(‘G-‘,’H-’) (for example).  Node “u” in G is then renamed\n“G-u” and “v” in H is renamed “H-v”. Infinite generators (like itertools.count)\nare also supported.\nReturns:: U : a graph with the same type as the first graph in list:\nRaises:: ValueError: Ifgraphsis an empty list.\nNetworkXError: In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\nMethods: []\nRubrics: Notes: For operating on mixed type graphs, they should be converted to the same type.\n>>> G = nx.Graph()\n>>> H = nx.DiGraph()\n>>> GH = union_all([nx.DiGraph(G), H]) To force a disjoint union with node relabeling, use\ndisjoint_union_all(G,H) or convert_node_labels_to integers(). Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.\nExamples: G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(4,5),(5,6)])\nresult_graph=nx.union_all([G1,G2])\nresult_graph.nodes()\n# NodeView((1, 2, 3, 4, 5, 6))\nresult_graph.edges()\n# EdgeView([(1, 2), (2, 3), (4, 5), (5, 6)])",
    "Section ID: maximum_flow_value\nDescription: [Find the value of maximum single-commodity flow.]\nField List: Parameters:: flowG : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\n_s : node: Source node for the flow.\n_t : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nflow_func : function: A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.\nkwargs : Any other keyword parameter is passed to the function that: computes the maximum flow.\nReturns:: flow_value : integer, float: Value of the maximum flow, i.e., net outflow from the source.\nRaises:: NetworkXError: The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.\nNetworkXUnbounded: If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded.\nMethods: []\nRubrics: Notes: The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.\nExamples: G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow_value computes only the value of the\nmaximum flow:\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow_value(G,\"x\",\"y\",flow_func=shortest_augmenting_path)\n# True",
    "Section ID: closeness_centrality\nDescription: [Compute closeness centrality for nodes., Closeness centrality [1] of a node u is the reciprocal of the\naverage shortest path distance to u over all n-1 reachable nodes., where d(v,u) is the shortest-path distance between v and u ,\nand n-1 is the number of nodes reachable from u . Notice that the\ncloseness distance function computes the incoming distance to u for directed graphs. To use outward distance, act on G.reverse() ., Notice that higher values of closeness indicate higher centrality., Wasserman and Faust propose an improved formula for graphs with\nmore than one connected component. The result is “a ratio of the\nfraction of actors in the group who are reachable, to the average\ndistance” from the reachable actors [2] . You might think this\nscale factor is inverted but it is not. As is, nodes from small\ncomponents receive a smaller closeness value. Letting N denote\nthe number of nodes in the graph,]\nField List: Parameters:: G : graph: A NetworkX graph\nu : node, optional: Return only the value for node u\ndistance : edge attribute key, optional (default=None): Use the specified edge attribute as the edge distance in shortest\npath calculations.  IfNone(the default) all edges have a distance of 1.\nAbsent edge attributes are assigned a distance of 1. Note that no check\nis performed to ensure that edges have the provided attribute.\nwf_improved : bool, optional (default=True): If True, scale by the fraction of nodes reachable. This gives the\nWasserman and Faust improved formula. For single component graphs\nit is the same as the original formula.\nReturns:: nodes : dictionary: Dictionary of nodes with closeness centrality as the value.\nMethods: []\nRubrics: Notes: The closeness centrality is normalized to (n-1)/(|G|-1) where n is the number of nodes in the connected part of graph\ncontaining the node.  If the graph is not completely connected,\nthis algorithm computes the closeness centrality for each\nconnected part separately scaled by that parts size. If the ‘distance’ keyword is set to an edge attribute key then the\nshortest-path length will be computed using Dijkstra’s algorithm with\nthat edge attribute as the edge weight. The closeness centrality uses inward distance to a node, not outward.\nIf you want to use outword distances apply the function to G.reverse() In NetworkX 2.2 and earlier a bug caused Dijkstra’s algorithm to use the\noutward distance rather than the inward distance. If you use a ‘distance’\nkeyword and a DiGraph, your results will change between v2.2 and v2.3.\nReferences: [1]Linton C. Freeman: Centrality in networks: I.\nConceptual clarification. Social Networks 1:215-239, 1979.https://doi.org/10.1016/0378-8733(78)90021-7  [2]pg. 201 of Wasserman, S. and Faust, K.,\nSocial Network Analysis: Methods and Applications, 1994,\nCambridge University Press.\nExamples: G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.closeness_centrality(G)\n# {0: 1.0, 1: 1.0, 2: 0.75, 3: 0.75}",
    "Section ID: naive_greedy_modularity_communities\nDescription: [Find communities in G using greedy modularity maximization., This implementation is O(n^4), much slower than alternatives, but it is\nprovided as an easy-to-understand reference implementation., Greedy modularity maximization begins with each node in its own community\nand joins the pair of communities that most increases modularity until no\nsuch pair exists., This function maximizes the generalized modularity, where resolution is the resolution parameter, often expressed as \\(\\gamma\\) .\nSee modularity() .]\nField List: Parameters:: G : NetworkX graph: Graph must be simple and undirected.\nresolution : float (default=1): If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities.\nweight : string or None, optional (default=None): The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.\nReturns:: list: A list of sets of nodes, one for each community.\nSorted by length with largest communities first.\nMethods: []\nRubrics: Examples: G=nx.karate_club_graph()\nc=nx.community.naive_greedy_modularity_communities(G)\nsorted(c[0])\n# [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]",
    "Section ID: corona_product\nDescription: [Returns the Corona product of G and H., The corona product of \\(G\\) and \\(H\\) is the graph \\(C = G \\circ H\\) obtained by\ntaking one copy of \\(G\\) , called the center graph, \\(|V(G)|\\) copies of \\(H\\) ,\ncalled the outer graph, and making the \\(i\\) -th vertex of \\(G\\) adjacent to\nevery vertex of the \\(i\\) -th copy of \\(H\\) , where \\(1 ≤ i ≤ |V(G)|\\) .]\nField List: Parameters:: G, H: NetworkX graphs: The graphs to take the carona product of.Gis the center graph andHis the outer graph\nReturns:: C: NetworkX graph: The Corona product of G and H.\nRaises:: NetworkXError: If G and H are not both directed or both undirected.\nMethods: []\nRubrics: References: [1] M. Tavakoli, F. Rahbarnia, and A. R. Ashrafi, “Studying the corona product of graphs under some graph invariants,”\nTransactions on Combinatorics, vol. 3, no. 3, pp. 43–49, Sep. 2014,\ndoi: 10.22108/toc.2014.5542.  [2] A. Faraji, “Corona Product in Graph Theory,” Ali Faraji, May 11, 2021. https://blog.alifaraji.ir/math/graph-theory/corona-product.html(accessed Dec. 07, 2021).\nExamples: G=nx.cycle_graph(4)\nH=nx.path_graph(2)\nC=nx.corona_product(G,H)\nlist(C)\n# [0, 1, 2, 3, (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\nprint(C)\n# Graph with 12 nodes and 16 edges",
    "Section ID: planted_partition_graph\nDescription: [Returns the planted l-partition graph., This model partitions a graph with n=l*k vertices in\nl groups with k vertices each. Vertices of the same\ngroup are linked with a probability p_in, and vertices\nof different groups are linked with probability p_out.]\nField List: Parameters:: l : int: Number of groups\nk : int: Number of vertices in each group\np_in : float: probability of connecting vertices within a group\np_out : float: probability of connected vertices between groups\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : bool,optional (default=False): If True return a directed graph\nReturns:: G : NetworkX Graph or DiGraph: planted l-partition graph\nRaises:: NetworkXError: Ifp_in,p_outare not in[0,1]\nMethods: []\nRubrics: References: [1]A. Condon, R.M. Karp, Algorithms for graph partitioning\non the planted partition model,\nRandom Struct. Algor. 18 (2001) 116-140.  [2]Santo Fortunato ‘Community Detection in Graphs’ Physical Reports\nVolume 486, Issue 3-5 p. 75-174.https://arxiv.org/abs/0906.0612\nExamples: G=nx.planted_partition_graph(4,3,0.5,0.1,seed=42)",
    "Section ID: percolation_centrality\nDescription: [Compute the percolation centrality for nodes., Percolation centrality of a node \\(v\\) , at a given time, is defined\nas the proportion of ‘percolated paths’ that go through that node., This measure quantifies relative impact of nodes based on their\ntopological connectivity, as well as their percolation states., Percolation states of nodes are used to depict network percolation\nscenarios (such as during infection transmission in a social network\nof individuals, spreading of computer viruses on computer networks, or\ntransmission of disease over a network of towns) over time. In this\nmeasure usually the percolation state is expressed as a decimal\nbetween 0.0 and 1.0., When all nodes are in the same percolated state this measure is\nequivalent to betweenness centrality.]\nField List: Parameters:: G : graph: A NetworkX graph.\nattribute : None or string, optional (default=’percolation’): Name of the node attribute to use for percolation state, used\nifstatesis None. If a node does not set the attribute the\nstate of that node will be set to the default value of 1.\nIf all nodes do not have the attribute all nodes will be set to\n1 and the centrality measure will be equivalent to betweenness centrality.\nstates : None or dict, optional (default=None): Specify percolation states for the nodes, nodes as keys states\nas values.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.\nReturns:: nodes : dictionary: Dictionary of nodes with percolation centrality as the value.\nMethods: []\nRubrics: Notes: The algorithm is from Mahendra Piraveenan, Mikhail Prokopenko, and\nLiaquat Hossain [1] Pair dependencies are calculated and accumulated using [2] For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\nReferences: [1]Mahendra Piraveenan, Mikhail Prokopenko, Liaquat Hossain\nPercolation Centrality: Quantifying Graph-Theoretic Impact of Nodes\nduring Percolation in Networkshttp://journals.plos.org/plosone/article?id=10.1371/journal.pone.0053095  [2]Ulrik Brandes:\nA Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249",
    "Section ID: cost_of_flow\nDescription: [Compute the cost of the flow given by flowDict on graph G., Note that this function does not check for the validity of the\nflow flowDict. This function will fail if the graph G and the\nflow don’t have the same edge set.]\nField List: Parameters:: G : NetworkX graph: DiGraph on which a minimum cost flow satisfying all demands is\nto be found.\nweight : string: Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: ‘weight’.\nflowDict : dictionary: Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v).\nReturns:: cost : Integer, float: The total cost of the flow. This is given by the sum over all\nedges of the product of the edge’s flow and the edge’s weight.\nMethods: []\nRubrics: Notes: This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\nExamples: G=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowDict=nx.min_cost_flow(G)\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nnx.cost_of_flow(G,flowDict)\n# 24",
    "Section ID: bfs_edges\nDescription: [Iterate over edges in a breadth-first-search starting at source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Specify starting node for breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.\nreverse : bool, optional: If True traverse a directed graph in the reverse direction\ndepth_limit : int, optional(default=len(G)): Specify the maximum search depth\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nYields:: edge: 2-tuple of nodes: Yields edges resulting from the breadth-first search.\nMethods: []\nRubrics: Notes: The naming of this function is very similar to edge_bfs() . The difference\nis that edge_bfs yields edges even if they extend back to an already\nexplored node while this generator yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means edge_bfs reports all edges while bfs_edges only reports those traversed by a node-based BFS. Yet another\ndescription is that bfs_edges reports the edges traversed during BFS\nwhile edge_bfs reports all edges in the order they are explored. Based on the breadth-first search implementation in PADS [1] by D. Eppstein, July 2004; with modifications to allow depth limits\nas described in [2] .\nReferences: [1]http://www.ics.uci.edu/~eppstein/PADS/BFS.py.  [2]https://en.wikipedia.org/wiki/Depth-limited_search\nExamples: To get the edges in a breadth-first search:\nG=nx.path_graph(3)\nlist(nx.bfs_edges(G,0))\n# [(0, 1), (1, 2)]\nlist(nx.bfs_edges(G,source=0,depth_limit=1))\n# [(0, 1)]\nTo get the nodes in a breadth-first search order:\nG=nx.path_graph(3)\nroot=2\nedges=nx.bfs_edges(G,root)\nnodes=[root]+[vforu,vinedges]\nnodes\n# [2, 1, 0]",
    "Section ID: katz_centrality_numpy\nDescription: [Compute the Katz centrality for the graph G., Katz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node \\(i\\) is, where \\(A\\) is the adjacency matrix of graph G with eigenvalues \\(\\lambda\\) ., The parameter \\(\\beta\\) controls the initial centrality and, Katz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors., Extra weight can be provided to immediate neighbors through the\nparameter \\(\\beta\\) .  Connections made with distant neighbors\nare, however, penalized by an attenuation factor \\(\\alpha\\) which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1] .]\nField List: Parameters:: G : graph: A NetworkX graph\nalpha : float: Attenuation factor\nbeta : scalar or dictionary, optional (default=1.0): Weight attributed to the immediate neighborhood. If not a scalar the\ndictionary must have an value for every node.\nnormalized : bool: If True normalize the resulting values.\nweight : None or string, optional: If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nIn this measure the weight is interpreted as the connection strength.\nReturns:: nodes : dictionary: Dictionary of nodes with Katz centrality as the value.\nRaises:: NetworkXError: If the parameterbetais not a scalar but lacks a value for at least\none node\nMethods: []\nRubrics: Notes: Katz centrality was introduced by [2] . This algorithm uses a direct linear solver to solve the above equation.\nThe parameter alpha should be strictly less than the inverse of largest\neigenvalue of the adjacency matrix for there to be a solution.\nYou can use max(nx.adjacency_spectrum(G)) to get \\(\\lambda_{\\max}\\) the largest\neigenvalue of the adjacency matrix. For strongly connected graphs, as \\(\\alpha \\to 1/\\lambda_{\\max}\\) , and \\(\\beta > 0\\) ,\nKatz centrality approaches the results for eigenvector centrality. For directed graphs this finds “left” eigenvectors which corresponds\nto the in-edges in the graph. For out-edges Katz centrality,\nfirst reverse the graph with G.reverse() .\nReferences: [1]Mark E. J. Newman:\nNetworks: An Introduction.\nOxford University Press, USA, 2010, p. 173.  [2]Leo Katz:\nA New Status Index Derived from Sociometric Index.\nPsychometrika 18(1):39–43, 1953https://link.springer.com/content/pdf/10.1007/BF02289026.pdf\nExamples: importmath\nG=nx.path_graph(4)\nphi=(1+math.sqrt(5))/2.0# largest eigenvalue of adj matrix\ncentrality=nx.katz_centrality_numpy(G,1/phi)\nforn,cinsorted(centrality.items()):\nprint(f\"{n} {c:.2f}\")\n# 0 0.37\n# 1 0.60\n# 2 0.60\n# 3 0.37",
    "Section ID: complete_graph\nDescription: [Return the complete graph K_n with n nodes., A complete graph on n nodes means that all pairs\nof distinct nodes have an edge connecting them., ( Sourcecode , png )]\nField List: Parameters:: n : int or iterable container of nodes: If n is an integer, nodes are from range(n).\nIf n is a container of nodes, those nodes appear in the graph.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nMethods: []\nRubrics: Examples: G=nx.complete_graph(9)\nlen(G)\n# 9\nG.size()\n# 36\nG=nx.complete_graph(range(11,14))\nlist(G.nodes())\n# [11, 12, 13]\nG=nx.complete_graph(4,nx.DiGraph())\nG.is_directed()\n# True",
    "Section ID: local_reaching_centrality\nDescription: [Returns the local reaching centrality of a node in a directed\ngraph., The local reaching centrality of a node in a directed graph is the\nproportion of other nodes reachable from that node [1] .]\nField List: Parameters:: G : DiGraph: A NetworkX DiGraph.\nv : node: A node in the directed graphG.\npaths : dictionary (default=None): If this is notNoneit must be a dictionary representation\nof single-source shortest paths, as computed by, for example,networkx.shortest_path()with source nodev. Use this\nkeyword argument if you intend to invoke this function many\ntimes but don’t want the paths to be recomputed each time.\nweight : None or string, optional (default=None): Attribute to use for edge weights.  IfNone, each edge weight\nis assumed to be one. A higher weight implies a stronger\nconnection between nodes and ashorterpath length.\nnormalized : bool, optional (default=True): Whether to normalize the edge weights by the total sum of edge\nweights.\nReturns:: h : float: The local reaching centrality of the nodevin the graphG.\nMethods: []\nRubrics: References: [1]Mones, Enys, Lilla Vicsek, and Tamás Vicsek.\n“Hierarchy Measure for Complex Networks.”PLoS ONE7.3 (2012): e33799.https://doi.org/10.1371/journal.pone.0033799\nExamples: G=nx.DiGraph()\nG.add_edges_from([(1,2),(1,3)])\nnx.local_reaching_centrality(G,3)\n# 0.0\nG.add_edge(3,2)\nnx.local_reaching_centrality(G,3)\n# 0.5",
    "Section ID: sedgewick_maze_graph\nDescription: [Return a small maze with a cycle., This is the maze used in Sedgewick, 3rd Edition, Part 5, Graph\nAlgorithms, Chapter 18, e.g. Figure 18.2 and following [1] .\nNodes are numbered 0,..,7]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Small maze with a cycle\nMethods: []\nRubrics: References: [1]Figure 18.2, Chapter 18, Graph Algorithms (3rd Ed), Sedgewick",
    "Section ID: random_clustered_graph\nDescription: [Generate a random graph with the given joint independent edge degree and\ntriangle degree sequence., This uses a configuration model-like approach to generate a random graph\n(with parallel edges and self-loops) by randomly assigning edges to match\nthe given joint degree sequence., The joint degree sequence is a list of pairs of integers of the form \\([(d_{1,i}, d_{1,t}), \\dotsc, (d_{n,i}, d_{n,t})]\\) . According to this list,\nvertex \\(u\\) is a member of \\(d_{u,t}\\) triangles and has \\(d_{u, i}\\) other\nedges. The number \\(d_{u,t}\\) is the triangle degree of \\(u\\) and the number \\(d_{u,i}\\) is the independent edge degree .]\nField List: Parameters:: joint_degree_sequence : list of integer pairs: Each list entry corresponds to the independent edge degree and\ntriangle degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph): Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : MultiGraph: A graph with the specified degree sequence. Nodes are labeled\nstarting at 0 with an index corresponding to the position in\ndeg_sequence.\nRaises:: NetworkXError: If the independent edge degree sequence sum is not even\nor the triangle degree sequence sum is not divisible by 3.\nMethods: []\nRubrics: Notes: As described by Miller [1] (see also Newman [2] for an equivalent\ndescription). A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the\nindependent degree sequence does not have an even sum or the\ntriangle degree sequence sum is not divisible by 3. This configuration model-like construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn’t have the exact degree sequence specified.  This\n“finite-size effect” decreases as the size of the graph increases.\nReferences: [1]Joel C. Miller. “Percolation and epidemics in random clustered\nnetworks”. In: Physical review. E, Statistical, nonlinear, and soft\nmatter physics 80 (2 Part 1 August 2009).  [2]M. E. J. Newman. “Random Graphs with Clustering”.\nIn: Physical Review Letters 103 (5 July 2009)\nExamples: deg=[(1,0),(1,0),(1,0),(2,0),(1,0),(2,1),(0,1),(0,1)]\nG=nx.random_clustered_graph(deg)\nTo remove parallel edges:\nG=nx.Graph(G)\nTo remove self loops:\nG.remove_edges_from(nx.selfloop_edges(G))",
    "Section ID: k_components\nDescription: [Returns the approximate k-component structure of a graph G., A k -component is a maximal subgraph of a graph G that has, at least,\nnode connectivity k : we need to remove at least k nodes to break it\ninto more components. k -components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth., This implementation is based on the fast heuristics to approximate\nthe k -component structure of a graph [1] . Which, in turn, it is based on\na fast approximation algorithm for finding good lower bounds of the number\nof node independent paths between two nodes [2] .]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nmin_density : Float: Density relaxation threshold. Default value 0.95\nReturns:: k_components : dict: Dictionary with connectivity levelkas key and a list of\nsets of nodes that form a k-component of levelkas values.\nRaises:: NetworkXNotImplemented: If G is directed.\nMethods: []\nRubrics: Notes: The logic of the approximation algorithm for computing the k -component\nstructure [1] is based on repeatedly applying simple and fast algorithms\nfor k -cores and biconnected components in order to narrow down the\nnumber of pairs of nodes over which we have to compute White and Newman’s\napproximation algorithm for finding node independent paths [2] . More\nformally, this algorithm is based on Whitney’s theorem, which states\nan inclusion relation among node connectivity, edge connectivity, and\nminimum degree for any graph G. This theorem implies that every k -component is nested inside a k -edge-component, which in turn,\nis contained in a k -core. Thus, this algorithm computes node independent\npaths among pairs of nodes in each biconnected part of each k -core,\nand repeats this procedure for each k from 3 to the maximal core number\nof a node in the input graph. Because, in practice, many nodes of the core of level k inside a\nbicomponent actually are part of a component of level k, the auxiliary\ngraph needed for the algorithm is likely to be very dense. Thus, we use\na complement graph data structure (see AntiGraph ) to save memory.\nAntiGraph only stores information of the edges that are not present\nin the actual auxiliary graph. When applying algorithms to this\ncomplement graph data structure, it behaves as if it were the dense\nversion.\nReferences: [1](1,2)Torrents, J. and F. Ferraro (2015) Structural Cohesion:\nVisualization and Heuristics for Fast Computation.https://arxiv.org/pdf/1503.04476v1  [2](1,2)White, Douglas R., and Mark Newman (2001) A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035https://www.santafe.edu/research/results/working-papers/fast-approximation-algorithms-for-finding-node-ind  [3]Moody, J. and D. White (2003). Social cohesion and embeddedness:\nA hierarchical conception of social groups.\nAmerican Sociological Review 68(1), 103–28.https://doi.org/10.2307/3088904\nExamples: # Petersen graph has 10 nodes and it is triconnected, thus all\n# nodes are in a single component on all three connectivity levels\nfromnetworkx.algorithmsimportapproximationasapxa\nG=nx.petersen_graph()\nk_components=apxa.k_components(G)",
    "Section ID: label_propagation_communities\nDescription: [Generates community sets determined by label propagation, Finds communities in G using a semi-synchronous label propagation\nmethod [1] . This method combines the advantages of both the synchronous\nand asynchronous models. Not implemented for directed graphs.]\nField List: Parameters:: G : graph: An undirected NetworkX graph.\nReturns:: communities : iterable: A dict_values object that contains a set of nodes for each community.\nRaises:: NetworkXNotImplemented: If the graph is directed\nMethods: []\nRubrics: References: [1]Cordasco, G., & Gargano, L. (2010, December). Community detection\nvia semi-synchronous label propagation algorithms. In Business\nApplications of Social Network Analysis (BASNA), 2010 IEEE International\nWorkshop on (pp. 1-8). IEEE.",
    "Section ID: dijkstra_path\nDescription: [Returns the shortest weighted path from source to target in G., Uses Dijkstra’s Method to compute the shortest weighted path\nbetween two nodes in a graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node\ntarget : node: Ending node\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: path : list: List of nodes in a shortest path.\nRaises:: NodeNotFound: Ifsourceis not inG.\nNetworkXNoPath: If no path exists between source and target.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. The weight function can be used to include node weights.\nExamples: G=nx.path_graph(5)\nprint(nx.dijkstra_path(G,0,4))\n# [0, 1, 2, 3, 4]\nFind edges of shortest path in Multigraph\nG=nx.MultiDiGraph()\nG.add_weighted_edges_from([(1,2,0.75),(1,2,0.5),(2,3,0.5),(1,3,1.5)])\nnodes=nx.dijkstra_path(G,1,3)\nedges=nx.utils.pairwise(nodes)\nlist(\n(u,v,min(G[u][v],key=lambdak:G[u][v][k].get(\"weight\",1)))\nforu,vinedges\n)\n# [(1, 2, 1), (2, 3, 0)]",
    "Section ID: biconnected_component_edges\nDescription: [Returns a generator of lists of edges, one list for each biconnected\ncomponent of the input graph., Biconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph.  Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.\nHowever, each edge belongs to one, and only one, biconnected component., Notice that by convention a dyad is considered a biconnected component.]\nField List: Parameters:: G : NetworkX Graph: An undirected graph.\nReturns:: edges : generator of lists: Generator of lists of edges, one list for each bicomponent.\nRaises:: NetworkXNotImplemented: If the input graph is not undirected.\nMethods: []\nRubrics: Notes: The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.\nReferences: [1]Hopcroft, J.; Tarjan, R. (1973).\n“Efficient algorithms for graph manipulation”.\nCommunications of the ACM 16: 372–378. doi:10.1145/362248.362272\nExamples: G=nx.barbell_graph(4,2)\nprint(nx.is_biconnected(G))\n# False\nbicomponents_edges=list(nx.biconnected_component_edges(G))\nlen(bicomponents_edges)\n# 5\nG.add_edge(2,8)\nprint(nx.is_biconnected(G))\n# True\nbicomponents_edges=list(nx.biconnected_component_edges(G))\nlen(bicomponents_edges)\n# 1",
    "Section ID: asyn_fluidc\nDescription: [Returns communities in G as detected by Fluid Communities algorithm., The asynchronous fluid communities algorithm is described in [1] . The algorithm is based on the simple idea of fluids interacting\nin an environment, expanding and pushing each other. Its initialization is\nrandom, so found communities may vary on different executions., The algorithm proceeds as follows. First each of the initial k communities\nis initialized in a random vertex in the graph. Then the algorithm iterates\nover all vertices in a random order, updating the community of each vertex\nbased on its own community and the communities of its neighbors. This\nprocess is performed several times until convergence.\nAt all times, each community has a total density of 1, which is equally\ndistributed among the vertices it contains. If a vertex changes of\ncommunity, vertex densities of affected communities are adjusted\nimmediately. When a complete iteration over all vertices is done, such that\nno vertex changes the community it belongs to, the algorithm has converged\nand returns., This is the original version of the algorithm described in [1] .\nUnfortunately, it does not support weighted graphs yet.]\nField List: Parameters:: G : NetworkX graph: Graph must be simple and undirected.\nk : integer: The number of communities to be found.\nmax_iter : integer: The number of maximum iterations allowed. By default 100.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: communities : iterable: Iterable of communities given as sets of nodes.\nMethods: []\nRubrics: Notes: k variable is not an optional argument.\nReferences: [1](1,2)Parés F., Garcia-Gasulla D. et al. “Fluid Communities: A\nCompetitive and Highly Scalable Community Detection Algorithm”.\n[https://arxiv.org/pdf/1703.09307.pdf].",
    "Section ID: is_valid_degree_sequence_erdos_gallai\nDescription: [Returns True if deg_sequence can be realized by a simple graph., The validation is done using the Erdős-Gallai theorem [EG1960] .]\nField List: Parameters:: deg_sequence : list: A list of integers\nReturns:: valid : bool: True if deg_sequence is graphical and False if not.\nMethods: []\nRubrics: Notes: This implementation uses an equivalent form of the Erdős-Gallai criterion.\nWorst-case run time is \\(O(n)\\) where \\(n\\) is the length of the sequence. Specifically, a sequence d is graphical if and only if the\nsum of the sequence is even and for all strong indices k in the sequence,\nReferences: [1]A. Tripathi and S. Vijay. “A note on a theorem of Erdős & Gallai”,\nDiscrete Mathematics, 265, pp. 417-420 (2003).  [2](1,2)I.E. Zverovich and V.E. Zverovich. “Contributions to the theory\nof graphic sequences”, Discrete Mathematics, 105, pp. 292-303 (1992).  [EG1960]Erdős and Gallai, Mat. Lapok 11 264, 1960.\nExamples: G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_valid_degree_sequence_erdos_gallai(sequence)\n# True\nTo test a non-valid sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\nFalse",
    "Section ID: maximal_independent_set\nDescription: [Returns a random maximal independent set guaranteed to contain\na given set of nodes., An independent set is a set of nodes such that the subgraph\nof G induced by these nodes contains no edges. A maximal\nindependent set is an independent set such that it is not possible\nto add a new node and still get an independent set.]\nField List: Parameters:: G : NetworkX graph: \nnodes : list or iterable: Nodes that must be part of the independent set. This set of nodes\nmust be independent.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: indep_nodes : list: List of nodes that are part of a maximal independent set.\nRaises:: NetworkXUnfeasible: If the nodes in the provided list are not part of the graph or\ndo not form an independent set, an exception is raised.\nNetworkXNotImplemented: IfGis directed.\nMethods: []\nRubrics: Notes: This algorithm does not solve the maximum independent set problem.\nExamples: G=nx.path_graph(5)\nnx.maximal_independent_set(G)\n# [4, 0, 2]\nnx.maximal_independent_set(G,[1])\n# [1, 3]",
    "Section ID: group_out_degree_centrality\nDescription: [Compute the group out-degree centrality for a group of nodes., Group out-degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members by outgoing edges.]\nField List: Parameters:: G : graph: A NetworkX graph.\nS : list or set: S is a group of nodes which belong to G, for which group in-degree\ncentrality is to be calculated.\nReturns:: centrality : float: Group out-degree centrality of the group S.\nRaises:: NetworkXNotImplemented: If G is undirected.\nNodeNotFound: If node(s) in S are not in G.\nMethods: []\nRubrics: Notes: The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. G.neighbors(i) gives nodes with an outward edge from i, in a DiGraph,\nso for group out-degree centrality, the graph itself is used.",
    "Section ID: adjacency_spectrum\nDescription: [Returns eigenvalues of the adjacency matrix of G.]\nField List: Parameters:: G : graph: A NetworkX graph\nweight : string or None, optional (default=’weight’): The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.\nReturns:: evals : NumPy array: Eigenvalues\nMethods: []\nRubrics: Notes: For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array for other options.",
    "Section ID: local_and_global_consistency\nDescription: [Node classification by Local and Global Consistency, Function for computing Local and global consistency algorithm by Zhou et al.]\nField List: Parameters:: G : NetworkX Graph: \nalpha : float: Clamping factor\nmax_iter : int: Maximum number of iterations allowed\nlabel_name : string: Name of target labels to predict\nReturns:: predicted : list: List of lengthlen(G)with the predicted labels for each node.\nRaises:: NetworkXError: If no nodes inGhave attributelabel_name.\nMethods: []\nRubrics: References: Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Schölkopf, B. (2004).\nLearning with local and global consistency.\nAdvances in neural information processing systems, 16(16), 321-328.\nExamples: fromnetworkx.algorithmsimportnode_classification\nG=nx.path_graph(4)\nG.nodes[0][\"label\"]=\"A\"\nG.nodes[3][\"label\"]=\"B\"\nG.nodes(data=True)\n# NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\nG.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])\npredicted=node_classification.local_and_global_consistency(G)\npredicted\n# ['A', 'A', 'B', 'B']",
    "Section ID: read_dot\nDescription: [Returns a NetworkX graph from a dot file on path.]\nField List: Parameters:: path : file or string: File name or file handle to read.\nMethods: []\nRubrics:",
    "Section ID: moebius_kantor_graph\nDescription: [Returns the Moebius-Kantor graph., The Möbius-Kantor graph is the cubic symmetric graph on 16 nodes.\nIts LCF notation is [5,-5]^8, and it is isomorphic to the generalized\nPetersen graph [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Moebius-Kantor graph\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/M%C3%B6bius%E2%80%93Kantor_graph",
    "Section ID: is_arborescence\nDescription: [Returns True if G is an arborescence., An arborescence is a directed tree with maximum in-degree equal to 1.]\nField List: Parameters:: G : graph: The graph to test.\nReturns:: b : bool: A boolean that is True ifGis an arborescence.\nMethods: []\nRubrics: Notes: In another convention, an arborescence is known as a tree .\nExamples: G=nx.DiGraph([(0,1),(0,2),(2,3),(3,4)])\nnx.is_arborescence(G)\n# True\nG.remove_edge(0,1)\nG.add_edge(1,2)# maximum in-degree is 2\nnx.is_arborescence(G)\n# False",
    "Section ID: ramsey_R2\nDescription: [Compute the largest clique and largest independent set in G ., This can be used to estimate bounds for the 2-color\nRamsey number R(2;s,t) for G ., This is a recursive implementation which could run into trouble\nfor large recursions. Note that self-loop edges are ignored.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nReturns:: max_pair : (set, set) tuple: Maximum clique, Maximum independent set.\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics:",
    "Section ID: is_distance_regular\nDescription: [Returns True if the graph is distance regular, False otherwise., A connected graph G is distance-regular if for any nodes x,y\nand any integers i,j=0,1,…,d (where d is the graph\ndiameter), the number of vertices at distance i from x and\ndistance j from y depends only on i,j and the graph distance\nbetween x and y, independently of the choice of x and y.]\nField List: Parameters:: G: Networkx graph (undirected):\nReturns:: bool: True if the graph is Distance Regular, False otherwise\nMethods: []\nRubrics: Notes: For undirected and simple graphs only\nReferences: [1]Brouwer, A. E.; Cohen, A. M.; and Neumaier, A.\nDistance-Regular Graphs. New York: Springer-Verlag, 1989.  [2]Weisstein, Eric W. “Distance-Regular Graph.”http://mathworld.wolfram.com/Distance-RegularGraph.html\nExamples: G=nx.hypercube_graph(6)\nnx.is_distance_regular(G)\n# True",
    "Section ID: write_latex\nDescription: [Write the latex code to draw the graph(s) onto path ., This convenience function creates the latex drawing code as a string\nand writes that to a file ready to be compiled when as_document is True\nor ready to be import ed or include ed into your main LaTeX document., The path argument can be a string filename or a file handle to write to.]\nField List: Parameters:: Gbunch : NetworkX graph or iterable of NetworkX graphs: If Gbunch is a graph, it is drawn in a figure environment.\nIf Gbunch is an iterable of graphs, each is drawn in a subfigure\nenvironment within a single figure environment.\npath : filename: Filename or file handle to write to\noptions : dict: By default, TikZ is used with options: (others are ignored):pos : string or dict or list\n    The name of the node attribute on `G` that holds the position of each node.\n    Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n    They can also be strings to denote positions in TikZ style, such as (x, y)\n    or (angle:radius).\n    If a dict, it should be keyed by node to a position.\n    If an empty dict, a circular layout is computed by TikZ.\n    If you are drawing many graphs in subfigures, use a list of position dicts.\ntikz_options : string\n    The tikzpicture options description defining the options for the picture.\n    Often large scale options like `[scale=2]`.\ndefault_node_options : string\n    The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict\n    The name of the node attribute on `G` that holds the options for each node.\n    Or a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict\n    The name of the node attribute on `G` that holds the node label (text)\n    displayed for each node. If the attribute is \"\" or not present, the node\n    itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n    Or a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string\n    The options for the scope drawing all edges. The default is \"[-]\" for\n    undirected graphs and \"[->]\" for directed graphs.\nedge_options : string or dict\n    The name of the edge attribute on `G` that holds the options for each edge.\n    If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n    \"loop,\" is added to the options for the self-loop edge. Hence you can\n    use \"[loop above]\" explicitly, but the default is \"[loop]\".\n    Or a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict\n    The name of the edge attribute on `G` that holds the edge label (text)\n    displayed for each edge. If the attribute is \"\" or not present, no edge\n    label is drawn.\n    Or a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict\n    The name of the edge attribute on `G` that holds the label options for\n    each edge. For example, \"[sloped,above,blue]\". The default is no options.\n    Or a dict keyed by edge to a string holding the label options for that edge.\ncaption : string\n    The caption string for the figure environment\nlatex_label : string\n    The latex label used for the figure for easy referral from the main text\nsub_captions : list of strings\n    The sub_caption string for each subfigure in the figure\nsub_latex_labels : list of strings\n    The latex label for each subfigure in the figure\nn_rows : int\n    The number of rows of subfigures to arrange for multiple graphs\nas_document : bool\n    Whether to wrap the latex code in a document environment for compiling\ndocument_wrapper : formatted text string with variable ``content``.\n    This text is called to evaluate the content embedded in a document\n    environment with a preamble setting up the TikZ syntax.\nfigure_wrapper : formatted text string\n    This text is evaluated with variables ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\nsubfigure_wrapper : formatted text string\n    This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\n    The size is the vertical size of each row of subfigures as a fraction.\nMethods: []\nRubrics:",
    "Section ID: chain_decomposition\nDescription: [Returns the chain decomposition of a graph., The chain decomposition of a graph with respect a depth-first\nsearch tree is a set of cycles or paths derived from the set of\nfundamental cycles of the tree in the following manner. Consider\neach fundamental cycle with respect to the given tree, represented\nas a list of edges beginning with the nontree edge oriented away\nfrom the root of the tree. For each fundamental cycle, if it\noverlaps with any previous fundamental cycle, just take the initial\nnon-overlapping segment, which is a path instead of a cycle. Each\ncycle or path is called a chain . For more information, see [1] .]\nField List: Parameters:: G : undirected graph: \nroot : node (optional): A node in the graphG. If specified, only the chain\ndecomposition for the connected component containing this node\nwill be returned. This node indicates the root of the depth-first\nsearch tree.\nYields:: chain : list: A list of edges representing a chain. There is no guarantee on\nthe orientation of the edges in each chain (for example, if a\nchain includes the edge joining nodes 1 and 2, the chain may\ninclude either (1, 2) or (2, 1)).\nRaises:: NodeNotFound: Ifrootis not in the graphG.\nMethods: []\nRubrics: Notes: The worst-case running time of this implementation is linear in the\nnumber of nodes and number of edges [1] .\nReferences: [1](1,2)Jens M. Schmidt (2013). “A simple test on 2-vertex-\nand 2-edge-connectivity.”Information Processing Letters,\n113, 241–244. Elsevier. <https://doi.org/10.1016/j.ipl.2013.01.016>\nExamples: G=nx.Graph([(0,1),(1,4),(3,4),(3,5),(4,5)])\nlist(nx.chain_decomposition(G))\n# [[(4, 5), (5, 3), (3, 4)]]",
    "Section ID: strategy_connected_sequential\nDescription: [Returns an iterable over nodes in G in the order given by a\nbreadth-first or depth-first traversal., traversal must be one of the strings 'dfs' or 'bfs' ,\nrepresenting depth-first traversal or breadth-first traversal,\nrespectively., The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence., G is a NetworkX graph. colors is ignored.]\nField List: Methods: []\nRubrics:",
    "Section ID: draw\nDescription: [Draw the graph G with Matplotlib., Draw the graph as a simple representation with no node\nlabels or edge labels and using the full Matplotlib figure area\nand no axis labels by default.  See draw_networkx() for more\nfull-featured drawing that allows title, axis labels etc.]\nField List: Parameters:: G : graph: A networkx graph\npos : dictionary, optional: A dictionary with nodes as keys and positions as values.\nIf not specified a spring layout positioning will be computed.\nSeenetworkx.drawing.layoutfor functions that\ncompute node positions.\nax : Matplotlib Axes object, optional: Draw the graph in specified Matplotlib axes.\nkwds : optional keywords: See networkx.draw_networkx() for a description of optional keywords.\nMethods: []\nRubrics: Notes: This function has the same name as pylab.draw and pyplot.draw\nso beware when using fromnetworkximport* since you might overwrite the pylab.draw function. With pyplot use\nExamples: G=nx.dodecahedral_graph()\nnx.draw(G)\nnx.draw(G,pos=nx.spring_layout(G))# use spring layout",
    "Section ID: intersection\nDescription: [Returns a new graph that contains only the nodes and the edges that exist in\nboth G and H.]\nField List: Parameters:: G,H : graph: A NetworkX graph. G and H can have different node sets but must be both graphs or both multigraphs.\nReturns:: GH : A new graph with the same type as G.:\nRaises:: NetworkXError: If one is a MultiGraph and the other one is a graph.\nMethods: []\nRubrics: Notes: Attributes from the graph, nodes, and edges are not copied to the new\ngraph.  If you want a new graph of the intersection of G and H\nwith the attributes (including edge data) from G use remove_nodes_from()\nas follows\nExamples: G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,3),(1,2),(2,3)])\nR=nx.intersection(G,H)\nR.nodes\n# NodeView((0, 1, 2))\nR.edges\n# EdgeView([(1, 2)])",
    "Section ID: k_edge_augmentation\nDescription: [Finds set of edges to k-edge-connect G., Adding edges from the augmentation to G make it impossible to disconnect G\nunless k or more edges are removed. This function uses the most efficient\nfunction available (depending on the value of k and if the problem is\nweighted or unweighted) to search for a minimum weight subset of available\nedges that k-edge-connects G. In general, finding a k-edge-augmentation is\nNP-hard, so solutions are not guaranteed to be minimal. Furthermore, a\nk-edge-augmentation may not exist.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nk : integer: Desired edge connectivity\navail : dict or a set of 2 or 3 tuples: The available edges that can be used in the augmentation.If unspecified, then all edges in the complement of G are available.\nOtherwise, each item is an available edge (with an optional weight).In the unweighted case, each item is an edge(u,v).In the weighted case, each item is a 3-tuple(u,v,d)or a dict\nwith items(u,v):d.  The third item,d, can be a dictionary\nor a real number.  Ifdis a dictionaryd[weight]correspondings to the weight.\nweight : string: key to use to find weights ifavailis a set of 3-tuples where the\nthird item in each tuple is a dictionary.\npartial : boolean: If partial is True and no feasible k-edge-augmentation exists, then all\na partial k-edge-augmentation is generated. Adding the edges in a\npartial augmentation to G, minimizes the number of k-edge-connected\ncomponents and maximizes the edge connectivity between those\ncomponents. For details, seepartial_k_edge_augmentation().\nYields:: edge : tuple: Edges that, once added to G, would cause G to become k-edge-connected.\nIf partial is False, an error is raised if this is not possible.\nOtherwise, generated edges form a partial augmentation, which\nk-edge-connects any part of G where it is possible, and maximally\nconnects the remaining parts.\nRaises:: NetworkXUnfeasible: If partial is False and no k-edge-augmentation exists.\nNetworkXNotImplemented: If the input graph is directed or a multigraph.\nValueError:: If k is less than 1\nMethods: []\nRubrics: Notes: When k=1 this returns an optimal solution. When k=2 and avail is None, this returns an optimal solution.\nOtherwise when k=2, this returns a 2-approximation of the optimal solution.\nExamples: # Unweighted cases\nG=nx.path_graph((1,2,3,4))\nG.add_node(5)\nsorted(nx.k_edge_augmentation(G,k=1))\n# [(1, 5)]\nsorted(nx.k_edge_augmentation(G,k=2))\n# [(1, 5), (5, 4)]\nsorted(nx.k_edge_augmentation(G,k=3))\n# [(1, 4), (1, 5), (2, 5), (3, 5), (4, 5)]\ncomplement=list(nx.k_edge_augmentation(G,k=5,partial=True))\nG.add_edges_from(complement)\nnx.edge_connectivity(G)\n# 4\n# Weighted cases\nG=nx.path_graph((1,2,3,4))\nG.add_node(5)\n# avail can be a tuple with a dict\navail=[(1,5,{\"weight\":11}),(2,5,{\"weight\":10})]\nsorted(nx.k_edge_augmentation(G,k=1,avail=avail,weight=\"weight\"))\n# [(2, 5)]\n# or avail can be a 3-tuple with a real number\navail=[(1,5,11),(2,5,10),(4,3,1),(4,5,51)]\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail))\n# [(1, 5), (2, 5), (4, 5)]\n# or avail can be a dict\navail={(1,5):11,(2,5):10,(4,3):1,(4,5):51}\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail))\n# [(1, 5), (2, 5), (4, 5)]\n# If augmentation is infeasible, then a partial solution can be found\navail={(1,5):11}\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail,partial=True))\n# [(1, 5)]",
    "Section ID: petersen_graph\nDescription: [Returns the Petersen graph., The Peterson graph is a cubic, undirected graph with 10 nodes and 15 edges [1] .\nJulius Petersen constructed the graph as the smallest counterexample\nagainst the claim that a connected bridgeless cubic graph\nhas an edge colouring with three colours [2] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Petersen graph\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Petersen_graph  [2]https://www.win.tue.nl/~aeb/drg/graphs/Petersen.html",
    "Section ID: score_sequence\nDescription: [Returns the score sequence for the given tournament graph., The score sequence is the sorted list of the out-degrees of the\nnodes of the graph.]\nField List: Parameters:: G : NetworkX graph: A directed graph representing a tournament.\nReturns:: list: A sorted list of the out-degrees of the nodes ofG.\nMethods: []\nRubrics: Examples: G=nx.DiGraph([(1,0),(1,3),(0,2),(0,3),(2,1),(3,2)])\nnx.is_tournament(G)\n# True\nnx.tournament.score_sequence(G)\n# [1, 1, 2, 2]",
    "Section ID: clique_removal\nDescription: [Repeatedly remove cliques from the graph., Results in a \\(O(|V|/(\\log |V|)^2)\\) approximation of maximum clique\nand independent set. Returns the largest independent set found, along\nwith found maximal cliques.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nReturns:: max_ind_cliques : (set, list) tuple: 2-tuple of Maximal Independent Set and list of maximal cliques (sets).\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics: References: [1]Boppana, R., & Halldórsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180–196. Springer.\nExamples: G=nx.path_graph(10)\nnx.approximation.clique_removal(G)\n# ({0, 2, 4, 6, 9}, [{0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9}])",
    "Section ID: all_pairs_dijkstra\nDescription: [Find shortest weighted paths and lengths between all nodes.]\nField List: Parameters:: G : NetworkX graph: \ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edge[u][v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nYields:: (node, (distance, path)) : (node obj, (dict, dict)): Each source node has two associated dicts. The first holds distance\nkeyed by target and the second holds paths keyed by target.\n(See single_source_dijkstra for the source/target node terminology.)\nIf desired you can applydict()to this function to create a dict\nkeyed by source node to the two dicts.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The yielded dicts only have keys for reachable nodes.\nExamples: G=nx.path_graph(5)\nlen_path=dict(nx.all_pairs_dijkstra(G))\nlen_path[3][0][1]\n# 2\nfornodein[0,1,2,3,4]:\nprint(f\"3 - {node}: {len_path[3][0][node]}\")\n# 3 - 0: 3\n# 3 - 1: 2\n# 3 - 2: 1\n# 3 - 3: 0\n# 3 - 4: 1\nlen_path[3][1][1]\n# [3, 2, 1]\nforn,(dist,path)innx.all_pairs_dijkstra(G):\nprint(path[1])\n# [0, 1]\n# [1]\n# [2, 1]\n# [3, 2, 1]\n# [4, 3, 2, 1]",
    "Section ID: random_labeled_rooted_tree\nDescription: [Returns a labeled rooted tree with n nodes., The returned tree is chosen uniformly at random from all labeled rooted trees.]\nField List: Parameters:: n : int: The number of nodes\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: networkx.Graph: Anetworkx.Graphwith integer nodes 0 <= node <=n- 1.\nThe root of the tree is selected uniformly from the nodes.\nThe “root” graph attribute identifies the root of the tree.\nRaises:: NetworkXPointlessConcept: Ifnis zero (because the null graph is not a tree).\nMethods: []\nRubrics: Notes: This function returns the result of random_labeled_tree() with a randomly selected root.",
    "Section ID: maximum_spanning_tree\nDescription: [Returns a maximum spanning tree or forest on an undirected graph G .]\nField List: Parameters:: G : undirected graph: An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.\nweight : str: Data key to use for edge weights.\nalgorithm : string: The algorithm to use when finding a maximum spanning tree. Valid\nchoices are ‘kruskal’, ‘prim’, or ‘boruvka’. The default is\n‘kruskal’.\nignore_nan : bool (default: False): If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead.\nReturns:: G : NetworkX Graph: A maximum spanning tree or forest.\nMethods: []\nRubrics: Notes: For Borůvka’s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. There may be more than one tree with the same minimum or maximum weight.\nSee networkx.tree.recognition for more detailed definitions. Isolated nodes with self-loops are in the tree as edgeless isolated nodes.\nExamples: G=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nT=nx.maximum_spanning_tree(G)\nsorted(T.edges(data=True))\n# [(0, 1, {}), (0, 3, {'weight': 2}), (1, 2, {})]",
    "Section ID: edge_dfs\nDescription: [A directed, depth-first-search of edges in G , beginning at source ., Yield the edges of G in a depth-first-search order continuing until\nall edges are generated.]\nField List: Parameters:: G : graph: A directed/undirected graph/multigraph.\nsource : node, list of nodes: The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.\norientation : None | ‘original’ | ‘reverse’ | ‘ignore’ (default: None): For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to ‘reverse’ every edge is traversed in the reverse direction.\nWhen set to ‘ignore’, every edge is treated as undirected.\nWhen set to ‘original’, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported.\nYields:: edge : directed edge: A directed edge indicating the path taken by the depth-first traversal.\nFor graphs,edgeis of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs,edgeis of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (‘forward’ or ‘reverse’) on that edge.\nMethods: []\nRubrics: Notes: The goal of this function is to visit edges. It differs from the more\nfamiliar depth-first traversal of nodes, as provided by dfs_edges() , in\nthat it does not stop once every node has been visited. In a directed graph\nwith edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\nif not for the functionality provided by this function.\nExamples: nodes=[0,1,2,3]\nedges=[(0,1),(1,0),(1,0),(2,1),(3,1)]\nlist(nx.edge_dfs(nx.Graph(edges),nodes))\n# [(0, 1), (1, 2), (1, 3)]\nlist(nx.edge_dfs(nx.DiGraph(edges),nodes))\n# [(0, 1), (1, 0), (2, 1), (3, 1)]\nlist(nx.edge_dfs(nx.MultiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 1), (0, 1, 2), (1, 2, 0), (1, 3, 0)]\nlist(nx.edge_dfs(nx.MultiDiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 1, 0), (3, 1, 0)]\nlist(nx.edge_dfs(nx.DiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 0, 'forward'), (2, 1, 'reverse'), (3, 1, 'reverse')]\nlist(nx.edge_dfs(nx.MultiDiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 0, 'forward'), (1, 0, 0, 'forward'), (1, 0, 1, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]",
    "Section ID: prefix_tree\nDescription: [Creates a directed prefix tree from a list of paths., Usually the paths are described as strings or lists of integers., A “prefix tree” represents the prefix structure of the strings.\nEach node represents a prefix of some string. The root represents\nthe empty prefix with children for the single letter prefixes which\nin turn have children for each double letter prefix starting with\nthe single letter corresponding to the parent node, and so on., More generally the prefixes do not need to be strings. A prefix refers\nto the start of a sequence. The root has children for each one element\nprefix and they have children for each two element prefix that starts\nwith the one element sequence of the parent, and so on., Note that this implementation uses integer nodes with an attribute.\nEach node has an attribute “source” whose value is the original element\nof the path to which this node corresponds. For example, suppose paths consists of one path: “can”. Then the nodes [1,2,3] which represent\nthis path have “source” values “c”, “a” and “n”., All the descendants of a node have a common prefix in the sequence/path\nassociated with that node. From the returned tree, the prefix for each\nnode can be constructed by traversing the tree up to the root and\naccumulating the “source” values along the way., The root node is always 0 and has “source” attribute None .\nThe root is the only node with in-degree zero.\nThe nil node is always -1 and has “source” attribute \"NIL\" .\nThe nil node is the only node with out-degree zero.]\nField List: Parameters:: paths: iterable of paths: An iterable of paths which are themselves sequences.\nMatching prefixes among these sequences are identified with\nnodes of the prefix tree. One leaf of the tree is associated\nwith each path. (Identical paths are associated with the same\nleaf of the tree.)\nReturns:: tree: DiGraph: A directed graph representing an arborescence consisting of the\nprefix tree generated bypaths. Nodes are directed “downward”,\nfrom parent to child. A special “synthetic” root node is added\nto be the parent of the first node in each path. A special\n“synthetic” leaf node, the “nil” node-1, is added to be the child\nof all nodes representing the last element in a path. (The\naddition of this nil node technically makes this not an\narborescence but a directed acyclic graph; removing the nil node\nmakes it an arborescence.)\nMethods: []\nRubrics: Notes: The prefix tree is also known as a trie .\nExamples: Create a prefix tree from a list of strings with common prefixes:\npaths=[\"ab\",\"abs\",\"ad\"]\nT=nx.prefix_tree(paths)\nlist(T.edges)\n# [(0, 1), (1, 2), (1, 4), (2, -1), (2, 3), (3, -1), (4, -1)]\nThe leaf nodes can be obtained as predecessors of the nil node:\nroot,NIL=0,-1\nlist(T.predecessors(NIL))\n# [2, 3, 4]\nTo recover the original paths that generated the prefix tree,\ntraverse up the tree from the node-1to the node0:\nrecovered=[]\nforvinT.predecessors(NIL):\nprefix=\"\"\nwhilev!=root:\nprefix=str(T.nodes[v][\"source\"])+prefix\nv=next(T.predecessors(v))# only one predecessor\nrecovered.append(prefix)\nsorted(recovered)\n# ['ab', 'abs', 'ad']",
    "Section ID: non_edges\nDescription: [Returns the nonexistent edges in the graph.]\nField List: Parameters:: graph : NetworkX graph.: Graph to find nonexistent edges.\nReturns:: non_edges : iterator: Iterator of edges that are not in the graph.\nMethods: []\nRubrics:",
    "Section ID: hoffman_singleton_graph\nDescription: [Returns the Hoffman-Singleton Graph., The Hoffman–Singleton graph is a symmetrical undirected graph\nwith 50 nodes and 175 edges.\nAll indices lie in Z%5 : that is, the integers mod 5 [1] .\nIt is the only regular graph of vertex degree 7, diameter 2, and girth 5.\nIt is the unique (7,5)-cage graph and Moore graph, and contains many\ncopies of the Petersen graph [2] .]\nField List: Returns:: G : networkx Graph: Hoffman–Singleton Graph with 50 nodes and 175 edges\nMethods: []\nRubrics: Notes: Constructed from pentagon and pentagram as follows: Take five pentagons \\(P_h\\) and five pentagrams \\(Q_i\\) . Join vertex \\(j\\) of \\(P_h\\) to vertex \\(h·i+j\\) of \\(Q_i\\)  [3] .\nReferences: [1]https://blogs.ams.org/visualinsight/2016/02/01/hoffman-singleton-graph/  [2]https://mathworld.wolfram.com/Hoffman-SingletonGraph.html  [3]https://en.wikipedia.org/wiki/Hoffman%E2%80%93Singleton_graph",
    "Section ID: k_truss\nDescription: [Returns the k-truss of G ., The k-truss is the maximal induced subgraph of G which contains at least\nthree vertices where every edge is incident to at least k-2 triangles.]\nField List: Parameters:: G : NetworkX graph: An undirected graph\nk : int: The order of the truss\nReturns:: H : NetworkX graph: The k-truss subgraph\nRaises:: NetworkXNotImplemented: IfGis a multigraph or directed graph or if it contains self loops.\nMethods: []\nRubrics: Notes: A k-clique is a (k-2)-truss and a k-truss is a (k+1)-core. Graph, node, and edge attributes are copied to the subgraph. K-trusses were originally defined in [2] which states that the k-truss\nis the maximal induced subgraph where each edge belongs to at least k-2 triangles. A more recent paper, [1], uses a slightly different\ndefinition requiring that each edge belong to at least k triangles.\nThis implementation uses the original definition of k-2 triangles.\nReferences: [1]Bounds and Algorithms for k-truss. Paul Burkhardt, Vance Faber,\nDavid G. Harris, 2018.https://arxiv.org/abs/1806.05523v2  [2]Trusses: Cohesive Subgraphs for Social Network Analysis. Jonathan\nCohen, 2005.\nExamples: degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_truss(H,k=2).nodes\n# NodeView((0, 1, 2, 3, 4, 5))",
    "Section ID: is_k_regular\nDescription: [Determines whether the graph G is a k-regular graph., A k-regular graph is a graph where each vertex has degree k.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: bool: Whether the given graph is k-regular.\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(2,3),(3,4),(4,1)])\nnx.is_k_regular(G,k=3)\n# False",
    "Section ID: node_connected_component\nDescription: [Returns the set of nodes in the component of graph containing node n.]\nField List: Parameters:: G : NetworkX Graph: An undirected graph.\nn : node label: A node in G\nReturns:: comp : set: A set of nodes in the component of G containing node n.\nRaises:: NetworkXNotImplemented: If G is directed.\nMethods: []\nRubrics: Notes: For undirected graphs only.\nExamples: G=nx.Graph([(0,1),(1,2),(5,6),(3,4)])\nnx.node_connected_component(G,0)# nodes of component that contains node 0\n# {0, 1, 2}",
    "Section ID: floyd_warshall_predecessor_and_distance\nDescription: [Find all-pairs shortest path lengths using Floyd’s algorithm.]\nField List: Parameters:: G : NetworkX graph: \nweight: string, optional (default= ‘weight’): Edge data key corresponding to the edge weight.\nReturns:: predecessor,distance : dictionaries: Dictionaries, keyed by source and target, of predecessors and distances\nin the shortest path.\nMethods: []\nRubrics: Notes: Floyd’s algorithm is appropriate for finding shortest paths\nin dense graphs or graphs with negative weights when Dijkstra’s algorithm\nfails.  This algorithm can still fail if there are negative cycles.\nIt has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .\nExamples: G=nx.DiGraph()\nG.add_weighted_edges_from(\n[\n(\"s\",\"u\",10),\n(\"s\",\"x\",5),\n(\"u\",\"v\",1),\n(\"u\",\"x\",2),\n(\"v\",\"y\",1),\n(\"x\",\"u\",3),\n(\"x\",\"v\",5),\n(\"x\",\"y\",2),\n(\"y\",\"s\",7),\n(\"y\",\"v\",6),\n]\n)\npredecessors,_=nx.floyd_warshall_predecessor_and_distance(G)\nprint(nx.reconstruct_path(\"s\",\"v\",predecessors))\n# ['s', 'x', 'u', 'v']",
    "Section ID: read_sparse6\nDescription: [Read an undirected graph in sparse6 format from path.]\nField List: Parameters:: path : file or string: File or filename to write.\nReturns:: G : Graph/Multigraph or list of Graphs/MultiGraphs: If the file contains multiple lines then a list of graphs is returned\nRaises:: NetworkXError: If the string is unable to be parsed in sparse6 format\nMethods: []\nRubrics: References: [1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>\nExamples: You can read a sparse6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\n_=f.write(b\">>sparse6<<:An\\n\")\n_=f.seek(0)\nG=nx.read_sparse6(f.name)\nlist(G.edges())\n# [(0, 1)]\nYou can also read a sparse6 file by giving an open file-like object:\nimporttempfile\nwithtempfile.NamedTemporaryFile()asf:\n_=f.write(b\">>sparse6<<:An\\n\")\n_=f.seek(0)\nG=nx.read_sparse6(f)\nlist(G.edges())\n# [(0, 1)]",
    "Section ID: all_pairs_dijkstra_path_length\nDescription: [Compute shortest path lengths between all nodes in a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: distance : iterator: (source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionary returned only has keys for reachable node pairs.\nExamples: G=nx.path_graph(5)\nlength=dict(nx.all_pairs_dijkstra_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0",
    "Section ID: MultiAdjacencyView\nDescription: [An MultiAdjacencyView is a Read-only Map of Maps of Maps of Maps., It is a View into a dict-of-dict-of-dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter levels are read-only.]\nField List: Methods: []\nRubrics:",
    "Section ID: is_matching\nDescription: [Return True if matching is a valid matching of G, A matching in a graph is a set of edges in which no two distinct\nedges share a common endpoint. Each node is incident to at most one\nedge in the matching. The edges are said to be independent.]\nField List: Parameters:: G : NetworkX graph: \nmatching : dict or set: A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching.\nReturns:: bool: Whether the given set or dictionary represents a valid matching\nin the graph.\nRaises:: NetworkXError: If the proposed matching has an edge to a node not in G.\nOr if the matching is not a collection of 2-tuple edges.\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5)])\nnx.is_maximal_matching(G,{1:3,2:4})# using dict to represent matching\n# True\nnx.is_matching(G,{(1,3),(2,4)})# using set to represent matching\n# True",
    "Section ID: degree_assortativity_coefficient\nDescription: [Compute degree assortativity of graph., Assortativity measures the similarity of connections\nin the graph with respect to the node degree.]\nField List: Parameters:: G : NetworkX graph: \nx: string (‘in’,’out’): The degree type for source node (directed graphs only).\ny: string (‘in’,’out’): The degree type for target node (directed graphs only).\nweight: string or None, optional (default=None): The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.\nnodes: list or iterable (optional): Compute degree assortativity only for nodes in container.\nThe default is all nodes.\nReturns:: r : float: Assortativity of graph by degree.\nMethods: []\nRubrics: Notes: This computes Eq. (21) in Ref. [1] , where e is the joint\nprobability distribution (mixing matrix) of the degrees.  If G is\ndirected than the matrix e is the joint probability of the\nuser-specified degree type for the source and target.\nReferences: [1]M. E. J. Newman, Mixing patterns in networks,\nPhysical Review E, 67 026126, 2003  [2]Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\nEdge direction and the structure of networks, PNAS 107, 10815-20 (2010).\nExamples: G=nx.path_graph(4)\nr=nx.degree_assortativity_coefficient(G)\nprint(f\"{r:3.1f}\")\n# -0.5",
    "Section ID: jaccard_coefficient\nDescription: [Compute the Jaccard coefficient of all node pairs in ebunch., Jaccard coefficient of nodes u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .]\nField List: Parameters:: G : graph: A NetworkX undirected graph.\nebunch : iterable of node pairs, optional (default = None): Jaccard coefficient will be computed for each pair of nodes\ngiven in the iterable. The pairs must be given as 2-tuples\n(u, v) where u and v are nodes in the graph. If ebunch is None\nthen all nonexistent edges in the graph will be used.\nDefault value: None.\nReturns:: piter : iterator: An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Jaccard coefficient.\nRaises:: NetworkXNotImplemented: IfGis aDiGraph, aMultigraphor aMultiDiGraph.\nNodeNotFound: Ifebunchhas a node that is not inG.\nMethods: []\nRubrics: References: [1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf\nExamples: G=nx.complete_graph(5)\npreds=nx.jaccard_coefficient(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 0.60000000\n# (2, 3) -> 0.60000000",
    "Section ID: random_internet_as_graph\nDescription: [Generates a random undirected graph resembling the Internet AS network]\nField List: Parameters:: n: integer in [1000, 10000]: Number of graph nodes\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G: Networkx Graph object: A randomly generated undirected graph\nMethods: []\nRubrics: Notes: This algorithm returns an undirected graph resembling the Internet\nAutonomous System (AS) network, it uses the approach by Elmokashfi et al. [1] and it grants the properties described in the related paper [1] . Each node models an autonomous system, with an attribute ‘type’ specifying\nits kind; tier-1 (T), mid-level (M), customer (C) or content-provider (CP).\nEach edge models an ADV communication link (hence, bidirectional) with\nattributes:\nReferences: [1](1,2)A. Elmokashfi, A. Kvalbein and C. Dovrolis, “On the Scalability of\nBGP: The Role of Topology Growth,” in IEEE Journal on Selected Areas\nin Communications, vol. 28, no. 8, pp. 1250-1261, October 2010.",
    "Section ID: eulerize\nDescription: [Transforms a graph into an Eulerian graph., If G is Eulerian the result is G as a MultiGraph, otherwise the result is a smallest\n(in terms of the number of edges) multigraph whose underlying simple graph is G .]\nField List: Parameters:: G : NetworkX graph: An undirected graph\nReturns:: G : NetworkX multigraph:\nRaises:: NetworkXError: If the graph is not connected.\nMethods: []\nRubrics: References: [1]J. Edmonds, E. L. Johnson.\nMatching, Euler tours and the Chinese postman.\nMathematical programming, Volume 5, Issue 1 (1973), 111-114.  [2]https://en.wikipedia.org/wiki/Eulerian_path  [3]http://web.math.princeton.edu/math_alive/5/Notes1.pdf\nExamples: G=nx.complete_graph(10)\nH=nx.eulerize(G)\nnx.is_eulerian(H)\n# True",
    "Section ID: min_maximal_matching\nDescription: [Returns the minimum maximal matching of G. That is, out of all maximal\nmatchings of the graph G, the smallest is returned.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nReturns:: min_maximal_matching : set: Returns a set of edges such that no two edges share a common endpoint\nand every edge not in the set shares some common endpoint in the set.\nCardinality will be 2*OPT in the worst case.\nMethods: []\nRubrics: Notes: The algorithm computes an approximate solution for the minimum maximal\ncardinality matching problem. The solution is no more than 2 * OPT in size.\nRuntime is \\(O(|E|)\\) .\nReferences: [1]Vazirani, Vijay Approximation Algorithms (2001)",
    "Section ID: to_agraph\nDescription: [Returns a pygraphviz graph from a NetworkX graph N.]\nField List: Parameters:: N : NetworkX graph: A graph created with NetworkX\nMethods: []\nRubrics: Notes: If N has an dict N.graph_attr an attempt will be made first\nto copy properties attached to the graph (see from_agraph)\nand then updated with the calling arguments if any.\nExamples: K5=nx.complete_graph(5)\nA=nx.nx_agraph.to_agraph(K5)",
    "Section ID: generate_gexf\nDescription: [Generate lines of GEXF format representation of G., “GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics” [1] .]\nField List: Parameters:: G : graph: \nA NetworkX graph: \nencoding : string (optional, default: ‘utf-8’): \nEncoding for text data.: \nprettyprint : bool (optional, default: True): \nIf True use line breaks and indenting in output XML.: \nversion : string (default: 1.2draft): \nVersion of GEFX File Format (see http://gexf.net/schema.html): \nSupported values: “1.1draft”, “1.2draft”:\nMethods: []\nRubrics: Notes: This implementation does not support mixed graphs (directed and undirected\nedges together). The node id attribute is set to be the string of the node label.\nIf you want to specify an id use set it as node data, e.g.\nnode[‘a’][‘id’]=1 to set the id of node ‘a’ to 1.\nReferences: [1]GEXF File Format,https://gephi.org/gexf/format/\nExamples: G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed=\ns=linefeed.join(nx.generate_gexf(G))\nforlineinnx.generate_gexf(G):\nprint(line)",
    "Section ID: asadpour_atsp\nDescription: [Returns an approximate solution to the traveling salesman problem., This approximate solution is one of the best known approximations for the\nasymmetric traveling salesman problem developed by Asadpour et al, [1] . The algorithm first solves the Held-Karp relaxation to find a lower\nbound for the weight of the cycle. Next, it constructs an exponential\ndistribution of undirected spanning trees where the probability of an\nedge being in the tree corresponds to the weight of that edge using a\nmaximum entropy rounding scheme. Next we sample that distribution \\(2 \\lceil \\ln n \\rceil\\) times and save the minimum sampled tree once the\ndirection of the arcs is added back to the edges. Finally, we augment\nthen short circuit that graph to find the approximate tour for the\nsalesman.]\nField List: Parameters:: G : nx.DiGraph: The graph should be a complete weighted directed graph. The\ndistance between all paris of nodes should be included and the triangle\ninequality should hold. That is, the direct edge between any two nodes\nshould be the path of least cost.\nweight : string, optional (default=”weight”): Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nsource : node label (default=`None`): If given, return the cycle starting and ending at the given node.\nReturns:: cycle : list of nodes: Returns the cycle (list of nodes) that a salesman can follow to minimize\nthe total weight of the trip.\nRaises:: NetworkXError: Ifsourceis notNoneand is not a node inG, the algorithm raises\nan exception.\nNetworkXNotImplemented: IfGis an undirected graph.\nMethods: []\nRubrics: References: [1]A. Asadpour, M. X. Goemans, A. Madry, S. O. Gharan, and A. Saberi,\nAn o(log n/log log n)-approximation algorithm for the asymmetric\ntraveling salesman problem, Operations research, 65 (2017),\npp. 1043–1061\nExamples: importnetworkxasnx\nimportnetworkx.algorithms.approximationasapprox\nG=nx.complete_graph(3,create_using=nx.DiGraph)\nnx.set_edge_attributes(\nG,{(0,1):2,(1,2):2,(2,0):2,(0,2):1,(2,1):1,(1,0):1},\"weight\"\n)\ntour=approx.asadpour_atsp(G,source=0)\ntour\n# [0, 2, 1, 0]",
    "Section ID: planar_layout\nDescription: [Position nodes without edge intersections.]\nField List: Parameters:: G : NetworkX graph or list of nodes: A position will be assigned to every node in G. If G is of type\nnx.PlanarEmbedding, the positions are selected accordingly.\nscale : number (default: 1): Scale factor for positions.\ncenter : array-like or None: Coordinate pair around which to center the layout.\ndim : int: Dimension of layout.\nReturns:: pos : dict: A dictionary of positions keyed by node\nRaises:: NetworkXException: If G is not planar\nMethods: []\nRubrics: Examples: G=nx.path_graph(4)\npos=nx.planar_layout(G)",
    "Section ID: show_edges\nDescription: [Returns a filter function that shows specific undirected edges.]\nField List: Methods: []\nRubrics:",
    "Section ID: literal_destringizer\nDescription: [Convert a Python literal to the value it represents.]\nField List: Parameters:: rep : string: A Python literal.\nReturns:: value : object: The value of the Python literal.\nRaises:: ValueError: Ifrepis not a Python literal.\nMethods: []\nRubrics:",
    "Section ID: to_pandas_edgelist\nDescription: [Returns the graph edge list as a Pandas DataFrame.]\nField List: Parameters:: G : graph: The NetworkX graph used to construct the Pandas DataFrame.\nsource : str or int, optional: A valid column name (string or integer) for the source nodes (for the\ndirected case).\ntarget : str or int, optional: A valid column name (string or integer) for the target nodes (for the\ndirected case).\nnodelist : list, optional: Use only nodes specified in nodelist\ndtype : dtype, default None: Use to create the DataFrame. Data type to force.\nOnly a single dtype is allowed. If None, infer.\nedge_key : str or int or None, optional (default=None): A valid column name (string or integer) for the edge keys (for the\nmultigraph case). If None, edge keys are not stored in the DataFrame.\nReturns:: df : Pandas DataFrame: Graph edge list\nMethods: []\nRubrics: Examples: G=nx.Graph(\n[\n(\"A\",\"B\",{\"cost\":1,\"weight\":7}),\n(\"C\",\"E\",{\"cost\":9,\"weight\":10}),\n]\n)\ndf=nx.to_pandas_edgelist(G,nodelist=[\"A\",\"C\"])\ndf[[\"source\",\"target\",\"cost\",\"weight\"]]\n#   source target  cost  weight\n# 0      A      B     1       7\n# 1      C      E     9      10\nG=nx.MultiGraph([(\"A\",\"B\",{\"cost\":1}),(\"A\",\"B\",{\"cost\":9})])\ndf=nx.to_pandas_edgelist(G,nodelist=[\"A\",\"C\"],edge_key=\"ekey\")\ndf[[\"source\",\"target\",\"cost\",\"ekey\"]]\n#   source target  cost  ekey\n# 0      A      B     1     0\n# 1      A      B     9     1",
    "Section ID: ra_index_soundarajan_hopcroft\nDescription: [Compute the resource allocation index of all node pairs in\nebunch using community information., For two nodes \\(u\\) and \\(v\\) , this function computes the resource\nallocation index considering only common neighbors belonging to the\nsame community as \\(u\\) and \\(v\\) . Mathematically,, where \\(f(w)\\) equals 1 if \\(w\\) belongs to the same community as \\(u\\) and \\(v\\) or 0 otherwise and \\(\\Gamma(u)\\) denotes the set of\nneighbors of \\(u\\) .]\nField List: Parameters:: G : graph: A NetworkX undirected graph.\nebunch : iterable of node pairs, optional (default = None): The score will be computed for each pair of nodes given in the\niterable. The pairs must be given as 2-tuples (u, v) where u\nand v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.\ncommunity : string, optional (default = ‘community’): Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: ‘community’.\nReturns:: piter : iterator: An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their score.\nRaises:: NetworkXNotImplemented: IfGis aDiGraph, aMultigraphor aMultiDiGraph.\nNetworkXAlgorithmError: If no community information is available for a node inebunchor inG(ifebunchisNone).\nNodeNotFound: Ifebunchhas a node that is not inG.\nMethods: []\nRubrics: References: [1]Sucheta Soundarajan and John Hopcroft.\nUsing community information to improve the precision of link\nprediction methods.\nIn Proceedings of the 21st international conference companion on\nWorld Wide Web (WWW ‘12 Companion). ACM, New York, NY, USA, 607-608.http://doi.acm.org/10.1145/2187980.2188150\nExamples: G=nx.Graph()\nG.add_edges_from([(0,1),(0,2),(1,3),(2,3)])\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=0\nG.nodes[2][\"community\"]=1\nG.nodes[3][\"community\"]=0\npreds=nx.ra_index_soundarajan_hopcroft(G,[(0,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 3) -> 0.50000000",
    "Section ID: cd_index\nDescription: [Compute the CD index for node within the graph G ., Calculates the CD index for the given node of the graph,\nconsidering only its predecessors who have the time attribute\nsmaller than or equal to the time attribute of the node plus time_delta .]\nField List: Parameters:: G : graph: A directed networkx graph whose nodes havetimeattributes and optionallyweightattributes (if a weight is not given, it is considered 1).\nnode : node: The node for which the CD index is calculated.\ntime_delta : numeric or timedelta: Amount of time after thetimeattribute of thenode. The value oftime_deltamust support comparison with thetimenode attribute. For\nexample, if thetimeattribute of the nodes aredatetime.datetimeobjects, thentime_deltashould be adatetime.timedeltaobject.\ntime : string (Optional, default is “time”): The name of the node attribute that will be used for the calculations.\nweight : string (Optional, default is None): The name of the node attribute used as weight.\nReturns:: float: The CD index calculated for the nodenodewithin the graphG.\nRaises:: NetworkXError: If not all nodes have atimeattribute ortime_deltaandtimeattribute types are not compatible ornequals 0.\nNetworkXNotImplemented: IfGis a non-directed graph or a multigraph.\nMethods: []\nRubrics: Notes: This method implements the algorithm for calculating the CD index,\nas described in the paper by Funk and Owen-Smith [1] . The CD index\nis used in order to check how consolidating or destabilizing a patent\nis, hence the nodes of the graph represent patents and the edges show\nthe citations between these patents. The mathematical model is given\nbelow:\nReferences: [1]Funk, Russell J., and Jason Owen-Smith.\n“A dynamic network measure of technological change.”\nManagement science 63, no. 3 (2017): 791-817.http://russellfunk.org/cdindex/static/papers/funk_ms_2017.pdf\nExamples: fromdatetimeimportdatetime,timedelta\nG=nx.DiGraph()\nnodes={\n1:{\"time\":datetime(2015,1,1)},\n2:{\"time\":datetime(2012,1,1),\"weight\":4},\n3:{\"time\":datetime(2010,1,1)},\n4:{\"time\":datetime(2008,1,1)},\n5:{\"time\":datetime(2014,1,1)},\n}\nG.add_nodes_from([(n,nodes[n])forninnodes])\nedges=[(1,3),(1,4),(2,3),(3,4),(3,5)]\nG.add_edges_from(edges)\ndelta=timedelta(days=5*365)\nnx.cd_index(G,3,time_delta=delta,time=\"time\")\n# 0.5\nnx.cd_index(G,3,time_delta=delta,time=\"time\",weight=\"weight\")\n# 0.12\nIntegers can also be used for the time values:\n>>> node_times = {1: 2015, 2: 2012, 3: 2010, 4: 2008, 5: 2014}\n>>> nx.set_node_attributes(G, node_times, “new_time”)\n>>> nx.cd_index(G, 3, time_delta=4, time=”new_time”)\n0.5\n>>> nx.cd_index(G, 3, time_delta=4, time=”new_time”, weight=”weight”)\n0.12",
    "Section ID: hnm_harary_graph\nDescription: [Returns the Harary graph with given numbers of nodes and edges., The Harary graph \\(H_{n,m}\\) is the graph that maximizes node connectivity\nwith \\(n\\) nodes and \\(m\\) edges., This maximum node connectivity is known to be floor( \\(2m/n\\) ). [1]]\nField List: Parameters:: n: integer: The number of nodes the generated graph is to contain\nm: integer: The number of edges the generated graph is to contain\ncreate_using : NetworkX graph constructor, optional Graph type: to create (default=nx.Graph). If graph instance, then cleared\nbefore populated.\nReturns:: NetworkX graph: The Harary graph\\(H_{n,m}\\).\nMethods: []\nRubrics: Notes: This algorithm runs in \\(O(m)\\) time.\nIt is implemented by following the Reference [2] .\nReferences: [1]F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\n“A Survey of Some Network Reliability Analysis and Synthesis Results,”\nNetworks, pp. 99-107, 2009.  [2]Harary, F. “The Maximum Connectivity of a Graph.”\nProc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.",
    "Section ID: draw_shell\nDescription: [Draw networkx graph G with shell layout., This is a convenience function equivalent to:]\nField List: Parameters:: G : graph: A networkx graph\nnlist : list of list of nodes, optional: A list containing lists of nodes representing the shells.\nDefault isNone, meaning all nodes are in a single shell.\nSeeshell_layoutfor details.\nkwargs : optional keywords: Seedraw_networkxfor a description of optional keywords.\nMethods: []\nRubrics: Notes: The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call shell_layout directly and reuse the result:\nExamples: G=nx.path_graph(4)\nshells=[[0],[1,2,3]]\nnx.draw_shell(G,nlist=shells)",
    "Section ID: hypercube_graph\nDescription: [Returns the n -dimensional hypercube graph., The nodes are the integers between 0 and 2**n-1 , inclusive., For more information on the hypercube graph, see the Wikipedia\narticle Hypercube graph .]\nField List: Parameters:: n : int: The dimension of the hypercube.\nThe number of nodes in the graph will be2**n.\nReturns:: NetworkX graph: The hypercube graph of dimensionn.\nMethods: []\nRubrics:",
    "Section ID: dorogovtsev_goltsev_mendes_graph\nDescription: [Returns the hierarchically constructed Dorogovtsev-Goltsev-Mendes graph., The Dorogovtsev-Goltsev-Mendes [1] procedure produces a scale-free graph\ndeterministically with the following properties for a given n :\n- Total number of nodes = 3*(3**n+1)/2 - Total number of edges = 3**(n+1), ( Sourcecode , png )]\nField List: Parameters:: n : integer: The generation number.\ncreate_using : NetworkX Graph, optional: Graph type to be returned. Directed graphs and multi graphs are not\nsupported.\nReturns:: G : NetworkX Graph:\nMethods: []\nRubrics: References: [1]S. N. Dorogovtsev, A. V. Goltsev and J. F. F. Mendes,\n“Pseudofractal scale-free web”, Physical Review E 65, 066122, 2002.https://arxiv.org/pdf/cond-mat/0112143.pdf\nExamples: G=nx.dorogovtsev_goltsev_mendes_graph(3)\nG.number_of_nodes()\n# 15\nG.number_of_edges()\n# 27\nnx.is_planar(G)\n# True",
    "Section ID: stochastic_block_model\nDescription: [Returns a stochastic block model graph., This model partitions the nodes in blocks of arbitrary sizes, and places\nedges between pairs of nodes independently, with a probability that depends\non the blocks.]\nField List: Parameters:: sizes : list of ints: Sizes of blocks\np : list of list of floats: Element (r,s) gives the density of edges going from the nodes\nof group r to nodes of group s.\np must match the number of groups (len(sizes) == len(p)),\nand it must be symmetric if the graph is undirected.\nnodelist : list, optional: The block tags are assigned according to the node identifiers\nin nodelist. If nodelist is None, then the ordering is the\nrange [0,sum(sizes)-1].\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : boolean optional, default=False: Whether to create a directed graph or not.\nselfloops : boolean optional, default=False: Whether to include self-loops or not.\nsparse: boolean optional, default=True: Use the sparse heuristic to speed up the generator.\nReturns:: g : NetworkX Graph or DiGraph: Stochastic block model graph of size sum(sizes)\nRaises:: NetworkXError: If probabilities are not in [0,1].\nIf the probability matrix is not square (directed case).\nIf the probability matrix is not symmetric (undirected case).\nIf the sizes list does not match nodelist or the probability matrix.\nIf nodelist contains duplicate.\nMethods: []\nRubrics: References: [1]Holland, P. W., Laskey, K. B., & Leinhardt, S.,\n“Stochastic blockmodels: First steps”,\nSocial networks, 5(2), 109-137, 1983.\nExamples: sizes=[75,75,300]\nprobs=[[0.25,0.05,0.02],[0.05,0.35,0.07],[0.02,0.07,0.40]]\ng=nx.stochastic_block_model(sizes,probs,seed=0)\nlen(g)\n# 450\nH=nx.quotient_graph(g,g.graph[\"partition\"],relabel=True)\nforvinH.nodes(data=True):\nprint(round(v[1][\"density\"],3))\n# 0.245\n# 0.348\n# 0.405\nforvinH.edges(data=True):\nprint(round(1.0*v[2][\"weight\"]/(sizes[v[0]]*sizes[v[1]]),3))\n# 0.051\n# 0.022\n# 0.07",
    "Section ID: strategy_connected_sequential_dfs\nDescription: [Returns an iterable over nodes in G in the order given by a\ndepth-first traversal., The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence., G is a NetworkX graph. colors is ignored.]\nField List: Methods: []\nRubrics:",
    "Section ID: literal_stringizer\nDescription: [Convert a value to a Python literal in GML representation.]\nField List: Parameters:: value : object: Thevalueto be converted to GML representation.\nReturns:: rep : string: A double-quoted Python literal representing value. Unprintable\ncharacters are replaced by XML character references.\nRaises:: ValueError: Ifvaluecannot be converted to GML.\nMethods: []\nRubrics: Notes: The original value can be recovered using the networkx.readwrite.gml.literal_destringizer() function.",
    "Section ID: single_source_bellman_ford_path\nDescription: [Compute shortest path between source and all other reachable\nnodes for a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path.\nweight : string or function (default=”weight”): If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: paths : dictionary: Dictionary of shortest path lengths keyed by target.\nRaises:: NodeNotFound: Ifsourceis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\nExamples: G=nx.path_graph(5)\npath=nx.single_source_bellman_ford_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]",
    "Section ID: diamond_graph\nDescription: [Returns the Diamond graph, The Diamond Graph is  planar undirected graph with 4 nodes and 5 edges.\nIt is also sometimes known as the double triangle graph or kite graph [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Diamond Graph with 4 nodes and 5 edges\nMethods: []\nRubrics: References: [1]https://mathworld.wolfram.com/DiamondGraph.html",
    "Section ID: generate_gml\nDescription: [Generate a single entry of the graph G in GML format.]\nField List: Parameters:: G : NetworkX graph: The graph to be converted to GML.\nstringizer : callable, optional: Astringizerwhich converts non-int/non-float/non-dict values into\nstrings. If it cannot convert a value into a string, it should raise aValueErrorto indicate that. Default value: None.\nReturns:: lines: generator of strings: Lines of GML data. Newlines are not appended.\nRaises:: NetworkXError: Ifstringizercannot convert a value into a string, or the value to\nconvert is not a string whilestringizeris None.\nMethods: []\nRubrics: Notes: Graph attributes named ‘directed’, ‘multigraph’, ‘node’ or\n‘edge’, node attributes named ‘id’ or ‘label’, edge attributes\nnamed ‘source’ or ‘target’ (or ‘key’ if G is a multigraph)\nare ignored because these attribute names are used to encode the graph\nstructure. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.\nExamples: G=nx.Graph()\nG.add_node(\"1\")\nprint(\"\\n\".join(nx.generate_gml(G)))\n# graph [\n#   node [\n#     id 0\n#     label \"1\"\n#   ]\n# ]\nG=nx.MultiGraph([(\"a\",\"b\"),(\"a\",\"b\")])\nprint(\"\\n\".join(nx.generate_gml(G)))\n# graph [\n#   multigraph 1\n#   node [\n#     id 0\n#     label \"a\"\n#   ]\n#   node [\n#     id 1\n#     label \"b\"\n#   ]\n#   edge [\n#     source 0\n#     target 1\n#     key 0\n#   ]\n#   edge [\n#     source 0\n#     target 1\n#     key 1\n#   ]\n# ]",
    "Section ID: is_valid_joint_degree\nDescription: [Checks whether the given joint degree dictionary is realizable., A joint degree dictionary is a dictionary of dictionaries, in\nwhich entry joint_degrees[k][l] is an integer representing the\nnumber of edges joining nodes of degree k with nodes of degree l . Such a dictionary is realizable as a simple graph if and only\nif the following conditions are satisfied.]\nField List: Parameters:: joint_degrees : dictionary of dictionary of integers: A joint degree dictionary in which entryjoint_degrees[k][l]is the number of edges joining nodes of degreekwith nodes of\ndegreel.\nReturns:: bool: Whether the given joint degree dictionary is realizable as a\nsimple graph.\nMethods: []\nRubrics: References: [1]M. Gjoka, M. Kurant, A. Markopoulou, “2.5K Graphs: from Sampling\nto Generation”, IEEE Infocom, 2013.  [2]I. Stanton, A. Pinar, “Constructing and sampling graphs with a\nprescribed joint degree distribution”, Journal of Experimental\nAlgorithmics, 2012.",
    "Section ID: fiedler_vector\nDescription: [Returns the Fiedler vector of a connected undirected graph., The Fiedler vector of a connected undirected graph is the eigenvector\ncorresponding to the second smallest eigenvalue of the Laplacian matrix\nof the graph.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nweight : object, optional (default: None): The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.\nnormalized : bool, optional (default: False): Whether the normalized Laplacian matrix is used.\ntol : float, optional (default: 1e-8): Tolerance of relative residual in eigenvalue computation.\nmethod : string, optional (default: ‘tracemin_pcg’): Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), ‘lanczos’ (Lanczos iteration)\nor ‘lobpcg’ (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver‘tracemin_pcg’Preconditioned conjugate gradient method‘tracemin_lu’LU factorization\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: fiedler_vector : NumPy array of floats.: Fiedler vector.\nRaises:: NetworkXNotImplemented: If G is directed.\nNetworkXError: If G has less than two nodes or is not connected.\nMethods: []\nRubrics: Notes: Edge weights are interpreted by their absolute values. For MultiGraph’s,\nweights of parallel edges are summed. Zero-weighted edges are ignored.\nExamples: Given a connected graph the signs of the values in the Fiedler vector can be\nused to partition the graph into two components.\nG=nx.barbell_graph(5,0)\nnx.fiedler_vector(G,normalized=True,seed=1)\n# array([-0.32864129, -0.32864129, -0.32864129, -0.32864129, -0.26072899,\n#         0.26072899,  0.32864129,  0.32864129,  0.32864129,  0.32864129])\nThe connected components are the two 5-node cliques of the barbell graph.",
    "Section ID: global_parameters\nDescription: [Returns global parameters for a given intersection array., Given a distance-regular graph G with integers b_i, c_i,i = 0,….,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x., Thus, a distance regular graph has the global parameters,\n[[c_0,a_0,b_0],[c_1,a_1,b_1],……,[c_d,a_d,b_d]] for the\nintersection array  [b_0,b_1,…..b_{d-1};c_1,c_2,…..c_d]\nwhere a_i+b_i+c_i=k , k= degree of every vertex.]\nField List: Parameters:: b : list: \nc : list:\nReturns:: iterable: An iterable over three tuples.\nMethods: []\nRubrics: References: [1]Weisstein, Eric W. “Global Parameters.”\nFrom MathWorld–A Wolfram Web Resource.http://mathworld.wolfram.com/GlobalParameters.html\nExamples: G=nx.dodecahedral_graph()\nb,c=nx.intersection_array(G)\nlist(nx.global_parameters(b,c))\n# [(0, 0, 3), (1, 0, 2), (1, 1, 1), (1, 1, 1), (2, 0, 1), (3, 0, 0)]",
    "Section ID: from_agraph\nDescription: [Returns a NetworkX Graph or DiGraph from a PyGraphviz graph.]\nField List: Parameters:: A : PyGraphviz AGraph: A graph created with PyGraphviz\ncreate_using : NetworkX graph constructor, optional (default=None): Graph type to create. If graph instance, then cleared before populated.\nIfNone, then the appropriate Graph type is inferred fromA.\nMethods: []\nRubrics: Notes: The Graph G will have a dictionary G.graph_attr containing\nthe default graphviz attributes for graphs, nodes and edges. Default node attributes will be in the dictionary G.node_attr\nwhich is keyed by node. Edge attributes will be returned as edge data in G.  With\nedge_attr=False the edge data will be the Graphviz edge weight\nattribute or the value 1 if no edge weight attribute is found.\nExamples: K5=nx.complete_graph(5)\nA=nx.nx_agraph.to_agraph(K5)\nG=nx.nx_agraph.from_agraph(A)",
    "Section ID: all_pairs_shortest_path_length\nDescription: [Computes the shortest path lengths between all nodes in G .]\nField List: Parameters:: G : NetworkX graph: \ncutoff : integer, optional: Depth at which to stop the search. Only paths of length at mostcutoffare returned.\nReturns:: lengths : iterator: (source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value.\nMethods: []\nRubrics: Notes: The iterator returned only has reachable node pairs.\nExamples: G=nx.path_graph(5)\nlength=dict(nx.all_pairs_shortest_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0",
    "Section ID: topological_sort\nDescription: [Returns a generator of nodes in topologically sorted order., A topological sort is a nonunique permutation of the nodes of a\ndirected graph such that an edge from u to v implies that u\nappears before v in the topological sort order. This ordering is\nvalid only if the graph has no directed cycles.]\nField List: Parameters:: G : NetworkX digraph: A directed acyclic graph (DAG)\nYields:: nodes: Yields the nodes in topological sorted order.\nRaises:: NetworkXError: Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.\nNetworkXUnfeasible: IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed\nRuntimeError: IfGis changed while the returned iterator is being processed.\nMethods: []\nRubrics: Notes: This algorithm is based on a description and proof in\n“Introduction to Algorithms: A Creative Approach” [1] .\nReferences: [1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.\nExamples: To get the reverse order of the topological sort:\nDG=nx.DiGraph([(1,2),(2,3)])\nlist(reversed(list(nx.topological_sort(DG))))\n# [3, 2, 1]\nIf your DiGraph naturally has the edges representing tasks/inputs\nand nodes representing people/processes that initiate tasks, then\ntopological_sort is not quite what you need. You will have to change\nthe tasks to nodes with dependence reflected by edges. The result is\na kind of topological sort of the edges. This can be done\nwithnetworkx.line_graph()as follows:\nlist(nx.topological_sort(nx.line_graph(DG)))\n# [(1, 2), (2, 3)]",
    "Section ID: hkn_harary_graph\nDescription: [Returns the Harary graph with given node connectivity and node number., The Harary graph \\(H_{k,n}\\) is the graph that minimizes the number of\nedges needed with given node connectivity \\(k\\) and node number \\(n\\) ., This smallest number of edges is known to be ceil( \\(kn/2\\) ) [1] .]\nField List: Parameters:: k: integer: The node connectivity of the generated graph\nn: integer: The number of nodes the generated graph is to contain\ncreate_using : NetworkX graph constructor, optional Graph type: to create (default=nx.Graph). If graph instance, then cleared\nbefore populated.\nReturns:: NetworkX graph: The Harary graph\\(H_{k,n}\\).\nMethods: []\nRubrics: Notes: This algorithm runs in \\(O(kn)\\) time.\nIt is implemented by following the Reference [2] .\nReferences: [1]Weisstein, Eric W. “Harary Graph.” From MathWorld–A Wolfram Web\nResource.http://mathworld.wolfram.com/HararyGraph.html.  [2]Harary, F. “The Maximum Connectivity of a Graph.”\nProc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.",
    "Section ID: s_metric\nDescription: [Returns the s-metric [1] of graph., The s-metric is defined as the sum of the products deg(u)*deg(v) for every edge (u,v) in G .]\nField List: Parameters:: G : graph: The graph used to compute the s-metric.\nnormalized : bool (optional): Normalize the value.Deprecated since version 3.2:Thenormalizedkeyword argument is deprecated and will be removed\nin the future\nReturns:: s : float: The s-metric of the graph.\nMethods: []\nRubrics: References: [1]Lun Li, David Alderson, John C. Doyle, and Walter Willinger,\nTowards a Theory of Scale-Free Graphs:\nDefinition, Properties, and  Implications (Extended Version), 2005.https://arxiv.org/abs/cond-mat/0501169",
    "Section ID: vf2pp_isomorphism\nDescription: [Return an isomorphic mapping between G1 and G2 if it exists.]\nField List: Parameters:: G1, G2 : NetworkX Graph or MultiGraph instances.: The two graphs to check for isomorphism.\nnode_label : str, optional: The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn’t have thenode_labelattribute usesdefault_labelinstead.\ndefault_label : scalar: Default value to use when a node doesn’t have an attribute\nnamednode_label. Default isNone.\nReturns:: dict or None: Node mapping if the two graphs are isomorphic. None otherwise.\nMethods: []\nRubrics:",
    "Section ID: katz_centrality\nDescription: [Compute the Katz centrality for the nodes of the graph G., Katz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node \\(i\\) is, where \\(A\\) is the adjacency matrix of graph G with eigenvalues \\(\\lambda\\) ., The parameter \\(\\beta\\) controls the initial centrality and, Katz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors., Extra weight can be provided to immediate neighbors through the\nparameter \\(\\beta\\) .  Connections made with distant neighbors\nare, however, penalized by an attenuation factor \\(\\alpha\\) which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1] .]\nField List: Parameters:: G : graph: A NetworkX graph.\nalpha : float, optional (default=0.1): Attenuation factor\nbeta : scalar or dictionary, optional (default=1.0): Weight attributed to the immediate neighborhood. If not a scalar, the\ndictionary must have a value for every node.\nmax_iter : integer, optional (default=1000): Maximum number of iterations in power method.\ntol : float, optional (default=1.0e-6): Error tolerance used to check convergence in power method iteration.\nnstart : dictionary, optional: Starting value of Katz iteration for each node.\nnormalized : bool, optional (default=True): If True normalize the resulting values.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nIn this measure the weight is interpreted as the connection strength.\nReturns:: nodes : dictionary: Dictionary of nodes with Katz centrality as the value.\nRaises:: NetworkXError: If the parameterbetais not a scalar but lacks a value for at least\none node\nPowerIterationFailedConvergence: If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod.\nMethods: []\nRubrics: Notes: Katz centrality was introduced by [2] . This algorithm it uses the power method to find the eigenvector\ncorresponding to the largest eigenvalue of the adjacency matrix of G .\nThe parameter alpha should be strictly less than the inverse of largest\neigenvalue of the adjacency matrix for the algorithm to converge.\nYou can use max(nx.adjacency_spectrum(G)) to get \\(\\lambda_{\\max}\\) the largest\neigenvalue of the adjacency matrix.\nThe iteration will stop after max_iter iterations or an error tolerance of number_of_nodes(G)*tol has been reached. For strongly connected graphs, as \\(\\alpha \\to 1/\\lambda_{\\max}\\) , and \\(\\beta > 0\\) ,\nKatz centrality approaches the results for eigenvector centrality. For directed graphs this finds “left” eigenvectors which corresponds\nto the in-edges in the graph. For out-edges Katz centrality,\nfirst reverse the graph with G.reverse() .\nReferences: [1]Mark E. J. Newman:\nNetworks: An Introduction.\nOxford University Press, USA, 2010, p. 720.  [2]Leo Katz:\nA New Status Index Derived from Sociometric Index.\nPsychometrika 18(1):39–43, 1953https://link.springer.com/content/pdf/10.1007/BF02289026.pdf\nExamples: importmath\nG=nx.path_graph(4)\nphi=(1+math.sqrt(5))/2.0# largest eigenvalue of adj matrix\ncentrality=nx.katz_centrality(G,1/phi-0.01)\nforn,cinsorted(centrality.items()):\nprint(f\"{n} {c:.2f}\")\n# 0 0.37\n# 1 0.60\n# 2 0.60\n# 3 0.37",
    "Section ID: network_simplex\nDescription: [Find a minimum cost flow satisfying all demands in digraph G., This is a primal network simplex algorithm that uses the leaving\narc rule to prevent cycling., G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.]\nField List: Parameters:: G : NetworkX graph: DiGraph on which a minimum cost flow satisfying all demands is\nto be found.\ndemand : string: Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: ‘demand’.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nweight : string: Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: ‘weight’.\nReturns:: flowCost : integer, float: Cost of a minimum cost flow satisfying all demands.\nflowDict : dictionary: Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v).\nRaises:: NetworkXError: This exception is raised if the input graph is not directed or\nnot connected.\nNetworkXUnfeasible: This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.\nNetworkXUnbounded: This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below.\nMethods: []\nRubrics: Notes: This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\nReferences: [1]Z. Kiraly, P. Kovacs.\nEfficient implementation of minimum-cost flow algorithms.\nActa Universitatis Sapientiae, Informatica 4(1):67–118. 2012.  [2]R. Barr, F. Glover, D. Klingman.\nEnhancement of spanning tree labeling procedures for network\noptimization.\nINFOR 17(1):16–34. 1979.\nExamples: A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost,flowDict=nx.network_simplex(G)\nflowCost\n# 24\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nThe mincost flow algorithm can also be used to solve shortest path\nproblems. To find the shortest path between two nodes u and v,\ngive all edges an infinite capacity, give node u a demand of -1 and\nnode v a demand a 1. Then run the network simplex. The value of a\nmin cost flow will be the distance between u and v and edges\ncarrying positive flow will indicate the path.\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n[\n(\"s\",\"u\",10),\n(\"s\",\"x\",5),\n(\"u\",\"v\",1),\n(\"u\",\"x\",2),\n(\"v\",\"y\",1),\n(\"x\",\"u\",3),\n(\"x\",\"v\",5),\n(\"x\",\"y\",2),\n(\"y\",\"s\",7),\n(\"y\",\"v\",6),\n]\n)\nG.add_node(\"s\",demand=-1)\nG.add_node(\"v\",demand=1)\nflowCost,flowDict=nx.network_simplex(G)\nflowCost==nx.shortest_path_length(G,\"s\",\"v\",weight=\"weight\")\n# True\nsorted([(u,v)foruinflowDictforvinflowDict[u]ifflowDict[u][v]>0])\n# [('s', 'x'), ('u', 'v'), ('x', 'u')]\nnx.shortest_path(G,\"s\",\"v\",weight=\"weight\")\n# ['s', 'x', 'u', 'v']\nIt is possible to change the name of the attributes used for the\nalgorithm.\nG=nx.DiGraph()\nG.add_node(\"p\",spam=-4)\nG.add_node(\"q\",spam=2)\nG.add_node(\"a\",spam=-2)\nG.add_node(\"d\",spam=-1)\nG.add_node(\"t\",spam=2)\nG.add_node(\"w\",spam=3)\nG.add_edge(\"p\",\"q\",cost=7,vacancies=5)\nG.add_edge(\"p\",\"a\",cost=1,vacancies=4)\nG.add_edge(\"q\",\"d\",cost=2,vacancies=3)\nG.add_edge(\"t\",\"q\",cost=1,vacancies=2)\nG.add_edge(\"a\",\"t\",cost=2,vacancies=4)\nG.add_edge(\"d\",\"w\",cost=3,vacancies=4)\nG.add_edge(\"t\",\"w\",cost=4,vacancies=1)\nflowCost,flowDict=nx.network_simplex(\nG,demand=\"spam\",capacity=\"vacancies\",weight=\"cost\"\n)\nflowCost\n# 37\nflowDict\n# {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}",
    "Section ID: to_dict_of_lists\nDescription: [Returns adjacency representation of graph as a dictionary of lists.]\nField List: Parameters:: G : graph: A NetworkX graph\nnodelist : list: Use only nodes specified in nodelist\nMethods: []\nRubrics: Notes: Completely ignores edge data for MultiGraph and MultiDiGraph.",
    "Section ID: write_graph6\nDescription: [Write a simple undirected graph to a path in graph6 format.]\nField List: Parameters:: G : Graph (undirected): \npath : str: The path naming the file to which to write the graph.\nnodes: list or iterable: Nodes are labeled 0…n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.\nheader: bool: If True add ‘>>graph6<<’ string to head of data\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nValueError: If the graph has at least2**36nodes; the graph6 format\nis only defined for graphs of order less than2**36.\nMethods: []\nRubrics: Notes: The function writes a newline character after writing the encoding\nof the graph. The format does not support edge or node labels, parallel edges or\nself loops.  If self loops are present they are silently ignored.\nReferences: [1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>\nExamples: You can write a graph6 file by giving the path to a file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\nnx.write_graph6(nx.path_graph(2),f.name)\n_=f.seek(0)\nprint(f.read())\n# b'>>graph6<<A_\\n'",
    "Section ID: random_spanning_tree\nDescription: [Sample a random spanning tree using the edges weights of G ., This function supports two different methods for determining the\nprobability of the graph. If multiplicative=True , the probability\nis based on the product of edge weights, and if multiplicative=False it is based on the sum of the edge weight. However, since it is\neasier to determine the total weight of all spanning trees for the\nmultiplicative version, that is significantly faster and should be used if\npossible. Additionally, setting weight to None will cause a spanning tree\nto be selected with uniform probability., The function uses algorithm A8 in [1] .]\nField List: Parameters:: G : nx.Graph: An undirected version of the original graph.\nweight : string: The edge key for the edge attribute holding edge weight.\nmultiplicative : bool, default=True: IfTrue, the probability of each tree is the product of its edge weight\nover the sum of the product of all the spanning trees in the graph. IfFalse, the probability is the sum of its edge weight over the sum of\nthe sum of weights for all spanning trees in the graph.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: nx.Graph: A spanning tree using the distribution defined by the weight of the tree.\nMethods: []\nRubrics: References: [1]V. Kulkarni, Generating random combinatorial objects, Journal of\nAlgorithms, 11 (1990), pp. 185–207",
    "Section ID: has_bridges\nDescription: [Decide whether a graph has any bridges., A bridge in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.]\nField List: Parameters:: G : undirected graph: \nroot : node (optional): A node in the graphG. If specified, only the bridges in the\nconnected component containing this node will be considered.\nReturns:: bool: Whether the graph (or the connected component containingroot)\nhas any bridges.\nRaises:: NodeNotFound: Ifrootis not in the graphG.\nNetworkXNotImplemented: IfGis a directed graph.\nMethods: []\nRubrics: Notes: This implementation uses the networkx.bridges() function, so\nit shares its worst-case time complexity, \\(O(m + n)\\) , ignoring\npolylogarithmic factors, where \\(n\\) is the number of nodes in the\ngraph and \\(m\\) is the number of edges.\nExamples: The barbell graph with parameter zero has a single bridge:\nG=nx.barbell_graph(10,0)\nnx.has_bridges(G)\n# True\nOn the other hand, the cycle graph has no bridges:\nG=nx.cycle_graph(5)\nnx.has_bridges(G)\n# False",
    "Section ID: rooted_product\nDescription: [Return the rooted product of graphs G and H rooted at root in H., A new graph is constructed representing the rooted product of\nthe inputted graphs, G and H, with a root in H.\nA rooted product duplicates H for each nodes in G with the root\nof H corresponding to the node in G. Nodes are renamed as the direct\nproduct of G and H. The result is a subgraph of the cartesian product.]\nField List: Parameters:: G,H : graph: A NetworkX graph\nroot : node: A node in H\nReturns:: R : The rooted product of G and H with a specified root in H:\nMethods: []\nRubrics: Notes: The nodes of R are the Cartesian Product of the nodes of G and H.\nThe nodes of G and H are not relabeled.",
    "Section ID: grid_2d_graph\nDescription: [Returns the two-dimensional grid graph., The grid graph has each node connected to its four nearest neighbors.]\nField List: Parameters:: m, n : int or iterable container of nodes: If an integer, nodes are fromrange(n).\nIf a container, elements become the coordinate of the nodes.\nperiodic : bool or iterable: Ifperiodicis True, both dimensions are periodic. If False, none\nare periodic.  Ifperiodicis iterable, it should yield 2 bool\nvalues indicating whether the 1st and 2nd axes, respectively, are\nperiodic.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: NetworkX graph: The (possibly periodic) grid graph of the specified dimensions.\nMethods: []\nRubrics:",
    "Section ID: is_triad\nDescription: [Returns True if the graph G is a triad, else False.]\nField List: Parameters:: G : graph: A NetworkX Graph\nReturns:: istriad : boolean: Whether G is a valid triad\nMethods: []\nRubrics: Examples: G=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.is_triad(G)\n# True\nG.add_edge(0,1)\nnx.is_triad(G)\n# False",
    "Section ID: graph_edit_distance\nDescription: [Returns GED (graph edit distance) between graphs G1 and G2., Graph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2.]\nField List: Parameters:: G1, G2: graphs: The two graphs G1 and G2 must be of the same type.\nnode_match : callable: A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.\nedge_match : callable: A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.\nnode_subst_cost, node_del_cost, node_ins_cost : callable: Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.\nedge_subst_cost, edge_del_cost, edge_ins_cost : callable: Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.\nroots : 2-tuple: Tuple where first element is a node in G1 and the second\nis a node in G2.\nThese nodes are forced to be matched in the comparison to\nallow comparison between rooted graphs.\nupper_bound : numeric: Maximum edit distance to consider.  Return None if no edit\ndistance under or equal to upper_bound exists.\ntimeout : numeric: Maximum number of seconds to execute.\nAfter timeout is met, the current best GED is returned.\nMethods: []\nRubrics: References: [1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816\nExamples: G1=nx.cycle_graph(6)\nG2=nx.wheel_graph(7)\nnx.graph_edit_distance(G1,G2)\n# 7.0\nG1=nx.star_graph(5)\nG2=nx.star_graph(5)\nnx.graph_edit_distance(G1,G2,roots=(0,0))\n# 0.0\nnx.graph_edit_distance(G1,G2,roots=(1,0))\n# 8.0",
    "Section ID: condensation\nDescription: [Returns the condensation of G., The condensation of G is the graph with each of the strongly connected\ncomponents contracted into a single node.]\nField List: Parameters:: G : NetworkX DiGraph: A directed graph.\nscc:  list or generator (optional, default=None): Strongly connected components. If provided, the elements insccmust partition the nodes inG. If not provided, it will be\ncalculated as scc=nx.strongly_connected_components(G).\nReturns:: C : NetworkX DiGraph: The condensation graph C of G.  The node labels are integers\ncorresponding to the index of the component in the list of\nstrongly connected components of G.  C has a graph attribute named\n‘mapping’ with a dictionary mapping the original nodes to the\nnodes in C to which they belong.  Each node in C also has a node\nattribute ‘members’ with the set of original nodes in G that\nform the SCC that the node in C represents.\nRaises:: NetworkXNotImplemented: If G is undirected.\nMethods: []\nRubrics: Notes: After contracting all strongly connected components to a single node,\nthe resulting graph is a directed acyclic graph.\nExamples: Contracting two sets of strongly connected nodes into two distinct SCC\nusing the barbell graph.\nG=nx.barbell_graph(4,0)\nG.remove_edge(3,4)\nG=nx.DiGraph(G)\nH=nx.condensation(G)\nH.nodes.data()\n# NodeDataView({0: {'members': {0, 1, 2, 3}}, 1: {'members': {4, 5, 6, 7}}})\nH.graph[\"mapping\"]\n# {0: 0, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1}\nContracting a complete graph into one single SCC.\nG=nx.complete_graph(7,create_using=nx.DiGraph)\nH=nx.condensation(G)\nH.nodes\n# NodeView((0,))\nH.nodes.data()\n# NodeDataView({0: {'members': {0, 1, 2, 3, 4, 5, 6}}})",
    "Section ID: minimum_spanning_arborescence\nDescription: [Returns a minimum spanning arborescence from G.]\nField List: Parameters:: G : (multi)digraph-like: The graph to be searched.\nattr : str: The edge attribute used to in determining optimality.\ndefault : float: The value of the edge attribute used if an edge does not have\nthe attributeattr.\npreserve_attrs : bool: If True, preserve the other attributes of the original graph (that are not\npassed toattr)\npartition : str: The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum.\nReturns:: B : (multi)digraph-like: A minimum spanning arborescence.\nRaises:: NetworkXException: If the graph does not contain a minimum spanning arborescence.\nMethods: []\nRubrics:",
    "Section ID: group_in_degree_centrality\nDescription: [Compute the group in-degree centrality for a group of nodes., Group in-degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members by incoming edges.]\nField List: Parameters:: G : graph: A NetworkX graph.\nS : list or set: S is a group of nodes which belong to G, for which group in-degree\ncentrality is to be calculated.\nReturns:: centrality : float: Group in-degree centrality of the group S.\nRaises:: NetworkXNotImplemented: If G is undirected.\nNodeNotFound: If node(s) in S are not in G.\nMethods: []\nRubrics: Notes: The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. G.neighbors(i) gives nodes with an outward edge from i, in a DiGraph,\nso for group in-degree centrality, the reverse graph is used.",
    "Section ID: edges\nDescription: [Returns an edge view of edges incident to nodes in nbunch., Return all edges if nbunch is unspecified or nbunch=None., For digraphs, edges=out_edges, This function wraps the G.edges property.]\nField List: Methods: []\nRubrics:",
    "Section ID: lexicographic_product\nDescription: [Returns the lexicographic product of G and H., The lexicographical product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set\nthat is the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\((u,v)\\) is an edge in \\(G\\) or \\(u==v\\) and \\((x,y)\\) is an edge in \\(H\\) .]\nField List: Parameters:: G, H: graphs: Networkx graphs.\nReturns:: P: NetworkX graph: The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected.\nRaises:: NetworkXError: If G and H are not both directed or both undirected.\nMethods: []\nRubrics: Notes: Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.\nExamples: G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.lexicographic_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph",
    "Section ID: show_multiedges\nDescription: [Returns a filter function that shows specific multi-undirected edges.]\nField List: Methods: []\nRubrics:",
    "Section ID: read_leda\nDescription: [Read graph in LEDA format from path.]\nField List: Parameters:: path : file or string: File or filename to read.  Filenames ending in .gz or .bz2  will be\nuncompressed.\nReturns:: G : NetworkX graph:\nMethods: []\nRubrics: References: [1]http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html\nExamples: G=nx.read_leda(‘file.leda’)",
    "Section ID: negative_edge_cycle\nDescription: [Returns True if there exists a negative edge cycle anywhere in G.]\nField List: Parameters:: G : NetworkX graph: \nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nheuristic : bool: Determines whether to use a heuristic to early detect negative\ncycles at a negligible cost. In case of graphs with a negative cycle,\nthe performance of detection increases by at least an order of magnitude.\nReturns:: negative_cycle : bool: True if a negative edge cycle exists, otherwise False.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. This algorithm uses bellman_ford_predecessor_and_distance() but finds\nnegative cycles on any component by first adding a new node connected to\nevery node, and starting bellman_ford_predecessor_and_distance on that\nnode.  It then removes that extra node.\nExamples: G=nx.cycle_graph(5,create_using=nx.DiGraph())\nprint(nx.negative_edge_cycle(G))\n# False\nG[1][2][\"weight\"]=-7\nprint(nx.negative_edge_cycle(G))\n# True",
    "Section ID: bethe_hessian_spectrum\nDescription: [Returns eigenvalues of the Bethe Hessian matrix of G.]\nField List: Parameters:: G : Graph: A NetworkX Graph or DiGraph\nr : float: Regularizer parameter\nReturns:: evals : NumPy array: Eigenvalues\nMethods: []\nRubrics: References: [1]A. Saade, F. Krzakala and L. Zdeborová\n“Spectral clustering of graphs with the bethe hessian”,\nAdvances in Neural Information Processing Systems. 2014.",
    "Section ID: find_cliques\nDescription: [Returns all maximal cliques in an undirected graph., For each node n , a maximal clique for n is a largest complete\nsubgraph containing n . The largest maximal clique is sometimes\ncalled the maximum clique ., This function returns an iterator over cliques, each of which is a\nlist of nodes. It is an iterative implementation, so should not\nsuffer from recursion depth issues., This function accepts a list of nodes and only the maximal cliques\ncontaining all of these nodes are returned. It can considerably speed up\nthe running time if some specific cliques are desired.]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nnodes : list, optional (default=None): If provided, only yieldmaximal cliquescontaining all nodes innodes.\nIfnodesisn’t a clique itself, a ValueError is raised.\nReturns:: iterator: An iterator over maximal cliques, each of which is a list of\nnodes inG. Ifnodesis provided, only the maximal cliques\ncontaining all the nodes innodesare returned. The order of\ncliques is arbitrary.\nRaises:: ValueError: Ifnodesis not a clique.\nMethods: []\nRubrics: Notes: To obtain a list of all maximal cliques, use list(find_cliques(G)) . However, be aware that in the worst-case,\nthe length of this list can be exponential in the number of nodes in\nthe graph. This function avoids storing all cliques in memory by\nonly keeping current candidate node lists in memory during its search. This implementation is based on the algorithm published by Bron and\nKerbosch (1973) [1] , as adapted by Tomita, Tanaka and Takahashi\n(2006) [2] and discussed in Cazals and Karande (2008) [3] . It\nessentially unrolls the recursion used in the references to avoid\nissues of recursion stack depth (for a recursive implementation, see find_cliques_recursive() ). This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.\nReferences: [1]Bron, C. and Kerbosch, J.\n“Algorithm 457: finding all cliques of an undirected graph”.Communications of the ACM16, 9 (Sep. 1973), 575–577.\n<http://portal.acm.org/citation.cfm?doid=362342.362367>  [2]Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n“The worst-case time complexity for generating all maximal\ncliques and computational experiments”,Theoretical Computer Science, Volume 363, Issue 1,\nComputing and Combinatorics,\n10th Annual International Conference on\nComputing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28–42\n<https://doi.org/10.1016/j.tcs.2006.06.015>  [3]F. Cazals, C. Karande,\n“A note on the problem of reporting maximal cliques”,Theoretical Computer Science,\nVolume 407, Issues 1–3, 6 November 2008, Pages 564–568,\n<https://doi.org/10.1016/j.tcs.2008.05.010>\nExamples: frompprintimportpprint# For nice dict formatting\nG=nx.karate_club_graph()\nsum(1forcinnx.find_cliques(G))# The number of maximal cliques in G\n# 36\nmax(nx.find_cliques(G),key=len)# The largest maximal clique in G\n# [0, 1, 2, 3, 13]\nThe size of the largest maximal clique is known as theclique numberof\nthe graph, which can be found directly with:\nmax(len(c)forcinnx.find_cliques(G))\n# 5\nOne can also compute the number of maximal cliques inGthat contain a given\nnode. The following produces a dictionary keyed by node whose\nvalues are the number of maximal cliques inGthat contain the node:\npprint({n:sum(1forcinnx.find_cliques(G)ifninc)forninG})\n# {0: 13,\n#  1: 6,\n#  2: 7,\n#  3: 3,\n#  4: 2,\n#  5: 3,\n#  6: 3,\n#  7: 1,\n#  8: 3,\n#  9: 2,\n#  10: 2,\n#  11: 1,\n#  12: 1,\n#  13: 2,\n#  14: 1,\n#  15: 1,\n#  16: 1,\n#  17: 1,\n#  18: 1,\n#  19: 2,\n#  20: 1,\n#  21: 1,\n#  22: 1,\n#  23: 3,\n#  24: 2,\n#  25: 2,\n#  26: 1,\n#  27: 3,\n#  28: 2,\n#  29: 2,\n#  30: 2,\n#  31: 4,\n#  32: 9,\n#  33: 14}\nOr, similarly, the maximal cliques inGthat contain a given node.\nFor example, the 4 maximal cliques that contain node 31:\n[cforcinnx.find_cliques(G)if31inc]\n# [[0, 31], [33, 32, 31], [33, 28, 31], [24, 25, 31]]",
    "Section ID: hide_multiedges\nDescription: [Returns a filter function that hides specific multi-undirected edges.]\nField List: Methods: []\nRubrics:",
    "Section ID: kemeny_constant\nDescription: [Returns the Kemeny constant of the given graph., The Kemeny constant (or Kemeny’s constant) of a graph G can be computed by regarding the graph as a Markov chain.\nThe Kemeny constant is then the expected number of time steps\nto transition from a starting state i to a random destination state\nsampled from the Markov chain’s stationary distribution.\nThe Kemeny constant is independent of the chosen initial state [1] ., The Kemeny constant measures the time needed for spreading\nacross a graph. Low values indicate a closely connected graph\nwhereas high values indicate a spread-out graph., If weight is not provided, then a weight of 1 is used for all edges., Since G represents a Markov chain, the weights must be positive.]\nField List: Parameters:: G : NetworkX graph: \nweight : string or None, optional (default=None): The edge data key used to compute the Kemeny constant.\nIf None, then each edge has weight 1.\nReturns:: float: The Kemeny constant of the graphG.\nRaises:: NetworkXNotImplemented: If the graphGis directed.\nNetworkXError: If the graphGis not connected, or contains no nodes,\nor has edges with negative weights.\nMethods: []\nRubrics: Notes: The implementation is based on equation (3.3) in [2] .\nSelf-loops are allowed and indicate a Markov chain where\nthe state can remain the same. Multi-edges are contracted\nin one edge with weight equal to the sum of the weights.\nReferences: [1]Wikipedia\n“Kemeny’s constant.”https://en.wikipedia.org/wiki/Kemeny%27s_constant  [2]Lovász L.\nRandom walks on graphs: A survey.\nPaul Erdös is Eighty, vol. 2, Bolyai Society,\nMathematical Studies, Keszthely, Hungary (1993), pp. 1-46\nExamples: G=nx.complete_graph(5)\nround(nx.kemeny_constant(G),10)\n# 3.2",
    "Section ID: selfloop_edges\nDescription: [Returns an iterator over selfloop edges., A selfloop edge has the same node at both ends.]\nField List: Parameters:: G : graph: A NetworkX graph.\ndata : string or bool, optional (default=False): Return selfloop edges as two tuples (u, v) (data=False)\nor three-tuples (u, v, datadict) (data=True)\nor three-tuples (u, v, datavalue) (data=’attrname’)\nkeys : bool, optional (default=False): If True, return edge keys with each edge.\ndefault : value, optional (default=None): Value used for edges that don’t have the requested attribute.\nOnly relevant if data is not True or False.\nReturns:: edgeiter : iterator over edge tuples: An iterator over all selfloop edges.\nMethods: []\nRubrics: Examples: G=nx.MultiGraph()# or Graph, DiGraph, MultiDiGraph, etc\nekey=G.add_edge(1,1)\nekey=G.add_edge(1,2)\nlist(nx.selfloop_edges(G))\n# [(1, 1)]\nlist(nx.selfloop_edges(G,data=True))\n# [(1, 1, {})]\nlist(nx.selfloop_edges(G,keys=True))\n# [(1, 1, 0)]\nlist(nx.selfloop_edges(G,keys=True,data=True))\n# [(1, 1, 0, {})]",
    "Section ID: recursive_simple_cycles\nDescription: [Find simple cycles (elementary circuits) of a directed graph., A simplecycle , or elementarycircuit , is a closed path where\nno node appears twice. Two elementary circuits are distinct if they\nare not cyclic permutations of each other., This version uses a recursive algorithm to build a list of cycles.\nYou should probably use the iterator version called simple_cycles().\nWarning: This recursive version uses lots of RAM!\nIt appears in NetworkX for pedagogical value.]\nField List: Parameters:: G : NetworkX DiGraph: A directed graph\nReturns:: A list of cycles, where each cycle is represented by a list of nodes: \nalong the cycle.: \nExample:: \n[[0], [2], [0, 1, 2], [0, 2], [1, 2]]:\nMethods: []\nRubrics: Notes: The implementation follows pp. 79-80 in [1] . The time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) elementary circuits.\nReferences: [1]Finding all the elementary circuits of a directed graph.\nD. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.https://doi.org/10.1137/0204007",
    "Section ID: chvatal_graph\nDescription: [Returns the Chvátal Graph, The Chvátal Graph is an undirected graph with 12 nodes and 24 edges [1] .\nIt has 370 distinct (directed) Hamiltonian cycles, giving a unique generalized\nLCF notation of order 4, two of order 6 , and 43 of order 1 [2] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: The Chvátal graph with 12 nodes and 24 edges\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Chv%C3%A1tal_graph  [2]https://mathworld.wolfram.com/ChvatalGraph.html",
    "Section ID: to_undirected\nDescription: [Returns an undirected view of the graph graph ., Identical to graph.to_undirected(as_view=True)\nNote that graph.to_undirected defaults to as_view=False while this function always provides a view.]\nField List: Methods: []\nRubrics:",
    "Section ID: tree_broadcast_time\nDescription: [Return the Broadcast Time of the tree G ., The minimum broadcast time of a node is defined as the minimum amount\nof time required to complete broadcasting starting from the\noriginator. The broadcast time of a graph is the maximum over\nall nodes of the minimum broadcast time from that node [1] .\nThis function returns the minimum broadcast time of node .\nIf node is None the broadcast time for the graph is returned.]\nField List: Parameters:: G : undirected graph: The graph should be an undirected tree\nnode: int, optional: index of starting node. IfNone, the algorithm returns the broadcast\ntime of the tree.\nReturns:: BT : int: Broadcast Time of a node in a tree\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics: References: [1]Harutyunyan, H. A. and Li, Z.\n“A Simple Construction of Broadcast Graphs.”\nIn Computing and Combinatorics. COCOON 2019\n(Ed. D. Z. Du and C. Tian.) Springer, pp. 240-253, 2019.",
    "Section ID: node_expansion\nDescription: [Returns the node expansion of the set S ., The node expansion is the quotient of the size of the node\nboundary of S and the cardinality of S . [1]]\nField List: Parameters:: G : NetworkX graph: \nS : collection: A collection of nodes inG.\nReturns:: number: The node expansion of the setS.\nMethods: []\nRubrics: References: [1]Vadhan, Salil P.\n“Pseudorandomness.”Foundations and Trends\nin Theoretical Computer Science7.1–3 (2011): 1–336.\n<https://doi.org/10.1561/0400000010>",
    "Section ID: optimize_graph_edit_distance\nDescription: [Returns consecutive approximations of GED (graph edit distance)\nbetween graphs G1 and G2., Graph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2.]\nField List: Parameters:: G1, G2: graphs: The two graphs G1 and G2 must be of the same type.\nnode_match : callable: A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.\nedge_match : callable: A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.\nnode_subst_cost, node_del_cost, node_ins_cost : callable: Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.\nedge_subst_cost, edge_del_cost, edge_ins_cost : callable: Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.\nupper_bound : numeric: Maximum edit distance to consider.\nReturns:: Generator of consecutive approximations of graph edit distance.:\nMethods: []\nRubrics: References: [1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816\nExamples: G1=nx.cycle_graph(6)\nG2=nx.wheel_graph(7)\nforvinnx.optimize_graph_edit_distance(G1,G2):\nminv=v\nminv\n# 7.0",
    "Section ID: trophic_levels\nDescription: [Compute the trophic levels of nodes., The trophic level of a node \\(i\\) is, where \\(k^{in}_i\\) is the in-degree of i, and nodes with \\(k^{in}_i = 0\\) have \\(s_i = 1\\) by convention., These are calculated using the method outlined in Levine [1] .]\nField List: Parameters:: G : DiGraph: A directed networkx graph\nReturns:: nodes : dict: Dictionary of nodes with trophic level as the value.\nMethods: []\nRubrics: References: [1]Stephen Levine (1980) J. theor. Biol. 83, 195-207",
    "Section ID: to_edgelist\nDescription: [Returns a list of edges in the graph.]\nField List: Parameters:: G : graph: A NetworkX graph\nnodelist : list: Use only nodes specified in nodelist\nMethods: []\nRubrics:",
    "Section ID: fast_gnp_random_graph\nDescription: [Returns a \\(G_{n,p}\\) random graph, also known as an Erdős-Rényi graph or\na binomial graph.]\nField List: Parameters:: n : int: The number of nodes.\np : float: Probability for edge creation.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : bool, optional (default=False): If True, this function returns a directed graph.\nMethods: []\nRubrics: Notes: The \\(G_{n,p}\\) graph algorithm chooses each of the \\([n (n - 1)] / 2\\) (undirected) or \\(n (n - 1)\\) (directed) possible edges with probability \\(p\\) . This algorithm [1] runs in \\(O(n + m)\\) time, where m is the expected number of\nedges, which equals \\(p n (n - 1) / 2\\) . This should be faster than gnp_random_graph() when \\(p\\) is small and the expected number of edges\nis small (that is, the graph is sparse).\nReferences: [1]Vladimir Batagelj and Ulrik Brandes,\n“Efficient generation of large random networks”,\nPhys. Rev. E, 71, 036113, 2005.",
    "Section ID: gaussian_random_partition_graph\nDescription: [Generate a Gaussian random partition graph., A Gaussian random partition graph is created by creating k partitions\neach with a size drawn from a normal distribution with mean s and variance\ns/v. Nodes are connected within clusters with probability p_in and\nbetween clusters with probability p_out[1]]\nField List: Parameters:: n : int: Number of nodes in the graph\ns : float: Mean cluster size\nv : float: Shape parameter. The variance of cluster size distribution is s/v.\np_in : float: Probability of intra cluster connection.\np_out : float: Probability of inter cluster connection.\ndirected : boolean, optional default=False: Whether to create a directed graph or not\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : NetworkX Graph or DiGraph: gaussian random partition graph\nRaises:: NetworkXError: If s is > n\nIf p_in or p_out is not in [0,1]\nMethods: []\nRubrics: Notes: Note the number of partitions is dependent on s,v and n, and that the\nlast partition may be considerably smaller, as it is sized to simply\nfill out the nodes [1]\nReferences: [1]Ulrik Brandes, Marco Gaertler, Dorothea Wagner,\nExperiments on Graph Clustering Algorithms,\nIn the proceedings of the 11th Europ. Symp. Algorithms, 2003.\nExamples: G=nx.gaussian_random_partition_graph(100,10,10,0.25,0.1)\nlen(G)\n# 100",
    "Section ID: weighted_projected_graph\nDescription: [Returns a weighted projection of B onto one of its node sets., The weighted projected graph is the projection of the bipartite\nnetwork B onto the specified nodes with weights representing the\nnumber of shared neighbors or the ratio between actual shared\nneighbors and possible shared neighbors if ratioisTrue  [1] .\nThe nodes retain their attributes and are connected in the resulting\ngraph if they have an edge to a common node in the original graph.]\nField List: Parameters:: B : NetworkX graph: The input graph should be bipartite.\nnodes : list or iterable: Distinct nodes to project onto (the “bottom” nodes).\nratio: Bool (default=False): If True, edge weight is the ratio between actual shared neighbors\nand maximum possible shared neighbors (i.e., the size of the other\nnode set). If False, edges weight is the number of shared neighbors.\nReturns:: Graph : NetworkX graph: A graph that is the projection onto the given nodes.\nMethods: []\nRubrics: Notes: No attempt is made to verify that the input graph B is bipartite, or that\nthe input nodes are distinct. However, if the length of the input nodes is\ngreater than or equal to the nodes in the graph B, an exception is raised.\nIf the nodes are not distinct but don’t raise this error, the output weights\nwill be incorrect.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nReferences: [1]Borgatti, S.P. and Halgin, D. In press. “Analyzing Affiliation\nNetworks”. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.\nExamples: fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(4)\nG=bipartite.weighted_projected_graph(B,[1,3])\nlist(G)\n# [1, 3]\nlist(G.edges(data=True))\n# [(1, 3, {'weight': 1})]\nG=bipartite.weighted_projected_graph(B,[1,3],ratio=True)\nlist(G.edges(data=True))\n# [(1, 3, {'weight': 0.5})]",
    "Section ID: is_valid_degree_sequence_havel_hakimi\nDescription: [Returns True if deg_sequence can be realized by a simple graph., The validation proceeds using the Havel-Hakimi theorem [havel1955] , [hakimi1962] , [CL1996] .\nWorst-case run time is \\(O(s)\\) where \\(s\\) is the sum of the sequence.]\nField List: Parameters:: deg_sequence : list: A list of integers where each element specifies the degree of a node\nin a graph.\nReturns:: valid : bool: True if deg_sequence is graphical and False if not.\nMethods: []\nRubrics: Notes: The ZZ condition says that for the sequence d if\nReferences: [1]I.E. Zverovich and V.E. Zverovich. “Contributions to the theory\nof graphic sequences”, Discrete Mathematics, 105, pp. 292-303 (1992).  [havel1955]Havel, V. “A Remark on the Existence of Finite Graphs”\nCasopis Pest. Mat. 80, 477-480, 1955.  [hakimi1962]Hakimi, S. “On the Realizability of a Set of Integers as\nDegrees of the Vertices of a Graph.” SIAM J. Appl. Math. 10, 496-506, 1962.  [CL1996]G. Chartrand and L. Lesniak, “Graphs and Digraphs”,\nChapman and Hall/CRC, 1996.\nExamples: G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_valid_degree_sequence_havel_hakimi(sequence)\n# True\nTo test a non-valid sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\nFalse",
    "Section ID: floyd_warshall_numpy\nDescription: [Find all-pairs shortest path lengths using Floyd’s algorithm., This algorithm for finding shortest paths takes advantage of\nmatrix representations of a graph and works well for dense\ngraphs where all-pairs shortest path lengths are desired.\nThe results are returned as a NumPy array, distance[i, j],\nwhere i and j are the indexes of two nodes in nodelist.\nThe entry distance[i, j] is the distance along a shortest\npath from i to j. If no path exists the distance is Inf.]\nField List: Parameters:: G : NetworkX graph: \nnodelist : list, optional (default=G.nodes): The rows and columns are ordered by the nodes in nodelist.\nIf nodelist is None then the ordering is produced by G.nodes.\nNodelist should include all nodes in G.\nweight: string, optional (default=’weight’): Edge data key corresponding to the edge weight.\nReturns:: distance : 2D numpy.ndarray: A numpy array of shortest path distances between nodes.\nIf there is no path between two nodes the value is Inf.\nRaises:: NetworkXError: If nodelist is not a list of the nodes in G.\nMethods: []\nRubrics: Notes: Floyd’s algorithm is appropriate for finding shortest paths in\ndense graphs or graphs with negative weights when Dijkstra’s\nalgorithm fails. This algorithm can still fail if there are negative\ncycles. It has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .\nExamples: G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,5),(1,2,2),(2,3,-3),(1,3,10),(3,2,8)])\nnx.floyd_warshall_numpy(G)\n# array([[ 0.,  5.,  7.,  4.],\n#        [inf,  0.,  2., -1.],\n#        [inf, inf,  0., -3.],\n#        [inf, inf,  8.,  0.]])",
    "Section ID: parse_multiline_adjlist\nDescription: [Parse lines of a multiline adjacency list representation of a graph.]\nField List: Parameters:: lines : list or iterator of strings: Input data in multiline adjlist format\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nnodetype : Python type, optional: Convert nodes to this type.\nedgetype : Python type, optional: Convert edges to this type.\ncomments : string, optional: Marker for comment lines\ndelimiter : string, optional: Separator for node labels.  The default is whitespace.\nReturns:: G: NetworkX graph: The graph corresponding to the lines in multiline adjacency list format.\nMethods: []\nRubrics: Examples: lines=[\n\"1 2\",\n\"2 {'weight':3, 'name': 'Frodo'}\",\n\"3 {}\",\n\"2 1\",\n\"5 {'weight':6, 'name': 'Saruman'}\",\n]\nG=nx.parse_multiline_adjlist(iter(lines),nodetype=int)\nlist(G)\n# [1, 2, 3, 5]",
    "Section ID: is_biconnected\nDescription: [Returns True if the graph is biconnected, False otherwise., A graph is biconnected if, and only if, it cannot be disconnected by\nremoving only one node (and all edges incident on that node).  If\nremoving a node increases the number of disconnected components\nin the graph, that node is called an articulation point, or cut\nvertex.  A biconnected graph has no articulation points.]\nField List: Parameters:: G : NetworkX Graph: An undirected graph.\nReturns:: biconnected : bool: True if the graph is biconnected, False otherwise.\nRaises:: NetworkXNotImplemented: If the input graph is not undirected.\nMethods: []\nRubrics: Notes: The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.\nReferences: [1]Hopcroft, J.; Tarjan, R. (1973).\n“Efficient algorithms for graph manipulation”.\nCommunications of the ACM 16: 372–378. doi:10.1145/362248.362272\nExamples: G=nx.path_graph(4)\nprint(nx.is_biconnected(G))\n# False\nG.add_edge(0,3)\nprint(nx.is_biconnected(G))\n# True",
    "Section ID: k_edge_subgraphs\nDescription: [Generates nodes in each maximal k-edge-connected subgraph in G.]\nField List: Parameters:: G : NetworkX graph: \nk : Integer: Desired edge connectivity\nReturns:: k_edge_subgraphs : a generator of k-edge-subgraphs: Each k-edge-subgraph is a maximal set of nodes that defines a subgraph\nof G that is k-edge-connected.\nRaises:: NetworkXNotImplemented: If the input graph is a multigraph.\nValueError:: If k is less than 1\nMethods: []\nRubrics: Notes: Attempts to use the most efficient implementation available based on k.\nIf k=1, or k=2 and the graph is undirected, then this simply calls k_edge_components .  Otherwise the algorithm from _[1] is used.\nReferences: [1]Zhou, Liu, et al. (2012) Finding maximal k-edge-connected subgraphs\nfrom a large graph.  ACM International Conference on Extending Database\nTechnology 2012 480-–491.https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf\nExamples: importitertoolsasit\nfromnetworkx.utilsimportpairwise\npaths=[\n(1,2,4,3,1,4),\n(5,6,7,8,5,7,8,6),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# note this does not return {1, 4} unlike k_edge_components\nsorted(map(sorted,nx.k_edge_subgraphs(G,k=3)))\n# [[1], [2], [3], [4], [5, 6, 7, 8]]",
    "Section ID: nodes_equal\nDescription: [Check if nodes are equal., Equality here means equal as Python objects.\nNode data must match if included.\nThe order of nodes is not relevant.]\nField List: Parameters:: nodes1, nodes2 : iterables of nodes, or (node, datadict) tuples:\nReturns:: bool: True if nodes are equal, False otherwise.\nMethods: []\nRubrics:",
    "Section ID: add_star\nDescription: [Add a star to Graph G_to_add_to., The first node in nodes_for_star is the middle of the star.\nIt is connected to all other nodes.]\nField List: Parameters:: G_to_add_to : graph: A NetworkX graph\nnodes_for_star : iterable container: A container of nodes.\nattr : keyword arguments, optional (default= no attributes): Attributes to add to every edge in star.\nMethods: []\nRubrics: Examples: G=nx.Graph()\nnx.add_star(G,[0,1,2,3])\nnx.add_star(G,[10,11,12],weight=2)",
    "Section ID: octahedral_graph\nDescription: [Returns the Platonic Octahedral graph., The octahedral graph is the 6-node 12-edge Platonic graph having the\nconnectivity of the octahedron [1] . If 6 couples go to a party,\nand each person shakes hands with every person except his or her partner,\nthen this graph describes the set of handshakes that take place;\nfor this reason it is also called the cocktail party graph [2] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Octahedral graph\nMethods: []\nRubrics: References: [1]https://mathworld.wolfram.com/OctahedralGraph.html  [2]https://en.wikipedia.org/wiki/Tur%C3%A1n_graph#Special_cases",
    "Section ID: full_rary_tree\nDescription: [Creates a full r-ary tree of n nodes., Sometimes called a k-ary, n-ary, or m-ary tree.\n“… all non-leaf nodes have exactly r children and all levels\nare full except for some rightmost position of the bottom level\n(if a leaf at the bottom level is missing, then so are all of the\nleaves to its right.” [1], ( Sourcecode , png )]\nField List: Parameters:: r : int: branching factor of the tree\nn : int: Number of nodes in the tree\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: An r-ary tree with n nodes\nMethods: []\nRubrics: References: [1]An introduction to data structures and algorithms,\nJames Andrew Storer,  Birkhauser Boston 2001, (page 225).",
    "Section ID: draw_networkx_edge_labels\nDescription: [Draw edge labels.]\nField List: Parameters:: G : graph: A networkx graph\npos : dictionary: A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.\nedge_labels : dictionary (default=None): Edge labels in a dictionary of labels keyed by edge two-tuple.\nOnly labels for the keys in the dictionary are drawn.\nlabel_pos : float (default=0.5): Position of edge label along edge (0=head, 0.5=center, 1=tail)\nfont_size : int (default=10): Font size for text labels\nfont_color : color (default=’k’ black): Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.\nfont_weight : string (default=’normal’): Font weight\nfont_family : string (default=’sans-serif’): Font family\nalpha : float or None (default=None): The text transparency\nbbox : Matplotlib bbox, optional: Specify text box properties (e.g. shape, color etc.) for edge labels.\nDefault is {boxstyle=’round’, ec=(1.0, 1.0, 1.0), fc=(1.0, 1.0, 1.0)}.\nhorizontalalignment : string (default=’center’): Horizontal alignment {‘center’, ‘right’, ‘left’}\nverticalalignment : string (default=’center’): Vertical alignment {‘center’, ‘top’, ‘bottom’, ‘baseline’, ‘center_baseline’}\nax : Matplotlib Axes object, optional: Draw the graph in the specified Matplotlib axes.\nrotate : bool (default=True): Rotate edge labels to lie parallel to edges\nclip_on : bool (default=True): Turn on clipping of edge labels at axis boundaries\nnode_size : scalar or array (default=300): Size of nodes.  If an array it must be the same length as nodelist.\nnodelist : list, optional (default=G.nodes()): This provides the node order for thenode_sizearray (if it is an array).\nconnectionstyle : string or iterable of strings (default=”arc3”): Pass the connectionstyle parameter to create curved arc of rounding\nradius rad. For example, connectionstyle=’arc3,rad=0.2’.\nSeematplotlib.patches.ConnectionStyleandmatplotlib.patches.FancyArrowPatchfor more info.\nIf Iterable, index indicates i’th edge key of MultiGraph\nhide_ticks : bool, optional: Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False.\nReturns:: dict: dictof labels keyed by edge\nMethods: []\nRubrics: Examples: G=nx.dodecahedral_graph()\nedge_labels=nx.draw_networkx_edge_labels(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html",
    "Section ID: stochastic_graph\nDescription: [Returns a right-stochastic representation of directed graph G ., A right-stochastic graph is a weighted digraph in which for each\nnode, the sum of the weights of all the out-edges of that node is\n1. If the graph is already weighted (for example, via a ‘weight’\nedge attribute), the reweighting takes that into account.]\nField List: Parameters:: G : directed graph: ADiGraphorMultiDiGraph.\ncopy : boolean, optional: If this is True, then this function returns a new graph with\nthe stochastic reweighting. Otherwise, the original graph is\nmodified in-place (and also returned, for convenience).\nweight : edge attribute key (optional, default=’weight’): Edge attribute key used for reading the existing weight and\nsetting the new weight.  If no attribute with this key is found\nfor an edge, then the edge weight is assumed to be 1. If an edge\nhas a weight, it must be a positive number.\nMethods: []\nRubrics:",
    "Section ID: grid_graph\nDescription: [Returns the n -dimensional grid graph., The dimension n is the length of the list dim and the size in\neach dimension is the value of the corresponding list element.]\nField List: Parameters:: dim : list or tuple of numbers or iterables of nodes: ‘dim’ is a tuple or list with, for each dimension, either a number\nthat is the size of that dimension or an iterable of nodes for\nthat dimension. The dimension of the grid_graph is the length\nofdim.\nperiodic : bool or iterable: Ifperiodicis True, all dimensions are periodic. If False all\ndimensions are not periodic. Ifperiodicis iterable, it should\nyielddimbool values each of which indicates whether the\ncorresponding axis is periodic.\nReturns:: NetworkX graph: The (possibly periodic) grid graph of the specified dimensions.\nMethods: []\nRubrics: Examples: To produce a 2 by 3 by 4 grid graph, a graph on 24 nodes:\nfromnetworkximportgrid_graph\nG=grid_graph(dim=(2,3,4))\nlen(G)\n# 24\nG=grid_graph(dim=(range(7,9),range(3,6)))\nlen(G)\n# 6",
    "Section ID: dijkstra_path_length\nDescription: [Returns the shortest weighted path length in G from source to target., Uses Dijkstra’s Method to compute the shortest weighted path length\nbetween two nodes in a graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: starting node for path\ntarget : node label: ending node for path\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: length : number: Shortest path length.\nRaises:: NodeNotFound: Ifsourceis not inG.\nNetworkXNoPath: If no path exists between source and target.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. The function single_source_dijkstra() computes both\npath and length-of-path if you need both, use that.\nExamples: G=nx.path_graph(5)\nnx.dijkstra_path_length(G,0,4)\n# 4",
    "Section ID: relabel_gexf_graph\nDescription: [Relabel graph using “label” node keyword for node label.]\nField List: Parameters:: G : graph: A NetworkX graph read from GEXF data\nReturns:: H : graph: A NetworkX graph with relabeled nodes\nRaises:: NetworkXError: If node labels are missing or not unique while relabel=True.\nMethods: []\nRubrics: Notes: This function relabels the nodes in a NetworkX graph with the\n“label” attribute.  It also handles relabeling the specific GEXF\nnode attributes “parents”, and “pid”.",
    "Section ID: voterank\nDescription: [Select a list of influential nodes in a graph using VoteRank algorithm, VoteRank [1] computes a ranking of the nodes in a graph G based on a\nvoting scheme. With VoteRank, all nodes vote for each of its in-neighbors\nand the node with the highest votes is elected iteratively. The voting\nability of out-neighbors of elected nodes is decreased in subsequent turns.]\nField List: Parameters:: G : graph: A NetworkX graph.\nnumber_of_nodes : integer, optional: Number of ranked nodes to extract (default all nodes).\nReturns:: voterank : list: Ordered list of computed seeds.\nOnly nodes with positive number of votes are returned.\nMethods: []\nRubrics: Notes: Each edge is treated independently in case of multigraphs.\nReferences: [1]Zhang, J.-X. et al. (2016).\nIdentifying a set of influential spreaders in complex networks.\nSci. Rep. 6, 27823; doi: 10.1038/srep27823.\nExamples: G=nx.Graph([(0,1),(0,2),(0,3),(1,4)])\nnx.voterank(G)\n# [0, 1]\nThe algorithm can be used both for undirected and directed graphs.\nHowever, the directed version is different in two ways:\n(i) nodes only vote for their in-neighbors and\n(ii) only the voting ability of elected node and its out-neighbors are updated:\nG=nx.DiGraph([(0,1),(2,1),(2,3),(3,4)])\nnx.voterank(G)\n# [2, 3]",
    "Section ID: multi_source_dijkstra_path_length\nDescription: [Find shortest weighted path lengths in G from a given set of\nsource nodes., Compute the shortest path length between any of the source nodes and\nall other reachable nodes for a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsources : non-empty set of nodes: Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.\ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: length : dict: Dict keyed by node to shortest path length to nearest source.\nRaises:: ValueError: Ifsourcesis empty.\nNodeNotFound: If any ofsourcesis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.\nExamples: G=nx.path_graph(5)\nlength=nx.multi_source_dijkstra_path_length(G,{0,4})\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 1\n# 4: 0",
    "Section ID: is_tree\nDescription: [Returns True if G is a tree., A tree is a connected graph with no undirected cycles., For directed graphs, G is a tree if the underlying graph is a tree. The\nunderlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph.]\nField List: Parameters:: G : graph: The graph to test.\nReturns:: b : bool: A boolean that is True ifGis a tree.\nRaises:: NetworkXPointlessConcept: IfGis empty.\nMethods: []\nRubrics: Notes: In another convention, a directed tree is known as a polytree and then tree corresponds to an arborescence .\nExamples: G=nx.Graph()\nG.add_edges_from([(1,2),(1,3),(2,4),(2,5)])\nnx.is_tree(G)# n-1 edges\n# True\nG.add_edge(3,4)\nnx.is_tree(G)# n edges\n# False",
    "Section ID: UnionAtlas\nDescription: [A read-only union of two atlases (dict-of-dict)., The two dict-of-dicts represent the inner dict of\nan Adjacency: G.succ[node] and G.pred[node] .\nThe inner level of dict of both hold attribute key:value\npairs and is read-write. But the outer level is read-only.]\nField List: Methods: []\nRubrics:",
    "Section ID: chordal_graph_cliques\nDescription: [Returns all maximal cliques of a chordal graph., The algorithm breaks the graph in connected components and performs a\nmaximum cardinality search in each component to get the cliques.]\nField List: Parameters:: G : graph: A NetworkX graph\nYields:: frozenset of nodes: Maximal cliques, each of which is a frozenset of\nnodes inG. The order of cliques is arbitrary.\nRaises:: NetworkXError: The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised.\nMethods: []\nRubrics: Examples: e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n(7,8),\n]\nG=nx.Graph(e)\nG.add_node(9)\ncliques=[cforcinchordal_graph_cliques(G)]\ncliques[0]\n# frozenset({1, 2, 3})",
    "Section ID: write_edgelist\nDescription: [Write a bipartite graph as a list of edges.]\nField List: Parameters:: G : Graph: A NetworkX bipartite graph\npath : file or string: File or filename to write. If a file is provided, it must be\nopened in ‘wb’ mode. Filenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional: The character used to indicate the start of a comment\ndelimiter : string, optional: The string used to separate values.  The default is whitespace.\ndata : bool or list, optional: If False write no edge data.\nIf True write a string representation of the edge data dictionary..\nIf a list (or other iterable) is provided, write the  keys specified\nin the list.\nencoding: string, optional: Specify which encoding to use when writing file.\nMethods: []\nRubrics: Examples: G=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nnx.write_edgelist(G,\"test.edgelist\")\nfh=open(\"test.edgelist\",\"wb\")\nnx.write_edgelist(G,fh)\nnx.write_edgelist(G,\"test.edgelist.gz\")\nnx.write_edgelist(G,\"test.edgelist.gz\",data=False)\nG=nx.Graph()\nG.add_edge(1,2,weight=7,color=\"red\")\nnx.write_edgelist(G,\"test.edgelist\",data=False)\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\"])\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\",\"weight\"])",
    "Section ID: generic_weighted_projected_graph\nDescription: [Weighted projection of B with a user-specified weight function., The bipartite network B is projected on to the specified nodes\nwith weights computed by a user-specified function.  This function\nmust accept as a parameter the neighborhood sets of two nodes and\nreturn an integer or a float., The nodes retain their attributes and are connected in the resulting graph\nif they have an edge to a common node in the original graph.]\nField List: Parameters:: B : NetworkX graph: The input graph should be bipartite.\nnodes : list or iterable: Nodes to project onto (the “bottom” nodes).\nweight_function : function: This function must accept as parameters the same input graph\nthat this function, and two nodes; and return an integer or a float.\nThe default function computes the number of shared neighbors.\nReturns:: Graph : NetworkX graph: A graph that is the projection onto the given nodes.\nMethods: []\nRubrics: Notes: No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nExamples: fromnetworkx.algorithmsimportbipartite\n# Define some custom weight functions\ndefjaccard(G,u,v):\nunbrs=set(G[u])\nvnbrs=set(G[v])\nreturnfloat(len(unbrs&vnbrs))/len(unbrs|vnbrs)\ndefmy_weight(G,u,v,weight=\"weight\"):\nw=0\nfornbrinset(G[u])&set(G[v]):\nw+=G[u][nbr].get(weight,1)+G[v][nbr].get(weight,1)\nreturnw\n# A complete bipartite graph with 4 nodes and 4 edges\nB=nx.complete_bipartite_graph(2,2)\n# Add some arbitrary weight to the edges\nfori,(u,v)inenumerate(B.edges()):\nB.edges[u,v][\"weight\"]=i+1\nforedgeinB.edges(data=True):\nprint(edge)\n# (0, 2, {'weight': 1})\n# (0, 3, {'weight': 2})\n# (1, 2, {'weight': 3})\n# (1, 3, {'weight': 4})\n# By default, the weight is the number of shared neighbors\nG=bipartite.generic_weighted_projected_graph(B,[0,1])\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 2})]\n# To specify a custom weight function use the weight_function parameter\nG=bipartite.generic_weighted_projected_graph(B,[0,1],weight_function=jaccard)\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 1.0})]\nG=bipartite.generic_weighted_projected_graph(B,[0,1],weight_function=my_weight)\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 10})]",
    "Section ID: nonisomorphic_trees\nDescription: [Generates lists of nonisomorphic trees]\nField List: Parameters:: order : int: order of the desired tree(s)\ncreate : one of {“graph”, “matrix”} (default=”graph”): If\"graph\"is selected a list ofGraphinstances will be returned,\nif matrix is selected a list of adjacency matrices will be returned.Deprecated since version 3.3:Thecreateargument is deprecated and will be removed in NetworkX\nversion 3.5. In the future,nonisomorphic_treeswill yield graph\ninstances by default. To generate adjacency matrices, callnx.to_numpy_arrayon the output, e.g.:[nx.to_numpy_array(G)forGinnx.nonisomorphic_trees(N)]\nYields:: list: A list of nonisomorphic trees, in one of two formats depending on the\nvalue of thecreateparameter:\n-create=\"graph\": yields a list ofnetworkx.Graphinstances\n-create=\"matrix\": yields a list of list-of-lists representing adjacency matrices\nMethods: []\nRubrics:",
    "Section ID: center\nDescription: [Returns the center of the graph G., The center is the set of nodes with eccentricity equal to radius.]\nField List: Parameters:: G : NetworkX graph: A graph\ne : eccentricity dictionary, optional: A precomputed dictionary of eccentricities.\nweight : string, function, or None: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances.\nReturns:: c : list: List of nodes in center\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nlist(nx.center(G))\n# [1, 3, 4]",
    "Section ID: is_perfect_matching\nDescription: [Return True if matching is a perfect matching for G, A perfect matching in a graph is a matching in which exactly one edge\nis incident upon each vertex.]\nField List: Parameters:: G : NetworkX graph: \nmatching : dict or set: A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching.\nReturns:: bool: Whether the given set or dictionary represents a valid perfect\nmatching in the graph.\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5),(4,6)])\nmy_match={1:2,3:5,4:6}\nnx.is_perfect_matching(G,my_match)\n# True",
    "Section ID: all_pairs_dijkstra_path\nDescription: [Compute shortest paths between all nodes in a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \ncutoff : integer or float, optional: Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: paths : iterator: (source, dictionary) iterator with dictionary keyed by target and\nshortest path as the key value.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\nExamples: G=nx.path_graph(5)\npath=dict(nx.all_pairs_dijkstra_path(G))\npath[0][4]\n# [0, 1, 2, 3, 4]",
    "Section ID: tensor_product\nDescription: [Returns the tensor product of G and H., The tensor product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\((u,x)\\) is an edge in \\(G\\) and \\((v,y)\\) is an edge in \\(H\\) ., Tensor product is sometimes also referred to as the categorical product,\ndirect product, cardinal product or conjunction.]\nField List: Parameters:: G, H: graphs: Networkx graphs.\nReturns:: P: NetworkX graph: The tensor product of G and H. P will be a multi-graph if either G\nor H is a multi-graph, will be a directed if G and H are directed,\nand undirected if G and H are undirected.\nRaises:: NetworkXError: If G and H are not both directed or both undirected.\nMethods: []\nRubrics: Notes: Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.\nExamples: G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.tensor_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph",
    "Section ID: random_tournament\nDescription: [Returns a random tournament graph on n nodes.]\nField List: Parameters:: n : int: The number of nodes in the returned graph.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : DiGraph: A tournament onnnodes, with exactly one directed edge joining\neach pair of distinct nodes.\nMethods: []\nRubrics: Notes: This algorithm adds, for each pair of distinct nodes, an edge with\nuniformly random orientation. In other words, binom{n}{2} flips\nof an unbiased coin decide the orientations of the edges in the\ngraph.",
    "Section ID: directed_joint_degree_graph\nDescription: [Generates a random simple directed graph with the joint degree.]\nField List: Parameters:: degree_seq : list of tuples (of size 3): degree sequence contains tuples of nodes with node id, in degree and\nout degree.\nnkk : dictionary of dictionary of integers: directed joint degree dictionary, for nodes of out degree k (first\nlevel of dict) and nodes of in degree l (second level of dict)\ndescribes the number of edges.\nseed : hashable object, optional: Seed for random number generator.\nReturns:: G : Graph: A directed graph with the specified inputs.\nRaises:: NetworkXError: If degree_seq and nkk are not realizable as a simple directed graph.\nMethods: []\nRubrics: Notes: Similarly to the undirected version:\nIn each iteration of the “while loop” the algorithm picks two disconnected\nnodes v and w, of degree k and l correspondingly,  for which nkk[k][l] has\nnot reached its target yet i.e. (for given k,l): n_edges_add < nkk[k][l].\nIt then adds edge (v,w) and always increases the number of edges in graph G\nby one. The intelligence of the algorithm lies in the fact that  it is always\npossible to add an edge between disconnected nodes v and w, for which\nnkk[degree(v)][degree(w)] has not reached its target, even if one or both\nnodes do not have free stubs. If either node v or w does not have a free\nstub, we perform a “neighbor switch”, an edge rewiring move that releases a\nfree stub while keeping nkk the same. The difference for the directed version lies in the fact that neighbor\nswitches might not be able to rewire, but in these cases unsaturated nodes\ncan be reassigned to use instead, see [1] for detailed description and\nproofs. The algorithm continues for E (number of edges in the graph) iterations of\nthe “while loop”, at which point all entries of the given nkk[k][l] have\nreached their target values and the construction is complete.\nReferences: [1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka, “Construction of Directed 2K Graphs”. In Proc. of KDD 2017.\nExamples: in_degrees=[0,1,1,2]\nout_degrees=[1,1,1,1]\nnkk={1:{1:2,2:2}}\nG=nx.directed_joint_degree_graph(in_degrees,out_degrees,nkk)",
    "Section ID: florentine_families_graph\nDescription: [Returns Florentine families graph., References]\nField List: Methods: []\nRubrics: References: [1]Ronald L. Breiger and Philippa E. Pattison\nCumulated social roles: The duality of persons and their algebras,1\nSocial Networks, Volume 8, Issue 3, September 1986, Pages 215-256",
    "Section ID: generic_bfs_edges\nDescription: [Iterate over edges in a breadth-first search., The breadth-first search begins at source and enqueues the\nneighbors of newly visited nodes specified by the neighbors function.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for the breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.\nneighbors : function: A function that takes a newly visited node of the graph as input\nand returns aniterator(not just a list) of nodes that are\nneighbors of that node with custom ordering. If not specified, this is\njust theG.neighborsmethod, but in general it can be any function\nthat returns an iterator over some or all of the neighbors of a\ngiven node, in any order.\ndepth_limit : int, optional(default=len(G)): Specify the maximum search depth.\nsort_neighbors : Callable (default=None): Deprecated since version 3.2:The sort_neighbors parameter is deprecated and will be removed in\nversion 3.4. A custom (e.g. sorted) ordering of neighbors can be\nspecified with theneighborsparameter.A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nYields:: edge: Edges in the breadth-first search starting fromsource.\nMethods: []\nRubrics: Notes: This implementation is from PADS , which was in the public domain\nwhen it was first accessed in July, 2004.  The modifications\nto allow depth limits are based on the Wikipedia article\n“ Depth-limited-search ”.\nExamples: G=nx.path_graph(7)\nlist(nx.generic_bfs_edges(G,source=0))\n# [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\nlist(nx.generic_bfs_edges(G,source=2))\n# [(2, 1), (2, 3), (1, 0), (3, 4), (4, 5), (5, 6)]\nlist(nx.generic_bfs_edges(G,source=2,depth_limit=2))\n# [(2, 1), (2, 3), (1, 0), (3, 4)]\nTheneighborsparam can be used to specify the visitation order of each\nnode’s neighbors generically. In the following example, we modify the default\nneighbor to returnoddnodes first:\ndefodd_first(n):\nreturnsorted(G.neighbors(n),key=lambdax:x%2,reverse=True)\nG=nx.star_graph(5)\nlist(nx.generic_bfs_edges(G,source=0))# Default neighbor ordering\n# [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\nlist(nx.generic_bfs_edges(G,source=0,neighbors=odd_first))\n# [(0, 1), (0, 3), (0, 5), (0, 2), (0, 4)]",
    "Section ID: read_pajek\nDescription: [Read graph in Pajek format from path.]\nField List: Parameters:: path : file or string: File or filename to write.\nFilenames ending in .gz or .bz2 will be uncompressed.\nReturns:: G : NetworkX MultiGraph or MultiDiGraph.:\nMethods: []\nRubrics: References: See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information.\nExamples: G=nx.path_graph(4)\nnx.write_pajek(G,\"test.net\")\nG=nx.read_pajek(\"test.net\")\nTo create a Graph instead of a MultiGraph use\nG1=nx.Graph(G)",
    "Section ID: attribute_assortativity_coefficient\nDescription: [Compute assortativity for node attributes., Assortativity measures the similarity of connections\nin the graph with respect to the given attribute.]\nField List: Parameters:: G : NetworkX graph: \nattribute : string: Node attribute key\nnodes: list or iterable (optional): Compute attribute assortativity for nodes in container.\nThe default is all nodes.\nReturns:: r: float: Assortativity of graph for given attribute\nMethods: []\nRubrics: Notes: This computes Eq. (2) in Ref. [1] , (trace(M)-sum(M^2))/(1-sum(M^2)),\nwhere M is the joint probability distribution (mixing matrix)\nof the specified attribute.\nReferences: [1]M. E. J. Newman, Mixing patterns in networks,\nPhysical Review E, 67 026126, 2003\nExamples: G=nx.Graph()\nG.add_nodes_from([0,1],color=\"red\")\nG.add_nodes_from([2,3],color=\"blue\")\nG.add_edges_from([(0,1),(2,3)])\nprint(nx.attribute_assortativity_coefficient(G,\"color\"))\n# 1.0",
    "Section ID: density\nDescription: [Returns density of bipartite graph B.]\nField List: Parameters:: B : NetworkX graph: \nnodes: list or container: Nodes in one node set of the bipartite graph.\nReturns:: d : float: The bipartite density\nMethods: []\nRubrics: Notes: The container of nodes passed as argument must contain all nodes\nin one of the two bipartite node sets to avoid ambiguity in the\ncase of disconnected graphs.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.complete_bipartite_graph(3,2)\nX=set([0,1,2])\nbipartite.density(G,X)\n# 1.0\nY=set([3,4])\nbipartite.density(G,Y)\n# 1.0",
    "Section ID: get_edge_attributes\nDescription: [Get edge attributes from graph]\nField List: Parameters:: G : NetworkX Graph: \nname : string: Attribute name\ndefault: object (default=None): Default value of the edge attribute if there is no value set for that\nedge in graph. IfNonethen edges without this attribute are not\nincluded in the returned dict.\nReturns:: Dictionary of attributes keyed by edge. For (di)graphs, the keys are: \n2-tuples of the form: (u, v). For multi(di)graphs, the keys are 3-tuples of: \nthe form: (u, v, key).:\nMethods: []\nRubrics: Examples: G=nx.Graph()\nnx.add_path(G,[1,2,3],color=\"red\")\ncolor=nx.get_edge_attributes(G,\"color\")\ncolor[(1,2)]\n# 'red'\nG.add_edge(3,4)\ncolor=nx.get_edge_attributes(G,\"color\",default=\"yellow\")\ncolor[(3,4)]\n# 'yellow'",
    "Section ID: scale_free_graph\nDescription: [Returns a scale-free directed graph.]\nField List: Parameters:: n : integer: Number of nodes in graph\nalpha : float: Probability for adding a new node connected to an existing node\nchosen randomly according to the in-degree distribution.\nbeta : float: Probability for adding an edge between two existing nodes.\nOne existing node is chosen randomly according the in-degree\ndistribution and the other chosen randomly according to the out-degree\ndistribution.\ngamma : float: Probability for adding a new node connected to an existing node\nchosen randomly according to the out-degree distribution.\ndelta_in : float: Bias for choosing nodes from in-degree distribution.\ndelta_out : float: Bias for choosing nodes from out-degree distribution.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ninitial_graph : MultiDiGraph instance, optional: Build the scale-free graph starting from this initial MultiDiGraph,\nif provided.\nReturns:: MultiDiGraph:\nMethods: []\nRubrics: Notes: The sum of alpha , beta , and gamma must be 1.\nReferences: [1]B. Bollobás, C. Borgs, J. Chayes, and O. Riordan,\nDirected scale-free graphs,\nProceedings of the fourteenth annual ACM-SIAM Symposium on\nDiscrete Algorithms, 132–139, 2003.\nExamples: Create a scale-free graph on one hundred nodes:\nG=nx.scale_free_graph(100)",
    "Section ID: rich_club_coefficient\nDescription: [Returns the rich-club coefficient of the graph G ., For each degree k , the rich-club coefficient is the ratio of the\nnumber of actual to the number of potential edges for nodes with\ndegree greater than k :, where N_k is the number of nodes with degree larger than k , and E_k is the number of edges among those nodes.]\nField List: Parameters:: G : NetworkX graph: Undirected graph with neither parallel edges nor self-loops.\nnormalized : bool (optional): Normalize using randomized network as in[1]\nQ : float (optional, default=100): Ifnormalizedis True, performQ*mdouble-edge\nswaps, wheremis the number of edges inG, to use as a\nnull-model for normalization.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: rc : dictionary: A dictionary, keyed by degree, with rich-club coefficient values.\nRaises:: NetworkXError: IfGhas fewer than four nodes andnormalized=True.\nA randomly sampled graph for normalization cannot be generated in this case.\nMethods: []\nRubrics: Notes: The rich club definition and algorithm are found in [1] .  This\nalgorithm ignores any edge weights and is not defined for directed\ngraphs or graphs with parallel edges or self loops. Normalization is done by computing the rich club coefficient for a randomly\nsampled graph with the same degree distribution as G by\nrepeatedly swapping the endpoints of existing edges. For graphs with fewer than 4\nnodes, it is not possible to generate a random graph with a prescribed\ndegree distribution, as the degree distribution fully determines the graph\n(hence making the coefficients trivially normalized to 1).\nThis function raises an exception in this case. Estimates for appropriate values of Q are found in [2] .\nReferences: [1](1,2)Julian J. McAuley, Luciano da Fontoura Costa,\nand Tibério S. Caetano,\n“The rich-club phenomenon across complex network hierarchies”,\nApplied Physics Letters Vol 91 Issue 8, August 2007.https://arxiv.org/abs/physics/0701290  [2]R. Milo, N. Kashtan, S. Itzkovitz, M. E. J. Newman, U. Alon,\n“Uniform generation of random graphs with arbitrary degree\nsequences”, 2006.https://arxiv.org/abs/cond-mat/0312028\nExamples: G=nx.Graph([(0,1),(0,2),(1,2),(1,3),(1,4),(4,5)])\nrc=nx.rich_club_coefficient(G,normalized=False,seed=42)\nrc[0]\n# 0.4",
    "Section ID: clustering\nDescription: [Compute the clustering coefficient for nodes., For unweighted graphs, the clustering of a node \\(u\\) is the fraction of possible triangles through that node that exist,, where \\(T(u)\\) is the number of triangles through node \\(u\\) and \\(deg(u)\\) is the degree of \\(u\\) ., For weighted graphs, there are several ways to define clustering [1] .\nthe one used here is defined\nas the geometric average of the subgraph edge weights [2] ,, The edge weights \\(\\hat{w}_{uv}\\) are normalized by the maximum weight\nin the network \\(\\hat{w}_{uv} = w_{uv}/\\max(w)\\) ., The value of \\(c_u\\) is assigned to 0 if \\(deg(u) < 2\\) ., Additionally, this weighted definition has been generalized to support negative edge weights [3] ., For directed graphs, the clustering is similarly defined as the fraction\nof all possible directed triangles or geometric average of the subgraph\nedge weights for unweighted and weighted directed graph respectively [4] ., where \\(T(u)\\) is the number of directed triangles through node \\(u\\) , \\(deg^{tot}(u)\\) is the sum of in degree and out degree of \\(u\\) and \\(deg^{\\leftrightarrow}(u)\\) is the reciprocal degree of \\(u\\) .]\nField List: Parameters:: G : graph: \nnodes : node, iterable of nodes, or None (default=None): If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG.\nweight : string or None, optional (default=None): The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.\nReturns:: out : float, or dictionary: Clustering coefficient at specified nodes\nMethods: []\nRubrics: Notes: Self loops are ignored.\nReferences: [1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saramäki, M. Kivelä, J.-P. Onnela,\nK. Kaski, and J. Kertész, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Intensity and coherence of motifs in weighted complex\nnetworks by J. P. Onnela, J. Saramäki, J. Kertész, and K. Kaski,\nPhysical Review E, 71(6), 065103 (2005).  [3]Generalization of Clustering Coefficients to Signed Correlation Networks\nby G. Costantini and M. Perugini, PloS one, 9(2), e88669 (2014).  [4]Clustering in complex directed networks by G. Fagiolo,\nPhysical Review E, 76(2), 026107 (2007).\nExamples: G=nx.complete_graph(5)\nprint(nx.clustering(G,0))\n# 1.0\nprint(nx.clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}",
    "Section ID: show_diedges\nDescription: [Returns a filter function that shows specific directed edges.]\nField List: Methods: []\nRubrics:",
    "Section ID: read_graph6\nDescription: [Read simple undirected graphs in graph6 format from path.]\nField List: Parameters:: path : file or string: File or filename to write.\nReturns:: G : Graph or list of Graphs: If the file contains multiple lines then a list of graphs is returned\nRaises:: NetworkXError: If the string is unable to be parsed in graph6 format\nMethods: []\nRubrics: References: [1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>\nExamples: You can read a graph6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\n_=f.write(b\">>graph6<<A_\\n\")\n_=f.seek(0)\nG=nx.read_graph6(f.name)\nlist(G.edges())\n# [(0, 1)]\nYou can also read a graph6 file by giving an open file-like object:\nimporttempfile\nwithtempfile.NamedTemporaryFile()asf:\n_=f.write(b\">>graph6<<A_\\n\")\n_=f.seek(0)\nG=nx.read_graph6(f)\nlist(G.edges())\n# [(0, 1)]",
    "Section ID: lattice_reference\nDescription: [Latticize the given graph by swapping edges.]\nField List: Parameters:: G : graph: An undirected graph.\nniter : integer (optional, default=1): An edge is rewired approximately niter times.\nD : numpy.array (optional, default=None): Distance to the diagonal matrix.\nconnectivity : boolean (optional, default=True): Ensure connectivity for the latticized graph when set to True.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : graph: The latticized graph.\nRaises:: NetworkXError: If there are fewer than 4 nodes or 2 edges inG\nMethods: []\nRubrics: Notes: The implementation is adapted from the algorithm by Sporns et al. [1] .\nwhich is inspired from the original work by Maslov and Sneppen(2002) [2] .\nReferences: [1]Sporns, Olaf, and Jonathan D. Zwi.\n“The small world of the cerebral cortex.”\nNeuroinformatics 2.2 (2004): 145-162.  [2]Maslov, Sergei, and Kim Sneppen.\n“Specificity and stability in topology of protein networks.”\nScience 296.5569 (2002): 910-913.",
    "Section ID: random_labeled_tree\nDescription: [Returns a labeled tree on n nodes chosen uniformly at random., Generating uniformly distributed random Prüfer sequences and\nconverting them into the corresponding trees is a straightforward\nmethod of generating uniformly distributed random labeled trees.\nThis function implements this method.]\nField List: Parameters:: n : int: The number of nodes, greater than zero.\nseed : random_state: Indicator of random number generation state.\nSeeRandomness\nReturns:: networkx.Graph: Anetworkx.Graphwith nodes in the set {0, …,n- 1}.\nRaises:: NetworkXPointlessConcept: Ifnis zero (because the null graph is not a tree).\nMethods: []\nRubrics:",
    "Section ID: trivial_graph\nDescription: [Return the Trivial graph with one node (with label 0) and no edges., ( Sourcecode , png )]\nField List: Methods: []\nRubrics:",
    "Section ID: general_random_intersection_graph\nDescription: [Returns a random intersection graph with independent probabilities\nfor connections between node and attribute sets.]\nField List: Parameters:: n : int: The number of nodes in the first bipartite set (nodes)\nm : int: The number of nodes in the second bipartite set (attributes)\np : list of floats of length m: Probabilities for connecting nodes to each attribute\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: References: [1]Nikoletseas, S. E., Raptopoulos, C., and Spirakis, P. G.\nThe existence and efficient construction of large independent sets\nin general random intersection graphs. In ICALP (2004), J. D´ıaz,\nJ. Karhum¨aki, A. Lepist¨o, and D. Sannella, Eds., vol. 3142\nof Lecture Notes in Computer Science, Springer, pp. 1029–1040.",
    "Section ID: wheel_graph\nDescription: [Return the wheel graph, The wheel graph consists of a hub node connected to a cycle of (n-1) nodes., ( Sourcecode , png )]\nField List: Parameters:: n : int or iterable: If an integer, node labels are 0 to n with center 0.\nIf an iterable of nodes, the center is the first.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nNode labels are the integers 0 to n - 1.:\nMethods: []\nRubrics:",
    "Section ID: is_directed_acyclic_graph\nDescription: [Returns True if the graph G is a directed acyclic graph (DAG) or\nFalse if not.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: bool: True ifGis a DAG, False otherwise\nMethods: []\nRubrics: Examples: Undirected graph:\nG=nx.Graph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected graph with cycle:\nG=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected acyclic graph:\nG=nx.DiGraph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# True",
    "Section ID: AdjacencyView\nDescription: [An AdjacencyView is a Read-only Map of Maps of Maps., It is a View into a dict-of-dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter levels are read-only.]\nField List: Methods: []\nRubrics:",
    "Section ID: graph_atlas\nDescription: [Returns graph number i from the Graph Atlas., For more information, see graph_atlas_g() .]\nField List: Parameters:: i : int: The index of the graph from the atlas to get. The graph at index\n0 is assumed to be the null graph.\nReturns:: list: A list ofGraphobjects, the one at indexicorresponding to the graphiin the Graph Atlas.\nMethods: []\nRubrics: Notes: The time required by this function increases linearly with the\nargument i , since it reads a large file sequentially in order to\ngenerate the graph [1] .\nReferences: [1]Ronald C. Read and Robin J. Wilson,An Atlas of Graphs.\nOxford University Press, 1998.",
    "Section ID: max_clique\nDescription: [Find the Maximum Clique, Finds the \\(O(|V|/(log|V|)^2)\\) apx of maximum clique/independent set\nin the worst case.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nReturns:: clique : set: The apx-maximum clique of the graph\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics: Notes: A clique in an undirected graph G = (V, E) is a subset of the vertex set CsubseteqV such that for every two vertices in C there exists an edge\nconnecting the two. This is equivalent to saying that the subgraph\ninduced by C is complete (in some cases, the term clique may also refer\nto the subgraph). A maximum clique is a clique of the largest possible size in a given graph.\nThe clique number omega(G) of a graph G is the number of\nvertices in a maximum clique in G. The intersection number of\nG is the smallest number of cliques that together cover all edges of G. https://en.wikipedia.org/wiki/Maximum_clique\nReferences: [1]Boppana, R., & Halldórsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180–196. Springer.\ndoi:10.1007/BF01994876\nExamples: G=nx.path_graph(10)\nnx.approximation.max_clique(G)\n# {8, 9}",
    "Section ID: strategy_connected_sequential_bfs\nDescription: [Returns an iterable over nodes in G in the order given by a\nbreadth-first traversal., The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence., G is a NetworkX graph. colors is ignored.]\nField List: Methods: []\nRubrics:",
    "Section ID: bidirectional_dijkstra\nDescription: [Dijkstra’s algorithm for shortest paths using bidirectional search.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node.\ntarget : node: Ending node.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\nReturns:: length, path : number and list: length is the distance from source to target.\npath is a list of nodes on a path from source to target.\nRaises:: NodeNotFound: If eithersourceortargetis not inG.\nNetworkXNoPath: If no path exists between source and target.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. In practice  bidirectional Dijkstra is much more than twice as fast as\nordinary Dijkstra. Ordinary Dijkstra expands nodes in a sphere-like manner from the\nsource. The radius of this sphere will eventually be the length\nof the shortest path. Bidirectional Dijkstra will expand nodes\nfrom both the source and the target, making two spheres of half\nthis radius. Volume of the first sphere is pi*r*r while the\nothers are 2*pi*r/2*r/2 , making up half the volume. This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).\nExamples: G=nx.path_graph(5)\nlength,path=nx.bidirectional_dijkstra(G,0,4)\nprint(length)\n# 4\nprint(path)\n# [0, 1, 2, 3, 4]",
    "Section ID: effective_size\nDescription: [Returns the effective size of all nodes in the graph G ., The effective size of a node’s ego network is based on the concept\nof redundancy. A person’s ego network has redundancy to the extent\nthat her contacts are connected to each other as well. The\nnonredundant part of a person’s relationships is the effective\nsize of her ego network [1] .  Formally, the effective size of a\nnode \\(u\\) , denoted \\(e(u)\\) , is defined by, where \\(N(u)\\) is the set of neighbors of \\(u\\) and \\(p_{uw}\\) is the\nnormalized mutual weight of the (directed or undirected) edges\njoining \\(u\\) and \\(v\\) , for each vertex \\(u\\) and \\(v\\)  [1] . And \\(m_{vw}\\) is the mutual weight of \\(v\\) and \\(w\\) divided by \\(v\\) highest mutual\nweight with any of its neighbors. The mutual weight of \\(u\\) and \\(v\\) is the sum of the weights of edges joining them (edge weights are\nassumed to be one if the graph is unweighted)., For the case of unweighted and undirected graphs, Borgatti proposed\na simplified formula to compute effective size [2], where t is the number of ties in the ego network (not including\nties to ego) and n is the number of nodes (excluding ego).]\nField List: Parameters:: G : NetworkX graph: The graph containingv. Directed graphs are treated like\nundirected graphs when computing neighbors ofv.\nnodes : container, optional: Container of nodes in the graphGto compute the effective size.\nIf None, the effective size of every node is computed.\nweight : None or string, optional: If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nReturns:: dict: Dictionary with nodes as keys and the effective size of the node as values.\nMethods: []\nRubrics: Notes: Burt also defined the related concept of efficiency of a node’s ego\nnetwork, which is its effective size divided by the degree of that\nnode [1] . So you can easily compute efficiency:\nReferences: [1](1,2,3)Burt, Ronald S.Structural Holes: The Social Structure of Competition.Cambridge: Harvard University Press, 1995.  [2]Borgatti, S.\n“Structural Holes: Unpacking Burt’s Redundancy Measures”\nCONNECTIONS 20(1):35-38.http://www.analytictech.com/connections/v20(1)/holes.htm",
    "Section ID: read_gexf\nDescription: [Read graph in GEXF format from path., “GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics” [1] .]\nField List: Parameters:: path : file or string: File or file name to read.\nFile names ending in .gz or .bz2 will be decompressed.\nnode_type: Python type (default: None): Convert node ids to this type if not None.\nrelabel : bool (default: False): If True relabel the nodes to use the GEXF node “label” attribute\ninstead of the node “id” attribute as the NetworkX node label.\nversion : string (default: 1.2draft): \nVersion of GEFX File Format (see http://gexf.net/schema.html): Supported values: “1.1draft”, “1.2draft”\nReturns:: graph: NetworkX graph: If no parallel edges are found a Graph or DiGraph is returned.\nOtherwise a MultiGraph or MultiDiGraph is returned.\nMethods: []\nRubrics: Notes: This implementation does not support mixed graphs (directed and undirected\nedges together).\nReferences: [1]GEXF File Format,http://gexf.net/",
    "Section ID: isolates\nDescription: [Iterator over isolates in the graph., An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: iterator: An iterator over the isolates ofG.\nMethods: []\nRubrics: Examples: To get a list of all isolates of a graph, use thelistconstructor:\nG=nx.Graph()\nG.add_edge(1,2)\nG.add_node(3)\nlist(nx.isolates(G))\n# [3]\nTo remove all isolates in the graph, first create a list of the\nisolates, then useGraph.remove_nodes_from():\nG.remove_nodes_from(list(nx.isolates(G)))\nlist(G)\n# [1, 2]\nFor digraphs, isolates have zero in-degree and zero out_degre:\nG=nx.DiGraph([(0,1),(1,2)])\nG.add_node(3)\nlist(nx.isolates(G))\n# [3]",
    "Section ID: degree\nDescription: [Returns a degree view of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of all nodes., This function wraps the G.degree property.]\nField List: Methods: []\nRubrics:",
    "Section ID: build_residual_network\nDescription: [Build a residual network and initialize a zero flow., The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G ., For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] ., The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.]\nField List: Methods: []\nRubrics:",
    "Section ID: spanner\nDescription: [Returns a spanner of the given graph with the given stretch., A spanner of a graph G = (V, E) with stretch t is a subgraph\nH = (V, E_S) such that E_S is a subset of E and the distance between\nany pair of nodes in H is at most t times the distance between the\nnodes in G.]\nField List: Parameters:: G : NetworkX graph: An undirected simple graph.\nstretch : float: The stretch of the spanner.\nweight : object: The edge attribute to use as distance.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: NetworkX graph: A spanner of the given graph with the given stretch.\nRaises:: ValueError: If a stretch less than 1 is given.\nMethods: []\nRubrics: Notes: This function implements the spanner algorithm by Baswana and Sen,\nsee [1]. This algorithm is a randomized las vegas algorithm: The expected\nrunning time is O(km) where k = (stretch + 1) // 2 and m is the\nnumber of edges in G. The returned graph is always a spanner of the\ngiven graph with the specified stretch. For weighted graphs the\nnumber of edges in the spanner is O(k * n^(1 + 1 / k)) where k is\ndefined as above and n is the number of nodes in G. For unweighted\ngraphs the number of edges is O(n^(1 + 1 / k) + kn).\nReferences: [1] S. Baswana, S. Sen. A Simple and Linear Time Randomized\nAlgorithm for Computing Sparse Spanners in Weighted Graphs.\nRandom Struct. Algorithms 30(4): 532-563 (2007).",
    "Section ID: open_file\nDescription: [Decorator to ensure clean opening and closing of files.]\nField List: Parameters:: path_arg : string or int: Name or index of the argument that is a path.\nmode : str: String for opening mode.\nReturns:: _open_file : function: Function which cleanly executes the io.\nMethods: []\nRubrics: Notes: Note that this decorator solves the problem when a path argument is\nspecified as a string, but it does not handle the situation when the\nfunction wants to accept a default of None (and then handle it). Here is an example of how to handle this case:\nExamples: Decorate functions like this:\n@open_file(0,\"r\")defread_function(pathname):pass@open_file(1,\"w\")defwrite_function(G,pathname):pass@open_file(1,\"w\")defwrite_function(G,pathname=\"graph.dot\"):pass@open_file(\"pathname\",\"w\")defwrite_function(G,pathname=\"graph.dot\"):pass@open_file(\"path\",\"w+\")defanother_function(arg,**kwargs):path=kwargs[\"path\"]pass",
    "Section ID: draw_circular\nDescription: [Draw the graph G with a circular layout., This is a convenience function equivalent to:]\nField List: Parameters:: G : graph: A networkx graph\nkwargs : optional keywords: Seedraw_networkxfor a description of optional keywords.\nMethods: []\nRubrics: Notes: The layout is computed each time this function is called. For\nrepeated drawing it is much more efficient to call circular_layout directly and reuse the result:\nExamples: G=nx.path_graph(5)\nnx.draw_circular(G)",
    "Section ID: betweenness_centrality_subset\nDescription: [Compute betweenness centrality for a subset of nodes., where \\(S\\) is the set of sources, \\(T\\) is the set of targets, \\(\\sigma(s, t)\\) is the number of shortest \\((s, t)\\) -paths,\nand \\(\\sigma(s, t|v)\\) is the number of those paths\npassing through some  node \\(v\\) other than \\(s, t\\) .\nIf \\(s = t\\) , \\(\\sigma(s, t) = 1\\) ,\nand if \\(v \\in {s, t}\\) , \\(\\sigma(s, t|v) = 0\\)  [2] .]\nField List: Parameters:: G : graph: A NetworkX graph.\nsources: list of nodes: Nodes to use as sources for shortest paths in betweenness\ntargets: list of nodes: Nodes to use as targets for shortest paths in betweenness\nnormalized : bool, optional: If True the betweenness values are normalized by\\(2/((n-1)(n-2))\\)for graphs, and\\(1/((n-1)(n-2))\\)for directed graphs where\\(n\\)is the number of nodes in G.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances.\nReturns:: nodes : dictionary: Dictionary of nodes with betweenness centrality as the value.\nMethods: []\nRubrics: Notes: The basic algorithm is from [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The normalization might seem a little strange but it is\ndesigned to make betweenness_centrality(G) be the same as\nbetweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()). The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nare easy to count. Undirected paths are tricky: should a path\nfrom “u” to “v” count as 1 undirected path or as 2 directed paths? For betweenness_centrality we report the number of undirected\npaths when G is undirected. For betweenness_centrality_subset the reporting is different.\nIf the source and target subsets are the same, then we want\nto count undirected paths. But if the source and target subsets\ndiffer – for example, if sources is {0} and targets is {1},\nthen we are only counting the paths in one direction. They are\nundirected paths but we are counting them in a directed way.\nTo count them as undirected paths, each should count as half a path.\nReferences: [1]Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001",
    "Section ID: gnp_random_graph\nDescription: [Returns a \\(G_{n,p}\\) random graph, also known as an Erdős-Rényi graph\nor a binomial graph., The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) .]\nField List: Parameters:: n : int: The number of nodes.\np : float: Probability for edge creation.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : bool, optional (default=False): If True, this function returns a directed graph.\nMethods: []\nRubrics: Notes: This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .\nReferences: [1]Erdős and A. Rényi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).",
    "Section ID: empty_graph\nDescription: [Returns the empty graph with n nodes and zero edges., ( Sourcecode , png )]\nField List: Parameters:: n : int or iterable container of nodes (default = 0): If n is an integer, nodes are fromrange(n).\nIf n is a container of nodes, those nodes appear in the graph.\ncreate_using : Graph Instance, Constructor or None: Indicator of type of graph to return.\nIf a Graph-type instance, then clear and use it.\nIf None, use thedefaultconstructor.\nIf a constructor, call it to create an empty graph.\ndefault : Graph constructor (optional, default = nx.Graph): The constructor to use if create_using is None.\nIf None, then nx.Graph is used.\nThis is used when passing an unknowncreate_usingvalue\nthrough your home-grown function toempty_graphand\nyou want a default constructor other than nx.Graph.\nMethods: []\nRubrics: Notes: The variable create_using should be a Graph Constructor or a\n“graph”-like object. Constructors, e.g. nx.Graph or nx.MultiGraph will be used to create the returned graph. “graph”-like objects\nwill be cleared (nodes and edges will be removed) and refitted as\nan empty “graph” with nodes specified in n. This capability\nis useful for specifying the class-nature of the resulting empty\n“graph” (i.e. Graph, DiGraph, MyWeirdGraphClass, etc.). The variable create_using has three main uses:\nFirstly, the variable create_using can be used to create an\nempty digraph, multigraph, etc.  For example,\nExamples: G=nx.empty_graph(10)\nG.number_of_nodes()\n# 10\nG.number_of_edges()\n# 0\nG=nx.empty_graph(\"ABC\")\nG.number_of_nodes()\n# 3\nsorted(G)\n# ['A', 'B', 'C']",
    "Section ID: equivalence_classes\nDescription: [Returns equivalence classes of relation when applied to iterable ., The equivalence classes, or blocks, consist of objects from iterable which are all equivalent. They are defined to be equivalent if the relation function returns True when passed any two objects from that\nclass, and False otherwise. To define an equivalence relation the\nfunction must be reflexive, symmetric and transitive.]\nField List: Parameters:: iterable : list, tuple, or set: An iterable of elements/nodes.\nrelation : function: A Boolean-valued function that implements an equivalence relation\n(reflexive, symmetric, transitive binary relation) on the elements\nofiterable- it must take two elements and returnTrueif\nthey are related, orFalseif not.\nReturns:: set of frozensets: A set of frozensets representing the partition induced by the equivalence\nrelation functionrelationon the elements ofiterable. Each\nmember set in the return set represents an equivalence class, or\nblock, of the partition.Duplicate elements will be ignored so it makes the most sense foriterableto be aset.\nMethods: []\nRubrics: Notes: This function does not check that relation represents an equivalence\nrelation. You can check that your equivalence classes provide a partition\nusing is_partition .\nExamples: LetXbe the set of integers from0to9, and consider an equivalence\nrelationRonXof congruence modulo3: this means that two integersxandyinXare equivalent underRif they leave the same\nremainder when divided by3, i.e.(x-y)mod3=0.\nThe equivalence classes of this relation are{0,3,6,9},{1,4,7},{2,5,8}:0,3,6,9are all divisible by3and leave zero\nremainder;1,4,7leave remainder1; while2,5and8leave\nremainder2. We can see this by callingequivalence_classeswithXand a function implementation ofR.\nX=set(range(10))\ndefmod3(x,y):\nreturn(x-y)%3==0\nequivalence_classes(X,mod3)\n# {frozenset({1, 4, 7}), frozenset({8, 2, 5}), frozenset({0, 9, 3, 6})}",
    "Section ID: set_edge_attributes\nDescription: [Sets edge attributes from a given value or dictionary of values.]\nField List: Parameters:: G : NetworkX Graph: \nvalues : scalar value, dict-like: What the edge attribute should be set to.  Ifvaluesis\nnot a dictionary, then it is treated as a single attribute value\nthat is then applied to every edge inG.  This means that if\nyou provide a mutable object, like a list, updates to that object\nwill be reflected in the edge attribute for each edge.  The attribute\nname will bename.Ifvaluesis a dict or a dict of dict, it should be keyed\nby edge tuple to either an attribute value or a dict of attribute\nkey/value pairs used to update the edge’s attributes.\nFor multigraphs, the edge tuples must be of the form(u,v,key),\nwhereuandvare nodes andkeyis the edge key.\nFor non-multigraphs, the keys must be tuples of the form(u,v).\nname : string (optional, default=None): Name of the edge attribute to set if values is a scalar.\nMethods: []\nRubrics: Examples: After computing some property of the edges of a graph, you may want\nto assign a edge attribute to store the value of that property for\neach edge:\nG=nx.path_graph(3)\nbb=nx.edge_betweenness_centrality(G,normalized=False)\nnx.set_edge_attributes(G,bb,\"betweenness\")\nG.edges[1,2][\"betweenness\"]\n# 2.0\nIf you provide a list as the second argument, updates to the list\nwill be reflected in the edge attribute for each edge:\nlabels=[]\nnx.set_edge_attributes(G,labels,\"labels\")\nlabels.append(\"foo\")\nG.edges[0,1][\"labels\"]\n# ['foo']\nG.edges[1,2][\"labels\"]\n# ['foo']\nIf you provide a dictionary of dictionaries as the second argument,\nthe entire dictionary will be used to update edge attributes:\nG=nx.path_graph(3)\nattrs={(0,1):{\"attr1\":20,\"attr2\":\"nothing\"},(1,2):{\"attr2\":3}}\nnx.set_edge_attributes(G,attrs)\nG[0][1][\"attr1\"]\n# 20\nG[0][1][\"attr2\"]\n# 'nothing'\nG[1][2][\"attr2\"]\n# 3\nThe attributes of one Graph can be used to set those of another.\nH=nx.path_graph(3)\nnx.set_edge_attributes(H,G.edges)\nNote that if the dict contains edges that are not inG, they are\nsilently ignored:\nG=nx.Graph([(0,1)])\nnx.set_edge_attributes(G,{(1,2):{\"weight\":2.0}})\n(1,2)inG.edges()\n# False\nFor multigraphs, thevaluesdict is expected to be keyed by 3-tuples\nincluding the edge key:\nMG=nx.MultiGraph()\nedges=[(0,1),(0,1)]\nMG.add_edges_from(edges)# Returns list of edge keys\n# [0, 1]\nattributes={(0,1,0):{\"cost\":21},(0,1,1):{\"cost\":7}}\nnx.set_edge_attributes(MG,attributes)\nMG[0][1][0][\"cost\"]\n# 21\nMG[0][1][1][\"cost\"]\n# 7\nIf MultiGraph attributes are desired for a Graph, you must convert the 3-tuple\nmultiedge to a 2-tuple edge and the last multiedge’s attribute value will\noverwrite the previous values. Continuing from the previous case we get:\nH=nx.path_graph([0,1,2])\nnx.set_edge_attributes(H,{(u,v):edforu,v,edinMG.edges.data()})\nnx.get_edge_attributes(H,\"cost\")\n# {(0, 1): 7}",
    "Section ID: all_pairs_lowest_common_ancestor\nDescription: [Return the lowest common ancestor of all pairs or the provided pairs]\nField List: Parameters:: G : NetworkX directed graph: \npairs : iterable of pairs of nodes, optional (default: all pairs): The pairs of nodes of interest.\nIf None, will find the LCA of all pairs of nodes.\nYields:: ((node1, node2), lca) : 2-tuple: Where lca is least common ancestor of node1 and node2.\nNote that for the default case, the order of the node pair is not considered,\ne.g. you will not get both(a,b)and(b,a)\nRaises:: NetworkXPointlessConcept: IfGis null.\nNetworkXError: IfGis not a DAG.\nMethods: []\nRubrics: Notes: Only defined on non-null directed acyclic graphs.\nExamples: The default behavior is to yield the lowest common ancestor for all\npossible combinations of nodes inG, including self-pairings:\nG=nx.DiGraph([(0,1),(0,3),(1,2)])\ndict(nx.all_pairs_lowest_common_ancestor(G))\n# {(0, 0): 0, (0, 1): 0, (0, 3): 0, (0, 2): 0, (1, 1): 1, (1, 3): 0, (1, 2): 1, (3, 3): 3, (3, 2): 0, (2, 2): 2}\nThe pairs argument can be used to limit the output to only the\nspecified node pairings:\ndict(nx.all_pairs_lowest_common_ancestor(G,pairs=[(1,2),(2,3)]))\n# {(1, 2): 1, (2, 3): 0}",
    "Section ID: attribute_mixing_matrix\nDescription: [Returns mixing matrix for attribute.]\nField List: Parameters:: G : graph: NetworkX graph object.\nattribute : string: Node attribute key.\nnodes: list or iterable (optional): Use only nodes in container to build the matrix. The default is\nall nodes.\nmapping : dictionary, optional: Mapping from node attribute to integer index in matrix.\nIf not specified, an arbitrary ordering will be used.\nnormalized : bool (default=True): Return counts if False or probabilities if True.\nReturns:: m: numpy array: Counts or joint probability of occurrence of attribute pairs.\nMethods: []\nRubrics: Notes: If each node has a unique attribute value, the unnormalized mixing matrix\nwill be equal to the adjacency matrix. To get a denser mixing matrix,\nthe rounding can be performed to form groups of nodes with equal values.\nFor example, the exact height of persons in cm (180.79155222, 163.9080892,\n163.30095355, 167.99016217, 168.21590163, …) can be rounded to (180, 163,\n163, 168, 168, …). Definitions of attribute mixing matrix vary on whether the matrix\nshould include rows for attribute values that don’t arise. Here we\ndo not include such empty-rows. But you can force them to appear\nby inputting a mapping that includes those values.\nExamples: G=nx.path_graph(3)\ngender={0:\"male\",1:\"female\",2:\"female\"}\nnx.set_node_attributes(G,gender,\"gender\")\nmapping={\"male\":0,\"female\":1}\nmix_mat=nx.attribute_mixing_matrix(G,\"gender\",mapping=mapping)\nmix_mat\n# array([[0.  , 0.25],\n#        [0.25, 0.5 ]])",
    "Section ID: join\nDescription: [A deprecated name for join_trees, Returns a new rooted tree with a root node joined with the roots\nof each of the given rooted trees.]\nField List: Methods: []\nRubrics:",
    "Section ID: branching_weight\nDescription: [Returns the total weight of a branching., You must access this function through the networkx.algorithms.tree module.]\nField List: Parameters:: G : DiGraph: The directed graph.\nattr : str: The attribute to use as weights. If None, then each edge will be\ntreated equally with a weight of 1.\ndefault : float: Whenattris not None, then if an edge does not have that attribute,defaultspecifies what value it should take.\nReturns:: weight: int or float: The total weight of the branching.\nMethods: []\nRubrics: Examples: G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,2),(1,2,4),(2,3,3),(3,4,2)])\nnx.tree.branching_weight(G)\n# 11",
    "Section ID: k_crust\nDescription: [Returns the k-crust of G., The k-crust is the graph G with the edges of the k-core removed\nand isolated nodes found after the removal of edges are also removed.]\nField List: Parameters:: G : NetworkX graph: A graph or directed graph.\nk : int, optional: The order of the shell. If not specified return the main crust.\ncore_number : dictionary, optional: Precomputed core numbers for the graph G.\nReturns:: G : NetworkX graph: The k-crust subgraph\nRaises:: NetworkXNotImplemented: The k-crust is not implemented for multigraphs or graphs with self loops.\nMethods: []\nRubrics: Notes: This definition of k-crust is different than the definition in [1] .\nThe k-crust in [1] is equivalent to the k+1 crust of this algorithm. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.\nReferences: [1](1,2)A model of Internet topology using k-shell decomposition\nShai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\nand Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154http://www.pnas.org/content/104/27/11150.full\nExamples: degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_crust(H,k=1).nodes\n# NodeView((0, 4, 6))",
    "Section ID: Edmonds\nDescription: [Edmonds algorithm [1] for finding optimal branchings and spanning\narborescences., This algorithm can find both minimum and maximum spanning arborescences and\nbranchings., Notes, While this algorithm can find a minimum branching, since it isn’t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs., References]\nField List: Methods: []\nRubrics: Notes: While this algorithm can find a minimum branching, since it isn’t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.\nReferences: [1]J. Edmonds, Optimum Branchings, Journal of Research of the National\nBureau of Standards, 1967, Vol. 71B, p.233-240,https://archive.org/details/jresv71Bn4p233",
    "Section ID: tree_data\nDescription: [Returns data in tree format that is suitable for JSON serialization\nand use in JavaScript documents.]\nField List: Parameters:: G : NetworkX graph: G must be an oriented tree\nroot : node: The root of the tree\nident : string: Attribute name for storing NetworkX-internal graph data.identmust\nhave a different value thanchildren. The default is ‘id’.\nchildren : string: Attribute name for storing NetworkX-internal graph data.childrenmust have a different value thanident. The default is ‘children’.\nReturns:: data : dict: A dictionary with node-link formatted data.\nRaises:: NetworkXError: Ifchildrenandidentattributes are identical.\nMethods: []\nRubrics: Notes: Node attributes are stored in this format but keys\nfor attributes must be strings if you want to serialize with JSON. Graph and edge attributes are not stored.\nExamples: fromnetworkx.readwriteimportjson_graph\nG=nx.DiGraph([(1,2)])\ndata=json_graph.tree_data(G,root=1)\nTo serialize with json\nimportjson\ns=json.dumps(data)",
    "Section ID: all_topological_sorts\nDescription: [Returns a generator of _all_ topological sorts of the directed graph G., A topological sort is a nonunique permutation of the nodes such that an\nedge from u to v implies that u appears before v in the topological sort\norder.]\nField List: Parameters:: G : NetworkX DiGraph: A directed graph\nYields:: topological_sort_order : list: a list of nodes inG, representing one of the topological sort orders\nRaises:: NetworkXNotImplemented: IfGis not directed\nNetworkXUnfeasible: IfGis not acyclic\nMethods: []\nRubrics: Notes: Implements an iterative version of the algorithm given in [1].\nReferences: [1]Knuth, Donald E., Szwarcfiter, Jayme L. (1974).\n“A Structured Program to Generate All Topological Sorting Arrangements”\nInformation Processing Letters, Volume 2, Issue 6, 1974, Pages 153-157,\nISSN 0020-0190,https://doi.org/10.1016/0020-0190(74)90001-5.\nElsevier (North-Holland), Amsterdam\nExamples: To enumerate all topological sorts of directed graph:\nDG=nx.DiGraph([(1,2),(2,3),(2,4)])\nlist(nx.all_topological_sorts(DG))\n# [[1, 2, 4, 3], [1, 2, 3, 4]]",
    "Section ID: communicability_betweenness_centrality\nDescription: [Returns subgraph communicability for all pairs of nodes in G., Communicability betweenness measure makes use of the number of walks\nconnecting every pair of nodes as the basis of a betweenness centrality\nmeasure.]\nField List: Parameters:: G: graph:\nReturns:: nodes : dictionary: Dictionary of nodes with communicability betweenness as the value.\nRaises:: NetworkXError: If the graph is not undirected and simple.\nMethods: []\nRubrics: Notes: Let G=(V,E) be a simple undirected graph with n nodes and m edges,\nand A denote the adjacency matrix of G . Let G(r)=(V,E(r)) be the graph resulting from\nremoving all edges connected to node r but not the node itself. The adjacency matrix for G(r) is A+E(r) ,  where E(r) has nonzeros\nonly in row and column r . The subraph betweenness of a node r is [1]\nReferences: [1]Ernesto Estrada, Desmond J. Higham, Naomichi Hatano,\n“Communicability Betweenness in Complex Networks”\nPhysica A 388 (2009) 764-774.https://arxiv.org/abs/0905.4102\nExamples: G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\ncbc=nx.communicability_betweenness_centrality(G)\nprint([f\"{node} {cbc[node]:0.2f}\"fornodeinsorted(cbc)])\n# ['0 0.03', '1 0.45', '2 0.51', '3 0.45', '4 0.40', '5 0.19', '6 0.03']",
    "Section ID: current_flow_closeness_centrality\nDescription: [Compute current-flow closeness centrality for nodes., Current-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality.]\nField List: Parameters:: G : graph: A NetworkX graph.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight reflects the capacity or the strength of the\nedge.\ndtype: data type (default=float): Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.\nsolver: string (default=’lu’): Type of linear solver to use for computing the flow matrix.\nOptions are “full” (uses most memory), “lu” (recommended), and\n“cg” (uses least memory).\nReturns:: nodes : dictionary: Dictionary of nodes with current flow closeness centrality as the value.\nMethods: []\nRubrics: Notes: The algorithm is from Brandes [1] . See also [2] for the original definition of information centrality.\nReferences: [1]Ulrik Brandes and Daniel Fleischer,\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS ‘05).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]Karen Stephenson and Marvin Zelen:\nRethinking centrality: Methods and examples.\nSocial Networks 11(1):1-37, 1989.https://doi.org/10.1016/0378-8733(89)90016-6",
    "Section ID: binomial_graph\nDescription: [Returns a \\(G_{n,p}\\) random graph, also known as an Erdős-Rényi graph\nor a binomial graph., The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) .]\nField List: Parameters:: n : int: The number of nodes.\np : float: Probability for edge creation.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : bool, optional (default=False): If True, this function returns a directed graph.\nMethods: []\nRubrics: Notes: This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .\nReferences: [1]Erdős and A. Rényi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).",
    "Section ID: subgraph\nDescription: [Returns the subgraph induced on nodes in nbunch.]\nField List: Parameters:: G : graph: A NetworkX graph\nnbunch : list, iterable: A container of nodes that will be iterated through once (thus\nit should be an iterator or be iterable).  Each element of the\ncontainer should be a valid node type: any hashable type except\nNone.  If nbunch is None, return all edges data in the graph.\nNodes in nbunch that are not in the graph will be (quietly)\nignored.\nMethods: []\nRubrics: Notes: subgraph(G) calls G.subgraph()",
    "Section ID: is_d_separator\nDescription: [Return whether node sets x and y are d-separated by z .]\nField List: Parameters:: G : nx.DiGraph: A NetworkX DAG.\nx : node or set of nodes: First node or set of nodes inG.\ny : node or set of nodes: Second node or set of nodes inG.\nz : node or set of nodes: Potential separator (set of conditioning nodes inG). Can be empty set.\nReturns:: b : bool: A boolean that is true ifxis d-separated fromygivenzinG.\nRaises:: NetworkXError: Thed-separationtest is commonly used on disjoint sets of\nnodes in acyclic directed graphs.  Accordingly, the algorithm\nraises aNetworkXErrorif the node sets are not\ndisjoint or if the input graph is not a DAG.\nNodeNotFound: If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised\nMethods: []\nRubrics: Notes: A d-separating set in a DAG is a set of nodes that\nblocks all paths between the two sets. Nodes in z block a path if they are part of the path and are not a collider,\nor a descendant of a collider. Also colliders that are not in z block a path. A collider structure along a path\nis ...->c<-... where c is the collider node. https://en.wikipedia.org/wiki/Bayesian_network#d-separation",
    "Section ID: k_components\nDescription: [Returns the k-component structure of a graph G., A k -component is a maximal subgraph of a graph G that has, at least,\nnode connectivity k : we need to remove at least k nodes to break it\ninto more components. k -components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth.]\nField List: Parameters:: G : NetworkX graph: \nflow_func : function: Function to perform the underlying flow computations. Default valueedmonds_karp(). This function performs better in sparse graphs with\nright tailed degree distributions.shortest_augmenting_path()will\nperform better in denser graphs.\nReturns:: k_components : dict: Dictionary with all connectivity levelskin the input Graph as keys\nand a list of sets of nodes that form a k-component of levelkas\nvalues.\nRaises:: NetworkXNotImplemented: If the input graph is directed.\nMethods: []\nRubrics: Notes: Moody and White [1] (appendix A) provide an algorithm for identifying\nk-components in a graph, which is based on Kanevsky’s algorithm [2] for finding all minimum-size node cut-sets of a graph (implemented in all_node_cuts() function):\nReferences: [1]Moody, J. and D. White (2003). Social cohesion and embeddedness:\nA hierarchical conception of social groups.\nAmerican Sociological Review 68(1), 103–28.http://www2.asanet.org/journals/ASRFeb03MoodyWhite.pdf  [2]Kanevsky, A. (1993). Finding all minimum-size separating vertex\nsets in a graph. Networks 23(6), 533–541.http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract  [3]Torrents, J. and F. Ferraro (2015). Structural Cohesion:\nVisualization and Heuristics for Fast Computation.https://arxiv.org/pdf/1503.04476v1\nExamples: # Petersen graph has 10 nodes and it is triconnected, thus all\n# nodes are in a single component on all three connectivity levels\nG=nx.petersen_graph()\nk_components=nx.k_components(G)",
    "Section ID: number_attracting_components\nDescription: [Returns the number of attracting components in G .]\nField List: Parameters:: G : DiGraph, MultiDiGraph: The graph to be analyzed.\nReturns:: n : int: The number of attracting components in G.\nRaises:: NetworkXNotImplemented: If the input graph is undirected.\nMethods: []\nRubrics:",
    "Section ID: duplication_divergence_graph\nDescription: [Returns an undirected graph using the duplication-divergence model., A graph of n nodes is created by duplicating the initial nodes\nand retaining edges incident to the original nodes with a retention\nprobability p .]\nField List: Parameters:: n : int: The desired number of nodes in the graph.\np : float: The probability for retaining the edge of the replicated node.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : Graph:\nRaises:: NetworkXError: Ifpis not a valid probability.\nIfnis less than 2.\nMethods: []\nRubrics: Notes: This algorithm appears in [1]. This implementation disallows the possibility of generating\ndisconnected graphs.\nReferences: [1]I. Ispolatov, P. L. Krapivsky, A. Yuryev,\n“Duplication-divergence model of protein interaction network”,\nPhys. Rev. E, 71, 061911, 2005.",
    "Section ID: betweenness_centrality\nDescription: [Compute the shortest-path betweenness centrality for nodes., Betweenness centrality of a node \\(v\\) is the sum of the\nfraction of all-pairs shortest paths that pass through \\(v\\), where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths,  and \\(\\sigma(s, t|v)\\) is the number of\nthose paths  passing through some  node \\(v\\) other than \\(s, t\\) .\nIf \\(s = t\\) , \\(\\sigma(s, t) = 1\\) , and if \\(v \\in {s, t}\\) , \\(\\sigma(s, t|v) = 0\\)  [2] .]\nField List: Parameters:: G : graph: A NetworkX graph.\nk : int, optional (default=None): If k is not None use k node samples to estimate betweenness.\nThe value of k <= n where n is the number of nodes in the graph.\nHigher values give better approximation.\nnormalized : bool, optional: If True the betweenness values are normalized by2/((n-1)(n-2))for graphs, and1/((n-1)(n-2))for directed graphs wherenis the number of nodes in G.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances.\nendpoints : bool, optional: If True include the endpoints in the shortest path counts.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nNote that this is only used if k is not None.\nReturns:: nodes : dictionary: Dictionary of nodes with betweenness centrality as the value.\nMethods: []\nRubrics: Notes: The algorithm is from Ulrik Brandes [1] .\nSee [4] for the original first published version and [2] for details on\nalgorithms for variations and related metrics. For approximate betweenness calculations set k=#samples to use\nk nodes (“pivots”) to estimate the betweenness values. For an estimate\nof the number of pivots needed see [3] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nare easy to count. Undirected paths are tricky: should a path\nfrom “u” to “v” count as 1 undirected path or as 2 directed paths? For betweenness_centrality we report the number of undirected\npaths when G is undirected. For betweenness_centrality_subset the reporting is different.\nIf the source and target subsets are the same, then we want\nto count undirected paths. But if the source and target subsets\ndiffer – for example, if sources is {0} and targets is {1},\nthen we are only counting the paths in one direction. They are\nundirected paths but we are counting them in a directed way.\nTo count them as undirected paths, each should count as half a path. This algorithm is not guaranteed to be correct if edge weights\nare floating point numbers. As a workaround you can use integer\nnumbers by multiplying the relevant edge attributes by a convenient\nconstant factor (eg 100) and converting to integers.\nReferences: [1]Ulrik Brandes:\nA Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2](1,2)Ulrik Brandes:\nOn Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001  [3]Ulrik Brandes and Christian Pich:\nCentrality Estimation in Large Networks.\nInternational Journal of Bifurcation and Chaos 17(7):2303-2318, 2007.https://dx.doi.org/10.1142/S0218127407018403  [4]Linton C. Freeman:\nA set of measures of centrality based on betweenness.\nSociometry 40: 35–41, 1977https://doi.org/10.2307/3033543",
    "Section ID: generate_random_paths\nDescription: [Randomly generate sample_size paths of length path_length .]\nField List: Parameters:: G : NetworkX graph: A NetworkX graph\nsample_size : integer: The number of paths to generate. This isRin[1].\npath_length : integer (default = 5): The maximum size of the path to randomly generate.\nThis isTin[1]. According to the paper,T>=5is\nrecommended.\nindex_map : dictionary, optional: If provided, this will be populated with the inverted\nindex of nodes mapped to the set of generated random path\nindices withinpaths.\nweight : string or None, optional (default=”weight”): The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: paths : generator of lists: Generator ofsample_sizepaths each with lengthpath_length.\nMethods: []\nRubrics: References: [1](1,2)Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.\nPanther: Fast top-k similarity search on large networks.\nIn Proceedings of the ACM SIGKDD International Conference\non Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445–1454).\nAssociation for Computing Machinery.https://doi.org/10.1145/2783258.2783267.\nExamples: Note that the return value is the list of paths:\nG=nx.star_graph(3)\nrandom_path=nx.generate_random_paths(G,2)\nBy passing a dictionary intoindex_map, it will build an\ninverted index mapping of nodes to the paths in which that node is present:\nG=nx.star_graph(3)\nindex_map={}\nrandom_path=nx.generate_random_paths(G,3,index_map=index_map)\npaths_containing_node_0=[\nrandom_path[path_idx]forpath_idxinindex_map.get(0,[])\n]",
    "Section ID: lexicographical_topological_sort\nDescription: [Generate the nodes in the unique lexicographical topological sort order., Generates a unique ordering of nodes by first sorting topologically (for which there are often\nmultiple valid orderings) and then additionally by sorting lexicographically., A topological sort arranges the nodes of a directed graph so that the\nupstream node of each directed edge precedes the downstream node.\nIt is always possible to find a solution for directed graphs that have no cycles.\nThere may be more than one valid solution., Lexicographical sorting is just sorting alphabetically. It is used here to break ties in the\ntopological sort and to determine a single, unique ordering.  This can be useful in comparing\nsort results., The lexicographical order can be customized by providing a function to the key= parameter.\nThe definition of the key function is the same as used in python’s built-in sort() .\nThe function takes a single argument and returns a key to use for sorting purposes., Lexicographical sorting can fail if the node names are un-sortable. See the example below.\nThe solution is to provide a function to the key= argument that returns sortable keys.]\nField List: Parameters:: G : NetworkX digraph: A directed acyclic graph (DAG)\nkey : function, optional: A function of one argument that converts a node name to a comparison key.\nIt defines and resolves ambiguities in the sort order.  Defaults to the identity function.\nYields:: nodes: Yields the nodes of G in lexicographical topological sort order.\nRaises:: NetworkXError: Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.\nNetworkXUnfeasible: IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed\nRuntimeError: IfGis changed while the returned iterator is being processed.\nTypeError: Results from un-sortable node names.\nConsider usingkey=parameter to resolve ambiguities in the sort order.\nMethods: []\nRubrics: Notes: This algorithm is based on a description and proof in\n“Introduction to Algorithms: A Creative Approach” [1] .\nReferences: [1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.\nExamples: DG=nx.DiGraph([(2,1),(2,5),(1,3),(1,4),(5,4)])\nlist(nx.lexicographical_topological_sort(DG))\n# [2, 1, 3, 5, 4]\nlist(nx.lexicographical_topological_sort(DG,key=lambdax:-x))\n# [2, 5, 1, 4, 3]\nThe sort will fail for any graph with integer and string nodes. Comparison of integer to strings\nis not defined in python.  Is 3 greater or less than ‘red’?\nDG=nx.DiGraph([(1,\"red\"),(3,\"red\"),(1,\"green\"),(2,\"blue\")])\nlist(nx.lexicographical_topological_sort(DG))Traceback (most recent call last):...TypeError'<' not supported between instances of 'str' and 'int'...\nIncomparable nodes can be resolved using akeyfunction. This example function\nallows comparison of integers and strings by returning a tuple where the first\nelement is True forstr, False otherwise. The second element is the node name.\nThis groups the strings and integers separately so they can be compared only among themselves.\nkey=lambdanode:(isinstance(node,str),node)\nlist(nx.lexicographical_topological_sort(DG,key=key))\n# [1, 2, 3, 'blue', 'green', 'red']",
    "Section ID: graphs_equal\nDescription: [Check if graphs are equal., Equality here means equal as Python objects (not isomorphism).\nNode, edge and graph data must match.]\nField List: Parameters:: graph1, graph2 : graph:\nReturns:: bool: True if graphs are equal, False otherwise.\nMethods: []\nRubrics:",
    "Section ID: binomial_tree\nDescription: [Returns the Binomial Tree of order n., The binomial tree of order 0 consists of a single node. A binomial tree of order k\nis defined recursively by linking two binomial trees of order k-1: the root of one is\nthe leftmost child of the root of the other., ( Sourcecode , png )]\nField List: Parameters:: n : int: Order of the binomial tree.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : NetworkX graph: A binomial tree of\\(2^n\\)nodes and\\(2^n - 1\\)edges.\nMethods: []\nRubrics:",
    "Section ID: modularity_matrix\nDescription: [Returns the modularity matrix of G., The modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the average adjacency matrix, assuming that the graph\nis described by the configuration model., More specifically, the element B_ij of B is defined as, where k_i is the degree of node i, and where m is the number of edges\nin the graph. When weight is set to a name of an attribute edge, Aij, k_i,\nk_j and m are computed using its value.]\nField List: Parameters:: G : Graph: A NetworkX graph\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nweight : string or None, optional (default=None): The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1.\nReturns:: B : Numpy array: The modularity matrix of G.\nMethods: []\nRubrics: References: [1]M. E. J. Newman, “Modularity and community structure in networks”,\nProc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006.\nExamples: k=[3,2,2,1,0]\nG=nx.havel_hakimi_graph(k)\nB=nx.modularity_matrix(G)",
    "Section ID: tree_graph\nDescription: [Returns graph from tree data format.]\nField List: Parameters:: data : dict: Tree formatted graph data\nident : string: Attribute name for storing NetworkX-internal graph data.identmust\nhave a different value thanchildren. The default is ‘id’.\nchildren : string: Attribute name for storing NetworkX-internal graph data.childrenmust have a different value thanident. The default is ‘children’.\nReturns:: G : NetworkX DiGraph:\nMethods: []\nRubrics: Examples: fromnetworkx.readwriteimportjson_graph\nG=nx.DiGraph([(1,2)])\ndata=json_graph.tree_data(G,root=1)\nH=json_graph.tree_graph(data)",
    "Section ID: reverse_view\nDescription: [View of G with edge directions reversed, reverse_view returns a read-only view of the input graph where\nedge directions are reversed., Identical to digraph.reverse(copy=False)]\nField List: Parameters:: G : networkx.DiGraph:\nReturns:: graph : networkx.DiGraph:\nMethods: []\nRubrics: Examples: G=nx.DiGraph()\nG.add_edge(1,2)\nG.add_edge(2,3)\nG.edges()\n# OutEdgeView([(1, 2), (2, 3)])\nview=nx.reverse_view(G)\nview.edges()\n# OutEdgeView([(2, 1), (3, 2)])",
    "Section ID: preferential_attachment_graph\nDescription: [Create a bipartite graph with a preferential attachment model from\na given single degree sequence., The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes starting with node len(aseq).\nThe number of nodes in set B is random.]\nField List: Parameters:: aseq : list: Degree sequence for node set A.\np : float: Probability that a new bottom node is added.\ncreate_using : NetworkX graph instance, optional: Return graph of this type.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: Notes: The nodes are assigned the attribute ‘bipartite’ with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.preferential_attachment_graph\nReferences: [1]Guillaume, J.L. and Latapy, M.,\nBipartite graphs as models of complex networks.\nPhysica A: Statistical Mechanics and its Applications,\n2006, 371(2), pp.795-813.  [2]Jean-Loup Guillaume and Matthieu Latapy,\nBipartite structure of all complex networks,\nInf. Process. Lett. 90, 2004, pg. 215-221https://doi.org/10.1016/j.ipl.2004.03.007",
    "Section ID: generate_multiline_adjlist\nDescription: [Generate a single line of the graph G in multiline adjacency list format.]\nField List: Parameters:: G : NetworkX graph: \ndelimiter : string, optional: Separator for node labels\nReturns:: lines : string: Lines of data in multiline adjlist format.\nMethods: []\nRubrics: Examples: G=nx.lollipop_graph(4,3)\nforlineinnx.generate_multiline_adjlist(G):\nprint(line)\n# 0 3\n# 1 {}\n# 2 {}\n# 3 {}\n# 1 2\n# 2 {}\n# 3 {}\n# 2 1\n# 3 {}\n# 3 1\n# 4 {}\n# 4 1\n# 5 {}\n# 5 1\n# 6 {}\n# 6 0",
    "Section ID: find_minimal_d_separator\nDescription: [Returns a minimal d-separating set between x and y if possible, A d-separating set in a DAG is a set of nodes that blocks all\npaths between the two sets of nodes, x and y . This function\nconstructs a d-separating set that is “minimal”, meaning no nodes can\nbe removed without it losing the d-separating property for x and y .\nIf no d-separating sets exist for x and y , this returns None ., In a DAG there may be more than one minimal d-separator between two\nsets of nodes. Minimal d-separators are not always unique. This function\nreturns one minimal d-separator, or None if no d-separator exists., Uses the algorithm presented in [1] . The complexity of the algorithm\nis \\(O(m)\\) , where \\(m\\) stands for the number of edges in\nthe subgraph of G consisting of only the ancestors of x and y .\nFor full details, see [1] .]\nField List: Parameters:: G : graph: A networkx DAG.\nx : set | node: A node or set of nodes in the graph.\ny : set | node: A node or set of nodes in the graph.\nincluded : set | node | None: A node or set of nodes which must be included in the found separating set,\ndefault is None, which means the empty set.\nrestricted : set | node | None: Restricted node or set of nodes to consider. Only these nodes can be in\nthe found separating set, default is None meaning all nodes inG.\nReturns:: z : set | None: The minimal d-separating set, if at least one d-separating set exists,\notherwise None.\nRaises:: NetworkXError: Raises aNetworkXErrorif the input graph is not a DAG\nor if node setsx,y, andincludedare not disjoint.\nNodeNotFound: If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised.\nMethods: []\nRubrics: References: [1](1,2)van der Zander, Benito, and Maciej Liśkiewicz. “Finding\nminimal d-separators in linear time and applications.” In\nUncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.",
    "Section ID: powerlaw_cluster_graph\nDescription: [Holme and Kim algorithm for growing graphs with powerlaw\ndegree distribution and approximate average clustering.]\nField List: Parameters:: n : int: the number of nodes\nm : int: the number of random edges to add for each new node\np : float,: Probability of adding a triangle after adding a random edge\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nRaises:: NetworkXError: Ifmdoes not satisfy1<=m<=norpdoes not\nsatisfy0<=p<=1.\nMethods: []\nRubrics: Notes: The average clustering has a hard time getting above a certain\ncutoff that depends on m .  This cutoff is often quite low.  The\ntransitivity (fraction of triangles to possible triangles) seems to\ndecrease with network size. It is essentially the Barabási–Albert (BA) growth model with an\nextra step that each random edge is followed by a chance of\nmaking an edge to one of its neighbors too (and thus a triangle). This algorithm improves on BA in the sense that it enables a\nhigher average clustering to be attained if desired. It seems possible to have a disconnected graph with this algorithm\nsince the initial m nodes may not be all linked to a new node\non the first iteration like the BA model.\nReferences: [1]P. Holme and B. J. Kim,\n“Growing scale-free networks with tunable clustering”,\nPhys. Rev. E, 65, 026107, 2002.",
    "Section ID: is_edge_cover\nDescription: [Decides whether a set of edges is a valid edge cover of the graph., Given a set of edges, whether it is an edge covering can\nbe decided if we just check whether all nodes of the graph\nhas an edge from the set, incident on it.]\nField List: Parameters:: G : NetworkX graph: An undirected bipartite graph.\ncover : set: Set of edges to be checked.\nReturns:: bool: Whether the set of edges is a valid edge cover of the graph.\nMethods: []\nRubrics: Notes: An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.\nExamples: G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\ncover={(2,1),(3,0)}\nnx.is_edge_cover(G,cover)\n# True",
    "Section ID: maximum_spanning_edges\nDescription: [Generate edges in a maximum spanning forest of an undirected\nweighted graph., A maximum spanning tree is a subgraph of the graph (a tree)\nwith the maximum possible sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph.]\nField List: Parameters:: G : undirected Graph: An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.\nalgorithm : string: The algorithm to use when finding a maximum spanning tree. Valid\nchoices are ‘kruskal’, ‘prim’, or ‘boruvka’. The default is ‘kruskal’.\nweight : string: Edge data key to use for weight (default ‘weight’).\nkeys : bool: Whether to yield edge key in multigraphs in addition to the edge.\nIfGis not a multigraph, this is ignored.\ndata : bool, optional: If True yield the edge data along with the edge.\nignore_nan : bool (default: False): If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead.\nReturns:: edges : iterator: An iterator over edges in a maximum spanning tree ofG.\nEdges connecting nodesuandvare represented as tuples:(u,v,k,d)or(u,v,k)or(u,v,d)or(u,v)IfGis a multigraph,keysindicates whether the edge keykwill\nbe reported in the third position in the edge tuple.dataindicates\nwhether the edge datadictdwill appear at the end of the edge tuple.IfGis not a multigraph, the tuples are(u,v,d)ifdatais True\nor(u,v)ifdatais False.\nMethods: []\nRubrics: Notes: For Borůvka’s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. Modified code from David Eppstein, April 2006 http://www.ics.uci.edu/~eppstein/PADS/\nExamples: fromnetworkx.algorithmsimporttree\nFind maximum spanning edges by Kruskal’s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.maximum_spanning_edges(G,algorithm=\"kruskal\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [0, 3], [1, 2]]\nFind maximum spanning edges by Prim’s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)# assign weight 2 to edge 0-3\nmst=tree.maximum_spanning_edges(G,algorithm=\"prim\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [0, 3], [2, 3]]",
    "Section ID: find_cliques_recursive\nDescription: [Returns all maximal cliques in a graph., For each node v , a maximal clique for v is a largest complete\nsubgraph containing v . The largest maximal clique is sometimes\ncalled the maximum clique ., This function returns an iterator over cliques, each of which is a\nlist of nodes. It is a recursive implementation, so may suffer from\nrecursion depth issues, but is included for pedagogical reasons.\nFor a non-recursive implementation, see find_cliques() ., This function accepts a list of nodes and only the maximal cliques\ncontaining all of these nodes are returned. It can considerably speed up\nthe running time if some specific cliques are desired.]\nField List: Parameters:: G : NetworkX graph: \nnodes : list, optional (default=None): If provided, only yieldmaximal cliquescontaining all nodes innodes.\nIfnodesisn’t a clique itself, a ValueError is raised.\nReturns:: iterator: An iterator over maximal cliques, each of which is a list of\nnodes inG. Ifnodesis provided, only the maximal cliques\ncontaining all the nodes innodesare yielded. The order of\ncliques is arbitrary.\nRaises:: ValueError: Ifnodesis not a clique.\nMethods: []\nRubrics: Notes: To obtain a list of all maximal cliques, use list(find_cliques_recursive(G)) . However, be aware that in the\nworst-case, the length of this list can be exponential in the number\nof nodes in the graph. This function avoids storing all cliques in memory\nby only keeping current candidate node lists in memory during its search. This implementation is based on the algorithm published by Bron and\nKerbosch (1973) [1] , as adapted by Tomita, Tanaka and Takahashi\n(2006) [2] and discussed in Cazals and Karande (2008) [3] . For a\nnon-recursive implementation, see find_cliques() . This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.\nReferences: [1]Bron, C. and Kerbosch, J.\n“Algorithm 457: finding all cliques of an undirected graph”.Communications of the ACM16, 9 (Sep. 1973), 575–577.\n<http://portal.acm.org/citation.cfm?doid=362342.362367>  [2]Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n“The worst-case time complexity for generating all maximal\ncliques and computational experiments”,Theoretical Computer Science, Volume 363, Issue 1,\nComputing and Combinatorics,\n10th Annual International Conference on\nComputing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28–42\n<https://doi.org/10.1016/j.tcs.2006.06.015>  [3]F. Cazals, C. Karande,\n“A note on the problem of reporting maximal cliques”,Theoretical Computer Science,\nVolume 407, Issues 1–3, 6 November 2008, Pages 564–568,\n<https://doi.org/10.1016/j.tcs.2008.05.010>",
    "Section ID: generate_edgelist\nDescription: [Generate a single line of the graph G in edge list format.]\nField List: Parameters:: G : NetworkX graph: \ndelimiter : string, optional: Separator for node labels\ndata : bool or list of keys: If False generate no edge data.  If True use a dictionary\nrepresentation of edge data.  If a list of keys use a list of data\nvalues corresponding to the keys.\nReturns:: lines : string: Lines of data in adjlist format.\nMethods: []\nRubrics: Examples: G=nx.lollipop_graph(4,3)\nG[1][2][\"weight\"]=3\nG[3][4][\"capacity\"]=12\nforlineinnx.generate_edgelist(G,data=False):\nprint(line)\n# 0 1\n# 0 2\n# 0 3\n# 1 2\n# 1 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6\nforlineinnx.generate_edgelist(G):\nprint(line)\n# 0 1 {}\n# 0 2 {}\n# 0 3 {}\n# 1 2 {'weight': 3}\n# 1 3 {}\n# 2 3 {}\n# 3 4 {'capacity': 12}\n# 4 5 {}\n# 5 6 {}\nforlineinnx.generate_edgelist(G,data=[\"weight\"]):\nprint(line)\n# 0 1\n# 0 2\n# 0 3\n# 1 2 3\n# 1 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6",
    "Section ID: get_node_attributes\nDescription: [Get node attributes from graph]\nField List: Parameters:: G : NetworkX Graph: \nname : string: Attribute name\ndefault: object (default=None): Default value of the node attribute if there is no value set for that\nnode in graph. IfNonethen nodes without this attribute are not\nincluded in the returned dict.\nReturns:: Dictionary of attributes keyed by node.:\nMethods: []\nRubrics: Examples: G=nx.Graph()\nG.add_nodes_from([1,2,3],color=\"red\")\ncolor=nx.get_node_attributes(G,\"color\")\ncolor[1]\n# 'red'\nG.add_node(4)\ncolor=nx.get_node_attributes(G,\"color\",default=\"yellow\")\ncolor[4]\n# 'yellow'",
    "Section ID: chordal_graph_treewidth\nDescription: [Returns the treewidth of the chordal graph G.]\nField List: Parameters:: G : graph: A NetworkX graph\nReturns:: treewidth : int: The size of the largest clique in the graph minus one.\nRaises:: NetworkXError: The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised.\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Tree_decomposition#Treewidth\nExamples: e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n(7,8),\n]\nG=nx.Graph(e)\nG.add_node(9)\nnx.chordal_graph_treewidth(G)\n# 3",
    "Section ID: vf2pp_all_isomorphisms\nDescription: [Yields all the possible mappings between G1 and G2.]\nField List: Parameters:: G1, G2 : NetworkX Graph or MultiGraph instances.: The two graphs to check for isomorphism.\nnode_label : str, optional: The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn’t have thenode_labelattribute usesdefault_labelinstead.\ndefault_label : scalar: Default value to use when a node doesn’t have an attribute\nnamednode_label. Default isNone.\nYields:: dict: Isomorphic mapping between the nodes inG1andG2.\nMethods: []\nRubrics:",
    "Section ID: desargues_graph\nDescription: [Returns the Desargues Graph, The Desargues Graph is a non-planar, distance-transitive cubic graph\nwith 20 nodes and 30 edges [1] .\nIt is a symmetric graph. It can be represented in LCF notation\nas [5,-5,9,-9]^5 [2] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Desargues Graph with 20 nodes and 30 edges\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Desargues_graph  [2]https://mathworld.wolfram.com/DesarguesGraph.html",
    "Section ID: common_neighbors\nDescription: [Returns the common neighbors of two nodes in a graph.]\nField List: Parameters:: G : graph: A NetworkX undirected graph.\nu, v : nodes: Nodes in the graph.\nReturns:: cnbors : set: Set of common neighbors of u and v in the graph.\nRaises:: NetworkXError: If u or v is not a node in the graph.\nMethods: []\nRubrics: Examples: G=nx.complete_graph(5)\nsorted(nx.common_neighbors(G,0,1))\n# [2, 3, 4]",
    "Section ID: kernighan_lin_bisection\nDescription: [Partition a graph into two blocks using the Kernighan–Lin\nalgorithm., This algorithm partitions a network into two sets by iteratively\nswapping pairs of nodes to reduce the edge cut between the two sets.  The\npairs are chosen according to a modified form of Kernighan-Lin [1] , which\nmoves node individually, alternating between sides to keep the bisection\nbalanced.]\nField List: Parameters:: G : NetworkX graph: Graph must be undirected.\npartition : tuple: Pair of iterables containing an initial partition. If not\nspecified, a random balanced partition is used.\nmax_iter : int: Maximum number of times to attempt swaps to find an\nimprovement before giving up.\nweight : key: Edge data key to use as weight. If None, the weights are all\nset to one.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nOnly used if partition is None\nReturns:: partition : tuple: A pair of sets of nodes representing the bipartition.\nRaises:: NetworkXError: If partition is not a valid partition of the nodes of the graph.\nMethods: []\nRubrics: References: [1]Kernighan, B. W.; Lin, Shen (1970).\n“An efficient heuristic procedure for partitioning graphs.”Bell Systems Technical Journal49: 291–307.\nOxford University Press 2011.",
    "Section ID: star_graph\nDescription: [Return the star graph, The star graph consists of one center node connected to n outer nodes., ( Sourcecode , png )]\nField List: Parameters:: n : int or iterable: If an integer, node labels are 0 to n with center 0.\nIf an iterable of nodes, the center is the first.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nMethods: []\nRubrics: Notes: The graph has n+1 nodes for integer n.\nSo star_graph(3) is the same as star_graph(range(4)).",
    "Section ID: thresholded_random_geometric_graph\nDescription: [Returns a thresholded random geometric graph in the unit cube., The thresholded random geometric graph [1] model places n nodes\nuniformly at random in the unit cube of dimensions dim . Each node u is assigned a weight \\(w_u\\) . Two nodes u and v are\njoined by an edge if they are within the maximum connection distance, radius computed by the p -Minkowski distance and the summation of\nweights \\(w_u\\) + \\(w_v\\) is greater than or equal\nto the threshold parameter theta ., Edges within radius of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) .]\nField List: Parameters:: n : int or iterable: Number of nodes or iterable of nodes\nradius: float: Distance threshold value\ntheta: float: Threshold value\ndim : int, optional: Dimension of graph\npos : dict, optional: A dictionary keyed by node with node positions as values.\nweight : dict, optional: Node weights as a dictionary of numbers keyed by node.\np : float, optional (default 2): Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.This should not be confused with thepof an Erdős-Rényi random\ngraph, which represents probability.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\npos_name : string, default=”pos”: The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.\nweight_name : string, default=”weight”: The name of the node attribute which represents the weight\nof the node in the returned graph.\nReturns:: Graph: A thresholded random geographic graph, undirected and without\nself-loops.Each node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function. Similarly, each node has a nodethre\nattribute'weight'that stores the weight of that node as\nprovided or as generated.\nMethods: []\nRubrics: Notes: This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2 If weights are not specified they are assigned to nodes by drawing randomly\nfrom the exponential distribution with rate parameter \\(\\lambda=1\\) .\nTo specify weights from a different distribution, use the weight keyword\nargument:\nReferences: [1]http://cole-maclean.github.io/blog/files/thesis.pdf\nExamples: Default Graph:\nG = nx.thresholded_random_geometric_graph(50, 0.2, 0.1)\nCustom Graph:\nCreate a thresholded random geometric graph on 50 uniformly distributed\nnodes where nodes are joined by an edge if their sum weights drawn from\na exponential distribution with rate = 5 are >= theta = 0.1 and their\nEuclidean distance is at most 0.2.",
    "Section ID: threshold_accepting_tsp\nDescription: [Returns an approximate solution to the traveling salesman problem., This function uses threshold accepting methods to approximate the minimal cost\ncycle through the nodes. Starting from a suboptimal solution, threshold\naccepting methods perturb that solution, accepting any changes that make\nthe solution no worse than increasing by a threshold amount. Improvements\nin cost are accepted, but so are changes leading to small increases in cost.\nThis allows the solution to leave suboptimal local minima in solution space.\nThe threshold is decreased slowly as iterations proceed helping to ensure\nan optimum. In summary, the function returns a cycle starting at source for which the total cost is minimized.]\nField List: Parameters:: G : Graph: Gshould be a complete weighted graph.\nThe distance between all pairs of nodes should be included.\ninit_cycle : list or “greedy”: The initial solution (a cycle through all nodes returning to the start).\nThis argument has no default to make you think about it.\nIf “greedy”, usegreedy_tsp(G,weight).\nOther common starting cycles arelist(G)+[next(iter(G))]or the final\nresult ofsimulated_annealing_tspwhen doingthreshold_accepting_tsp.\nweight : string, optional (default=”weight”): Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.\nsource : node, optional (default: first node in list(G)): Starting node.  If None, defaults tonext(iter(G))\nthreshold : int, optional (default=1): The algorithm’s threshold parameter. It represents the initial\nthreshold’s value\nmove : “1-1” or “1-0” or function, optional (default=”1-1”): Indicator of what move to use when finding new trial solutions.\nStrings indicate two special built-in moves:“1-1”: 1-1 exchange which transposes the position\nof two elements of the current solution.\nThe function called isswap_two_nodes().\nFor example if we apply 1-1 exchange in the solutionA=[3,2,1,4,3]we can get the following by the transposition of 1 and 4 elements:A'=[3,2,4,1,3]“1-0”: 1-0 exchange which moves an node in the solution\nto a new position.\nThe function called ismove_one_node().\nFor example if we apply 1-0 exchange in the solutionA=[3,2,1,4,3]we can transfer the fourth element to the second position:A'=[3,4,2,1,3]You may provide your own functions to enact a move from\none solution to a neighbor solution. The function must take\nthe solution as input along with aseedinput to control\nrandom number generation (see theseedinput here).\nYour function should maintain the solution as a cycle with\nequal first and last node and all others appearing once.\nYour function should return the new solution.\nmax_iterations : int, optional (default=10): Declared done when this number of consecutive iterations of\nthe outer loop occurs without any change in the best cost solution.\nN_inner : int, optional (default=100): The number of iterations of the inner loop.\nalpha : float between (0, 1), optional (default=0.1): Percentage of threshold decrease when there is at\nleast one acceptance of a neighbor solution.\nIf no inner loop moves are accepted the threshold remains unchanged.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: cycle : list of nodes: Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip.\nRaises:: NetworkXError: IfGis not complete the algorithm raises an exception.\nMethods: []\nRubrics: Notes: Threshold Accepting is a metaheuristic local search algorithm.\nThe main characteristic of this algorithm is that it accepts\neven solutions which lead to the increase of the cost in order\nto escape from low quality local optimal solutions. This algorithm needs an initial solution. This solution can be\nconstructed by a simple greedy algorithm. At every iteration, it\nselects thoughtfully a neighbor solution.\nConsider \\(c(x)\\) cost of current solution and \\(c(x')\\) cost of\nneighbor solution.\nIf \\(c(x') - c(x) <= threshold\\) then the neighbor solution becomes the current\nsolution for the next iteration, where the threshold is named threshold. In comparison to the Simulated Annealing algorithm, the Threshold\nAccepting algorithm does not accept very low quality solutions\n(due to the presence of the threshold value). In the case of\nSimulated Annealing, even a very low quality solution can\nbe accepted with probability \\(p\\) . Time complexity:\nIt has a running time \\(O(m * n * |V|)\\) where \\(m\\) and \\(n\\) are the number\nof times the outer and inner loop run respectively. For more information and how algorithm is inspired see: https://doi.org/10.1016/0021-9991(90)90201-B\nExamples: fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.threshold_accepting_tsp(G,\"greedy\",source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31\nincycle=[\"D\",\"B\",\"A\",\"C\",\"D\"]\ncycle=approx.threshold_accepting_tsp(G,incycle,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31",
    "Section ID: random_unlabeled_rooted_forest\nDescription: [Returns a forest or list of forests selected at random., Returns one or more (depending on number_of_forests )\nunlabeled rooted forests with n nodes, and with no more than q nodes per tree, drawn uniformly at random.\nThe “roots” graph attribute identifies the roots of the forest.]\nField List: Parameters:: n : int: The number of nodes\nq : int or None (default): The maximum number of nodes per tree.\nnumber_of_forests : int or None (default): If not None, this number of forests is generated and returned.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: networkx.Graph : or list of : networkx.Graph: A singlenetworkx.Graph(or a list thereof, ifnumber_of_forestsis specified) with nodes in the set {0, …,n- 1}.\nThe “roots” graph attribute is a set containing the roots\nof the trees in the forest.\nRaises:: ValueError: Ifnis non-zero butqis zero.\nMethods: []\nRubrics: Notes: This function implements the algorithm “Forest” of [1] .\nThe algorithm needs to compute some counting functions\nthat are relatively expensive: in case several trees are needed,\nit is advisable to use the number_of_forests optional argument\nto reuse the counting functions.\nReferences: [1]Wilf, Herbert S. “The uniform selection of free trees.”\nJournal of Algorithms 2.2 (1981): 204-207.https://doi.org/10.1016/0196-6774(81)90021-3",
    "Section ID: turan_graph\nDescription: [Return the Turan Graph, The Turan Graph is a complete multipartite graph on \\(n\\) nodes\nwith \\(r\\) disjoint subsets. That is, edges connect each node to\nevery node not in its subset., Given \\(n\\) and \\(r\\) , we create a complete multipartite graph with \\(r-(n \\mod r)\\) partitions of size \\(n/r\\) , rounded down, and \\(n \\mod r\\) partitions of size \\(n/r+1\\) , rounded down., ( Sourcecode , png )]\nField List: Parameters:: n : int: The number of nodes.\nr : int: The number of partitions.\nMust be less than or equal to n.\nMethods: []\nRubrics: Notes: Must satisfy \\(1 <= r <= n\\) .\nThe graph has \\((r-1)(n^2)/(2r)\\) edges, rounded down.",
    "Section ID: cytoscape_data\nDescription: [Returns data in Cytoscape JSON format (cyjs).]\nField List: Parameters:: G : NetworkX Graph: The graph to convert to cytoscape format\nname : string: A string which is mapped to the ‘name’ node element in cyjs format.\nMust not have the same value asident.\nident : string: A string which is mapped to the ‘id’ node element in cyjs format.\nMust not have the same value asname.\nReturns:: data: dict: A dictionary with cyjs formatted data.\nRaises:: NetworkXError: If the values fornameandidentare identical.\nMethods: []\nRubrics: References: [1]Cytoscape user’s manual:http://manual.cytoscape.org/en/stable/index.html\nExamples: G=nx.path_graph(2)\nnx.cytoscape_data(G)\n# {'data': [],\n#  'directed': False,\n#  'multigraph': False,\n#  'elements': {'nodes': [{'data': {'id': '0', 'value': 0, 'name': '0'}},\n#    {'data': {'id': '1', 'value': 1, 'name': '1'}}],\n#   'edges': [{'data': {'source': 0, 'target': 1}}]}}",
    "Section ID: extended_barabasi_albert_graph\nDescription: [Returns an extended Barabási–Albert model graph., An extended Barabási–Albert model graph is a random graph constructed\nusing preferential attachment. The extended model allows new edges,\nrewired edges or new nodes. Based on the probabilities \\(p\\) and \\(q\\) with \\(p + q < 1\\) , the growing behavior of the graph is determined as:, 1) With \\(p\\) probability, \\(m\\) new edges are added to the graph,\nstarting from randomly chosen existing nodes and attached preferentially at the other end., 2) With \\(q\\) probability, \\(m\\) existing edges are rewired\nby randomly choosing an edge and rewiring one end to a preferentially chosen node., 3) With \\((1 - p - q)\\) probability, \\(m\\) new nodes are added to the graph\nwith edges attached preferentially., When \\(p = q = 0\\) , the model behaves just like the Barabási–Alber model.]\nField List: Parameters:: n : int: Number of nodes\nm : int: Number of edges with which a new node attaches to existing nodes\np : float: Probability value for adding an edge between existing nodes. p + q < 1\nq : float: Probability value of rewiring of existing edges. p + q < 1\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : Graph:\nRaises:: NetworkXError: Ifmdoes not satisfy1<=m<nor1>=p+q\nMethods: []\nRubrics: References: [1]Albert, R., & Barabási, A. L. (2000)\nTopology of evolving networks: local events and universality\nPhysical review letters, 85(24), 5234.",
    "Section ID: write_edgelist\nDescription: [Write graph as a list of edges.]\nField List: Parameters:: G : graph: A NetworkX graph\npath : file or string: File or filename to write. If a file is provided, it must be\nopened in ‘wb’ mode. Filenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional: The character used to indicate the start of a comment\ndelimiter : string, optional: The string used to separate values.  The default is whitespace.\ndata : bool or list, optional: If False write no edge data.\nIf True write a string representation of the edge data dictionary..\nIf a list (or other iterable) is provided, write the  keys specified\nin the list.\nencoding: string, optional: Specify which encoding to use when writing file.\nMethods: []\nRubrics: Examples: G=nx.path_graph(4)\nnx.write_edgelist(G,\"test.edgelist\")\nG=nx.path_graph(4)\nfh=open(\"test.edgelist\",\"wb\")\nnx.write_edgelist(G,fh)\nnx.write_edgelist(G,\"test.edgelist.gz\")\nnx.write_edgelist(G,\"test.edgelist.gz\",data=False)\nG=nx.Graph()\nG.add_edge(1,2,weight=7,color=\"red\")\nnx.write_edgelist(G,\"test.edgelist\",data=False)\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\"])\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\",\"weight\"])",
    "Section ID: immediate_dominators\nDescription: [Returns the immediate dominators of all nodes of a directed graph.]\nField List: Parameters:: G : a DiGraph or MultiDiGraph: The graph where dominance is to be computed.\nstart : node: The start node of dominance computation.\nReturns:: idom : dict keyed by nodes: A dict containing the immediate dominators of each node reachable fromstart.\nRaises:: NetworkXNotImplemented: IfGis undirected.\nNetworkXError: Ifstartis not inG.\nMethods: []\nRubrics: Notes: Except for start , the immediate dominators are the parents of their\ncorresponding nodes in the dominator tree.\nReferences: [1]K. D. Cooper, T. J. Harvey, and K. Kennedy.\nA simple, fast dominance algorithm.\nSoftware Practice & Experience, 4:110, 2001.\nExamples: G=nx.DiGraph([(1,2),(1,3),(2,5),(3,4),(4,5)])\nsorted(nx.immediate_dominators(G,1).items())\n# [(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]",
    "Section ID: biadjacency_matrix\nDescription: [Returns the biadjacency matrix of the bipartite graph G., Let G=(U,V,E) be a bipartite graph with node sets U=u_{1},...,u_{r} and V=v_{1},...,v_{s} . The biadjacency\nmatrix [1] is the r x s matrix B in which b_{i,j}=1 if, and only if, (u_i,v_j)inE . If the parameter weight is\nnot None and matches the name of an edge attribute, its value is\nused instead of 1.]\nField List: Parameters:: G : graph: A NetworkX graph\nrow_order : list of nodes: The rows of the matrix are ordered according to the list of nodes.\ncolumn_order : list, optional: The columns of the matrix are ordered according to the list of nodes.\nIf column_order is None, then the ordering of columns is arbitrary.\ndtype : NumPy data-type, optional: A valid NumPy dtype used to initialize the array. If None, then the\nNumPy default is used.\nweight : string or None, optional (default=’weight’): The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1.\nformat : str in {‘bsr’, ‘csr’, ‘csc’, ‘coo’, ‘lil’, ‘dia’, ‘dok’}: The type of the matrix to be returned (default ‘csr’).  For\nsome algorithms different implementations of sparse matrices\ncan perform better.  See[2]for details.\nReturns:: M : SciPy sparse array: Biadjacency matrix representation of the bipartite graph G.\nMethods: []\nRubrics: Notes: No attempt is made to check that the input graph is bipartite. For directed bipartite graphs only successors are considered as neighbors.\nTo obtain an adjacency matrix with ones (or weight values) for both\npredecessors and successors you have to generate two biadjacency matrices\nwhere the rows of one of them are the columns of the other, and then add\none to the transpose of the other.\nReferences: [1]https://en.wikipedia.org/wiki/Adjacency_matrix#Adjacency_matrix_of_a_bipartite_graph  [2]Scipy Dev. References, “Sparse Matrices”,https://docs.scipy.org/doc/scipy/reference/sparse.html",
    "Section ID: transitive_closure\nDescription: [Returns transitive closure of a graph, The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a path from v to w in G., Handling of paths from v to v has some flexibility within this definition.\nA reflexive transitive closure creates a self-loop for the path\nfrom v to v of length 0. The usual transitive closure creates a\nself-loop only if a cycle exists (a path from v to v with length > 0).\nWe also allow an option for no self-loops.]\nField List: Parameters:: G : NetworkX Graph: A directed/undirected graph/multigraph.\nreflexive : Bool or None, optional (default: False): Determines when cycles create self-loops in the Transitive Closure.\nIf True, trivial cycles (length 0) create self-loops. The result\nis a reflexive transitive closure of G.\nIf False (the default) non-trivial cycles create self-loops.\nIf None, self-loops are not created.\nReturns:: NetworkX graph: The transitive closure ofG\nRaises:: NetworkXError: Ifreflexivenot in{None,True,False}\nMethods: []\nRubrics: References: [1]https://www.ics.uci.edu/~eppstein/PADS/PartialOrder.py\nExamples: The treatment of trivial (i.e. length 0) cycles is controlled by thereflexiveparameter.\nTrivial (i.e. length 0) cycles do not create self-loops whenreflexive=False(the default):\nDG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure(DG,reflexive=False)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3)])\nHowever, nontrivial (i.e. length greater than 0) cycles create self-loops\nwhenreflexive=False(the default):\nDG=nx.DiGraph([(1,2),(2,3),(3,1)])\nTC=nx.transitive_closure(DG,reflexive=False)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (1, 1), (2, 3), (2, 1), (2, 2), (3, 1), (3, 2), (3, 3)])\nTrivial cycles (length 0) create self-loops whenreflexive=True:\nDG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure(DG,reflexive=True)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 1), (1, 3), (2, 3), (2, 2), (3, 3)])\nAnd the third option is not to create self-loops at all whenreflexive=None:\nDG=nx.DiGraph([(1,2),(2,3),(3,1)])\nTC=nx.transitive_closure(DG,reflexive=None)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2)])",
    "Section ID: large_clique_size\nDescription: [Find the size of a large clique in a graph., A clique is a subset of nodes in which each pair of nodes is\nadjacent. This function is a heuristic for finding the size of a\nlarge clique in the graph.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: k: integer: The size of a large clique in the graph.\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nMethods: []\nRubrics: Notes: This implementation is from [1] . Its worst case time complexity is \\(O(n d^2)\\) , where n is the number of nodes in the graph and d is the maximum degree. This function is a heuristic, which means it may work well in\npractice, but there is no rigorous mathematical guarantee on the\nratio between the returned number and the actual largest clique size\nin the graph.\nReferences: [1]Pattabiraman, Bharath, et al.\n“Fast Algorithms for the Maximum Clique Problem on Massive Graphs\nwith Applications to Overlapping Community Detection.”Internet Mathematics11.4-5 (2015): 421–448.\n<https://doi.org/10.1080/15427951.2014.986778>\nExamples: G=nx.path_graph(10)\nnx.approximation.large_clique_size(G)\n# 2",
    "Section ID: relabel_nodes\nDescription: [Relabel the nodes of the graph G according to a given mapping., The original node ordering may not be preserved if copy is False and the\nmapping includes overlap between old and new labels.]\nField List: Parameters:: G : graph: A NetworkX graph\nmapping : dictionary: A dictionary with the old labels as keys and new labels as values.\nA partial mapping is allowed. Mapping 2 nodes to a single node is allowed.\nAny non-node keys in the mapping are ignored.\ncopy : bool (optional, default=True): If True return a copy, or if False relabel the nodes in place.\nMethods: []\nRubrics: Notes: Only the nodes specified in the mapping will be relabeled.\nAny non-node keys in the mapping are ignored. The keyword setting copy=False modifies the graph in place.\nRelabel_nodes avoids naming collisions by building a\ndirected graph from mapping which specifies the order of\nrelabelings. Naming collisions, such as a->b, b->c, are ordered\nsuch that “b” gets renamed to “c” before “a” gets renamed “b”.\nIn cases of circular mappings (e.g. a->b, b->a), modifying the\ngraph is not possible in-place and an exception is raised.\nIn that case, use copy=True. If a relabel operation on a multigraph would cause two or more\nedges to have the same source, target and key, the second edge must\nbe assigned a new key to retain all edges. The new key is set\nto the lowest non-negative integer not already used as a key\nfor edges between these two nodes. Note that this means non-numeric\nkeys may be replaced by numeric keys.\nExamples: To create a new graph with nodes relabeled according to a given\ndictionary:\nG=nx.path_graph(3)\nsorted(G)\n# [0, 1, 2]\nmapping={0:\"a\",1:\"b\",2:\"c\"}\nH=nx.relabel_nodes(G,mapping)\nsorted(H)\n# ['a', 'b', 'c']\nNodes can be relabeled with any hashable object, including numbers\nand strings:\nimportstring\nG=nx.path_graph(26)# nodes are integers 0 through 25\nsorted(G)[:3]\n# [0, 1, 2]\nmapping=dict(zip(G,string.ascii_lowercase))\nG=nx.relabel_nodes(G,mapping)# nodes are characters a through z\nsorted(G)[:3]\n# ['a', 'b', 'c']\nmapping=dict(zip(G,range(1,27)))\nG=nx.relabel_nodes(G,mapping)# nodes are integers 1 through 26\nsorted(G)[:3]\n# [1, 2, 3]\nTo perform a partial in-place relabeling, provide a dictionary\nmapping only a subset of the nodes, and set thecopykeyword\nargument to False:\nG=nx.path_graph(3)# nodes 0-1-2\nmapping={0:\"a\",1:\"b\"}# 0->'a' and 1->'b'\nG=nx.relabel_nodes(G,mapping,copy=False)\nsorted(G,key=str)\n# [2, 'a', 'b']\nA mapping can also be given as a function:\nG=nx.path_graph(3)\nH=nx.relabel_nodes(G,lambdax:x**2)\nlist(H)\n# [0, 1, 4]\nIn a multigraph, relabeling two or more nodes to the same new node\nwill retain all edges, but may change the edge keys in the process:\nG=nx.MultiGraph()\nG.add_edge(0,1,value=\"a\")# returns the key for this edge\n# 0\nG.add_edge(0,2,value=\"b\")\n# 0\nG.add_edge(0,3,value=\"c\")\n# 0\nmapping={1:4,2:4,3:4}\nH=nx.relabel_nodes(G,mapping,copy=True)\nprint(H[0])\n# {4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}\nThis works for in-place relabeling too:\nG=nx.relabel_nodes(G,mapping,copy=False)\nprint(G[0])\n# {4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}",
    "Section ID: all_triplets\nDescription: [Returns a generator of all possible sets of 3 nodes in a DiGraph.]\nField List: Parameters:: G : digraph: A NetworkX DiGraph\nReturns:: triplets : generator of 3-tuples: Generator of tuples of 3 nodes\nMethods: []\nRubrics: Examples: G=nx.DiGraph([(1,2),(2,3),(3,4)])\nlist(nx.all_triplets(G))\n# [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]",
    "Section ID: minimum_st_edge_cut\nDescription: [Returns the edges of the cut-set of a minimum (s, t)-cut., This function returns the set of edges of minimum cardinality that,\nif removed, would destroy all paths among source and target in G.\nEdge weights are not considered. See minimum_cut() for\ncomputing minimum cuts considering edge weights.]\nField List: Parameters:: G : NetworkX graph: \ns : node: Source node for the flow.\nt : node: Sink node for the flow.\nauxiliary : NetworkX DiGraph: Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.\nflow_func : function: A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. Seenode_connectivity()for\ndetails. The choice of the default function may change from version\nto version and should not be relied on. Default value: None.\nresidual : NetworkX DiGraph: Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.\nReturns:: cutset : set: Set of edges that, if removed from the graph, will disconnect it.\nMethods: []\nRubrics: Examples: This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportminimum_st_edge_cut\nWe use in this example the platonic icosahedral graph, which has edge\nconnectivity 5.\nG=nx.icosahedral_graph()\nlen(minimum_st_edge_cut(G,0,6))\n# 5\nIf you need to compute local edge cuts on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local edge cuts among all pairs of\nnodes of the platonic icosahedral graph reusing the data\nstructures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=len(minimum_st_edge_cut(G,u,v,auxiliary=H,residual=R))\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge\ncuts. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(minimum_st_edge_cut(G,0,6,flow_func=shortest_augmenting_path))\n# 5",
    "Section ID: periphery\nDescription: [Returns the periphery of the graph G., The periphery is the set of nodes with eccentricity equal to the diameter.]\nField List: Parameters:: G : NetworkX graph: A graph\ne : eccentricity dictionary, optional: A precomputed dictionary of eccentricities.\nweight : string, function, or None: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances.\nReturns:: p : list: List of nodes in periphery\nMethods: []\nRubrics: Examples: G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.periphery(G)\n# [2, 5]",
    "Section ID: is_bipartite_node_set\nDescription: [Returns True if nodes and G/nodes are a bipartition of G.]\nField List: Parameters:: G : NetworkX graph: \nnodes: list or container: Check if nodes are a one of a bipartite set.\nMethods: []\nRubrics: Notes: An exception is raised if the input nodes are not distinct, because in this\ncase some bipartite algorithms will yield incorrect results.\nFor connected graphs the bipartite sets are unique.  This function handles\ndisconnected graphs.\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nX=set([1,3])\nbipartite.is_bipartite_node_set(G,X)\n# True",
    "Section ID: from_numpy_array\nDescription: [Returns a graph from a 2D NumPy array., The 2D NumPy array is interpreted as an adjacency matrix for the graph.]\nField List: Parameters:: A : a 2D numpy.ndarray: An adjacency matrix representation of a graph\nparallel_edges : Boolean: If this is True,create_usingis a multigraph, andAis an\ninteger array, then entry(i, j)in the array is interpreted as the\nnumber of parallel edges joining verticesiandjin the graph.\nIf it is False, then the entries in the array are interpreted as\nthe weight of a single edge joining the vertices.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nedge_attr : String, optional (default=”weight”): The attribute to which the array values are assigned on each edge. If\nit is None, edge attributes will not be assigned.\nMethods: []\nRubrics: Notes: For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of A corresponds to an edge from i to j. If create_using is networkx.MultiGraph or networkx.MultiDiGraph , parallel_edges is True, and the\nentries of A are of type int , then this function returns a\nmultigraph (of the same type as create_using ) with parallel edges. If create_using indicates an undirected multigraph, then only the edges\nindicated by the upper triangle of the array A will be added to the\ngraph. If edge_attr is Falsy (False or None), edge attributes will not be\nassigned, and the array data will be treated like a binary mask of\nedge presence or absence. Otherwise, the attributes will be assigned\nas follows: If the NumPy array has a single data type for each array entry it\nwill be converted to an appropriate Python data type. If the NumPy array has a user-specified compound data type the names\nof the data fields will be used as attribute keys in the resulting\nNetworkX graph.\nExamples: Simple integer weights on edges:\nimportnumpyasnp\nA=np.array([[1,1],[2,1]])\nG=nx.from_numpy_array(A)\nG.edges(data=True)\n# EdgeDataView([(0, 0, {'weight': 1}), (0, 1, {'weight': 2}), (1, 1, {'weight': 1})])\nIfcreate_usingindicates a multigraph and the array has only integer\nentries andparallel_edgesis False, then the entries will be treated\nas weights for edges joining the nodes (without creating parallel edges):\nA=np.array([[1,1],[1,2]])\nG=nx.from_numpy_array(A,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 2}})\nIfcreate_usingindicates a multigraph and the array has only integer\nentries andparallel_edgesis True, then the entries will be treated\nas the number of parallel edges joining those two vertices:\nA=np.array([[1,1],[1,2]])\ntemp=nx.MultiGraph()\nG=nx.from_numpy_array(A,parallel_edges=True,create_using=temp)\nG[1][1]\n# AtlasView({0: {'weight': 1}, 1: {'weight': 1}})\nUser defined compound data type on edges:\ndt=[(\"weight\",float),(\"cost\",int)]\nA=np.array([[(1.0,2)]],dtype=dt)\nG=nx.from_numpy_array(A)\nG.edges()\n# EdgeView([(0, 0)])\nG[0][0][\"cost\"]\n# 2\nG[0][0][\"weight\"]\n# 1.0",
    "Section ID: number_of_isolates\nDescription: [Returns the number of isolates in the graph., An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: int: The number of degree zero nodes in the graphG.\nMethods: []\nRubrics:",
    "Section ID: cycle_basis\nDescription: [Returns a list of cycles which form a basis for cycles of G., A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as “exclusive or” of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff’s Laws.]\nField List: Parameters:: G : NetworkX Graph: \nroot : node, optional: Specify starting node for basis.\nReturns:: A list of cycle lists.  Each cycle list is a list of nodes: \nwhich forms a cycle (loop) in G.:\nMethods: []\nRubrics: Notes: This is adapted from algorithm CACM 491 [1] .\nReferences: [1]Paton, K. An algorithm for finding a fundamental set of\ncycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.\nExamples: G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.cycle_basis(G,0)\n# [[3, 4, 5, 0], [1, 2, 3, 0]]",
    "Section ID: johnson\nDescription: [Uses Johnson’s Algorithm to compute shortest paths., Johnson’s Algorithm finds a shortest path between each pair of\nnodes in a weighted graph even if negative weights are present.]\nField List: Parameters:: G : NetworkX graph: \nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: distance : dictionary: Dictionary, keyed by source and target, of shortest paths.\nMethods: []\nRubrics: Notes: Johnson’s algorithm is suitable even for graphs with negative weights. It\nworks by using the Bellman–Ford algorithm to compute a transformation of\nthe input graph that removes all negative weights, allowing Dijkstra’s\nalgorithm to be used on the transformed graph. The time complexity of this algorithm is \\(O(n^2 \\log n + n m)\\) ,\nwhere \\(n\\) is the number of nodes and \\(m\\) the number of edges in the\ngraph. For dense graphs, this may be faster than the Floyd–Warshall\nalgorithm.\nExamples: graph=nx.DiGraph()\ngraph.add_weighted_edges_from(\n[(\"0\",\"3\",3),(\"0\",\"1\",-5),(\"0\",\"2\",2),(\"1\",\"2\",4),(\"2\",\"3\",1)]\n)\npaths=nx.johnson(graph,weight=\"weight\")\npaths[\"0\"][\"2\"]\n# ['0', '1', '2']",
    "Section ID: second_order_centrality\nDescription: [Compute the second order centrality for nodes of G., The second order centrality of a given node is the standard deviation of\nthe return times to that node of a perpetual random walk on G:]\nField List: Parameters:: G : graph: A NetworkX connected and undirected graph.\nweight : string or None, optional (default=”weight”): The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.\nReturns:: nodes : dictionary: Dictionary keyed by node with second order centrality as the value.\nRaises:: NetworkXException: If the graph G is empty, non connected or has negative weights.\nMethods: []\nRubrics: Notes: Lower values of second order centrality indicate higher centrality. The algorithm is from Kermarrec, Le Merrer, Sericola and Trédan [1] . This code implements the analytical version of the algorithm, i.e.,\nthere is no simulation of a random walk process involved. The random walk\nis here unbiased (corresponding to eq 6 of the paper [1] ), thus the\ncentrality values are the standard deviations for random walk return times\non the transformed input graph G (equal in-degree at each nodes by adding\nself-loops). Complexity of this implementation, made to run locally on a single machine,\nis O(n^3), with n the size of G, which makes it viable only for small\ngraphs.\nReferences: [1](1,2)Anne-Marie Kermarrec, Erwan Le Merrer, Bruno Sericola, Gilles Trédan\n“Second order centrality: Distributed assessment of nodes criticity in\ncomplex networks”, Elsevier Computer Communications 34(5):619-628, 2011.\nExamples: G=nx.star_graph(10)\nsoc=nx.second_order_centrality(G)\nprint(sorted(soc.items(),key=lambdax:x[1])[0][0])# pick first id\n# 0",
    "Section ID: is_attracting_component\nDescription: [Returns True if G consists of a single attracting component.]\nField List: Parameters:: G : DiGraph, MultiDiGraph: The graph to be analyzed.\nReturns:: attracting : bool: True ifGhas a single attracting component. Otherwise, False.\nRaises:: NetworkXNotImplemented: If the input graph is undirected.\nMethods: []\nRubrics:",
    "Section ID: partial_duplication_graph\nDescription: [Returns a random graph using the partial duplication model.]\nField List: Parameters:: N : int: The total number of nodes in the final graph.\nn : int: The number of nodes in the initial clique.\np : float: The probability of joining each neighbor of a node to the\nduplicate node. Must be a number in the between zero and one,\ninclusive.\nq : float: The probability of joining the source node to the duplicate\nnode. Must be a number in the between zero and one, inclusive.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nMethods: []\nRubrics: Notes: A graph of nodes is grown by creating a fully connected graph\nof size n . The following procedure is then repeated until\na total of N nodes have been reached.\nReferences: [1]Knudsen Michael, and Carsten Wiuf. “A Markov chain approach to\nrandomly grown graphs.” Journal of Applied Mathematics 2008.\n<https://doi.org/10.1155/2008/190836>",
    "Section ID: simrank_similarity\nDescription: [Returns the SimRank similarity of nodes in the graph G ., SimRank is a similarity metric that says “two objects are considered\nto be similar if they are referenced by similar objects.” [1] ., The pseudo-code definition from the paper is:, where G is the graph, u is the source, v is the target,\nand C is a float decay or importance factor between 0 and 1., The SimRank algorithm for determining node similarity is defined in [2] .]\nField List: Parameters:: G : NetworkX graph: A NetworkX graph\nsource : node: If this is specified, the returned dictionary maps each nodevin the graph to the similarity betweensourceandv.\ntarget : node: If bothsourceandtargetare specified, the similarity\nvalue betweensourceandtargetis returned. Iftargetis specified butsourceis not, this argument is\nignored.\nimportance_factor : float: The relative importance of indirect neighbors with respect to\ndirect neighbors.\nmax_iterations : integer: Maximum number of iterations.\ntolerance : float: Error tolerance used to check convergence. When an iteration of\nthe algorithm finds that no similarity value changes more than\nthis amount, the algorithm halts.\nReturns:: similarity : dictionary or float: Ifsourceandtargetare bothNone, this returns a\ndictionary of dictionaries, where keys are node pairs and value\nare similarity of the pair of nodes.Ifsourceis notNonebuttargetis, this returns a\ndictionary mapping node to the similarity ofsourceand that\nnode.If neithersourcenortargetisNone, this returns\nthe similarity value for the given pair of nodes.\nRaises:: ExceededMaxIterations: If the algorithm does not converge withinmax_iterations.\nNodeNotFound: If eithersourceortargetis not inG.\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/SimRank  [2]G. Jeh and J. Widom.\n“SimRank: a measure of structural-context similarity”,\nIn KDD’02: Proceedings of the Eighth ACM SIGKDD\nInternational Conference on Knowledge Discovery and Data Mining,\npp. 538–543. ACM Press, 2002.\nExamples: G=nx.cycle_graph(2)\nnx.simrank_similarity(G)\n# {0: {0: 1.0, 1: 0.0}, 1: {0: 0.0, 1: 1.0}}\nnx.simrank_similarity(G,source=0)\n# {0: 1.0, 1: 0.0}\nnx.simrank_similarity(G,source=0,target=0)\n# 1.0\nThe result of this function can be converted to a numpy array\nrepresenting the SimRank matrix by using the node order of the\ngraph to determine which row and column represent each node.\nOther ordering of nodes is also possible.\nimportnumpyasnp\nsim=nx.simrank_similarity(G)\nnp.array([[sim[u][v]forvinG]foruinG])\n# array([[1., 0.],\n#        [0., 1.]])\nsim_1d=nx.simrank_similarity(G,source=0)\nnp.array([sim[0][v]forvinG])\n# array([1., 0.])",
    "Section ID: node_link_graph\nDescription: [Returns graph from node-link data format.\nUseful for de-serialization from JSON.]\nField List: Parameters:: data : dict: node-link formatted graph data\ndirected : bool: If True, and direction not specified in data, return a directed graph.\nmultigraph : bool: If True, and multigraph not specified in data, return a multigraph.\nsource : string: A string that provides the ‘source’ attribute name for storing NetworkX-internal graph data.\ntarget : string: A string that provides the ‘target’ attribute name for storing NetworkX-internal graph data.\nname : string: A string that provides the ‘name’ attribute name for storing NetworkX-internal graph data.\nkey : string: A string that provides the ‘key’ attribute name for storing NetworkX-internal graph data.\nlink : string: A string that provides the ‘link’ attribute name for storing NetworkX-internal graph data.\nReturns:: G : NetworkX graph: A NetworkX graph object\nMethods: []\nRubrics: Notes: Attribute ‘key’ is only used for multigraphs. To use node_link_data in conjunction with node_link_graph ,\nthe keyword names for the attributes must match.\nExamples: Create data in node-link format by converting a graph.\nG=nx.Graph([(\"A\",\"B\")])\ndata=nx.node_link_data(G)\ndata\n# {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\nRevert data in node-link format to a graph.\nH=nx.node_link_graph(data)\nprint(H.edges)\n# [('A', 'B')]\nTo serialize and deserialize a graph with JSON,\nimportjson\nd=json.dumps(node_link_data(G))\nH=node_link_graph(json.loads(d))\nprint(G.edges,H.edges)\n# [('A', 'B')] [('A', 'B')]",
    "Section ID: k_edge_components\nDescription: [Generates nodes in each maximal k-edge-connected component in G.]\nField List: Parameters:: G : NetworkX graph: \nk : Integer: Desired edge connectivity\nReturns:: k_edge_components : a generator of k-edge-ccs. Each set of returned nodes: will have k-edge-connectivity in the graph G.\nRaises:: NetworkXNotImplemented: If the input graph is a multigraph.\nValueError:: If k is less than 1\nMethods: []\nRubrics: Notes: Attempts to use the most efficient implementation available based on k.\nIf k=1, this is simply connected components for directed graphs and\nconnected components for undirected graphs.\nIf k=2 on an efficient bridge connected component algorithm from _[1] is\nrun based on the chain decomposition.\nOtherwise, the algorithm from _[2] is used.\nReferences: [1]https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29  [2]Wang, Tianhao, et al. (2015) A simple algorithm for finding all\nk-edge-connected components.http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264\nExamples: importitertoolsasit\nfromnetworkx.utilsimportpairwise\npaths=[\n(1,2,4,3,1,4),\n(5,6,7,8,5,7,8,6),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# note this returns {1, 4} unlike k_edge_subgraphs\nsorted(map(sorted,nx.k_edge_components(G,k=3)))\n# [[1, 4], [2], [3], [5, 6, 7, 8]]",
    "Section ID: laplacian_matrix\nDescription: [Returns the Laplacian matrix of G., The graph Laplacian is the matrix L = D - A, where\nA is the adjacency matrix and D is the diagonal matrix of node degrees.]\nField List: Parameters:: G : graph: A NetworkX graph\nnodelist : list, optional: The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().\nweight : string or None, optional (default=’weight’): The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.\nReturns:: L : SciPy sparse array: The Laplacian matrix of G.\nMethods: []\nRubrics: Notes: For MultiGraph, the edges weights are summed. This returns an unnormalized matrix. For a normalized output,\nuse normalized_laplacian_matrix , directed_laplacian_matrix ,\nor directed_combinatorial_laplacian_matrix . This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.\nReferences: [1]Langville, Amy N., and Carl D. Meyer. Google’s PageRank and Beyond:\nThe Science of Search Engine Rankings. Princeton University Press, 2006.\nExamples: For graphs with multiple connected components, L is permutation-similar\nto a block diagonal matrix where each block is the respective Laplacian\nmatrix for each component.\nG=nx.Graph([(1,2),(2,3),(4,5)])\nprint(nx.laplacian_matrix(G).toarray())\n# [[ 1 -1  0  0  0]\n#  [-1  2 -1  0  0]\n#  [ 0 -1  1  0  0]\n#  [ 0  0  0  1 -1]\n#  [ 0  0  0 -1  1]]\nedges=[\n(1,2),\n(2,1),\n(2,4),\n(4,3),\n(3,4),\n]\nDiG=nx.DiGraph(edges)\nprint(nx.laplacian_matrix(DiG).toarray())\n# [[ 1 -1  0  0]\n#  [-1  2 -1  0]\n#  [ 0  0  1 -1]\n#  [ 0  0 -1  1]]\nNotice that node 4 is represented by the third column and row. This is because\nby default the row/column order is the order ofG.nodes(i.e. the node added\norder – in the edgelist, 4 first appears in (2, 4), before node 3 in edge (4, 3).)\nTo control the node order of the matrix, use thenodelistargument.\nprint(nx.laplacian_matrix(DiG,nodelist=[1,2,3,4]).toarray())\n# [[ 1 -1  0  0]\n#  [-1  2  0 -1]\n#  [ 0  0  1 -1]\n#  [ 0  0 -1  1]]\nThis calculation uses the out-degree of the graphG. To use the\nin-degree for calculations instead, useG.reverse(copy=False)and\ntake the transpose.\nprint(nx.laplacian_matrix(DiG.reverse(copy=False)).toarray().T)\n# [[ 1 -1  0  0]\n#  [-1  1 -1  0]\n#  [ 0  0  2 -1]\n#  [ 0  0 -1  1]]",
    "Section ID: flow_hierarchy\nDescription: [Returns the flow hierarchy of a directed network., Flow hierarchy is defined as the fraction of edges not participating\nin cycles in a directed graph [1] .]\nField List: Parameters:: G : DiGraph or MultiDiGraph: A directed graph\nweight : string, optional (default=None): Attribute to use for edge weights. If None the weight defaults to 1.\nReturns:: h : float: Flow hierarchy value\nMethods: []\nRubrics: Notes: The algorithm described in [1] computes the flow hierarchy through\nexponentiation of the adjacency matrix.  This function implements an\nalternative approach that finds strongly connected components.\nAn edge is in a cycle if and only if it is in a strongly connected\ncomponent, which can be found in \\(O(m)\\) time using Tarjan’s algorithm.\nReferences: [1](1,2)Luo, J.; Magee, C.L. (2011),\nDetecting evolving patterns of self-organizing networks by flow\nhierarchy measurement, Complexity, Volume 16 Issue 6 53-61.\nDOI: 10.1002/cplx.20368http://web.mit.edu/~cmagee/www/documents/28-DetectingEvolvingPatterns_FlowHierarchy.pdf",
    "Section ID: edge_current_flow_betweenness_centrality_subset\nDescription: [Compute current-flow betweenness centrality for edges using subsets\nof nodes., Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths., Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] .]\nField List: Parameters:: G : graph: A NetworkX graph\nsources: list of nodes: Nodes to use as sources for current\ntargets: list of nodes: Nodes to use as sinks for current\nnormalized : bool, optional (default=True): If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.\nweight : string or None, optional (default=None): Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.\ndtype: data type (float): Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.\nsolver: string (default=’lu’): Type of linear solver to use for computing the flow matrix.\nOptions are “full” (uses most memory), “lu” (recommended), and\n“cg” (uses least memory).\nReturns:: nodes : dict: Dictionary of edge tuples with betweenness centrality as the value.\nMethods: []\nRubrics: Notes: Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a ‘weight’ attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\nReferences: [1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS ‘05).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005).",
    "Section ID: max_weight_clique\nDescription: [Find a maximum weight clique in G., A clique in a graph is a set of nodes such that every two distinct nodes\nare adjacent.  The weight of a clique is the sum of the weights of its\nnodes.  A maximum weight clique of graph G is a clique C in G such that\nno clique in G has weight greater than the weight of C.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nweight : string or None, optional (default=’weight’): The node attribute that holds the integer value used as a weight.\nIf None, then each node has weight 1.\nReturns:: clique : list: the nodes of a maximum weight clique\nweight : int: the weight of a maximum weight clique\nMethods: []\nRubrics: Notes: The implementation is recursive, and therefore it may run into recursion\ndepth issues if G contains a clique whose number of nodes is close to the\nrecursion depth limit. At each search node, the algorithm greedily constructs a weighted\nindependent set cover of part of the graph in order to find a small set of\nnodes on which to branch.  The algorithm is very similar to the algorithm\nof Tavares et al. [1] , other than the fact that the NetworkX version does\nnot use bitsets.  This style of algorithm for maximum weight clique (and\nmaximum weight independent set, which is the same problem but on the\ncomplement graph) has a decades-long history.  See Algorithm B of Warren\nand Hicks [2] and the references in that paper.\nReferences: [1]Tavares, W.A., Neto, M.B.C., Rodrigues, C.D., Michelon, P.: Um\nalgoritmo de branch and bound para o problema da clique máxima\nponderada.  Proceedings of XLVII SBPO 1 (2015).  [2]Warren, Jeffrey S, Hicks, Illya V.: Combinatorial Branch-and-Bound\nfor the Maximum Weight Independent Set Problem.  Technical Report,\nTexas A&M University (2016).",
    "Section ID: cycle_graph\nDescription: [Returns the cycle graph \\(C_n\\) of cyclically connected nodes., \\(C_n\\) is a path with its two end-nodes connected., ( Sourcecode , png )]\nField List: Parameters:: n : int or iterable container of nodes: If n is an integer, nodes are fromrange(n).\nIf n is a container of nodes, those nodes appear in the graph.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nMethods: []\nRubrics: Notes: If create_using is directed, the direction is in increasing order.",
    "Section ID: stoer_wagner\nDescription: [Returns the weighted minimum edge cut using the Stoer-Wagner algorithm., Determine the minimum edge cut of a connected graph using the\nStoer-Wagner algorithm. In weighted cases, all weights must be\nnonnegative., The running time of the algorithm depends on the type of heaps used:]\nField List: Parameters:: G : NetworkX graph: Edges of the graph are expected to have an attribute named by the\nweight parameter below. If this attribute is not present, the edge is\nconsidered to have unit weight.\nweight : string: Name of the weight attribute of the edges. If the attribute is not\npresent, unit weight is assumed. Default value: ‘weight’.\nheap : class: Type of heap to be used in the algorithm. It should be a subclass ofMinHeapor implement a compatible interface.If a stock heap implementation is to be used,BinaryHeapis\nrecommended overPairingHeapfor Python implementations without\noptimized attribute accesses (e.g., CPython) despite a slower\nasymptotic running time. For Python implementations with optimized\nattribute accesses (e.g., PyPy),PairingHeapprovides better\nperformance. Default value:BinaryHeap.\nReturns:: cut_value : integer or float: The sum of weights of edges in a minimum cut.\npartition : pair of node lists: A partitioning of the nodes that defines a minimum cut.\nRaises:: NetworkXNotImplemented: If the graph is directed or a multigraph.\nNetworkXError: If the graph has less than two nodes, is not connected or has a\nnegative-weighted edge.\nMethods: []\nRubrics: Examples: G=nx.Graph()\nG.add_edge(\"x\",\"a\",weight=3)\nG.add_edge(\"x\",\"b\",weight=1)\nG.add_edge(\"a\",\"c\",weight=3)\nG.add_edge(\"b\",\"c\",weight=5)\nG.add_edge(\"b\",\"d\",weight=4)\nG.add_edge(\"d\",\"e\",weight=2)\nG.add_edge(\"c\",\"y\",weight=2)\nG.add_edge(\"e\",\"y\",weight=3)\ncut_value,partition=nx.stoer_wagner(G)\ncut_value\n# 4",
    "Section ID: from_pandas_adjacency\nDescription: [Returns a graph from Pandas DataFrame., The Pandas DataFrame is interpreted as an adjacency matrix for the graph.]\nField List: Parameters:: df : Pandas DataFrame: An adjacency matrix representation of a graph\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nMethods: []\nRubrics: Notes: For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of df corresponds to an edge from i to j. If df has a single data type for each entry it will be converted to an\nappropriate Python data type. If you have node attributes stored in a separate dataframe df_nodes ,\nyou can load those attributes to the graph G using the following code: `df_nodes=pd.DataFrame({\"node_id\":[1,2,3],\"attribute1\":[\"A\",\"B\",\"C\"]})G.add_nodes_from((n,dict(d))forn,dindf_nodes.iterrows())` If df has a user-specified compound data type the names\nof the data fields will be used as attribute keys in the resulting\nNetworkX graph.\nExamples: Simple integer weights on edges:\nimportpandasaspd\npd.options.display.max_columns=20\ndf=pd.DataFrame([[1,1],[2,1]])\ndf\n#    0  1\n# 0  1  1\n# 1  2  1\nG=nx.from_pandas_adjacency(df)\nG.name=\"Graph from pandas adjacency matrix\"\nprint(G)\n# Graph named 'Graph from pandas adjacency matrix' with 2 nodes and 3 edges",
    "Section ID: spectral_ordering\nDescription: [Compute the spectral_ordering of a graph., The spectral ordering of a graph is an ordering of its nodes where nodes\nin the same weakly connected components appear contiguous and ordered by\ntheir corresponding elements in the Fiedler vector of the component.]\nField List: Parameters:: G : NetworkX graph: A graph.\nweight : object, optional (default: None): The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.\nnormalized : bool, optional (default: False): Whether the normalized Laplacian matrix is used.\ntol : float, optional (default: 1e-8): Tolerance of relative residual in eigenvalue computation.\nmethod : string, optional (default: ‘tracemin_pcg’): Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), ‘lanczos’ (Lanczos iteration)\nor ‘lobpcg’ (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver‘tracemin_pcg’Preconditioned conjugate gradient method‘tracemin_lu’LU factorization\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: spectral_ordering : NumPy array of floats.: Spectral ordering of nodes.\nRaises:: NetworkXError: If G is empty.\nMethods: []\nRubrics: Notes: Edge weights are interpreted by their absolute values. For MultiGraph’s,\nweights of parallel edges are summed. Zero-weighted edges are ignored.",
    "Section ID: numeric_assortativity_coefficient\nDescription: [Compute assortativity for numerical node attributes., Assortativity measures the similarity of connections\nin the graph with respect to the given numeric attribute.]\nField List: Parameters:: G : NetworkX graph: \nattribute : string: Node attribute key.\nnodes: list or iterable (optional): Compute numeric assortativity only for attributes of nodes in\ncontainer. The default is all nodes.\nReturns:: r: float: Assortativity of graph for given attribute\nMethods: []\nRubrics: Notes: This computes Eq. (21) in Ref. [1] , which is the Pearson correlation\ncoefficient of the specified (scalar valued) attribute across edges.\nReferences: [1]M. E. J. Newman, Mixing patterns in networks\nPhysical Review E, 67 026126, 2003\nExamples: G=nx.Graph()\nG.add_nodes_from([0,1],size=2)\nG.add_nodes_from([2,3],size=3)\nG.add_edges_from([(0,1),(2,3)])\nprint(nx.numeric_assortativity_coefficient(G,\"size\"))\n# 1.0",
    "Section ID: degrees\nDescription: [Returns the degrees of the two node sets in the bipartite graph B.]\nField List: Parameters:: B : NetworkX graph: \nnodes: list or container: Nodes in one node set of the bipartite graph.\nweight : string or None, optional (default=None): The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.\nReturns:: (degX,degY) : tuple of dictionaries: The degrees of the two bipartite sets as dictionaries keyed by node.\nMethods: []\nRubrics: Notes: The container of nodes passed as argument must contain all nodes\nin one of the two bipartite node sets to avoid ambiguity in the\ncase of disconnected graphs.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.complete_bipartite_graph(3,2)\nY=set([3,4])\ndegX,degY=bipartite.degrees(G,Y)\ndict(degX)\n# {0: 2, 1: 2, 2: 2}",
    "Section ID: treewidth_min_degree\nDescription: [Returns a treewidth decomposition using the Minimum Degree heuristic., The heuristic chooses the nodes according to their degree, i.e., first\nthe node with the lowest degree is chosen, then the graph is updated\nand the corresponding node is removed. Next, a new node with the lowest\ndegree is chosen, and so on.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: Treewidth decomposition : (int, Graph) tuple: 2-tuple with treewidth and the corresponding decomposed tree.\nMethods: []\nRubrics:",
    "Section ID: argmap\nDescription: [A decorator to apply a map to arguments before calling the function, This class provides a decorator that maps (transforms) arguments of the function\nbefore the function is called. Thus for example, we have similar code\nin many functions to determine whether an argument is the number of nodes\nto be created, or a list of nodes to be handled. The decorator provides\nthe code to accept either – transforming the indicated argument into a\nlist of nodes before the actual function is called., This decorator class allows us to process single or multiple arguments.\nThe arguments to be processed can be specified by string, naming the argument,\nor by index, specifying the item in the args list.]\nField List: Parameters:: func : callable: The function to apply to arguments\n*args : iterable of (int, str or tuple): A list of parameters, specified either as strings (their names), ints\n(numerical indices) or tuples, which may contain ints, strings, and\n(recursively) tuples. Each indicates which parameters the decorator\nshould map. Tuples indicate that the map function takes (and returns)\nmultiple parameters in the same order and nested structure as indicated\nhere.\ntry_finally : bool (default: False): When True, wrap the function call in a try-finally block with code\nfor the finally block created byfunc. This is used when the map\nfunction constructs an object (like a file handle) that requires\npost-processing (like closing).Note: try_finally decorators cannot be used to decorate generator\nfunctions.\nMethods: []\nRubrics: Notes: An object of this class is callable and intended to be used when\ndefining a decorator. Generally, a decorator takes a function as input\nand constructs a function as output. Specifically, an argmap object\nreturns the input function decorated/wrapped so that specified arguments\nare mapped (transformed) to new values before the decorated function is called. As an overview, the argmap object returns a new function with all the\ndunder values of the original function (like __doc__ , __name__ , etc).\nCode for this decorated function is built based on the original function’s\nsignature. It starts by mapping the input arguments to potentially new\nvalues. Then it calls the decorated function with these new values in place\nof the indicated arguments that have been mapped. The return value of the\noriginal function is then returned. This new function is the function that\nis actually called by the user.\nExamples: Most of these examples use@argmap(...)to apply the decorator to\nthe function defined on the next line.\nIn the NetworkX codebase however,argmapis used within a function to\nconstruct a decorator. That is, the decorator defines a mapping function\nand then usesargmapto build and return a decorated function.\nA simple example is a decorator that specifies which currency to report money.\nThe decorator (namedconvert_to) would be used like:\n@convert_to(\"US_Dollars\",\"income\")defshow_me_the_money(name,income):print(f\"{name} : {income}\")\nAnd the code to create the decorator might be:\ndefconvert_to(currency,which_arg):def_convert(amount):ifamount.currency!=currency:amount=amount.to_currency(currency)returnamountreturnargmap(_convert,which_arg)\nDespite this common idiom for argmap, most of the following examples\nuse the@argmap(...)idiom to save space.\nHere’s an example use of argmap to sum the elements of two of the functions\narguments. The decorated function:\n@argmap(sum,\"xlist\",\"zlist\")deffoo(xlist,y,zlist):returnxlist-y+zlist\nis syntactic sugar for:\ndeffoo(xlist,y,zlist):x=sum(xlist)z=sum(zlist)returnx-y+z\nand is equivalent to (using argument indexes):\n@argmap(sum,\"xlist\",2)deffoo(xlist,y,zlist):returnxlist-y+zlist\nor:\n@argmap(sum,\"zlist\",0)deffoo(xlist,y,zlist):returnxlist-y+zlist\nTransforming functions can be applied to multiple arguments, such as:\ndefswap(x,y):returny,x# the 2-tuple tells argmap that the map `swap` has 2 inputs/outputs.@argmap(swap,(\"a\",\"b\")):deffoo(a,b,c):returna/b*c\nis equivalent to:\ndeffoo(a,b,c):a,b=swap(a,b)returna/b*c\nMore generally, the applied arguments can be nested tuples of strings or ints.\nThe syntax@argmap(some_func,(\"a\",(\"b\",\"c\")))would expectsome_functo\naccept 2 inputs with the second expected to be a 2-tuple. It should then return\n2 outputs with the second a 2-tuple. The returns values would replace input “a”\n“b” and “c” respectively. Similarly for@argmap(some_func,(0,(\"b\",2))).\nAlso, note that an index larger than the number of named parameters is allowed\nfor variadic functions. For example:\ndefdouble(a):return2*a@argmap(double,3)defoverflow(a,*args):returna,argsprint(overflow(1,2,3,4,5,6))# output is 1, (2, 3, 8, 5, 6)\nTry Finally\nAdditionally, thisargmapclass can be used to create a decorator that\ninitiates a try…finally block. The decorator must be written to return\nboth the transformed argument and a closing function.\nThis feature was included to enable theopen_filedecorator which might\nneed to close the file or not depending on whether it had to open that file.\nThis feature uses the keyword-onlytry_finallyargument to@argmap.\nFor example this map opens a file and then makes sure it is closed:\ndefopen_file(fn):f=open(fn)returnf,lambda:f.close()\nThe decorator applies that to the functionfoo:\n@argmap(open_file,\"file\",try_finally=True)deffoo(file):print(file.read())\nis syntactic sugar for:\ndeffoo(file):file,close_file=open_file(file)try:print(file.read())finally:close_file()\nand is equivalent to (using indexes):\n@argmap(open_file,0,try_finally=True)deffoo(file):print(file.read())\nHere’s an example of the try_finally feature used to create a decorator:\ndefmy_closing_decorator(which_arg):def_opener(path):ifpathisNone:path=open(path)fclose=path.closeelse:# assume `path` handles the closingfclose=lambda:Nonereturnpath,fclosereturnargmap(_opener,which_arg,try_finally=True)\nwhich can then be used as:\n@my_closing_decorator(\"file\")deffancy_reader(file=None):# this code doesn't need to worry about closing the fileprint(file.read())\nDecorators with try_finally = True cannot be used with generator functions,\nbecause thefinallyblock is evaluated before the generator is exhausted:\n@argmap(open_file,\"file\",try_finally=True)deffile_to_lines(file):forlineinfile.readlines():yieldline\nis equivalent to:\ndeffile_to_lines_wrapped(file):forlineinfile.readlines():yieldlinedeffile_to_lines_wrapper(file):try:file=open_file(file)returnfile_to_lines_wrapped(file)finally:file.close()\nwhich behaves similarly to:\ndeffile_to_lines_whoops(file):file=open_file(file)file.close()forlineinfile.readlines():yieldline\nbecause thefinallyblock offile_to_lines_wrapperis executed before\nthe caller has a chance to exhaust the iterator.",
    "Section ID: reverse_cuthill_mckee_ordering\nDescription: [Generate an ordering (permutation) of the graph nodes to make\na sparse matrix., Uses the reverse Cuthill-McKee heuristic (based on breadth-first search) [1] .]\nField List: Parameters:: G : graph: A NetworkX graph\nheuristic : function, optional: Function to choose starting node for RCM algorithm.  If None\na node from a pseudo-peripheral pair is used.  A user-defined function\ncan be supplied that takes a graph object and returns a single node.\nReturns:: nodes : generator: Generator of nodes in reverse Cuthill-McKee ordering.\nMethods: []\nRubrics: Notes: The optimal solution the bandwidth reduction is NP-complete [2] .\nReferences: [1]E. Cuthill and J. McKee.\nReducing the bandwidth of sparse symmetric matrices,\nIn Proc. 24th Nat. Conf. ACM, pages 157-72, 1969.http://doi.acm.org/10.1145/800195.805928  [2]Steven S. Skiena. 1997. The Algorithm Design Manual.\nSpringer-Verlag New York, Inc., New York, NY, USA.\nExamples: fromnetworkx.utilsimportreverse_cuthill_mckee_ordering\nG=nx.path_graph(4)\nrcm=list(reverse_cuthill_mckee_ordering(G))\nA=nx.adjacency_matrix(G,nodelist=rcm)\nSmallest degree node as heuristic function:\ndefsmallest_degree(G):\nreturnmin(G,key=G.degree)\nrcm=list(reverse_cuthill_mckee_ordering(G,heuristic=smallest_degree))",
    "Section ID: maximal_extendability\nDescription: [Computes the extendability of a graph., The extendability of a graph is defined as the maximum \\(k\\) for which G is \\(k\\) -extendable. Graph G is \\(k\\) -extendable if and only if G has a\nperfect matching and every set of \\(k\\) independent edges can be extended\nto a perfect matching in G .]\nField List: Parameters:: G : NetworkX Graph: A fully-connected bipartite graph without self-loops\nReturns:: extendability : int:\nRaises:: NetworkXError: If the graphGis disconnected.\nIf the graphGis not bipartite.\nIf the graphGdoes not contain a perfect matching.\nIf the residual graph ofGis not strongly connected.\nMethods: []\nRubrics: Notes: Definition:\nLet G be a simple, connected, undirected and bipartite graph with a perfect\nmatching M and bipartition (U,V). The residual graph of G , denoted by \\(G_M\\) ,\nis the graph obtained from G by directing the edges of M from V to U and the\nedges that do not belong to M from U to V. Lemma [1] :\nLet M be a perfect matching of G . G is \\(k\\) -extendable if and only if its residual\ngraph \\(G_M\\) is strongly connected and there are \\(k\\) vertex-disjoint directed\npaths between every vertex of U and every vertex of V. Assuming that input graph G is undirected, simple, connected, bipartite and contains\na perfect matching M, this function constructs the residual graph \\(G_M\\) of G and\nreturns the minimum value among the maximum vertex-disjoint directed paths between\nevery vertex of U and every vertex of V in \\(G_M\\) . By combining the definitions\nand the lemma, this value represents the extendability of the graph G . Time complexity O( \\(n^3\\)  \\(m^2\\) )) where \\(n\\) is the number of vertices\nand \\(m\\) is the number of edges.\nReferences: [1]“A polynomial algorithm for the extendability problem in bipartite graphs”,\nJ. Lakhal, L. Litzler, Information Processing Letters, 1998.  [2]“On n-extendible graphs”, M. D. Plummer, Discrete Mathematics, 31:201–210, 1980https://doi.org/10.1016/0012-365X(80)90037-0",
    "Section ID: dfs_predecessors\nDescription: [Returns dictionary of predecessors in depth-first-search from source.]\nField List: Parameters:: G : NetworkX graph: \nsource : node, optional: Specify starting node for depth-first search.\nNote that you will get predecessors for all nodes in the\ncomponent containingsource. This input only specifies\nwhere the DFS starts.\ndepth_limit : int, optional (default=len(G)): Specify the maximum search depth.\nsort_neighbors : function (default=None): A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order.\nReturns:: pred: dict: A dictionary with nodes as keys and predecessor nodes as values.\nMethods: []\nRubrics: Notes: If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein’s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n“ Depth-limited search ”.\nExamples: G=nx.path_graph(4)\nnx.dfs_predecessors(G,source=0)\n# {1: 0, 2: 1, 3: 2}\nnx.dfs_predecessors(G,source=0,depth_limit=2)\n# {1: 0, 2: 1}",
    "Section ID: number_of_walks\nDescription: [Returns the number of walks connecting each pair of nodes in G, A walk is a sequence of nodes in which each adjacent pair of nodes\nin the sequence is adjacent in the graph. A walk can repeat the same\nedge and go in the opposite direction just as people can walk on a\nset of paths, but standing still is not counted as part of the walk., This function only counts the walks with walk_length edges. Note that\nthe number of nodes in the walk sequence is one more than walk_length .\nThe number of walks can grow very quickly on a larger graph\nand with a larger walk length.]\nField List: Parameters:: G : NetworkX graph: \nwalk_length : int: A nonnegative integer representing the length of a walk.\nReturns:: dict: A dictionary of dictionaries in which outer keys are source\nnodes, inner keys are target nodes, and inner values are the\nnumber of walks of lengthwalk_lengthconnecting those nodes.\nRaises:: ValueError: Ifwalk_lengthis negative\nMethods: []\nRubrics: Examples: G=nx.Graph([(0,1),(1,2)])\nwalks=nx.number_of_walks(G,2)\nwalks\n# {0: {0: 1, 1: 0, 2: 1}, 1: {0: 0, 1: 2, 2: 0}, 2: {0: 1, 1: 0, 2: 1}}\ntotal_walks=sum(sum(tgts.values())for_,tgtsinwalks.items())\nYou can also get the number of walks from a specific source node using the\nreturned dictionary. For example, number of walks of length 1 from node 0\ncan be found as follows:\nwalks=nx.number_of_walks(G,1)\nwalks[0]\n# {0: 0, 1: 1, 2: 0}\nsum(walks[0].values())# walks from 0 of length 1\n# 1\nSimilarly, a target node can also be specified:\nwalks[0][1]\n# 1",
    "Section ID: to_graph6_bytes\nDescription: [Convert a simple undirected graph to bytes in graph6 format.]\nField List: Parameters:: G : Graph (undirected): \nnodes: list or iterable: Nodes are labeled 0…n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.\nheader: bool: If True add ‘>>graph6<<’ bytes to head of data.\nRaises:: NetworkXNotImplemented: If the graph is directed or is a multigraph.\nValueError: If the graph has at least2**36nodes; the graph6 format\nis only defined for graphs of order less than2**36.\nMethods: []\nRubrics: Notes: The returned bytes end with a newline character. The format does not support edge or node labels, parallel edges or\nself loops. If self loops are present they are silently ignored.\nReferences: [1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>\nExamples: nx.to_graph6_bytes(nx.path_graph(2))\n# b'>>graph6<<A_\\n'",
    "Section ID: dual_barabasi_albert_graph\nDescription: [Returns a random graph using dual Barabási–Albert preferential attachment, A graph of \\(n\\) nodes is grown by attaching new nodes each with either \\(m_1\\) edges (with probability \\(p\\) ) or \\(m_2\\) edges (with probability \\(1-p\\) ) that\nare preferentially attached to existing nodes with high degree.]\nField List: Parameters:: n : int: Number of nodes\nm1 : int: Number of edges to link each new node to existing nodes with probability\\(p\\)\nm2 : int: Number of edges to link each new node to existing nodes with probability\\(1-p\\)\np : float: The probability of attaching\\(m_1\\)edges (as opposed to\\(m_2\\)edges)\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ninitial_graph : Graph or None (default): Initial network for Barabási–Albert algorithm.\nA copy ofinitial_graphis used.\nIt should be connected for most use cases.\nIf None, starts from an star graph on max(m1, m2) + 1 nodes.\nReturns:: G : Graph:\nRaises:: NetworkXError: Ifm1andm2do not satisfy1<=m1,m2<n, orpdoes not satisfy0<=p<=1, or\nthe initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\nMethods: []\nRubrics: References: [1]Moshiri “The dual-Barabasi-Albert model”, arXiv:1810.10538.",
    "Section ID: margulis_gabber_galil_graph\nDescription: [Returns the Margulis-Gabber-Galil undirected MultiGraph on n^2 nodes., The undirected MultiGraph is regular with degree 8 . Nodes are integer\npairs. The second-largest eigenvalue of the adjacency matrix of the graph\nis at most 5sqrt{2} , regardless of n .]\nField List: Parameters:: n : int: Determines the number of nodes in the graph:n^2.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : graph: The constructed undirected multigraph.\nRaises:: NetworkXError: If the graph is directed or not a multigraph.\nMethods: []\nRubrics:",
    "Section ID: single_source_shortest_path_length\nDescription: [Compute the shortest path lengths from source to all reachable nodes.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path\ncutoff : integer, optional: Depth to stop the search. Only paths of length <= cutoff are returned.\nReturns:: lengths : dict: Dict keyed by node to shortest path length to source.\nMethods: []\nRubrics: Examples: G=nx.path_graph(5)\nlength=nx.single_source_shortest_path_length(G,0)\nlength[4]\n# 4\nfornodeinlength:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4",
    "Section ID: ancestors\nDescription: [Returns all nodes having a path to source in G .]\nField List: Parameters:: G : NetworkX Graph: \nsource : node inG:\nReturns:: set(): The ancestors ofsourceinG\nRaises:: NetworkXError: If nodesourceis not inG.\nMethods: []\nRubrics: Examples: DG=nx.path_graph(5,create_using=nx.DiGraph)\nsorted(nx.ancestors(DG,2))\n# [0, 1]\nThesourcenode is not an ancestor of itself, but can be included manually:\nsorted(nx.ancestors(DG,2)|{2})\n# [0, 1, 2]",
    "Section ID: union\nDescription: []\nField List: Methods: []\nRubrics:",
    "Section ID: edge_subgraph\nDescription: [Returns a view of the subgraph induced by the specified edges., The induced subgraph contains each edge in edges and each\nnode incident to any of those edges.]\nField List: Parameters:: G : NetworkX Graph: \nedges : iterable: An iterable of edges. Edges not present inGare ignored.\nReturns:: subgraph : SubGraph View: A read-only edge-induced subgraph ofG.\nChanges toGare reflected in the view.\nMethods: []\nRubrics: Notes: To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) If you create a subgraph of a subgraph recursively you can end up\nwith a chain of subgraphs that becomes very slow with about 15\nnested subgraph views. Luckily the edge_subgraph filter nests\nnicely so you can use the original graph as G in this function\nto avoid chains. We do not rule out chains programmatically so\nthat odd cases like an edge_subgraph of a restricted_view can be created.\nExamples: G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]",
    "Section ID: single_target_shortest_path\nDescription: [Compute shortest path to target from all nodes that reach target.]\nField List: Parameters:: G : NetworkX graph: \ntarget : node label: Target node for path\ncutoff : integer, optional: Depth to stop the search. Only paths of length <= cutoff are returned.\nReturns:: paths : dictionary: Dictionary, keyed by target, of shortest paths.\nMethods: []\nRubrics: Notes: The shortest path is not necessarily unique. So there can be multiple\npaths between the source and each target node, all of which have the\nsame ‘shortest’ length. For each target node, this function returns\nonly one of those paths.\nExamples: G=nx.path_graph(5,create_using=nx.DiGraph())\npath=nx.single_target_shortest_path(G,4)\npath[0]\n# [0, 1, 2, 3, 4]",
    "Section ID: find_asteroidal_triple\nDescription: [Find an asteroidal triple in the given graph., An asteroidal triple is a triple of non-adjacent vertices such that\nthere exists a path between any two of them which avoids the closed\nneighborhood of the third. It checks all independent triples of vertices\nand whether they are an asteroidal triple or not. This is done with the\nhelp of a data structure called a component structure.\nA component structure encodes information about which vertices belongs to\nthe same connected component when the closed neighborhood of a given vertex\nis removed from the graph. The algorithm used to check is the trivial\none, outlined in [1] , which has a runtime of \\(O(|V||\\overline{E} + |V||E|)\\) , where the second term is the\ncreation of the component structure.]\nField List: Parameters:: G : NetworkX Graph: The graph to check whether is AT-free or not\nReturns:: list or None: An asteroidal triple is returned as a list of nodes. If no asteroidal\ntriple exists, i.e. the graph is AT-free, then None is returned.\nThe returned value depends on the certificate parameter. The default\noption is a bool which is True if the graph is AT-free, i.e. the\ngiven graph contains no asteroidal triples, and False otherwise, i.e.\nif the graph contains at least one asteroidal triple.\nMethods: []\nRubrics: Notes: The component structure and the algorithm is described in [1] . The current\nimplementation implements the trivial algorithm for simple graphs.\nReferences: [1](1,2)Ekkehard Köhler,\n“Recognizing Graphs without asteroidal triples”,\nJournal of Discrete Algorithms 2, pages 439-452, 2004.https://www.sciencedirect.com/science/article/pii/S157086670400019X",
    "Section ID: color\nDescription: [Returns a two-coloring of the graph., Raises an exception if the graph is not bipartite.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: color : dictionary: A dictionary keyed by node with a 1 or 0 as data for each node color.\nRaises:: NetworkXError: If the graph is not two-colorable.\nMethods: []\nRubrics: Examples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nc=bipartite.color(G)\nprint(c)\n# {0: 1, 1: 0, 2: 1, 3: 0}\nYou can use this to set a node attribute indicating the bipartite set:\nnx.set_node_attributes(G,c,\"bipartite\")\nprint(G.nodes[0][\"bipartite\"])\n# 1\nprint(G.nodes[1][\"bipartite\"])\n# 0",
    "Section ID: single_source_bellman_ford_path_length\nDescription: [Compute the shortest path length between source and all other\nreachable nodes for a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nsource : node label: Starting node for path\nweight : string or function (default=”weight”): If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: length : dictionary: Dictionary of shortest path length keyed by target\nRaises:: NodeNotFound: Ifsourceis not inG.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\nExamples: G=nx.path_graph(5)\nlength=nx.single_source_bellman_ford_path_length(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4",
    "Section ID: reconstruct_path\nDescription: [Reconstruct a path from source to target using the predecessors\ndict as returned by floyd_warshall_predecessor_and_distance]\nField List: Parameters:: source : node: Starting node for path\ntarget : node: Ending node for path\npredecessors: dictionary: Dictionary, keyed by source and target, of predecessors in the\nshortest path, as returned by floyd_warshall_predecessor_and_distance\nReturns:: path : list: A list of nodes containing the shortest path from source to targetIf source and target are the same, an empty list is returned\nMethods: []\nRubrics: Notes: This function is meant to give more applicability to the\nfloyd_warshall_predecessor_and_distance function",
    "Section ID: minimum_cut_value\nDescription: [Compute the value of a minimum (s, t)-cut., Use the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow.]\nField List: Parameters:: flowG : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\n_s : node: Source node for the flow.\n_t : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nflow_func : function: A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.\nkwargs : Any other keyword parameter is passed to the function that: computes the maximum flow.\nReturns:: cut_value : integer, float: Value of the minimum cut.\nRaises:: NetworkXUnbounded: If the graph has a path of infinite capacity, all cuts have\ninfinite capacity and the function raises a NetworkXError.\nMethods: []\nRubrics: Notes: The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.\nExamples: G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nminimum_cut_value computes only the value of the\nminimum cut:\ncut_value=nx.minimum_cut_value(G,\"x\",\"y\")\ncut_value\n# 3.0\nYou can also use alternative algorithms for computing the\nminimum cut by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\ncut_value==nx.minimum_cut_value(G,\"x\",\"y\",flow_func=shortest_augmenting_path)\n# True",
    "Section ID: interval_graph\nDescription: [Generates an interval graph for a list of intervals given., In graph theory, an interval graph is an undirected graph formed from a set\nof closed intervals on the real line, with a vertex for each interval\nand an edge between vertices whose intervals intersect.\nIt is the intersection graph of the intervals., More information can be found at: https://en.wikipedia.org/wiki/Interval_graph]\nField List: Parameters:: intervals : a sequence of intervals, say (l, r) where l is the left end,: \nand r is the right end of the closed interval.:\nReturns:: G : networkx graph:\nRaises:: TypeError: ifintervalscontains None or an element which is not\ncollections.abc.Sequence or not a length of 2.\nValueError: ifintervalscontains an interval such that min1 > max1\nwhere min1,max1 = interval\nMethods: []\nRubrics: Examples: intervals=[(-2,3),[1,4],(2,3),(4,6)]\nG=nx.interval_graph(intervals)\nsorted(G.edges)\n# [((-2, 3), (1, 4)), ((-2, 3), (2, 3)), ((1, 4), (2, 3)), ((1, 4), (4, 6))]",
    "Section ID: clustering\nDescription: [Compute a bipartite clustering coefficient for nodes., The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :, where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v ., The mode selects the function for c_{uv} which can be:, dot :, min :, max :]\nField List: Parameters:: G : graph: A bipartite graph\nnodes : list or iterable (optional): Compute bipartite clustering for these nodes. The default\nis all nodes in G.\nmode : string: The pairwise bipartite clustering method to be used in the computation.\nIt must be “dot”, “max”, or “min”.\nReturns:: clustering : dictionary: A dictionary keyed by node with the clustering coefficient value.\nMethods: []\nRubrics: References: [1]Latapy, Matthieu, Clémence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31–48.\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0",
    "Section ID: trophic_incoherence_parameter\nDescription: [Compute the trophic incoherence parameter of a graph., Trophic coherence is defined as the homogeneity of the distribution of\ntrophic distances: the more similar, the more coherent. This is measured by\nthe standard deviation of the trophic differences and referred to as the\ntrophic incoherence parameter \\(q\\) by [1].]\nField List: Parameters:: G : DiGraph: A directed networkx graph\ncannibalism: Boolean: If set to False, self edges are not considered in the calculation\nReturns:: trophic_incoherence_parameter : float: The trophic coherence of a graph\nMethods: []\nRubrics: References: [1]Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\nMunoz (2014) PNAS “Trophic coherence determines food-web stability”",
    "Section ID: is_strongly_regular\nDescription: [Returns True if and only if the given graph is strongly\nregular., An undirected graph is strongly regular if, Each strongly regular graph is a distance-regular graph.\nConversely, if a distance-regular graph has diameter two, then it is\na strongly regular graph. For more information on distance-regular\ngraphs, see is_distance_regular() .]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nReturns:: bool: WhetherGis strongly regular.\nMethods: []\nRubrics: Examples: The cycle graph on five vertices is strongly regular. It is\ntwo-regular, each pair of adjacent vertices has no shared neighbors,\nand each pair of nonadjacent vertices has one shared neighbor:\nG=nx.cycle_graph(5)\nnx.is_strongly_regular(G)\n# True",
    "Section ID: weisfeiler_lehman_graph_hash\nDescription: [Return Weisfeiler Lehman (WL) graph hash., The function iteratively aggregates and hashes neighborhoods of each node.\nAfter each node’s neighbors are hashed to obtain updated node labels,\na hashed histogram of resulting labels is returned as the final hash., Hashes are identical for isomorphic graphs and strong guarantees that\nnon-isomorphic graphs will get different hashes. See [1] for details., If no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash.]\nField List: Parameters:: G : graph: The graph to be hashed.\nCan have node and/or edge attributes. Can also have no attributes.\nedge_attr : string, optional (default=None): The key in edge attribute dictionary to be used for hashing.\nIf None, edge labels are ignored.\nnode_attr: string, optional (default=None): The key in node attribute dictionary to be used for hashing.\nIf None, and no edge_attr given, use the degrees of the nodes as labels.\niterations: int, optional (default=3): Number of neighbor aggregations to perform.\nShould be larger for larger graphs.\ndigest_size: int, optional (default=16): Size (in bits) of blake2b hash digest to use for hashing node labels.\nReturns:: h : string: Hexadecimal string corresponding to hash of the input graph.\nMethods: []\nRubrics: Notes: To return the WL hashes of each subgraph of a graph, use weisfeiler_lehman_subgraph_hashes Similarity between hashes does not imply similarity between graphs.\nReferences: [1]Shervashidze, Nino, Pascal Schweitzer, Erik Jan Van Leeuwen,\nKurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler Lehman\nGraph Kernels. Journal of Machine Learning Research. 2011.http://www.jmlr.org/papers/volume12/shervashidze11a/shervashidze11a.pdf\nExamples: Two graphs with edge attributes that are isomorphic, except for\ndifferences in the edge labels.\nG1=nx.Graph()\nG1.add_edges_from(\n[\n(1,2,{\"label\":\"A\"}),\n(2,3,{\"label\":\"A\"}),\n(3,1,{\"label\":\"A\"}),\n(1,4,{\"label\":\"B\"}),\n]\n)\nG2=nx.Graph()\nG2.add_edges_from(\n[\n(5,6,{\"label\":\"B\"}),\n(6,7,{\"label\":\"A\"}),\n(7,5,{\"label\":\"A\"}),\n(7,8,{\"label\":\"A\"}),\n]\n)\nOmitting theedge_attroption, results in identical hashes.\nnx.weisfeiler_lehman_graph_hash(G1)\n# '7bc4dde9a09d0b94c5097b219891d81a'\nnx.weisfeiler_lehman_graph_hash(G2)\n# '7bc4dde9a09d0b94c5097b219891d81a'\nWith edge labels, the graphs are no longer assigned\nthe same hash digest.\nnx.weisfeiler_lehman_graph_hash(G1,edge_attr=\"label\")\n# 'c653d85538bcf041d88c011f4f905f10'\nnx.weisfeiler_lehman_graph_hash(G2,edge_attr=\"label\")\n# '3dcd84af1ca855d0eff3c978d88e7ec7'",
    "Section ID: hide_edges\nDescription: [Returns a filter function that hides specific undirected edges.]\nField List: Methods: []\nRubrics:",
    "Section ID: to_latex\nDescription: [Return latex code to draw the graph(s) in Gbunch, The TikZ drawing utility in LaTeX is used to draw the graph(s).\nIf Gbunch is a graph, it is drawn in a figure environment.\nIf Gbunch is an iterable of graphs, each is drawn in a subfigure environment\nwithin a single figure environment., If as_document is True, the figure is wrapped inside a document environment\nso that the resulting string is ready to be compiled by LaTeX. Otherwise,\nthe string is ready for inclusion in a larger tex document using \\include or \\input statements.]\nField List: Parameters:: Gbunch : NetworkX graph or iterable of NetworkX graphs: The NetworkX graph to be drawn or an iterable of graphs\nto be drawn inside subfigures of a single figure.\npos : string or list of strings: The name of the node attribute onGthat holds the position of each node.\nPositions can be sequences of length 2 with numbers for (x,y) coordinates.\nThey can also be strings to denote positions in TikZ style, such as (x, y)\nor (angle:radius).\nIf a dict, it should be keyed by node to a position.\nIf an empty dict, a circular layout is computed by TikZ.\nIf you are drawing many graphs in subfigures, use a list of position dicts.\ntikz_options : string: The tikzpicture options description defining the options for the picture.\nOften large scale options like[scale=2].\ndefault_node_options : string: The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict: The name of the node attribute onGthat holds the options for each node.\nOr a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict: The name of the node attribute onGthat holds the node label (text)\ndisplayed for each node. If the attribute is “” or not present, the node\nitself is drawn as a string. LaTeX processing such as\"$A_1$\"is allowed.\nOr a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string: The options for the scope drawing all edges. The default is “[-]” for\nundirected graphs and “[->]” for directed graphs.\nedge_options : string or dict: The name of the edge attribute onGthat holds the options for each edge.\nIf the edge is a self-loop and\"loop\"notinedge_optionsthe option\n“loop,” is added to the options for the self-loop edge. Hence you can\nuse “[loop above]” explicitly, but the default is “[loop]”.\nOr a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict: The name of the edge attribute onGthat holds the edge label (text)\ndisplayed for each edge. If the attribute is “” or not present, no edge\nlabel is drawn.\nOr a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict: The name of the edge attribute onGthat holds the label options for\neach edge. For example, “[sloped,above,blue]”. The default is no options.\nOr a dict keyed by edge to a string holding the label options for that edge.\ncaption : string: The caption string for the figure environment\nlatex_label : string: The latex label used for the figure for easy referral from the main text\nsub_captions : list of strings: The sub_caption string for each subfigure in the figure\nsub_latex_labels : list of strings: The latex label for each subfigure in the figure\nn_rows : int: The number of rows of subfigures to arrange for multiple graphs\nas_document : bool: Whether to wrap the latex code in a document environment for compiling\ndocument_wrapper : formatted text string with variablecontent.: This text is called to evaluate the content embedded in a document\nenvironment with a preamble setting up TikZ.\nfigure_wrapper : formatted text string: This text is evaluated with variablescontent,captionandlabel.\nIt wraps the content and if a caption is provided, adds the latex code for\nthat caption, and if a label is provided, adds the latex code for a label.\nsubfigure_wrapper : formatted text string: This text evaluate variablessize,content,captionandlabel.\nIt wraps the content and if a caption is provided, adds the latex code for\nthat caption, and if a label is provided, adds the latex code for a label.\nThe size is the vertical size of each row of subfigures as a fraction.\nReturns:: latex_code : string: The text string which draws the desired graph(s) when compiled by LaTeX.\nMethods: []\nRubrics:",
    "Section ID: pappus_graph\nDescription: [Returns the Pappus graph., The Pappus graph is a cubic symmetric distance-regular graph with 18 nodes\nand 27 edges. It is Hamiltonian and can be represented in LCF notation as\n[5,7,-7,7,-7,-5]^3 [1] .]\nField List: Returns:: G : networkx Graph: Pappus graph\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Pappus_graph",
    "Section ID: robins_alexander_clustering\nDescription: [Compute the bipartite clustering of G., Robins and Alexander [1] defined bipartite clustering coefficient as\nfour times the number of four cycles C_4 divided by the number of\nthree paths L_3 in a bipartite graph:]\nField List: Parameters:: G : graph: a bipartite graph\nReturns:: clustering : float: The Robins and Alexander bipartite clustering for the input graph.\nMethods: []\nRubrics: References: [1]Robins, G. and M. Alexander (2004). Small worlds among interlocking\ndirectors: Network structure and distance in bipartite graphs.\nComputational & Mathematical Organization Theory 10(1), 69–94.\nExamples: fromnetworkx.algorithmsimportbipartite\nG=nx.davis_southern_women_graph()\nprint(round(bipartite.robins_alexander_clustering(G),3))\n# 0.468",
    "Section ID: geometric_edges\nDescription: [Returns edge list of node pairs within radius of each other.]\nField List: Parameters:: G : networkx graph: The graph from which to generate the edge list. The nodes inGshould\nhave an attributeposcorresponding to the node position, which is\nused to compute the distance to other nodes.\nradius : scalar: The distance threshold. Edges are included in the edge list if the\ndistance between the two nodes is less thanradius.\npos_name : string, default=”pos”: The name of the node attribute which represents the position of each\nnode in 2D coordinates. Every node in the Graph must have this attribute.\np : scalar, default=2: TheMinkowski distance metricused to compute\ndistances. The default value is 2, i.e. Euclidean distance.\nReturns:: edges : list: List of edges whose distances are less thanradius\nMethods: []\nRubrics: Notes: Radius uses Minkowski distance metric p .\nIf scipy is available, scipy.spatial.cKDTree is used to speed computation.\nExamples: Create a graph with nodes that have a “pos” attribute representing 2D\ncoordinates.\nG=nx.Graph()\nG.add_nodes_from(\n[\n(0,{\"pos\":(0,0)}),\n(1,{\"pos\":(3,0)}),\n(2,{\"pos\":(8,0)}),\n]\n)\nnx.geometric_edges(G,radius=1)\n# []\nnx.geometric_edges(G,radius=4)\n# [(0, 1)]\nnx.geometric_edges(G,radius=6)\n# [(0, 1), (1, 2)]\nnx.geometric_edges(G,radius=9)\n# [(0, 1), (0, 2), (1, 2)]",
    "Section ID: make_clique_bipartite\nDescription: [Returns the bipartite clique graph corresponding to G ., In the returned bipartite graph, the “bottom” nodes are the nodes of G and the “top” nodes represent the maximal cliques of G .\nThere is an edge from node v to clique C in the returned graph\nif and only if v is an element of C .]\nField List: Parameters:: G : NetworkX graph: An undirected graph.\nfpos : bool: If True or not None, the returned graph will have an\nadditional attribute,pos, a dictionary mapping node to\nposition in the Euclidean plane.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: NetworkX graph: A bipartite graph whose “bottom” set is the nodes of the graphG, whose “top” set is the cliques ofG, and whose edges\njoin nodes ofGto the cliques that contain them.The nodes of the graphGhave the node attribute\n‘bipartite’ set to 1 and the nodes representing cliques\nhave the node attribute ‘bipartite’ set to 0, as is the\nconvention for bipartite graphs in NetworkX.\nMethods: []\nRubrics:",
    "Section ID: dict_to_numpy_array\nDescription: [Convert a dictionary of dictionaries to a numpy array\nwith optional mapping.]\nField List: Methods: []\nRubrics:",
    "Section ID: astar_path_length\nDescription: [Returns the length of the shortest path between source and target using\nthe A* (“A-star”) algorithm.]\nField List: Parameters:: G : NetworkX graph: \nsource : node: Starting node for path\ntarget : node: Ending node for path\nheuristic : function: A function to evaluate the estimate of the distance\nfrom the a node to the target.  The function takes\ntwo nodes arguments and must return a number.\nIf the heuristic is inadmissible (if it might\noverestimate the cost of reaching the goal from a node),\nthe result may not be a shortest path.\nThe algorithm does not support updating heuristic\nvalues for the same node due to caching the first\nheuristic calculation per node.\nweight : string or function: If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.\ncutoff : float, optional: If this is provided, the search will be bounded to this value. I.e. if\nthe evaluation function surpasses this value for a node n, the node will not\nbe expanded further and will be ignored. More formally, let h’(n) be the\nheuristic function, and g(n) be the cost of reaching n from the source node. Then,\nif g(n) + h’(n) > cutoff, the node will not be explored further.\nNote that if the heuristic is inadmissible, it is possible that paths\nare ignored even though they satisfy the cutoff.\nRaises:: NetworkXNoPath: If no path exists between source and target.\nMethods: []\nRubrics:",
    "Section ID: all_pairs_bellman_ford_path\nDescription: [Compute shortest paths between all nodes in a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nweight : string or function (default=”weight”): If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: paths : iterator: (source, dictionary) iterator with dictionary keyed by target and\nshortest path as the key value.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\nExamples: G=nx.path_graph(5)\npath=dict(nx.all_pairs_bellman_ford_path(G))\npath[0][4]\n# [0, 1, 2, 3, 4]",
    "Section ID: find_induced_nodes\nDescription: [Returns the set of induced nodes in the path from s to t.]\nField List: Parameters:: G : graph: A chordal NetworkX graph\ns : node: Source node to look for induced nodes\nt : node: Destination node to look for induced nodes\ntreewidth_bound: float: Maximum treewidth acceptable for the graph H. The search\nfor induced nodes will end as soon as the treewidth_bound is exceeded.\nReturns:: induced_nodes : Set of nodes: The set of induced nodes in the path from s to t in G\nRaises:: NetworkXError: The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nIf the input graph is an instance of one of these classes, aNetworkXErroris raised.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised.\nMethods: []\nRubrics: Notes: G must be a chordal graph and (s,t) an edge that is not in G. If a treewidth_bound is provided, the search for induced nodes will end\nas soon as the treewidth_bound is exceeded. The algorithm is inspired by Algorithm 4 in [1] .\nA formal definition of induced node can also be found on that reference. Self Loops are ignored\nReferences: [1]Learning Bounded Treewidth Bayesian Networks.\nGal Elidan, Stephen Gould; JMLR, 9(Dec):2699–2731, 2008.http://jmlr.csail.mit.edu/papers/volume9/elidan08a/elidan08a.pdf\nExamples: G=nx.Graph()\nG=nx.generators.classic.path_graph(10)\ninduced_nodes=nx.find_induced_nodes(G,1,9,2)\nsorted(induced_nodes)\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]",
    "Section ID: efficiency\nDescription: [Returns the efficiency of a pair of nodes in a graph., The efficiency of a pair of nodes is the multiplicative inverse of the\nshortest path distance between the nodes [1] . Returns 0 if no path\nbetween nodes.]\nField List: Parameters:: G : networkx.Graph: An undirected graph for which to compute the average local efficiency.\nu, v : node: Nodes in the graphG.\nReturns:: float: Multiplicative inverse of the shortest path distance between the nodes.\nMethods: []\nRubrics: Notes: Edge weights are ignored when computing the shortest path distances.\nReferences: [1]Latora, Vito, and Massimo Marchiori.\n“Efficient behavior of small-world networks.”Physical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>\nExamples: G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.efficiency(G,2,3)# this gives efficiency for node 2 and 3\n# 0.5",
    "Section ID: sudoku_graph\nDescription: [Returns the n-Sudoku graph. The default value of n is 3., The n-Sudoku graph is a graph with n^4 vertices, corresponding to the\ncells of an n^2 by n^2 grid. Two distinct vertices are adjacent if and\nonly if they belong to the same row, column, or n-by-n box.]\nField List: Parameters:: n: integer: The order of the Sudoku graph, equal to the square root of the\nnumber of rows. The default is 3.\nReturns:: NetworkX graph: The n-Sudoku graph Sud(n).\nMethods: []\nRubrics: References: [1]Herzberg, A. M., & Murty, M. R. (2007). Sudoku squares and chromatic\npolynomials. Notices of the AMS, 54(6), 708-717.  [2]Sander, Torsten (2009), “Sudoku graphs are integral”,\nElectronic Journal of Combinatorics, 16 (1): Note 25, 7pp, MR 2529816  [3]Wikipedia contributors. “Glossary of Sudoku.” Wikipedia, The Free\nEncyclopedia, 3 Dec. 2019. Web. 22 Dec. 2019.\nExamples: G=nx.sudoku_graph()\nG.number_of_nodes()\n# 81\nG.number_of_edges()\n# 810\nsorted(G.neighbors(42))\n# [6, 15, 24, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 51, 52, 53, 60, 69, 78]\nG=nx.sudoku_graph(2)\nG.number_of_nodes()\n# 16\nG.number_of_edges()\n# 56",
    "Section ID: write_network_text\nDescription: [Creates a nice text representation of a graph, This works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented.]\nField List: Parameters:: graph : nx.DiGraph | nx.Graph: Graph to represent\npath : string or file or callable or None: Filename or file handle for data output.\nif a function, then it will be called for each generated line.\nif None, this will default to “sys.stdout.write”\nwith_labels : bool | str: If True will use the “label” attribute of a node to display if it\nexists otherwise it will use the node value itself. If given as a\nstring, then that attribute name will be used instead of “label”.\nDefaults to True.\nsources : List: Specifies which nodes to start traversal from. Note: nodes that are not\nreachable from one of these sources may not be shown. If unspecified,\nthe minimal set of nodes needed to reach all others will be used.\nmax_depth : int | None: The maximum depth to traverse before stopping. Defaults to None.\nascii_only : Boolean: If True only ASCII characters are used to construct the visualization\nend : string: The line ending character\nvertical_chains : Boolean: If True, chains of nodes will be drawn vertically when possible.\nMethods: []\nRubrics: Examples: graph=nx.balanced_tree(r=2,h=2,create_using=nx.DiGraph)\nnx.write_network_text(graph)\n# ╙── 0\n#     ├─╼ 1\n#     │   ├─╼ 3\n#     │   └─╼ 4\n#     └─╼ 2\n#         ├─╼ 5\n#         └─╼ 6\n# A near tree with one non-tree edge\ngraph.add_edge(5,1)\nnx.write_network_text(graph)\n# ╙── 0\n#     ├─╼ 1 ╾ 5\n#     │   ├─╼ 3\n#     │   └─╼ 4\n#     └─╼ 2\n#         ├─╼ 5\n#         │   └─╼  ...\n#         └─╼ 6\ngraph=nx.cycle_graph(5)\nnx.write_network_text(graph)\n# ╙── 0\n#     ├── 1\n#     │   └── 2\n#     │       └── 3\n#     │           └── 4 ─ 0\n#     └──  ...\ngraph=nx.cycle_graph(5,nx.DiGraph)\nnx.write_network_text(graph,vertical_chains=True)\n# ╙── 0 ╾ 4\n#     ╽\n#     1\n#     ╽\n#     2\n#     ╽\n#     3\n#     ╽\n#     4\n#     └─╼  ...\nnx.write_network_text(graph,vertical_chains=True,ascii_only=True)\n# +-- 0 <- 4\n#     !\n#     1\n#     !\n#     2\n#     !\n#     3\n#     !\n#     4\n#     L->  ...\ngraph=nx.generators.barbell_graph(4,2)\nnx.write_network_text(graph,vertical_chains=False)\n# ╙── 4\n#     ├── 5\n#     │   └── 6\n#     │       ├── 7\n#     │       │   ├── 8 ─ 6\n#     │       │   │   └── 9 ─ 6, 7\n#     │       │   └──  ...\n#     │       └──  ...\n#     └── 3\n#         ├── 0\n#         │   ├── 1 ─ 3\n#         │   │   └── 2 ─ 0, 3\n#         │   └──  ...\n#         └──  ...\nnx.write_network_text(graph,vertical_chains=True)\n# ╙── 4\n#     ├── 5\n#     │   │\n#     │   6\n#     │   ├── 7\n#     │   │   ├── 8 ─ 6\n#     │   │   │   │\n#     │   │   │   9 ─ 6, 7\n#     │   │   └──  ...\n#     │   └──  ...\n#     └── 3\n#         ├── 0\n#         │   ├── 1 ─ 3\n#         │   │   │\n#         │   │   2 ─ 0, 3\n#         │   └──  ...\n#         └──  ...\ngraph=nx.complete_graph(5,create_using=nx.Graph)\nnx.write_network_text(graph)\n# ╙── 0\n#     ├── 1\n#     │   ├── 2 ─ 0\n#     │   │   ├── 3 ─ 0, 1\n#     │   │   │   └── 4 ─ 0, 1, 2\n#     │   │   └──  ...\n#     │   └──  ...\n#     └──  ...\ngraph=nx.complete_graph(3,create_using=nx.DiGraph)\nnx.write_network_text(graph)\n# ╙── 0 ╾ 1, 2\n#     ├─╼ 1 ╾ 2\n#     │   ├─╼ 2 ╾ 0\n#     │   │   └─╼  ...\n#     │   └─╼  ...\n#     └─╼  ...",
    "Section ID: group_degree_centrality\nDescription: [Compute the group degree centrality for a group of nodes., Group degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members.]\nField List: Parameters:: G : graph: A NetworkX graph.\nS : list or set: S is a group of nodes which belong to G, for which group degree\ncentrality is to be calculated.\nReturns:: centrality : float: Group degree centrality of the group S.\nRaises:: NetworkXError: If node(s) in S are not in G.\nMethods: []\nRubrics: Notes: The measure was introduced in [1] . The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph.\nReferences: [1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm",
    "Section ID: disjoint_union\nDescription: [Combine graphs G and H. The nodes are assumed to be unique (disjoint)., This algorithm automatically relabels nodes to avoid name collisions.]\nField List: Parameters:: G,H : graph: A NetworkX graph\nReturns:: U : A union graph with the same type as G.:\nMethods: []\nRubrics: Notes: A new graph is created, of the same class as G.  It is recommended\nthat G and H be either both directed or both undirected. The nodes of G are relabeled 0 to len(G)-1, and the nodes of H are\nrelabeled len(G) to len(G)+len(H)-1. Renumbering forces G and H to be disjoint, so no exception is ever raised for a name collision.\nTo preserve the check for common nodes, use union(). Edge and node attributes are propagated from G and H to the union graph.\nGraph attributes are also propagated, but if they are present in both G and H,\nthen the value from H is used. To combine graphs that have common nodes, consider compose(G, H)\nor the method, Graph.update().\nExamples: G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,3),(1,2),(2,3)])\nG.nodes[0][\"key1\"]=5\nH.nodes[0][\"key2\"]=10\nU=nx.disjoint_union(G,H)\nU.nodes(data=True)\n# NodeDataView({0: {'key1': 5}, 1: {}, 2: {}, 3: {'key2': 10}, 4: {}, 5: {}, 6: {}})\nU.edges\n# EdgeView([(0, 1), (0, 2), (1, 2), (3, 4), (4, 6), (5, 6)])",
    "Section ID: descendants_at_distance\nDescription: [Returns all nodes at a fixed distance from source in G .]\nField List: Parameters:: G : NetworkX graph: A graph\nsource : node inG: \ndistance : the distance of the wanted nodes fromsource:\nReturns:: set(): The descendants ofsourceinGat the givendistancefromsource\nMethods: []\nRubrics: Examples: G=nx.path_graph(5)\nnx.descendants_at_distance(G,2,2)\n# {0, 4}\nH=nx.DiGraph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\nnx.descendants_at_distance(H,0,2)\n# {3, 4, 5, 6}\nnx.descendants_at_distance(H,5,0)\n# {5}\nnx.descendants_at_distance(H,5,1)\n# set()",
    "Section ID: write_sparse6\nDescription: [Write graph G to given path in sparse6 format.]\nField List: Parameters:: G : Graph (undirected): \npath : file or string: File or filename to write\nnodes: list or iterable: Nodes are labeled 0…n-1 in the order provided.  If None the ordering\ngiven by G.nodes() is used.\nheader: bool: If True add ‘>>sparse6<<’ string to head of data\nRaises:: NetworkXError: If the graph is directed\nMethods: []\nRubrics: Notes: The format does not support edge or node labels.\nReferences: [1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>\nExamples: You can write a sparse6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\nnx.write_sparse6(nx.path_graph(2),f.name)\nprint(f.read())\n# b'>>sparse6<<:An\\n'\nYou can also write a sparse6 file by giving an open file-like object:\nwithtempfile.NamedTemporaryFile()asf:\nnx.write_sparse6(nx.path_graph(2),f)\n_=f.seek(0)\nprint(f.read())\n# b'>>sparse6<<:An\\n'",
    "Section ID: preferential_attachment\nDescription: [Compute the preferential attachment score of all node pairs in ebunch., Preferential attachment score of u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .]\nField List: Parameters:: G : graph: NetworkX undirected graph.\nebunch : iterable of node pairs, optional (default = None): Preferential attachment score will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None.\nReturns:: piter : iterator: An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their preferential attachment score.\nRaises:: NetworkXNotImplemented: IfGis aDiGraph, aMultigraphor aMultiDiGraph.\nNodeNotFound: Ifebunchhas a node that is not inG.\nMethods: []\nRubrics: References: [1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf\nExamples: G=nx.complete_graph(5)\npreds=nx.preferential_attachment(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 1) -> 16\n# (2, 3) -> 16",
    "Section ID: truncated_cube_graph\nDescription: [Returns the skeleton of the truncated cube., The truncated cube is an Archimedean solid with 14 regular\nfaces (6 octagonal and 8 triangular), 36 edges and 24 nodes [1] .\nThe truncated cube is created by truncating (cutting off) the tips\nof the cube one third of the way into each edge [2] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: Skeleton of the truncated cube\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Truncated_cube  [2]https://www.coolmath.com/reference/polyhedra-truncated-cube",
    "Section ID: cytoscape_graph\nDescription: [Create a NetworkX graph from a dictionary in cytoscape JSON format.]\nField List: Parameters:: data : dict: A dictionary of data conforming to cytoscape JSON format.\nname : string: A string which is mapped to the ‘name’ node element in cyjs format.\nMust not have the same value asident.\nident : string: A string which is mapped to the ‘id’ node element in cyjs format.\nMust not have the same value asname.\nReturns:: graph : a NetworkX graph instance: Thegraphcan be an instance ofGraph,DiGraph,MultiGraph, orMultiDiGraphdepending on the input data.\nRaises:: NetworkXError: If thenameandidentattributes are identical.\nMethods: []\nRubrics: References: [1]Cytoscape user’s manual:http://manual.cytoscape.org/en/stable/index.html\nExamples: data_dict={\n\"data\":[],\n\"directed\":False,\n\"multigraph\":False,\n\"elements\":{\n\"nodes\":[\n{\"data\":{\"id\":\"0\",\"value\":0,\"name\":\"0\"}},\n{\"data\":{\"id\":\"1\",\"value\":1,\"name\":\"1\"}},\n],\n\"edges\":[{\"data\":{\"source\":0,\"target\":1}}],\n},\n}\nG=nx.cytoscape_graph(data_dict)\nG.name\n# ''\nG.nodes()\n# NodeView((0, 1))\nG.nodes(data=True)[0]\n# {'id': '0', 'value': 0, 'name': '0'}\nG.edges(data=True)\n# EdgeDataView([(0, 1, {'source': 0, 'target': 1})])",
    "Section ID: attribute_mixing_dict\nDescription: [Returns dictionary representation of mixing matrix for attribute.]\nField List: Parameters:: G : graph: NetworkX graph object.\nattribute : string: Node attribute key.\nnodes: list or iterable (optional): Unse nodes in container to build the dict. The default is all nodes.\nnormalized : bool (default=False): Return counts if False or probabilities if True.\nReturns:: d : dictionary: Counts or joint probability of occurrence of attribute pairs.\nMethods: []\nRubrics: Examples: G=nx.Graph()\nG.add_nodes_from([0,1],color=\"red\")\nG.add_nodes_from([2,3],color=\"blue\")\nG.add_edge(1,3)\nd=nx.attribute_mixing_dict(G,\"color\")\nprint(d[\"red\"][\"blue\"])\n# 1\nprint(d[\"blue\"][\"red\"])# d symmetric for undirected graphs\n# 1",
    "Section ID: to_nested_tuple\nDescription: [Returns a nested tuple representation of the given tree., The nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, () . A tree with k subtrees is represented\nby a tuple of length k in which each element is the nested tuple\nrepresentation of a subtree.]\nField List: Parameters:: T : NetworkX graph: An undirected graph object representing a tree.\nroot : node: The node inTto interpret as the root of the tree.\ncanonical_form : bool: IfTrue, each tuple is sorted so that the function returns\na canonical form for rooted trees. This means “lighter” subtrees\nwill appear as nested tuples before “heavier” subtrees. In this\nway, each isomorphic rooted tree has the same nested tuple\nrepresentation.\nReturns:: tuple: A nested tuple representation of the tree.\nMethods: []\nRubrics: Notes: This function is not the inverse of from_nested_tuple() ; the\nonly guarantee is that the rooted trees are isomorphic.\nExamples: The tree need not be a balanced binary tree:\nT=nx.Graph()\nT.add_edges_from([(0,1),(0,2),(0,3)])\nT.add_edges_from([(1,4),(1,5)])\nT.add_edges_from([(3,6),(3,7)])\nroot=0\nnx.to_nested_tuple(T,root)\n# (((), ()), (), ((), ()))\nContinuing the above example, ifcanonical_formisTrue, the\nnested tuples will be sorted:\nnx.to_nested_tuple(T,root,canonical_form=True)\n# ((), ((), ()), ((), ()))\nEven the path graph can be interpreted as a tree:\nT=nx.path_graph(4)\nroot=0\nnx.to_nested_tuple(T,root)\n# ((((),),),)",
    "Section ID: havel_hakimi_graph\nDescription: [Returns a simple graph with given degree sequence constructed\nusing the Havel-Hakimi algorithm.]\nField List: Parameters:: deg_sequence: list of integers: Each integer corresponds to the degree of a node (need not be sorted).\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nDirected graphs are not allowed.\nRaises:: NetworkXException: For a non-graphical degree sequence (i.e. one\nnot realizable by some simple graph).\nMethods: []\nRubrics: Notes: The Havel-Hakimi algorithm constructs a simple graph by\nsuccessively connecting the node of highest degree to other nodes\nof highest degree, resorting remaining nodes by degree, and\nrepeating the process. The resulting graph has a high\ndegree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\ncorresponding to their position in deg_sequence. The basic algorithm is from Hakimi [1] and was generalized by\nKleitman and Wang [2] .\nReferences: [1]Hakimi S., On Realizability of a Set of Integers as\nDegrees of the Vertices of a Linear Graph. I,\nJournal of SIAM, 10(3), pp. 496-506 (1962)  [2]Kleitman D.J. and Wang D.L.\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)",
    "Section ID: draw_networkx_labels\nDescription: [Draw node labels on the graph G.]\nField List: Parameters:: G : graph: A networkx graph\npos : dictionary: A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.\nlabels : dictionary (default={n: n for n in G}): Node labels in a dictionary of text labels keyed by node.\nNode-keys in labels should appear as keys inpos.\nIf needed use:{n:labforn,labinlabels.items()ifninpos}\nfont_size : int (default=12): Font size for text labels\nfont_color : color (default=’k’ black): Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.\nfont_weight : string (default=’normal’): Font weight\nfont_family : string (default=’sans-serif’): Font family\nalpha : float or None (default=None): The text transparency\nbbox : Matplotlib bbox, (default is Matplotlib’s ax.text default): Specify text box properties (e.g. shape, color etc.) for node labels.\nhorizontalalignment : string (default=’center’): Horizontal alignment {‘center’, ‘right’, ‘left’}\nverticalalignment : string (default=’center’): Vertical alignment {‘center’, ‘top’, ‘bottom’, ‘baseline’, ‘center_baseline’}\nax : Matplotlib Axes object, optional: Draw the graph in the specified Matplotlib axes.\nclip_on : bool (default=True): Turn on clipping of node labels at axis boundaries\nhide_ticks : bool, optional: Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False.\nReturns:: dict: dictof labels keyed on the nodes\nMethods: []\nRubrics: Examples: G=nx.dodecahedral_graph()\nlabels=nx.draw_networkx_labels(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html",
    "Section ID: onion_layers\nDescription: [Returns the layer of each vertex in an onion decomposition of the graph., The onion decomposition refines the k-core decomposition by providing\ninformation on the internal organization of each k-shell. It is usually\nused alongside the corenumbers .]\nField List: Parameters:: G : NetworkX graph: An undirected graph without self loops.\nReturns:: od_layers : dictionary: A dictionary keyed by node to the onion layer. The layers are\ncontiguous integers starting at 1.\nRaises:: NetworkXNotImplemented: IfGis a multigraph or directed graph or if it contains self loops.\nMethods: []\nRubrics: References: [1]Multi-scale structure and topological anomaly detection via a new\nnetwork statistic: The onion decomposition\nL. Hébert-Dufresne, J. A. Grochow, and A. Allard\nScientific Reports 6, 31708 (2016)http://doi.org/10.1038/srep31708  [2]Percolation and the effective structure of complex networks\nA. Allard and L. Hébert-Dufresne\nPhysical Review X 9, 011023 (2019)http://doi.org/10.1103/PhysRevX.9.011023\nExamples: degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.onion_layers(H)\n# {6: 1, 0: 2, 4: 3, 1: 4, 2: 4, 3: 4, 5: 4}",
    "Section ID: check_planarity\nDescription: [Check if a graph is planar and return a counterexample or an embedding., A graph is planar iff it can be drawn in a plane without\nany edge intersections.]\nField List: Parameters:: G : NetworkX graph: \ncounterexample : bool: A Kuratowski subgraph (to proof non planarity) is only returned if set\nto true.\nReturns:: (is_planar, certificate) : (bool, NetworkX graph) tuple: is_planar is true if the graph is planar.\nIf the graph is planarcertificateis a PlanarEmbedding\notherwise it is a Kuratowski subgraph.\nMethods: []\nRubrics: Notes: A (combinatorial) embedding consists of cyclic orderings of the incident\nedges at each vertex. Given such an embedding there are multiple approaches\ndiscussed in literature to drawing the graph (subject to various\nconstraints, e.g. integer coordinates), see e.g. [2]. The planarity check algorithm and extraction of the combinatorial embedding\nis based on the Left-Right Planarity Test [1]. A counterexample is only generated if the corresponding parameter is set,\nbecause the complexity of the counterexample generation is higher.\nReferences: [1]Ulrik Brandes:\nThe Left-Right Planarity Test\n2009http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.217.9208  [2]Takao Nishizeki, Md Saidur Rahman:\nPlanar graph drawing\nLecture Notes Series on Computing: Volume 12\n2004\nExamples: G=nx.Graph([(0,1),(0,2)])\nis_planar,P=nx.check_planarity(G)\nprint(is_planar)\n# True\nWhenGis planar, aPlanarEmbeddinginstance is returned:\nP.get_data()\n# {0: [1, 2], 1: [0], 2: [0]}",
    "Section ID: complete_bipartite_graph\nDescription: [Returns the complete bipartite graph K_{n_1,n_2} ., The graph is composed of two partitions with nodes 0 to (n1 - 1)\nin the first and nodes n1 to (n1 + n2 - 1) in the second.\nEach node in the first is connected to each node in the second.]\nField List: Parameters:: n1, n2 : integer or iterable container of nodes: If integers, nodes are fromrange(n1)andrange(n1,n1+n2).\nIf a container, the elements are the nodes.\ncreate_using : NetworkX graph instance, (default: nx.Graph): Return graph of this type.\nMethods: []\nRubrics: Notes: Nodes are the integers 0 to n1+n2-1 unless either n1 or n2 are\ncontainers of nodes. If only one of n1 or n2 are integers, that\ninteger is replaced by range of that integer. The nodes are assigned the attribute ‘bipartite’ with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.complete_bipartite_graph",
    "Section ID: identified_nodes\nDescription: [Returns the graph that results from contracting u and v ., Node contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes.]\nField List: Parameters:: G : NetworkX graph: The graph whose nodes will be contracted.\nu, v : nodes: Must be nodes inG.\nself_loops : Boolean: If this is True, any edges joininguandvinGbecome\nself-loops on the new node in the returned graph.\ncopy : Boolean: If this is True (default True), make a copy ofGand return that instead of directly changingG.\nReturns:: Networkx graph: If Copy is True,\nA new graph object of the same type asG(leavingGunmodified)\nwithuandvidentified in a single node. The right nodevwill be merged into the nodeu, so onlyuwill appear in the\nreturned graph.\nIf copy is False,\nModifiesGwithuandvidentified in a single node.\nThe right nodevwill be merged into the nodeu, so\nonlyuwill appear in the returned graph.\nMethods: []\nRubrics: Notes: For multigraphs, the edge keys for the realigned edges may\nnot be the same as the edge keys for the old edges. This is\nnatural because edge keys are unique only within each pair of nodes. For non-multigraphs where u and v are adjacent to a third node w , the edge ( v , w ) will be contracted into the edge ( u , w ) with its attributes stored into a “contraction” attribute. This function is also available as identified_nodes .\nExamples: Contracting two nonadjacent nodes of the cycle graph on four nodesC_4yields the path graph (ignoring parallel edges):\nG=nx.cycle_graph(4)\nM=nx.contracted_nodes(G,1,3)\nP3=nx.path_graph(3)\nnx.is_isomorphic(M,P3)\n# True\nG=nx.MultiGraph(P3)\nM=nx.contracted_nodes(G,0,2)\nM.edges\n# MultiEdgeView([(0, 1, 0), (0, 1, 1)])\nG=nx.Graph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.nodes())\n# [1]\nlist(H.edges())\n# [(1, 1)]\nIn aMultiDiGraphwith a self loop, the in and out edges will\nbe treated separately as edges, so while contracting a node which\nhas a self loop the contraction will add multiple edges:\nG=nx.MultiDiGraph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2)\nlist(H.edges())# edge 1->2, 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1), (1, 1)]\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.edges())# edge 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1)]",
    "Section ID: from_sparse6_bytes\nDescription: [Read an undirected graph in sparse6 format from string.]\nField List: Parameters:: string : string: Data in sparse6 format\nReturns:: G : Graph:\nRaises:: NetworkXError: If the string is unable to be parsed in sparse6 format\nMethods: []\nRubrics: References: [1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>\nExamples: G=nx.from_sparse6_bytes(b\":A_\")\nsorted(G.edges())\n# [(0, 1), (0, 1), (0, 1)]",
    "Section ID: is_planar\nDescription: [Returns True if and only if G is planar., A graph is planar iff it can be drawn in a plane without\nany edge intersections.]\nField List: Parameters:: G : NetworkX graph:\nReturns:: bool: Whether the graph is planar.\nMethods: []\nRubrics: Examples: G=nx.Graph([(0,1),(0,2)])\nnx.is_planar(G)\n# True\nnx.is_planar(nx.complete_graph(5))\n# False",
    "Section ID: random_powerlaw_tree_sequence\nDescription: [Returns a degree sequence for a tree with a power law distribution.]\nField List: Parameters:: n : int,: The number of nodes.\ngamma : float: Exponent of the power law.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ntries : int: Number of attempts to adjust the sequence to make it a tree.\nRaises:: NetworkXError: If no valid sequence is found within the maximum number of\nattempts.\nMethods: []\nRubrics: Notes: A trial power law degree sequence is chosen and then elements are\nswapped with new elements from a power law distribution until\nthe sequence makes a tree (by checking, for example, that the number of\nedges is one smaller than the number of nodes).",
    "Section ID: constraint\nDescription: [Returns the constraint on all nodes in the graph G ., The constraint is a measure of the extent to which a node v is\ninvested in those nodes that are themselves invested in the\nneighbors of v . Formally, the constraint on v , denoted c(v) ,\nis defined by, where \\(N(v)\\) is the subset of the neighbors of v that are either\npredecessors or successors of v and \\(\\ell(v, w)\\) is the local\nconstraint on v with respect to w  [1] . For the definition of local\nconstraint, see local_constraint() .]\nField List: Parameters:: G : NetworkX graph: The graph containingv. This can be either directed or undirected.\nnodes : container, optional: Container of nodes in the graphGto compute the constraint. If\nNone, the constraint of every node is computed.\nweight : None or string, optional: If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nReturns:: dict: Dictionary with nodes as keys and the constraint on the node as values.\nMethods: []\nRubrics: References: [1]Burt, Ronald S.\n“Structural holes and good ideas”.\nAmerican Journal of Sociology (110): 349–399.",
    "Section ID: node_link_data\nDescription: [Returns data in node-link format that is suitable for JSON serialization\nand use in JavaScript documents.]\nField List: Parameters:: G : NetworkX graph: \nsource : string: A string that provides the ‘source’ attribute name for storing NetworkX-internal graph data.\ntarget : string: A string that provides the ‘target’ attribute name for storing NetworkX-internal graph data.\nname : string: A string that provides the ‘name’ attribute name for storing NetworkX-internal graph data.\nkey : string: A string that provides the ‘key’ attribute name for storing NetworkX-internal graph data.\nlink : string: A string that provides the ‘link’ attribute name for storing NetworkX-internal graph data.\nReturns:: data : dict: A dictionary with node-link formatted data.\nRaises:: NetworkXError: If the values of ‘source’, ‘target’ and ‘key’ are not unique.\nMethods: []\nRubrics: Notes: Graph, node, and link attributes are stored in this format.  Note that\nattribute keys will be converted to strings in order to comply with JSON. Attribute ‘key’ is only used for multigraphs. To use node_link_data in conjunction with node_link_graph ,\nthe keyword names for the attributes must match.\nExamples: G=nx.Graph([(\"A\",\"B\")])\ndata1=nx.node_link_data(G)\ndata1\n# {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\nTo serialize with JSON\nimportjson\ns1=json.dumps(data1)\ns1\n# '{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\nA graph can also be serialized by passingnode_link_dataas an encoder function. The two methods are equivalent.\ns1=json.dumps(G,default=nx.node_link_data)\ns1\n# '{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\nThe attribute names for storing NetworkX-internal graph data can\nbe specified as keyword options.\nH=nx.gn_graph(2)\ndata2=nx.node_link_data(H,link=\"edges\",source=\"from\",target=\"to\")\ndata2\n# {'directed': True, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 0}, {'id': 1}], 'edges': [{'from': 1, 'to': 0}]}",
    "Section ID: degree_centrality\nDescription: [Compute the degree centrality for nodes., The degree centrality for a node v is the fraction of nodes it\nis connected to.]\nField List: Parameters:: G : graph: A networkx graph\nReturns:: nodes : dictionary: Dictionary of nodes with degree centrality as the value.\nMethods: []\nRubrics: Notes: The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.\nExamples: G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.degree_centrality(G)\n# {0: 1.0, 1: 1.0, 2: 0.6666666666666666, 3: 0.6666666666666666}",
    "Section ID: all_pairs_bellman_ford_path_length\nDescription: [Compute shortest path lengths between all nodes in a weighted graph.]\nField List: Parameters:: G : NetworkX graph: \nweight : string or function (default=”weight”): If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.\nReturns:: distance : iterator: (source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value.\nMethods: []\nRubrics: Notes: Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionary returned only has keys for reachable node pairs.\nExamples: G=nx.path_graph(5)\nlength=dict(nx.all_pairs_bellman_ford_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0",
    "Section ID: is_graphical\nDescription: [Returns True if sequence is a valid degree sequence., A degree sequence is valid if some graph can realize it.]\nField List: Parameters:: sequence : list or iterable container: A sequence of integer node degrees\nmethod : “eg” | “hh”  (default: ‘eg’): The method used to validate the degree sequence.\n“eg” corresponds to the Erdős-Gallai algorithm[EG1960],[choudum1986], and\n“hh” to the Havel-Hakimi algorithm[havel1955],[hakimi1962],[CL1996].\nReturns:: valid : bool: True if the sequence is a valid degree sequence and False if not.\nMethods: []\nRubrics: References: [EG1960]Erdős and Gallai, Mat. Lapok 11 264, 1960.  [choudum1986]S.A. Choudum. “A simple proof of the Erdős-Gallai theorem on\ngraph sequences.” Bulletin of the Australian Mathematical Society, 33,\npp 67-70, 1986.https://doi.org/10.1017/S0004972700002872  [havel1955]Havel, V. “A Remark on the Existence of Finite Graphs”\nCasopis Pest. Mat. 80, 477-480, 1955.  [hakimi1962]Hakimi, S. “On the Realizability of a Set of Integers as\nDegrees of the Vertices of a Graph.” SIAM J. Appl. Math. 10, 496-506, 1962.  [CL1996]G. Chartrand and L. Lesniak, “Graphs and Digraphs”,\nChapman and Hall/CRC, 1996.\nExamples: G=nx.path_graph(4)\nsequence=(dforn,dinG.degree())\nnx.is_graphical(sequence)\n# True\nTo test a non-graphical sequence:\n>>> sequence_list = [d for n, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_graphical(sequence_list)\nFalse",
    "Section ID: powerlaw_sequence\nDescription: [Return sample sequence of length n from a power law distribution.]\nField List: Methods: []\nRubrics:",
    "Section ID: edge_current_flow_betweenness_centrality\nDescription: [Compute current-flow betweenness centrality for edges., Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths., Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] .]\nField List: Parameters:: G : graph: A NetworkX graph\nnormalized : bool, optional (default=True): If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.\nweight : string or None, optional (default=None): Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.\ndtype : data type (default=float): Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.\nsolver : string (default=’full’): Type of linear solver to use for computing the flow matrix.\nOptions are “full” (uses most memory), “lu” (recommended), and\n“cg” (uses least memory).\nReturns:: nodes : dictionary: Dictionary of edge tuples with betweenness centrality as the value.\nRaises:: NetworkXError: The algorithm does not support DiGraphs.\nIf the input graph is an instance of DiGraph class, NetworkXError\nis raised.\nMethods: []\nRubrics: Notes: Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a ‘weight’ attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\nReferences: [1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS ‘05).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005).",
    "Section ID: bull_graph\nDescription: [Returns the Bull Graph, The Bull Graph has 5 nodes and 5 edges. It is a planar undirected\ngraph in the form of a triangle with two disjoint pendant edges [1] The name comes from the triangle and pendant edges representing\nrespectively the body and legs of a bull.]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: A bull graph with 5 nodes\nMethods: []\nRubrics: References: [1]https://en.wikipedia.org/wiki/Bull_graph.",
    "Section ID: LFR_benchmark_graph\nDescription: [Returns the LFR benchmark graph., This algorithm proceeds as follows:]\nField List: Parameters:: n : int: Number of nodes in the created graph.\ntau1 : float: Power law exponent for the degree distribution of the created\ngraph. This value must be strictly greater than one.\ntau2 : float: Power law exponent for the community size distribution in the\ncreated graph. This value must be strictly greater than one.\nmu : float: Fraction of inter-community edges incident to each node. This\nvalue must be in the interval [0, 1].\naverage_degree : float: Desired average degree of nodes in the created graph. This value\nmust be in the interval [0,n]. Exactly one of this andmin_degreemust be specified, otherwise aNetworkXErroris raised.\nmin_degree : int: Minimum degree of nodes in the created graph. This value must be\nin the interval [0,n]. Exactly one of this andaverage_degreemust be specified, otherwise aNetworkXErroris raised.\nmax_degree : int: Maximum degree of nodes in the created graph. If not specified,\nthis is set ton, the total number of nodes in the graph.\nmin_community : int: Minimum size of communities in the graph. If not specified, this\nis set tomin_degree.\nmax_community : int: Maximum size of communities in the graph. If not specified, this\nis set ton, the total number of nodes in the graph.\ntol : float: Tolerance when comparing floats, specifically when comparing\naverage degree values.\nmax_iters : int: Maximum number of iterations to try to create the community sizes,\ndegree distribution, and community affiliations.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: G : NetworkX graph: The LFR benchmark graph generated according to the specified\nparameters.Each node in the graph has a node attribute'community'that\nstores the community (that is, the set of nodes) that includes\nit.\nRaises:: NetworkXError: If any of the parameters do not meet their upper and lower bounds:tau1andtau2must be strictly greater than 1.mumust be in [0, 1].max_degreemust be in {1, …,n}.min_communityandmax_communitymust be in {0, …,n}.If not exactly one ofaverage_degreeandmin_degreeis\nspecified.Ifmin_degreeis not specified and a suitablemin_degreecannot be found.\nExceededMaxIterations: If a valid degree sequence cannot be created withinmax_itersnumber of iterations.If a valid set of community sizes cannot be created withinmax_itersnumber of iterations.If a valid community assignment cannot be created within10*n*max_itersnumber of iterations.\nMethods: []\nRubrics: Notes: This algorithm differs slightly from the original way it was\npresented in [1].\nReferences: [1]“Benchmark graphs for testing community detection algorithms”,\nAndrea Lancichinetti, Santo Fortunato, and Filippo Radicchi,\nPhys. Rev. E 78, 046110 2008  [2]https://www.santofortunato.net/resources\nExamples: Basic usage:\nfromnetworkx.generators.communityimportLFR_benchmark_graph\nn=250\ntau1=3\ntau2=1.5\nmu=0.1\nG=LFR_benchmark_graph(\nn,tau1,tau2,mu,average_degree=5,min_community=20,seed=10\n)\nContinuing the example above, you can get the communities from the\nnode attributes of the graph:\ncommunities={frozenset(G.nodes[v][\"community\"])forvinG}",
    "Section ID: subgraph_centrality\nDescription: [Returns subgraph centrality for each node in G., Subgraph centrality  of a node n is the sum of weighted closed\nwalks of all lengths starting and ending at node n . The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ( [1] ).]\nField List: Parameters:: G: graph:\nReturns:: nodes : dictionary: Dictionary of nodes with subgraph centrality as the value.\nRaises:: NetworkXError: If the graph is not undirected and simple.\nMethods: []\nRubrics: Notes: This version of the algorithm computes eigenvalues and eigenvectors\nof the adjacency matrix. Subgraph centrality of a node u in G can be found using\na spectral decomposition of the adjacency matrix [1] ,\nReferences: [1](1,2,3)Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n“Subgraph centrality in complex networks”,\nPhysical Review E 71, 056103 (2005).https://arxiv.org/abs/cond-mat/0504730\nExamples: (Example from[1])\n>>> G = nx.Graph(\n…     [\n…         (1, 2),\n…         (1, 5),\n…         (1, 8),\n…         (2, 3),\n…         (2, 8),\n…         (3, 4),\n…         (3, 6),\n…         (4, 5),\n…         (4, 7),\n…         (5, 6),\n…         (6, 7),\n…         (7, 8),\n…     ]\n… )\n>>> sc = nx.subgraph_centrality(G)\n>>> print([f”{node} {sc[node]:0.2f}” for node in sorted(sc)])\n[‘1 3.90’, ‘2 3.90’, ‘3 3.64’, ‘4 3.71’, ‘5 3.64’, ‘6 3.71’, ‘7 3.64’, ‘8 3.90’]",
    "Section ID: mixing_expansion\nDescription: [Returns the mixing expansion between two node sets., The mixing expansion is the quotient of the cut size and twice the\nnumber of edges in the graph. [1]]\nField List: Parameters:: G : NetworkX graph: \nS : collection: A collection of nodes inG.\nT : collection: A collection of nodes inG.\nweight : object: Edge attribute key to use as weight. If not specified, edges\nhave weight one.\nReturns:: number: The mixing expansion between the two setsSandT.\nMethods: []\nRubrics: References: [1]Vadhan, Salil P.\n“Pseudorandomness.”Foundations and Trends\nin Theoretical Computer Science7.1–3 (2011): 1–336.\n<https://doi.org/10.1561/0400000010>",
    "Section ID: number_of_cliques\nDescription: [Returns the number of maximal cliques for each node., Returns a single or list depending on input nodes.\nOptional list of cliques can be input if already computed.]\nField List: Methods: []\nRubrics:",
    "Section ID: is_isomorphic\nDescription: [Returns True if the graphs G1 and G2 are isomorphic and False otherwise.]\nField List: Parameters:: G1, G2: graphs: The two graphs G1 and G2 must be the same type.\nnode_match : callable: A function that returns True if node n1 in G1 and n2 in G2 should\nbe considered equal during the isomorphism test.\nIf node_match is not specified then node attributes are not considered.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute dictionaries\nfor n1 and n2 as inputs.\nedge_match : callable: A function that returns True if the edge attribute dictionary\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during the isomorphism test.  If edge_match is\nnot specified then edge attributes are not considered.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute dictionaries\nof the edges under consideration.\nMethods: []\nRubrics: Notes: Uses the vf2 algorithm [1] .\nReferences: [1]L. P. Cordella, P. Foggia, C. Sansone, M. Vento,\n“An Improved Algorithm for Matching Large Graphs”,\n3rd IAPR-TC15 Workshop  on Graph-based Representations in\nPattern Recognition, Cuen, pp. 149-159, 2001.https://www.researchgate.net/publication/200034365_An_Improved_Algorithm_for_Matching_Large_Graphs\nExamples: importnetworkx.algorithms.isomorphismasiso\nFor digraphs G1 and G2, using ‘weight’ edge attribute (default: 1)\nG1=nx.DiGraph()\nG2=nx.DiGraph()\nnx.add_path(G1,[1,2,3,4],weight=1)\nnx.add_path(G2,[10,20,30,40],weight=2)\nem=iso.numerical_edge_match(\"weight\",1)\nnx.is_isomorphic(G1,G2)# no weights considered\n# True\nnx.is_isomorphic(G1,G2,edge_match=em)# match weights\n# False\nFor multidigraphs G1 and G2, using ‘fill’ node attribute (default: ‘’)\nG1=nx.MultiDiGraph()\nG2=nx.MultiDiGraph()\nG1.add_nodes_from([1,2,3],fill=\"red\")\nG2.add_nodes_from([10,20,30,40],fill=\"red\")\nnx.add_path(G1,[1,2,3,4],weight=3,linewidth=2.5)\nnx.add_path(G2,[10,20,30,40],weight=3)\nnm=iso.categorical_node_match(\"fill\",\"red\")\nnx.is_isomorphic(G1,G2,node_match=nm)\n# True\nFor multidigraphs G1 and G2, using ‘weight’ edge attribute (default: 7)\nG1.add_edge(1,2,weight=7)\n# 1\nG2.add_edge(10,20)\n# 1\nem=iso.numerical_multiedge_match(\"weight\",7,rtol=1e-6)\nnx.is_isomorphic(G1,G2,edge_match=em)\n# True\nFor multigraphs G1 and G2, using ‘weight’ and ‘linewidth’ edge attributes\nwith default values 7 and 2.5. Also using ‘fill’ node attribute with\ndefault value ‘red’.\nem=iso.numerical_multiedge_match([\"weight\",\"linewidth\"],[7,2.5])\nnm=iso.categorical_node_match(\"fill\",\"red\")\nnx.is_isomorphic(G1,G2,edge_match=em,node_match=nm)\n# True",
    "Section ID: ego_graph\nDescription: [Returns induced subgraph of neighbors centered at node n within\na given radius.]\nField List: Parameters:: G : graph: A NetworkX Graph or DiGraph\nn : node: A single node\nradius : number, optional: Include all neighbors of distance<=radius from n.\ncenter : bool, optional: If False, do not include center node in graph\nundirected : bool, optional: If True use both in- and out-neighbors of directed graphs.\ndistance : key, optional: Use specified edge data key as distance.  For example, setting\ndistance=’weight’ will use the edge weight to measure the\ndistance from the node n.\nMethods: []\nRubrics: Notes: For directed graphs D this produces the “out” neighborhood\nor successors.  If you want the neighborhood of predecessors\nfirst reverse the graph with D.reverse().  If you want both\ndirections use the keyword argument undirected=True. Node, edge, and graph attributes are copied to the returned subgraph.",
    "Section ID: greedy_modularity_communities\nDescription: [Find communities in G using greedy modularity maximization., This function uses Clauset-Newman-Moore greedy modularity maximization [2] to find the community partition with the largest modularity., Greedy modularity maximization begins with each node in its own community\nand repeatedly joins the pair of communities that lead to the largest\nmodularity until no further increase in modularity is possible (a maximum).\nTwo keyword arguments adjust the stopping condition. cutoff is a lower\nlimit on the number of communities so you can stop the process before\nreaching a maximum (used to save computation time). best_n is an upper\nlimit on the number of communities so you can make the process continue\nuntil at most n communities remain even if the maximum modularity occurs\nfor more. To obtain exactly n communities, set both cutoff and best_n to n., This function maximizes the generalized modularity, where resolution is the resolution parameter, often expressed as \\(\\gamma\\) .\nSee modularity() .]\nField List: Parameters:: G : NetworkX graph: \nweight : string or None, optional (default=None): The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.\nresolution : float, optional (default=1): If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities.\ncutoff : int, optional (default=1): A minimum number of communities below which the merging process stops.\nThe process stops at this number of communities even if modularity\nis not maximized. The goal is to let the user stop the process early.\nThe process stops before the cutoff if it finds a maximum of modularity.\nbest_n : int or None, optional (default=None): A maximum number of communities above which the merging process will\nnot stop. This forces community merging to continue after modularity\nstarts to decrease untilbest_ncommunities remain.\nIfNone, don’t force it to continue beyond a maximum.\nReturns:: communities: list: A list of frozensets of nodes, one for each community.\nSorted by length with largest communities first.\nRaises:: ValueError : If thecutofforbest_nvalue is not in the range: [1,G.number_of_nodes()], or ifbest_n<cutoff.\nMethods: []\nRubrics: References: [1]Newman, M. E. J. “Networks: An Introduction”, page 224\nOxford University Press 2011.  [2]Clauset, A., Newman, M. E., & Moore, C.\n“Finding community structure in very large networks.”\nPhysical Review E 70(6), 2004.  [3]Reichardt and Bornholdt “Statistical Mechanics of Community\nDetection” Phys. Rev. E74, 2006.  [4]Newman, M. E. J.”Analysis of weighted networks”\nPhysical Review E 70(5 Pt 2):056131, 2004.\nExamples: G=nx.karate_club_graph()\nc=nx.community.greedy_modularity_communities(G)\nsorted(c[0])\n# [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]",
    "Section ID: neighbors\nDescription: [Returns an iterator over all neighbors of node n., This function wraps the G.neighbors function.]\nField List: Methods: []\nRubrics:",
    "Section ID: random_weighted_sample\nDescription: [Returns k items without replacement from a weighted sample., The input is a dictionary of items with weights as values.]\nField List: Methods: []\nRubrics:",
    "Section ID: strategy_independent_set\nDescription: [Uses a greedy independent set removal strategy to determine the\ncolors., This function updates colors  in-place and return None ,\nunlike the other strategy functions in this module., This algorithm repeatedly finds and removes a maximal independent\nset, assigning each node in the set an unused color., G is a NetworkX graph., This strategy is related to strategy_smallest_last() : in that\nstrategy, an independent set of size one is chosen at each step\ninstead of a maximal independent set.]\nField List: Methods: []\nRubrics:",
    "Section ID: is_chordal\nDescription: [Checks whether G is a chordal graph., A graph is chordal if every cycle of length at least 4 has a chord\n(an edge joining two nodes not adjacent in the cycle).]\nField List: Parameters:: G : graph: A NetworkX graph.\nReturns:: chordal : bool: True if G is a chordal graph and False otherwise.\nRaises:: NetworkXNotImplemented: The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nMethods: []\nRubrics: Notes: The routine tries to go through every node following maximum cardinality\nsearch. It returns False when it finds that the separator for any node\nis not a clique.  Based on the algorithms in [1] . Self loops are ignored.\nReferences: [1]R. E. Tarjan and M. Yannakakis, Simple linear-time algorithms\nto test chordality of graphs, test acyclicity of hypergraphs, and\nselectively reduce acyclic hypergraphs, SIAM J. Comput., 13 (1984),\npp. 566–579.\nExamples: e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n]\nG=nx.Graph(e)\nnx.is_chordal(G)\n# True",
    "Section ID: approximate_current_flow_betweenness_centrality\nDescription: [Compute the approximate current-flow betweenness centrality for nodes., Approximates the current-flow betweenness centrality within absolute\nerror of epsilon with high probability [1] .]\nField List: Parameters:: G : graph: A NetworkX graph\nnormalized : bool, optional (default=True): If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.\nweight : string or None, optional (default=None): Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.\ndtype : data type (float): Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.\nsolver : string (default=’full’): Type of linear solver to use for computing the flow matrix.\nOptions are “full” (uses most memory), “lu” (recommended), and\n“cg” (uses least memory).\nepsilon: float: Absolute error tolerance.\nkmax: int: Maximum number of sample node pairs to use for approximation.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\nReturns:: nodes : dictionary: Dictionary of nodes with betweenness centrality as the value.\nMethods: []\nRubrics: Notes: The running time is \\(O((1/\\epsilon^2)m{\\sqrt k} \\log n)\\) and the space required is \\(O(m)\\) for \\(n\\) nodes and \\(m\\) edges. If the edges have a ‘weight’ attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\nReferences: [1]Ulrik Brandes and Daniel Fleischer:\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS ‘05).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44",
    "Section ID: is_bipartite\nDescription: [Returns True if graph G is bipartite, False if not.]\nField List: Parameters:: G : NetworkX graph:\nMethods: []\nRubrics: Examples: fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nprint(bipartite.is_bipartite(G))\n# True",
    "Section ID: kl_connected_subgraph\nDescription: [Returns the maximum locally (k,l) -connected subgraph of G ., A graph is locally (k,l) -connected if for each edge (u,v) in the\ngraph there are at least l edge-disjoint paths of length at most k joining u to v .]\nField List: Parameters:: G : NetworkX graph: The graph in which to find a maximum locally(k,l)-connected\nsubgraph.\nk : integer: The maximum length of paths to consider. A higher number means a looser\nconnectivity requirement.\nl : integer: The number of edge-disjoint paths. A higher number means a stricter\nconnectivity requirement.\nlow_memory : bool: If this is True, this function uses an algorithm that uses slightly\nmore time but less memory.\nsame_as_graph : bool: If True then return a tuple of the form(H,is_same),\nwhereHis the maximum locally(k,l)-connected subgraph andis_sameis a Boolean representing whetherGis locally(k,l)-connected (and hence, whetherHis simply a copy of the input\ngraphG).\nReturns:: NetworkX graph or two-tuple: Ifsame_as_graphis True, then this function returns a\ntwo-tuple as described above. Otherwise, it returns only the maximum\nlocally(k,l)-connected subgraph.\nMethods: []\nRubrics: References: [1]Chung, Fan and Linyuan Lu. “The Small World Phenomenon in Hybrid\nPower Law Graphs.”Complex Networks. Springer Berlin Heidelberg,\n2004. 89–104.",
    "Section ID: house_x_graph\nDescription: [Returns the House graph with a cross inside the house square., The House X-graph is the House graph plus the two edges connecting diagonally\nopposite vertices of the square base. It is also one of the two graphs\nobtained by removing two edges from the pentatope graph [1] .]\nField List: Parameters:: create_using : NetworkX graph constructor, optional (default=nx.Graph): Graph type to create. If graph instance, then cleared before populated.\nReturns:: G : networkx Graph: House graph with diagonal vertices connected\nMethods: []\nRubrics: References: [1]https://mathworld.wolfram.com/HouseGraph.html",
    "Section ID: edge_betweenness_centrality_subset\nDescription: [Compute betweenness centrality for edges for a subset of nodes., where \\(S\\) is the set of sources, \\(T\\) is the set of targets, \\(\\sigma(s, t)\\) is the number of shortest \\((s, t)\\) -paths,\nand \\(\\sigma(s, t|e)\\) is the number of those paths\npassing through edge \\(e\\)  [2] .]\nField List: Parameters:: G : graph: A networkx graph.\nsources: list of nodes: Nodes to use as sources for shortest paths in betweenness\ntargets: list of nodes: Nodes to use as targets for shortest paths in betweenness\nnormalized : bool, optional: If True the betweenness values are normalized by2/(n(n-1))for graphs, and1/(n(n-1))for directed graphs wherenis the number of nodes in G.\nweight : None or string, optional (default=None): If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances.\nReturns:: edges : dictionary: Dictionary of edges with Betweenness centrality as the value.\nMethods: []\nRubrics: Notes: The basic algorithm is from [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The normalization might seem a little strange but it is the same\nas in edge_betweenness_centrality() and is designed to make\nedge_betweenness_centrality(G) be the same as\nedge_betweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()).\nReferences: [1]Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001",
    "Section ID: read_dot\nDescription: [Returns a NetworkX MultiGraph or MultiDiGraph from the\ndot file with the passed path., If this file contains multiple graphs, only the first such graph is\nreturned. All graphs _except_ the first are silently ignored.]\nField List: Parameters:: path : str or file: Filename or file handle.\nReturns:: G : MultiGraph or MultiDiGraph: AMultiGraphorMultiDiGraph.\nMethods: []\nRubrics: Notes: Use G=nx.Graph(nx.nx_pydot.read_dot(path)) to return a Graph instead of a MultiGraph .",
    "Section ID: global_efficiency\nDescription: [Returns the average global efficiency of the graph., The efficiency of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The average\nglobal efficiency of a graph is the average efficiency of all pairs of\nnodes [1] .]\nField List: Parameters:: G : networkx.Graph: An undirected graph for which to compute the average global efficiency.\nReturns:: float: The average global efficiency of the graph.\nMethods: []\nRubrics: Notes: Edge weights are ignored when computing the shortest path distances.\nReferences: [1]Latora, Vito, and Massimo Marchiori.\n“Efficient behavior of small-world networks.”Physical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>\nExamples: G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nround(nx.global_efficiency(G),12)\n# 0.916666666667",
    "Section ID: edmonds_karp\nDescription: [Find a maximum single-commodity flow using the Edmonds-Karp algorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has a running time of \\(O(n m^2)\\) for \\(n\\) nodes and \\(m\\) edges.]\nField List: Parameters:: G : NetworkX graph: Edges of the graph are expected to have an attribute called\n‘capacity’. If this attribute is not present, the edge is\nconsidered to have infinite capacity.\ns : node: Source node for the flow.\nt : node: Sink node for the flow.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nresidual : NetworkX graph: Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.\nvalue_only : bool: If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.\ncutoff : integer, float: If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None.\nReturns:: R : NetworkX DiGraph: Residual network after computing the maximum flow.\nRaises:: NetworkXError: The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.\nNetworkXUnbounded: If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded.\nMethods: []\nRubrics: Notes: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.\nExamples: fromnetworkx.algorithms.flowimportedmonds_karp\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=edmonds_karp(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True",
    "Section ID: gnm_random_graph\nDescription: [Returns a \\(G_{n,m}\\) random graph., In the \\(G_{n,m}\\) model, a graph is chosen uniformly at random from the set\nof all graphs with \\(n\\) nodes and \\(m\\) edges., This algorithm should be faster than dense_gnm_random_graph() for\nsparse graphs.]\nField List: Parameters:: n : int: The number of nodes.\nm : int: The number of edges.\nseed : integer, random_state, or None (default): Indicator of random number generation state.\nSeeRandomness.\ndirected : bool, optional (default=False): If True return a directed graph\nMethods: []\nRubrics:",
    "Section ID: bridges\nDescription: [Generate all bridges in a graph., A bridge in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.  Equivalently, a bridge is an\nedge that does not belong to any cycle. Bridges are also known as cut-edges,\nisthmuses, or cut arcs.]\nField List: Parameters:: G : undirected graph: \nroot : node (optional): A node in the graphG. If specified, only the bridges in the\nconnected component containing this node will be returned.\nYields:: e : edge: An edge in the graph whose removal disconnects the graph (or\ncauses the number of connected components to increase).\nRaises:: NodeNotFound: Ifrootis not in the graphG.\nNetworkXNotImplemented: IfGis a directed graph.\nMethods: []\nRubrics: Notes: This is an implementation of the algorithm described in [1] .  An edge is a\nbridge if and only if it is not contained in any chain. Chains are found\nusing the networkx.chain_decomposition() function. The algorithm described in [1] requires a simple graph. If the provided\ngraph is a multigraph, we convert it to a simple graph and verify that any\nbridges discovered by the chain decomposition algorithm are not multi-edges. Ignoring polylogarithmic factors, the worst-case time complexity is the\nsame as the networkx.chain_decomposition() function, \\(O(m + n)\\) , where \\(n\\) is the number of nodes in the graph and \\(m\\) is\nthe number of edges.\nReferences: [1](1,2)https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29#Bridge-Finding_with_Chain_Decompositions\nExamples: The barbell graph with parameter zero has a single bridge:\nG=nx.barbell_graph(10,0)\nlist(nx.bridges(G))\n# [(9, 10)]",
    "Section ID: edges_equal\nDescription: [Check if edges are equal., Equality here means equal as Python objects.\nEdge data must match if included.\nThe order of the edges is not relevant.]\nField List: Parameters:: edges1, edges2 : iterables of with u, v nodes as: edge tuples (u, v), or\nedge tuples with data dicts (u, v, d), or\nedge tuples with keys and data dicts (u, v, k, d)\nReturns:: bool: True if edges are equal, False otherwise.\nMethods: []\nRubrics:",
    "Section ID: closeness_vitality\nDescription: [Returns the closeness vitality for nodes in the graph., The closeness vitality of a node, defined in Section 3.6.2 of [1],\nis the change in the sum of distances between all node pairs when\nexcluding that node.]\nField List: Parameters:: G : NetworkX graph: A strongly-connected graph.\nweight : string: The name of the edge attribute used as weight. This is passed\ndirectly to thewiener_index()function.\nnode : object: If specified, only the closeness vitality for this node will be\nreturned. Otherwise, a dictionary mapping each node to its\ncloseness vitality will be returned.\nReturns:: dictionary or float: Ifnodeis None, this function returns a dictionary\nwith nodes as keys and closeness vitality as the\nvalue. Otherwise, it returns only the closeness vitality for the\nspecifiednode.The closeness vitality of a node may be negative infinity if\nremoving that node would disconnect the graph.\nOther Parameters:: wiener_index : number: If you have already computed the Wiener index of the graphG, you can provide that value here. Otherwise, it will be\ncomputed for you.\nMethods: []\nRubrics: References: [1]Ulrik Brandes, Thomas Erlebach (eds.).Network Analysis: Methodological Foundations.\nSpringer, 2005.\n<http://books.google.com/books?id=TTNhSm7HYrIC>\nExamples: G=nx.cycle_graph(3)\nnx.closeness_vitality(G)\n# {0: 2.0, 1: 2.0, 2: 2.0}",
    "Section ID: floyd_warshall\nDescription: [Find all-pairs shortest path lengths using Floyd’s algorithm.]\nField List: Parameters:: G : NetworkX graph: \nweight: string, optional (default= ‘weight’): Edge data key corresponding to the edge weight.\nReturns:: distance : dict: A dictionary,  keyed by source and target, of shortest paths distances\nbetween nodes.\nMethods: []\nRubrics: Notes: Floyd’s algorithm is appropriate for finding shortest paths\nin dense graphs or graphs with negative weights when Dijkstra’s algorithm\nfails.  This algorithm can still fail if there are negative cycles.\nIt has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .\nExamples: G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,5),(1,2,2),(2,3,-3),(1,3,10),(3,2,8)])\nfw=nx.floyd_warshall(G,weight=\"weight\")\nresults={a:dict(b)fora,binfw.items()}\nprint(results)\n# {0: {0: 0, 1: 5, 2: 7, 3: 4}, 1: {1: 0, 2: 2, 3: -1, 0: inf}, 2: {2: 0, 3: -3, 0: inf, 1: inf}, 3: {3: 0, 2: 8, 0: inf, 1: inf}}",
    "Section ID: reverse_havel_hakimi_graph\nDescription: [Returns a bipartite graph from two given degree sequences using a\nHavel-Hakimi style construction., The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from set A are connected to nodes in the set B by connecting\nthe highest degree nodes in set A to the lowest degree nodes in\nset B until all stubs are connected.]\nField List: Parameters:: aseq : list: Degree sequence for node set A.\nbseq : list: Degree sequence for node set B.\ncreate_using : NetworkX graph instance, optional: Return graph of this type.\nMethods: []\nRubrics: Notes: The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute ‘bipartite’ with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.reverse_havel_hakimi_graph",
    "Section ID: FilterAtlas\nDescription: [A read-only Mapping of Mappings with filtering criteria for nodes., It is a view into a dict-of-dict data structure, and it selects only\nnodes that meet the criteria defined by NODE_OK .]\nField List: Methods: []\nRubrics:",
    "Section ID: graph_atlas_g\nDescription: [Returns the list of all graphs with up to seven nodes named in the\nGraph Atlas., The graphs are listed in increasing order by, in that order, with three exceptions as described in the Notes section below. This causes the list to correspond with the index of\nthe graphs in the Graph Atlas [atlas] , with the first graph, G[0] , being the null graph.]\nField List: Returns:: list: A list ofGraphobjects, the one at indexicorresponding to the graphiin the Graph Atlas.\nMethods: []\nRubrics: Notes: This function may be expensive in both time and space, since it\nreads a large file sequentially in order to populate the list. Although the NetworkX atlas functions match the order of graphs\ngiven in the “Atlas of Graphs” book, there are (at least) three\nerrors in the ordering described in the book. The following three\npairs of nodes violate the lexicographically nondecreasing sorted\ndegree sequence rule:\nReferences: [atlas]Ronald C. Read and Robin J. Wilson,An Atlas of Graphs.\nOxford University Press, 1998.",
    "Section ID: set_node_attributes\nDescription: [Sets node attributes from a given value or dictionary of values.]\nField List: Parameters:: G : NetworkX Graph: \nvalues : scalar value, dict-like: What the node attribute should be set to.  Ifvaluesis\nnot a dictionary, then it is treated as a single attribute value\nthat is then applied to every node inG.  This means that if\nyou provide a mutable object, like a list, updates to that object\nwill be reflected in the node attribute for every node.\nThe attribute name will bename.Ifvaluesis a dict or a dict of dict, it should be keyed\nby node to either an attribute value or a dict of attribute key/value\npairs used to update the node’s attributes.\nname : string (optional, default=None): Name of the node attribute to set if values is a scalar.\nMethods: []\nRubrics: Examples: After computing some property of the nodes of a graph, you may want\nto assign a node attribute to store the value of that property for\neach node:\nG=nx.path_graph(3)\nbb=nx.betweenness_centrality(G)\nisinstance(bb,dict)\n# True\nnx.set_node_attributes(G,bb,\"betweenness\")\nG.nodes[1][\"betweenness\"]\n# 1.0\nIf you provide a list as the second argument, updates to the list\nwill be reflected in the node attribute for each node:\nG=nx.path_graph(3)\nlabels=[]\nnx.set_node_attributes(G,labels,\"labels\")\nlabels.append(\"foo\")\nG.nodes[0][\"labels\"]\n# ['foo']\nG.nodes[1][\"labels\"]\n# ['foo']\nG.nodes[2][\"labels\"]\n# ['foo']\nIf you provide a dictionary of dictionaries as the second argument,\nthe outer dictionary is assumed to be keyed by node to an inner\ndictionary of node attributes for that node:\nG=nx.path_graph(3)\nattrs={0:{\"attr1\":20,\"attr2\":\"nothing\"},1:{\"attr2\":3}}\nnx.set_node_attributes(G,attrs)\nG.nodes[0][\"attr1\"]\n# 20\nG.nodes[0][\"attr2\"]\n# 'nothing'\nG.nodes[1][\"attr2\"]\n# 3\nG.nodes[2]\n# {}\nNote that if the dictionary contains nodes that are not inG, the\nvalues are silently ignored:\nG=nx.Graph()\nG.add_node(0)\nnx.set_node_attributes(G,{0:\"red\",1:\"blue\"},name=\"color\")\nG.nodes[0][\"color\"]\n# 'red'\n1inG.nodes\n# False",
    "Section ID: min_cost_flow\nDescription: [Returns a minimum cost flow satisfying all demands in digraph G., G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.]\nField List: Parameters:: G : NetworkX graph: DiGraph on which a minimum cost flow satisfying all demands is\nto be found.\ndemand : string: Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: ‘demand’.\ncapacity : string: Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: ‘capacity’.\nweight : string: Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: ‘weight’.\nReturns:: flowDict : dictionary: Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v).\nRaises:: NetworkXError: This exception is raised if the input graph is not directed or\nnot connected.\nNetworkXUnfeasible: This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.\nNetworkXUnbounded: This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below.\nMethods: []\nRubrics: Notes: This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\nExamples: A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowDict=nx.min_cost_flow(G)\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}",
    "Section ID: min_weight_matching\nDescription: [Computing a minimum-weight maximal matching of G., Use the maximum-weight algorithm with edge weights subtracted\nfrom the maximum weight of all edges., A matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges., This method replaces the edge weights with 1 plus the maximum edge weight\nminus the original edge weight., new_weight = (max_weight + 1) - edge_weight, then runs max_weight_matching() with the new weights.\nThe max weight matching with these new weights corresponds\nto the min weight matching using the original weights.\nAdding 1 to the max edge weight keeps all edge weights positive\nand as integers if they started as integers., You might worry that adding 1 to each weight would make the algorithm\nfavor matchings with more edges. But we use the parameter maxcardinality=True in max_weight_matching to ensure that the\nnumber of edges in the competing matchings are the same and thus\nthe optimum does not change due to changes in the number of edges., Read the documentation of max_weight_matching for more information.]\nField List: Parameters:: G : NetworkX graph: Undirected graph\nweight: string, optional (default=’weight’): Edge data key corresponding to the edge weight.\nIf key not found, uses 1 as weight.\nReturns:: matching : set: A minimal weight matching of the graph.\nMethods: []\nRubrics:",
    "Section ID: density\nDescription: [Returns the density of a graph., The density for undirected graphs is, and for directed graphs is, where n is the number of nodes and m is the number of edges in G ., Notes, The density is 0 for a graph without edges and 1 for a complete graph.\nThe density of multigraphs can be higher than 1., Self loops are counted in the total number of edges so graphs with self\nloops can have density higher than 1.]\nField List: Methods: []\nRubrics: Notes: The density is 0 for a graph without edges and 1 for a complete graph.\nThe density of multigraphs can be higher than 1. Self loops are counted in the total number of edges so graphs with self\nloops can have density higher than 1.",
    "Section ID: write_dot\nDescription: [Write NetworkX graph G to Graphviz dot format on path., Path can be a string or a file handle.]\nField List: Methods: []\nRubrics:",
    "Section_id: Graph\nDescription: [Base class for undirected graphs., A Graph stores nodes and edges with optional data, or attributes., Graphs hold undirected edges.  Self loops are allowed but multiple\n(parallel) edges are not., Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes, except that None is not allowed as a node., Edges are represented as links between nodes with optional\nkey/value attributes.]",
    "Section_id: DiGraph\nDescription: [Base class for directed graphs., A DiGraph stores nodes and edges with optional data, or attributes., DiGraphs hold directed edges.  Self loops are allowed but multiple\n(parallel) edges are not., Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node., Edges are represented as links between nodes with optional\nkey/value attributes.]",
    "Section_id: MultiGraph\nDescription: [An undirected graph class that can store multiedges., Multiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes., A MultiGraph holds undirected edges.  Self loops are allowed., Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node., Edges are represented as links between nodes with optional\nkey/value attributes, in a MultiGraph each edge has a key to\ndistinguish between multiple edges that have the same source and\ndestination nodes.]",
    "Section_id: MultiDiGraph\nDescription: [A directed graph class that can store multiedges., Multiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes., A MultiDiGraph holds directed edges.  Self loops are allowed., Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node., Edges are represented as links between nodes with optional\nkey/value attributes.]"
]