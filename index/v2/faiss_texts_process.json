[
    "cdlib: Node Communities representation.. Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won’t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n",
    "cdlib: Node Communities representation.. Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then “adjusted for chance” into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n",
    "cdlib: Node Communities representation.. The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n",
    "cdlib: Node Communities representation.. Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n",
    "cdlib: Node Communities representation.. Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n",
    "cdlib: Node Communities representation.. Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Node Communities representation.. Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n",
    "cdlib: Node Communities representation.. Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n",
    "cdlib: Node Communities representation.. Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n − n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n",
    "cdlib: Node Communities representation.. Number of edges internal to the algorithms.\n",
    "cdlib: Node Communities representation.. Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S − \\frac{mn_S(n_S −1)}{n(n−1)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
    "cdlib: Node Communities representation.. Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n",
    "cdlib: Node Communities representation.. Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
    "cdlib: Node Communities representation.. Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Node Communities representation.. Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n",
    "cdlib: Node Communities representation.. Return a description of the clustering, with the name of the method and its numeric parameters.\n",
    "cdlib: Node Communities representation.. Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n",
    "cdlib: Node Communities representation.. The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S−1)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n",
    "cdlib: Node Communities representation.. Quality function designed for directed graphs with overlapping communities.\n",
    "cdlib: Node Communities representation.. Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n",
    "cdlib: Node Communities representation.. The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} − d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n",
    "cdlib: Node Communities representation.. Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n",
    "cdlib: Node Communities representation.. Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
    "cdlib: Node Communities representation.. Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
    "cdlib: Node Communities representation.. Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m−m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n",
    "cdlib: Node Communities representation.. Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n",
    "cdlib: Node Communities representation.. Index of resemblance for overlapping, complete coverage, network clusterings.\n",
    "cdlib: Node Communities representation.. Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n",
    "cdlib: Node Communities representation.. Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n",
    "cdlib: Node Communities representation.. Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n",
    "cdlib: Node Communities representation.. Significance estimates how likely a partition of dense communities appear in a random graph.\n",
    "cdlib: Node Communities representation.. Size is the number of nodes in the community\n",
    "cdlib: Node Communities representation.. Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n",
    "cdlib: Node Communities representation.. Generate a JSON representation of the algorithms object\n",
    "cdlib: Node Communities representation.. Generate a <node, list(communities)> representation of the current clustering\n",
    "cdlib: Node Communities representation.. Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Node Communities representation.. Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n",
    "cdlib: Node Communities representation.. Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n",
    "cdlib: Fuzzy Node Communities representation.. Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won’t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n",
    "cdlib: Fuzzy Node Communities representation.. Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then “adjusted for chance” into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n",
    "cdlib: Fuzzy Node Communities representation.. The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n",
    "cdlib: Fuzzy Node Communities representation.. Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n",
    "cdlib: Fuzzy Node Communities representation.. Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n",
    "cdlib: Fuzzy Node Communities representation.. Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Fuzzy Node Communities representation.. Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n",
    "cdlib: Fuzzy Node Communities representation.. Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n",
    "cdlib: Fuzzy Node Communities representation.. Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n − n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n",
    "cdlib: Fuzzy Node Communities representation.. Number of edges internal to the algorithms.\n",
    "cdlib: Fuzzy Node Communities representation.. Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S − \\frac{mn_S(n_S −1)}{n(n−1)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
    "cdlib: Fuzzy Node Communities representation.. Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n",
    "cdlib: Fuzzy Node Communities representation.. Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
    "cdlib: Fuzzy Node Communities representation.. Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Fuzzy Node Communities representation.. Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n",
    "cdlib: Fuzzy Node Communities representation.. Return a description of the clustering, with the name of the method and its numeric parameters.\n",
    "cdlib: Fuzzy Node Communities representation.. Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n",
    "cdlib: Fuzzy Node Communities representation.. The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S−1)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n",
    "cdlib: Fuzzy Node Communities representation.. Quality function designed for directed graphs with overlapping communities.\n",
    "cdlib: Fuzzy Node Communities representation.. Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n",
    "cdlib: Fuzzy Node Communities representation.. The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} − d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n",
    "cdlib: Fuzzy Node Communities representation.. Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n",
    "cdlib: Fuzzy Node Communities representation.. Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
    "cdlib: Fuzzy Node Communities representation.. Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
    "cdlib: Fuzzy Node Communities representation.. Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m−m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n",
    "cdlib: Fuzzy Node Communities representation.. Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n",
    "cdlib: Fuzzy Node Communities representation.. Index of resemblance for overlapping, complete coverage, network clusterings.\n",
    "cdlib: Fuzzy Node Communities representation.. Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n",
    "cdlib: Fuzzy Node Communities representation.. Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n",
    "cdlib: Fuzzy Node Communities representation.. Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n",
    "cdlib: Fuzzy Node Communities representation.. Significance estimates how likely a partition of dense communities appear in a random graph.\n",
    "cdlib: Fuzzy Node Communities representation.. Size is the number of nodes in the community\n",
    "cdlib: Fuzzy Node Communities representation.. Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n",
    "cdlib: Fuzzy Node Communities representation.. Generate a JSON representation of the algorithms object\n",
    "cdlib: Fuzzy Node Communities representation.. Generate a <node, list(communities)> representation of the current clustering\n",
    "cdlib: Fuzzy Node Communities representation.. Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Fuzzy Node Communities representation.. Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n",
    "cdlib: Fuzzy Node Communities representation.. Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n",
    "cdlib: Attribute Node Communities representation.. Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won’t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n",
    "cdlib: Attribute Node Communities representation.. Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then “adjusted for chance” into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n",
    "cdlib: Attribute Node Communities representation.. The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n",
    "cdlib: Attribute Node Communities representation.. Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n",
    "cdlib: Attribute Node Communities representation.. Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n",
    "cdlib: Attribute Node Communities representation.. Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Attribute Node Communities representation.. Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n",
    "cdlib: Attribute Node Communities representation.. Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n",
    "cdlib: Attribute Node Communities representation.. Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n − n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n",
    "cdlib: Attribute Node Communities representation.. Number of edges internal to the algorithms.\n",
    "cdlib: Attribute Node Communities representation.. Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S − \\frac{mn_S(n_S −1)}{n(n−1)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
    "cdlib: Attribute Node Communities representation.. Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n",
    "cdlib: Attribute Node Communities representation.. Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
    "cdlib: Attribute Node Communities representation.. Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Attribute Node Communities representation.. Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n",
    "cdlib: Attribute Node Communities representation.. Return a description of the clustering, with the name of the method and its numeric parameters.\n",
    "cdlib: Attribute Node Communities representation.. Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n",
    "cdlib: Attribute Node Communities representation.. The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S−1)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n",
    "cdlib: Attribute Node Communities representation.. Quality function designed for directed graphs with overlapping communities.\n",
    "cdlib: Attribute Node Communities representation.. Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n",
    "cdlib: Attribute Node Communities representation.. The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} − d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n",
    "cdlib: Attribute Node Communities representation.. Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n",
    "cdlib: Attribute Node Communities representation.. Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
    "cdlib: Attribute Node Communities representation.. Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
    "cdlib: Attribute Node Communities representation.. Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m−m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n",
    "cdlib: Attribute Node Communities representation.. Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n",
    "cdlib: Attribute Node Communities representation.. Index of resemblance for overlapping, complete coverage, network clusterings.\n",
    "cdlib: Attribute Node Communities representation.. Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n",
    "cdlib: Attribute Node Communities representation.. Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n",
    "cdlib: Attribute Node Communities representation.. Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n",
    "cdlib: Attribute Node Communities representation.. Significance estimates how likely a partition of dense communities appear in a random graph.\n",
    "cdlib: Attribute Node Communities representation.. Size is the number of nodes in the community\n",
    "cdlib: Attribute Node Communities representation.. Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n",
    "cdlib: Attribute Node Communities representation.. Generate a JSON representation of the algorithms object\n",
    "cdlib: Attribute Node Communities representation.. Generate a <node, list(communities)> representation of the current clustering\n",
    "cdlib: Attribute Node Communities representation.. Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Attribute Node Communities representation.. Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n",
    "cdlib: Attribute Node Communities representation.. Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n",
    "cdlib: Edge Clustering representation.. Return a description of the clustering, with the name of the method and its numeric parameters.\n",
    "cdlib: Edge Clustering representation.. Generate a <edge, list(communities)> representation of the current clustering\n",
    "cdlib: Edge Clustering representation.. Generate a JSON representation of the algorithms object\n",
    "cdlib: Bipartite Node Communities representation.. Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won’t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n",
    "cdlib: Bipartite Node Communities representation.. Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then “adjusted for chance” into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n",
    "cdlib: Bipartite Node Communities representation.. The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n",
    "cdlib: Bipartite Node Communities representation.. Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n",
    "cdlib: Bipartite Node Communities representation.. Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n",
    "cdlib: Bipartite Node Communities representation.. Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Bipartite Node Communities representation.. Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n",
    "cdlib: Bipartite Node Communities representation.. Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n",
    "cdlib: Bipartite Node Communities representation.. Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n − n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n",
    "cdlib: Bipartite Node Communities representation.. Number of edges internal to the algorithms.\n",
    "cdlib: Bipartite Node Communities representation.. Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S − \\frac{mn_S(n_S −1)}{n(n−1)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
    "cdlib: Bipartite Node Communities representation.. Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n",
    "cdlib: Bipartite Node Communities representation.. Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
    "cdlib: Bipartite Node Communities representation.. Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Bipartite Node Communities representation.. Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n",
    "cdlib: Bipartite Node Communities representation.. Return a description of the clustering, with the name of the method and its numeric parameters.\n",
    "cdlib: Bipartite Node Communities representation.. Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n",
    "cdlib: Bipartite Node Communities representation.. The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S−1)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n",
    "cdlib: Bipartite Node Communities representation.. Quality function designed for directed graphs with overlapping communities.\n",
    "cdlib: Bipartite Node Communities representation.. Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n",
    "cdlib: Bipartite Node Communities representation.. The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} − d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n",
    "cdlib: Bipartite Node Communities representation.. Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n",
    "cdlib: Bipartite Node Communities representation.. Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
    "cdlib: Bipartite Node Communities representation.. Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
    "cdlib: Bipartite Node Communities representation.. Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m−m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n",
    "cdlib: Bipartite Node Communities representation.. Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n",
    "cdlib: Bipartite Node Communities representation.. Index of resemblance for overlapping, complete coverage, network clusterings.\n",
    "cdlib: Bipartite Node Communities representation.. Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n",
    "cdlib: Bipartite Node Communities representation.. Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n",
    "cdlib: Bipartite Node Communities representation.. Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n",
    "cdlib: Bipartite Node Communities representation.. Significance estimates how likely a partition of dense communities appear in a random graph.\n",
    "cdlib: Bipartite Node Communities representation.. Size is the number of nodes in the community\n",
    "cdlib: Bipartite Node Communities representation.. Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n",
    "cdlib: Bipartite Node Communities representation.. Generate a JSON representation of the algorithms object\n",
    "cdlib: Bipartite Node Communities representation.. Generate a <node, list(communities)> representation of the current clustering\n",
    "cdlib: Bipartite Node Communities representation.. Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n",
    "cdlib: Bipartite Node Communities representation.. Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n",
    "cdlib: Bipartite Node Communities representation.. Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Add to the Temporal Clustering the communities observed at a given time\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Add a precomputed matching of the communities.\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Returns the trend for community stability.\nThe stability index is computed for temporally adjacent clustering pairs.\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Reconstruct community matches across adjacent observations using a provided similarity function.\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Returns the clustering observed at a given time\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Returns the nodes within a given temporal community\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Return an explicit matching of computed communities (if it exists)\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Checks if the algorithm provided an explicit match of temporal communities\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Reconstruct the poly-tree representing communities lifecycles using a provided similarity function.\n",
    "cdlib: Add to the Temporal Clustering the communities observed at a given time. Generate a JSON representation of the TemporalClustering object\n",
    "graspologic: Flips the signs of all entries in one dataset, X along some of the dimensions. In particular, it does so in a way that brings this dataset to the same orthant as the second dataset, Y, according to some criterion, computed along each dimension. The two critera currently available are the median and the maximum (in magnitude) value along each dimension.\nThis module can also be used to bring the dataset to the first orthant (i.e. with all criteras being positive) by providing the identity matrix as the second dataset.. Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second.\nIn sign flips, Q_ is an diagonal orthogonal matrices (i.e. a matrix with 1 or -1 in each entry on diagonal and 0 everywhere else) picked such that all dimensions of X @ Q_ and Y are in the same orthant using some critera (median or max magnitude).",
    "graspologic: Flips the signs of all entries in one dataset, X along some of the dimensions. In particular, it does so in a way that brings this dataset to the same orthant as the second dataset, Y, according to some criterion, computed along each dimension. The two critera currently available are the median and the maximum (in magnitude) value along each dimension.\nThis module can also be used to bring the dataset to the first orthant (i.e. with all criteras being positive) by providing the identity matrix as the second dataset.. Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.",
    "graspologic: Flips the signs of all entries in one dataset, X along some of the dimensions. In particular, it does so in a way that brings this dataset to the same orthant as the second dataset, Y, according to some criterion, computed along each dimension. The two critera currently available are the median and the maximum (in magnitude) value along each dimension.\nThis module can also be used to bring the dataset to the first orthant (i.e. with all criteras being positive) by providing the identity matrix as the second dataset.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Flips the signs of all entries in one dataset, X along some of the dimensions. In particular, it does so in a way that brings this dataset to the same orthant as the second dataset, Y, according to some criterion, computed along each dimension. The two critera currently available are the median and the maximum (in magnitude) value along each dimension.\nThis module can also be used to bring the dataset to the first orthant (i.e. with all criteras being positive) by providing the identity matrix as the second dataset.. Get parameters for this estimator.",
    "graspologic: Flips the signs of all entries in one dataset, X along some of the dimensions. In particular, it does so in a way that brings this dataset to the same orthant as the second dataset, Y, according to some criterion, computed along each dimension. The two critera currently available are the median and the maximum (in magnitude) value along each dimension.\nThis module can also be used to bring the dataset to the first orthant (i.e. with all criteras being positive) by providing the identity matrix as the second dataset.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Flips the signs of all entries in one dataset, X along some of the dimensions. In particular, it does so in a way that brings this dataset to the same orthant as the second dataset, Y, according to some criterion, computed along each dimension. The two critera currently available are the median and the maximum (in magnitude) value along each dimension.\nThis module can also be used to bring the dataset to the first orthant (i.e. with all criteras being positive) by providing the identity matrix as the second dataset.. Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.",
    "graspologic: Computes the matrix solution of the seedless Procrustes problem, which is that given two matrices X and Y of equal shape (n, d), find an orthogonal matrix that most closely maps X to Y. Subsequently, uses that matrix to transform either the original X, or a different dataset in the same space.\nNote that when used to match two datasets, this method only requires that the datasets have the same number of entries, but not that there is some correspondence between the entries. In graph embeddings, this usually corresponds to the assumption that the vertex i in graph X has the same latent position as the vertex i in graph Y.. Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second.",
    "graspologic: Computes the matrix solution of the seedless Procrustes problem, which is that given two matrices X and Y of equal shape (n, d), find an orthogonal matrix that most closely maps X to Y. Subsequently, uses that matrix to transform either the original X, or a different dataset in the same space.\nNote that when used to match two datasets, this method only requires that the datasets have the same number of entries, but not that there is some correspondence between the entries. In graph embeddings, this usually corresponds to the assumption that the vertex i in graph X has the same latent position as the vertex i in graph Y.. Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.",
    "graspologic: Computes the matrix solution of the seedless Procrustes problem, which is that given two matrices X and Y of equal shape (n, d), find an orthogonal matrix that most closely maps X to Y. Subsequently, uses that matrix to transform either the original X, or a different dataset in the same space.\nNote that when used to match two datasets, this method only requires that the datasets have the same number of entries, but not that there is some correspondence between the entries. In graph embeddings, this usually corresponds to the assumption that the vertex i in graph X has the same latent position as the vertex i in graph Y.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Computes the matrix solution of the seedless Procrustes problem, which is that given two matrices X and Y of equal shape (n, d), find an orthogonal matrix that most closely maps X to Y. Subsequently, uses that matrix to transform either the original X, or a different dataset in the same space.\nNote that when used to match two datasets, this method only requires that the datasets have the same number of entries, but not that there is some correspondence between the entries. In graph embeddings, this usually corresponds to the assumption that the vertex i in graph X has the same latent position as the vertex i in graph Y.. Get parameters for this estimator.",
    "graspologic: Computes the matrix solution of the seedless Procrustes problem, which is that given two matrices X and Y of equal shape (n, d), find an orthogonal matrix that most closely maps X to Y. Subsequently, uses that matrix to transform either the original X, or a different dataset in the same space.\nNote that when used to match two datasets, this method only requires that the datasets have the same number of entries, but not that there is some correspondence between the entries. In graph embeddings, this usually corresponds to the assumption that the vertex i in graph X has the same latent position as the vertex i in graph Y.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Computes the matrix solution of the seedless Procrustes problem, which is that given two matrices X and Y of equal shape (n, d), find an orthogonal matrix that most closely maps X to Y. Subsequently, uses that matrix to transform either the original X, or a different dataset in the same space.\nNote that when used to match two datasets, this method only requires that the datasets have the same number of entries, but not that there is some correspondence between the entries. In graph embeddings, this usually corresponds to the assumption that the vertex i in graph X has the same latent position as the vertex i in graph Y.. Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.",
    "graspologic: Matches two datasets using an orthogonal matrix. Unlike OrthogonalProcrustes, this does not require a matching between entries. It can even be used in the settings where the two datasets do not have the same number of entries.\nIn graph setting, it is used to align the embeddings of two different graphs, when it requires some simultaneous inference task and no 1-1 matching between the vertices of the two graphs can be established, for example, inside of the test for the equivalence of the latent distributions (see: LatentDistributionTest).. Uses the two datasets to learn the matrix self.Q_ that aligns the first dataset with the second.",
    "graspologic: Matches two datasets using an orthogonal matrix. Unlike OrthogonalProcrustes, this does not require a matching between entries. It can even be used in the settings where the two datasets do not have the same number of entries.\nIn graph setting, it is used to align the embeddings of two different graphs, when it requires some simultaneous inference task and no 1-1 matching between the vertices of the two graphs can be established, for example, inside of the test for the equivalence of the latent distributions (see: LatentDistributionTest).. Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.",
    "graspologic: Matches two datasets using an orthogonal matrix. Unlike OrthogonalProcrustes, this does not require a matching between entries. It can even be used in the settings where the two datasets do not have the same number of entries.\nIn graph setting, it is used to align the embeddings of two different graphs, when it requires some simultaneous inference task and no 1-1 matching between the vertices of the two graphs can be established, for example, inside of the test for the equivalence of the latent distributions (see: LatentDistributionTest).. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Matches two datasets using an orthogonal matrix. Unlike OrthogonalProcrustes, this does not require a matching between entries. It can even be used in the settings where the two datasets do not have the same number of entries.\nIn graph setting, it is used to align the embeddings of two different graphs, when it requires some simultaneous inference task and no 1-1 matching between the vertices of the two graphs can be established, for example, inside of the test for the equivalence of the latent distributions (see: LatentDistributionTest).. Get parameters for this estimator.",
    "graspologic: Matches two datasets using an orthogonal matrix. Unlike OrthogonalProcrustes, this does not require a matching between entries. It can even be used in the settings where the two datasets do not have the same number of entries.\nIn graph setting, it is used to align the embeddings of two different graphs, when it requires some simultaneous inference task and no 1-1 matching between the vertices of the two graphs can be established, for example, inside of the test for the equivalence of the latent distributions (see: LatentDistributionTest).. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Matches two datasets using an orthogonal matrix. Unlike OrthogonalProcrustes, this does not require a matching between entries. It can even be used in the settings where the two datasets do not have the same number of entries.\nIn graph setting, it is used to align the embeddings of two different graphs, when it requires some simultaneous inference task and no 1-1 matching between the vertices of the two graphs can be established, for example, inside of the test for the equivalence of the latent distributions (see: LatentDistributionTest).. Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.",
    "graspologic: KMeans Cluster.\nIt computes all possible models from one component to max_clusters. When the true labels are known, the best model is given by the model with highest adjusted Rand index (ARI). Otherwise, the best model is given by the model with highest silhouette score.. Fits kmeans model to the data.",
    "graspologic: KMeans Cluster.\nIt computes all possible models from one component to max_clusters. When the true labels are known, the best model is given by the model with highest adjusted Rand index (ARI). Otherwise, the best model is given by the model with highest silhouette score.. Fit the models and predict clusters based on best model.",
    "graspologic: KMeans Cluster.\nIt computes all possible models from one component to max_clusters. When the true labels are known, the best model is given by the model with highest adjusted Rand index (ARI). Otherwise, the best model is given by the model with highest silhouette score.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: KMeans Cluster.\nIt computes all possible models from one component to max_clusters. When the true labels are known, the best model is given by the model with highest adjusted Rand index (ARI). Otherwise, the best model is given by the model with highest silhouette score.. Get parameters for this estimator.",
    "graspologic: KMeans Cluster.\nIt computes all possible models from one component to max_clusters. When the true labels are known, the best model is given by the model with highest adjusted Rand index (ARI). Otherwise, the best model is given by the model with highest silhouette score.. Predict clusters based on best model.",
    "graspologic: KMeans Cluster.\nIt computes all possible models from one component to max_clusters. When the true labels are known, the best model is given by the model with highest adjusted Rand index (ARI). Otherwise, the best model is given by the model with highest silhouette score.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Gaussian Mixture Model (GMM)\nRepresentation of a Gaussian mixture model probability distribution. This class allows to estimate the parameters of a Gaussian mixture distribution. It computes all possible models from one component to max_components. The best model is given by the lowest BIC score.. Fits gaussian mixure model to the data. Estimate model parameters with the EM algorithm.",
    "graspologic: Gaussian Mixture Model (GMM)\nRepresentation of a Gaussian mixture model probability distribution. This class allows to estimate the parameters of a Gaussian mixture distribution. It computes all possible models from one component to max_components. The best model is given by the lowest BIC score.. Fit the models and predict clusters based on best model.",
    "graspologic: Gaussian Mixture Model (GMM)\nRepresentation of a Gaussian mixture model probability distribution. This class allows to estimate the parameters of a Gaussian mixture distribution. It computes all possible models from one component to max_components. The best model is given by the lowest BIC score.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Gaussian Mixture Model (GMM)\nRepresentation of a Gaussian mixture model probability distribution. This class allows to estimate the parameters of a Gaussian mixture distribution. It computes all possible models from one component to max_components. The best model is given by the lowest BIC score.. Get parameters for this estimator.",
    "graspologic: Gaussian Mixture Model (GMM)\nRepresentation of a Gaussian mixture model probability distribution. This class allows to estimate the parameters of a Gaussian mixture distribution. It computes all possible models from one component to max_components. The best model is given by the lowest BIC score.. Predict clusters based on best model.",
    "graspologic: Gaussian Mixture Model (GMM)\nRepresentation of a Gaussian mixture model probability distribution. This class allows to estimate the parameters of a Gaussian mixture distribution. It computes all possible models from one component to max_components. The best model is given by the lowest BIC score.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Automatic Gaussian Mixture Model (GMM) selection.\nClustering algorithm using a hierarchical agglomerative clustering then Gaussian mixtured model (GMM) fitting. Different combinations of agglomeration, GMM, and cluster numbers are used and the clustering with the best selection criterion (bic/aic) is chosen.. Fits gaussian mixture model to the data. Initialize with agglomerative clustering then estimate model parameters with EM algorithm.",
    "graspologic: Automatic Gaussian Mixture Model (GMM) selection.\nClustering algorithm using a hierarchical agglomerative clustering then Gaussian mixtured model (GMM) fitting. Different combinations of agglomeration, GMM, and cluster numbers are used and the clustering with the best selection criterion (bic/aic) is chosen.. Fit the models and predict clusters based on best model.",
    "graspologic: Automatic Gaussian Mixture Model (GMM) selection.\nClustering algorithm using a hierarchical agglomerative clustering then Gaussian mixtured model (GMM) fitting. Different combinations of agglomeration, GMM, and cluster numbers are used and the clustering with the best selection criterion (bic/aic) is chosen.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Automatic Gaussian Mixture Model (GMM) selection.\nClustering algorithm using a hierarchical agglomerative clustering then Gaussian mixtured model (GMM) fitting. Different combinations of agglomeration, GMM, and cluster numbers are used and the clustering with the best selection criterion (bic/aic) is chosen.. Get parameters for this estimator.",
    "graspologic: Automatic Gaussian Mixture Model (GMM) selection.\nClustering algorithm using a hierarchical agglomerative clustering then Gaussian mixtured model (GMM) fitting. Different combinations of agglomeration, GMM, and cluster numbers are used and the clustering with the best selection criterion (bic/aic) is chosen.. Predict clusters based on best model.",
    "graspologic: Automatic Gaussian Mixture Model (GMM) selection.\nClustering algorithm using a hierarchical agglomerative clustering then Gaussian mixtured model (GMM) fitting. Different combinations of agglomeration, GMM, and cluster numbers are used and the clustering with the best selection criterion (bic/aic) is chosen.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Recursively clusters data based on a chosen clustering algorithm. This algorithm implements a 'divisive' or 'top-down' approach.. Fits clustering models to the data as well as resulting clusters",
    "graspologic: Recursively clusters data based on a chosen clustering algorithm. This algorithm implements a 'divisive' or 'top-down' approach.. Fits clustering models to the data as well as resulting clusters and using fitted models to predict a hierarchy of labels",
    "graspologic: Recursively clusters data based on a chosen clustering algorithm. This algorithm implements a 'divisive' or 'top-down' approach.. Predicts a hierarchy of labels based on fitted models",
    "graspologic: Recursively clusters data based on a chosen clustering algorithm. This algorithm implements a 'divisive' or 'top-down' approach.. Request metadata passed to the predict method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to the predict method.\nFalse: metadata is not requested, and not passed to the predict.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
    "graspologic: Class for computing the adjacency spectral embedding of a graph.\nThe adjacency spectral embedding (ASE) is a k-dimensional Euclidean representation of the graph based on its adjacency matrix. It relies on an SVD to reduce the dimensionality to the specified k, or if k is unspecified, can find a number of dimensions automatically (see select_svd).. Fit ASE model to input graph",
    "graspologic: Class for computing the adjacency spectral embedding of a graph.\nThe adjacency spectral embedding (ASE) is a k-dimensional Euclidean representation of the graph based on its adjacency matrix. It relies on an SVD to reduce the dimensionality to the specified k, or if k is unspecified, can find a number of dimensions automatically (see select_svd).. Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.",
    "graspologic: Class for computing the adjacency spectral embedding of a graph.\nThe adjacency spectral embedding (ASE) is a k-dimensional Euclidean representation of the graph based on its adjacency matrix. It relies on an SVD to reduce the dimensionality to the specified k, or if k is unspecified, can find a number of dimensions automatically (see select_svd).. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Class for computing the adjacency spectral embedding of a graph.\nThe adjacency spectral embedding (ASE) is a k-dimensional Euclidean representation of the graph based on its adjacency matrix. It relies on an SVD to reduce the dimensionality to the specified k, or if k is unspecified, can find a number of dimensions automatically (see select_svd).. Get parameters for this estimator.",
    "graspologic: Class for computing the adjacency spectral embedding of a graph.\nThe adjacency spectral embedding (ASE) is a k-dimensional Euclidean representation of the graph based on its adjacency matrix. It relies on an SVD to reduce the dimensionality to the specified k, or if k is unspecified, can find a number of dimensions automatically (see select_svd).. Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
    "graspologic: Class for computing the laplacian spectral embedding of a graph.\nThe laplacian spectral embedding (LSE) is a k-dimensional Euclidean representation of the graph based on its Laplacian matrix. It relies on an SVD to reduce the dimensionality to the specified n_components, or if n_components is unspecified, can find a number of dimensions automatically.. Fit LSE model to input graph",
    "graspologic: Class for computing the laplacian spectral embedding of a graph.\nThe laplacian spectral embedding (LSE) is a k-dimensional Euclidean representation of the graph based on its Laplacian matrix. It relies on an SVD to reduce the dimensionality to the specified n_components, or if n_components is unspecified, can find a number of dimensions automatically.. Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.",
    "graspologic: Class for computing the laplacian spectral embedding of a graph.\nThe laplacian spectral embedding (LSE) is a k-dimensional Euclidean representation of the graph based on its Laplacian matrix. It relies on an SVD to reduce the dimensionality to the specified n_components, or if n_components is unspecified, can find a number of dimensions automatically.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Class for computing the laplacian spectral embedding of a graph.\nThe laplacian spectral embedding (LSE) is a k-dimensional Euclidean representation of the graph based on its Laplacian matrix. It relies on an SVD to reduce the dimensionality to the specified n_components, or if n_components is unspecified, can find a number of dimensions automatically.. Get parameters for this estimator.",
    "graspologic: Class for computing the laplacian spectral embedding of a graph.\nThe laplacian spectral embedding (LSE) is a k-dimensional Euclidean representation of the graph based on its Laplacian matrix. It relies on an SVD to reduce the dimensionality to the specified n_components, or if n_components is unspecified, can find a number of dimensions automatically.. Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
    "graspologic: Class for computing the laplacian spectral embedding of a graph.\nThe laplacian spectral embedding (LSE) is a k-dimensional Euclidean representation of the graph based on its Laplacian matrix. It relies on an SVD to reduce the dimensionality to the specified n_components, or if n_components is unspecified, can find a number of dimensions automatically.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Class for computing the laplacian spectral embedding of a graph.\nThe laplacian spectral embedding (LSE) is a k-dimensional Euclidean representation of the graph based on its Laplacian matrix. It relies on an SVD to reduce the dimensionality to the specified n_components, or if n_components is unspecified, can find a number of dimensions automatically.. Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].",
    "graspologic: Omnibus embedding of arbitrary number of input graphs with matched vertex sets.\nGiven A1, A2, ..., An, a collection of (possibly weighted) adjacency matrices of a collection undirected graphs with matched vertices. Then the (mn x mn) omnibus matrix, M, has the subgraph where Mij = 1/2(Ai + Aj). The omnibus matrix is then embedded using adjacency spectral embedding.. Fit Omnibus model to input graphs",
    "graspologic: Omnibus embedding of arbitrary number of input graphs with matched vertex sets.\nGiven A1, A2, ..., An, a collection of (possibly weighted) adjacency matrices of a collection undirected graphs with matched vertices. Then the (mn x mn) omnibus matrix, M, has the subgraph where Mij = 1/2(Ai + Aj). The omnibus matrix is then embedded using adjacency spectral embedding.. Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.",
    "graspologic: Omnibus embedding of arbitrary number of input graphs with matched vertex sets.\nGiven A1, A2, ..., An, a collection of (possibly weighted) adjacency matrices of a collection undirected graphs with matched vertices. Then the (mn x mn) omnibus matrix, M, has the subgraph where Mij = 1/2(Ai + Aj). The omnibus matrix is then embedded using adjacency spectral embedding.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Omnibus embedding of arbitrary number of input graphs with matched vertex sets.\nGiven A1, A2, ..., An, a collection of (possibly weighted) adjacency matrices of a collection undirected graphs with matched vertices. Then the (mn x mn) omnibus matrix, M, has the subgraph where Mij = 1/2(Ai + Aj). The omnibus matrix is then embedded using adjacency spectral embedding.. Get parameters for this estimator.",
    "graspologic: Omnibus embedding of arbitrary number of input graphs with matched vertex sets.\nGiven A1, A2, ..., An, a collection of (possibly weighted) adjacency matrices of a collection undirected graphs with matched vertices. Then the (mn x mn) omnibus matrix, M, has the subgraph where Mij = 1/2(Ai + Aj). The omnibus matrix is then embedded using adjacency spectral embedding.. Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
    "graspologic: Omnibus embedding of arbitrary number of input graphs with matched vertex sets.\nGiven A1, A2, ..., An, a collection of (possibly weighted) adjacency matrices of a collection undirected graphs with matched vertices. Then the (mn x mn) omnibus matrix, M, has the subgraph where Mij = 1/2(Ai + Aj). The omnibus matrix is then embedded using adjacency spectral embedding.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Omnibus embedding of arbitrary number of input graphs with matched vertex sets.\nGiven A1, A2, ..., An, a collection of (possibly weighted) adjacency matrices of a collection undirected graphs with matched vertices. Then the (mn x mn) omnibus matrix, M, has the subgraph where Mij = 1/2(Ai + Aj). The omnibus matrix is then embedded using adjacency spectral embedding.. Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].",
    "graspologic: Multiple Adjacency Spectral Embedding (MASE) embeds arbitrary number of input graphs with matched vertex sets.\nFor a population of undirected graphs, MASE assumes that the population of graphs is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. Score matrices, Λ_k, are allowed to vary for each graph, but are symmetric. All graphs share a common a latent position matrix X.\nFor a population of directed graphs, MASE assumes that the population is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. In this case, score matrices Λ_k can be assymetric and non-square, but all graphs still share a common latent position matrices X and Y.. Fit MASE model to input graphs",
    "graspologic: Multiple Adjacency Spectral Embedding (MASE) embeds arbitrary number of input graphs with matched vertex sets.\nFor a population of undirected graphs, MASE assumes that the population of graphs is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. Score matrices, Λ_k, are allowed to vary for each graph, but are symmetric. All graphs share a common a latent position matrix X.\nFor a population of directed graphs, MASE assumes that the population is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. In this case, score matrices Λ_k can be assymetric and non-square, but all graphs still share a common latent position matrices X and Y.. Fit the model with graphs and apply the embedding on graphs. n_components is either automatically determined or based on user input.",
    "graspologic: Multiple Adjacency Spectral Embedding (MASE) embeds arbitrary number of input graphs with matched vertex sets.\nFor a population of undirected graphs, MASE assumes that the population of graphs is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. Score matrices, Λ_k, are allowed to vary for each graph, but are symmetric. All graphs share a common a latent position matrix X.\nFor a population of directed graphs, MASE assumes that the population is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. In this case, score matrices Λ_k can be assymetric and non-square, but all graphs still share a common latent position matrices X and Y.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Multiple Adjacency Spectral Embedding (MASE) embeds arbitrary number of input graphs with matched vertex sets.\nFor a population of undirected graphs, MASE assumes that the population of graphs is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. Score matrices, Λ_k, are allowed to vary for each graph, but are symmetric. All graphs share a common a latent position matrix X.\nFor a population of directed graphs, MASE assumes that the population is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. In this case, score matrices Λ_k can be assymetric and non-square, but all graphs still share a common latent position matrices X and Y.. Get parameters for this estimator.",
    "graspologic: Multiple Adjacency Spectral Embedding (MASE) embeds arbitrary number of input graphs with matched vertex sets.\nFor a population of undirected graphs, MASE assumes that the population of graphs is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. Score matrices, Λ_k, are allowed to vary for each graph, but are symmetric. All graphs share a common a latent position matrix X.\nFor a population of directed graphs, MASE assumes that the population is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. In this case, score matrices Λ_k can be assymetric and non-square, but all graphs still share a common latent position matrices X and Y.. Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
    "graspologic: Multiple Adjacency Spectral Embedding (MASE) embeds arbitrary number of input graphs with matched vertex sets.\nFor a population of undirected graphs, MASE assumes that the population of graphs is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. Score matrices, Λ_k, are allowed to vary for each graph, but are symmetric. All graphs share a common a latent position matrix X.\nFor a population of directed graphs, MASE assumes that the population is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. In this case, score matrices Λ_k can be assymetric and non-square, but all graphs still share a common latent position matrices X and Y.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Multiple Adjacency Spectral Embedding (MASE) embeds arbitrary number of input graphs with matched vertex sets.\nFor a population of undirected graphs, MASE assumes that the population of graphs is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. Score matrices, Λ_k, are allowed to vary for each graph, but are symmetric. All graphs share a common a latent position matrix X.\nFor a population of directed graphs, MASE assumes that the population is sampled from P(A) = ∑_{k=1}^{K} π_k P(A|Z=k) where P(A|Z=k) = N(0, Λ_k) and Λ_k = α_k I + β_k J. In this case, score matrices Λ_k can be assymetric and non-square, but all graphs still share a common latent position matrices X and Y.. Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].",
    "graspologic: Multigraphs-2-vectors (mug2vec).\n\nmug2vec is a sequence of three algorithms that learns a feature vector for each input graph.\n\nSteps:\n\n1. Pass to ranks - ranks all edge weights from smallest to largest valued edges then normalize by a constant.\n\n2. Omnibus embedding - jointly learns a low dimensional matrix representation for all graphs under the random dot product model (RDPG).\n\n3. Classical MDS (cMDS) - learns a feature vector for each graph by computing Euclidean distance between each pair of graph embeddings from omnibus embedding, followed by an eigen decomposition.. Computes a vector for each graph.",
    "graspologic: Multigraphs-2-vectors (mug2vec).\n\nmug2vec is a sequence of three algorithms that learns a feature vector for each input graph.\n\nSteps:\n\n1. Pass to ranks - ranks all edge weights from smallest to largest valued edges then normalize by a constant.\n\n2. Omnibus embedding - jointly learns a low dimensional matrix representation for all graphs under the random dot product model (RDPG).\n\n3. Classical MDS (cMDS) - learns a feature vector for each graph by computing Euclidean distance between each pair of graph embeddings from omnibus embedding, followed by an eigen decomposition.. Computes a vector for each graph.",
    "graspologic: Multigraphs-2-vectors (mug2vec).\n\nmug2vec is a sequence of three algorithms that learns a feature vector for each input graph.\n\nSteps:\n\n1. Pass to ranks - ranks all edge weights from smallest to largest valued edges then normalize by a constant.\n\n2. Omnibus embedding - jointly learns a low dimensional matrix representation for all graphs under the random dot product model (RDPG).\n\n3. Classical MDS (cMDS) - learns a feature vector for each graph by computing Euclidean distance between each pair of graph embeddings from omnibus embedding, followed by an eigen decomposition.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Multigraphs-2-vectors (mug2vec).\n\nmug2vec is a sequence of three algorithms that learns a feature vector for each input graph.\n\nSteps:\n\n1. Pass to ranks - ranks all edge weights from smallest to largest valued edges then normalize by a constant.\n\n2. Omnibus embedding - jointly learns a low dimensional matrix representation for all graphs under the random dot product model (RDPG).\n\n3. Classical MDS (cMDS) - learns a feature vector for each graph by computing Euclidean distance between each pair of graph embeddings from omnibus embedding, followed by an eigen decomposition.. Get parameters for this estimator.",
    "graspologic: Multigraphs-2-vectors (mug2vec).\n\nmug2vec is a sequence of three algorithms that learns a feature vector for each input graph.\n\nSteps:\n\n1. Pass to ranks - ranks all edge weights from smallest to largest valued edges then normalize by a constant.\n\n2. Omnibus embedding - jointly learns a low dimensional matrix representation for all graphs under the random dot product model (RDPG).\n\n3. Classical MDS (cMDS) - learns a feature vector for each graph by computing Euclidean distance between each pair of graph embeddings from omnibus embedding, followed by an eigen decomposition.. Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested",
    "graspologic: Multigraphs-2-vectors (mug2vec).\n\nmug2vec is a sequence of three algorithms that learns a feature vector for each input graph.\n\nSteps:\n\n1. Pass to ranks - ranks all edge weights from smallest to largest valued edges then normalize by a constant.\n\n2. Omnibus embedding - jointly learns a low dimensional matrix representation for all graphs under the random dot product model (RDPG).\n\n3. Classical MDS (cMDS) - learns a feature vector for each graph by computing Euclidean distance between each pair of graph embeddings from omnibus embedding, followed by an eigen decomposition.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Classical multidimensional scaling (cMDS).\n\ncMDS seeks a low-dimensional representation of the data in which the distances respect well the distances in the original high-dimensional space.. Fit the model with X.",
    "graspologic: Classical multidimensional scaling (cMDS).\n\ncMDS seeks a low-dimensional representation of the data in which the distances respect well the distances in the original high-dimensional space.. Fit the data from X, and returns the embedded coordinates.",
    "graspologic: Classical multidimensional scaling (cMDS).\n\ncMDS seeks a low-dimensional representation of the data in which the distances respect well the distances in the original high-dimensional space.. Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Classical multidimensional scaling (cMDS).\n\ncMDS seeks a low-dimensional representation of the data in which the distances respect well the distances in the original high-dimensional space.. Get parameters for this estimator.",
    "graspologic: Classical multidimensional scaling (cMDS).\n\ncMDS seeks a low-dimensional representation of the data in which the distances respect well the distances in the original high-dimensional space.. Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Contains the node id, 2d coordinates, size, and community id for a node.\n\nCreate new instance of NodePosition(node_id, x, y, size, community). Create new instance of NodePosition(node_id, x, y, size, community)",
    "graspologic: Contains the node id, 2d coordinates, size, and community id for a node.\n\nCreate new instance of NodePosition(node_id, x, y, size, community). Return number of occurrences of value.",
    "graspologic: Contains the node id, 2d coordinates, size, and community id for a node.\n\nCreate new instance of NodePosition(node_id, x, y, size, community). Return first index of value.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Get parameters for this estimator.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Fit the DCSBM to a graph, optionally with known block labels.\nIf y is None, the block assignments for each vertex will first be estimated.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Get parameters for this estimator.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial. Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Fit the SBM to a graph, optionally with known block labels\n\nIf y is None, the block assignments for each vertex will first be estimated.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Get parameters for this estimator.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Fit the DCSBM to a graph, optionally with known block labels\n\nIf y is None, the block assignments for each vertex will first be estimated.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Get parameters for this estimator.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere 𝟘𝟙 is an n_nodes length vector specifying which block each node belongs to, and θ is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]θ_iθ_j\n\nwhere θ_i and θ_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial. Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Calculate the parameters for the given graph model",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Get parameters for this estimator.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial. Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
    "graspologic: Degree Preserving Edge Swaps\n\nThis class allows for performing degree preserving edge swaps to generate new networks with the same degree sequence as the input network.. Performs a number of edge swaps on the graph",
    "graspologic: Class for spectral vertex nomination on a single graph.\n\nGiven a graph  and a subset of  called  (the \"seed\"), Single Graph Vertex Nomination is the problem of ranking all  in order of relation to members of . Spectral Vertex Nomination solves this problem by embedding  into a low dimensional euclidean space (see: Adjacency Spectral Embed Tutorial ), and then generating a nomination list by some distance based algorithm. In the simple unattributed case, for each seed vertex , the other vertices are ranked in order of euclidean distance from .. Constructs the embedding if not provided, then calculates the pairwise distance from each seed to each vertex in graph",
    "graspologic: Class for spectral vertex nomination on a single graph.\n\nGiven a graph  and a subset of  called  (the \"seed\"), Single Graph Vertex Nomination is the problem of ranking all  in order of relation to members of . Spectral Vertex Nomination solves this problem by embedding  into a low dimensional euclidean space (see: Adjacency Spectral Embed Tutorial ), and then generating a nomination list by some distance based algorithm. In the simple unattributed case, for each seed vertex , the other vertices are ranked in order of euclidean distance from .. Nominates vertices for each seed vertex. Methodology is distance based ranking",
    "graspologic: Class for spectral vertex nomination on a single graph.\n\nGiven a graph  and a subset of  called  (the \"seed\"), Single Graph Vertex Nomination is the problem of ranking all  in order of relation to members of . Spectral Vertex Nomination solves this problem by embedding  into a low dimensional euclidean space (see: Adjacency Spectral Embed Tutorial ), and then generating a nomination list by some distance based algorithm. In the simple unattributed case, for each seed vertex , the other vertices are ranked in order of euclidean distance from .. Calls this class' fit and then predict methods",
    "graspologic: Class for spectral vertex nomination on a single graph.\n\nGiven a graph  and a subset of  called  (the \"seed\"), Single Graph Vertex Nomination is the problem of ranking all  in order of relation to members of . Spectral Vertex Nomination solves this problem by embedding  into a low dimensional euclidean space (see: Adjacency Spectral Embed Tutorial ), and then generating a nomination list by some distance based algorithm. In the simple unattributed case, for each seed vertex , the other vertices are ranked in order of euclidean distance from .. Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: Class for spectral vertex nomination on a single graph.\n\nGiven a graph  and a subset of  called  (the \"seed\"), Single Graph Vertex Nomination is the problem of ranking all  in order of relation to members of . Spectral Vertex Nomination solves this problem by embedding  into a low dimensional euclidean space (see: Adjacency Spectral Embed Tutorial ), and then generating a nomination list by some distance based algorithm. In the simple unattributed case, for each seed vertex , the other vertices are ranked in order of euclidean distance from .. Get parameters for this estimator.",
    "graspologic: Class for spectral vertex nomination on a single graph.\n\nGiven a graph  and a subset of  called  (the \"seed\"), Single Graph Vertex Nomination is the problem of ranking all  in order of relation to members of . Spectral Vertex Nomination solves this problem by embedding  into a low dimensional euclidean space (see: Adjacency Spectral Embed Tutorial ), and then generating a nomination list by some distance based algorithm. In the simple unattributed case, for each seed vertex , the other vertices are ranked in order of euclidean distance from .. Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
    "graspologic: This class implements Vertex Nomination via Seeded Graph Matching (VNviaSGM) with the algorithm described in [1].\n\nRather than providing a 1-1 matching for the vertices of two graphs, as in GraphMatch, VNviaSGM ranks the potential matches for a vertex of interst (VOI) in one to graph to the vertices in another graph, based on probability of matching.. Fits the model to two graphs.",
    "graspologic: This class implements Vertex Nomination via Seeded Graph Matching (VNviaSGM) with the algorithm described in [1].\n\nRather than providing a 1-1 matching for the vertices of two graphs, as in GraphMatch, VNviaSGM ranks the potential matches for a vertex of interst (VOI) in one to graph to the vertices in another graph, based on probability of matching.. Fits model to two adjacency matrices and returns",
    "graspologic: This class implements Vertex Nomination via Seeded Graph Matching (VNviaSGM) with the algorithm described in [1].\n\nRather than providing a 1-1 matching for the vertices of two graphs, as in GraphMatch, VNviaSGM ranks the potential matches for a vertex of interst (VOI) in one to graph to the vertices in another graph, based on probability of matching.. Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
    "graspologic: This class implements Vertex Nomination via Seeded Graph Matching (VNviaSGM) with the algorithm described in [1].\n\nRather than providing a 1-1 matching for the vertices of two graphs, as in GraphMatch, VNviaSGM ranks the potential matches for a vertex of interst (VOI) in one to graph to the vertices in another graph, based on probability of matching.. Get parameters for this estimator.",
    "graspologic: This class implements Vertex Nomination via Seeded Graph Matching (VNviaSGM) with the algorithm described in [1].\n\nRather than providing a 1-1 matching for the vertices of two graphs, as in GraphMatch, VNviaSGM ranks the potential matches for a vertex of interst (VOI) in one to graph to the vertices in another graph, based on probability of matching.. Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
    "graspologic: GraphBuilder is a simple builder for networkx Graphs. To use less memory, it automatically maps all node ids of any hashable type to int.\n\nIn other words, if you can use it as a key in a dictionary, it will work.. Adds a weighted edge between the provided source and target. The source and target id are converted to a unique int.",
    "graspologic: Estimate the signal-subgraph of a set of labeled graph samples.\n\nThe incoherent estimator finds the signal-subgraph, constrained by the number of edges. The coherent estimator finds the signal-subgraph, constrained by the number of edges and by the number of vertices that the edges in the signal-subgraph may be incident to.. Fit the signal-subgraph estimator according to the constraints given.",
    "graspologic: Estimate the signal-subgraph of a set of labeled graph samples.\n\nThe incoherent estimator finds the signal-subgraph, constrained by the number of edges. The coherent estimator finds the signal-subgraph, constrained by the number of edges and by the number of vertices that the edges in the signal-subgraph may be incident to.. A function to return the indices of the signal-subgraph. If return_mask is True, also returns a mask for the signal-subgraph.",
    "igraph: Static class which draws rectangular vertices. overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a rectangle-shaped path on the Cairo context without stroking or filling it.",
    "igraph: Static class which draws rectangular vertices. overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the rectangle centered at (center_x, center_y) having the given width and height intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
    "igraph: A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n. overrides igraph.drawing.colors.Palette.__init__\nCreates a rainbow palette.",
    "igraph: A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n. Inherited from Palette:Returns the number of colors in this palette",
    "igraph: A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n. Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes",
    "igraph: A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n. Inherited from Palette:Undocumented",
    "igraph: A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n. Inherited from Palette:Clears the result cache.",
    "igraph: A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n. Inherited from Palette:Returns the given color from the palette.",
    "igraph: A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n. Inherited from Palette:Returns multiple colors from the palette.",
    "igraph: Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n. Shorthand notation to select()\nThis method simply passes all its arguments to EdgeSeq.select().",
    "igraph: Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n. Returns the list of all the edge attributes in the graph associated to this edge sequence.",
    "igraph: Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n. overrides igraph._igraph.EdgeSeq.find\nReturns the first edge of the edge sequence that matches some criteria.\nThe selection criteria are equal to the ones allowed by VertexSeq.select. See VertexSeq.select for more details.\nFor instance, to find the first edge with weight larger than 5 in graph g:",
    "igraph: Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n. overrides igraph._igraph.EdgeSeq.select\nSelects a subset of the edge sequence based on some criteria\nThe selection criteria can be specified by the positional and the keyword arguments. Positional arguments are always processed before keyword arguments.If the first positional argument is None, an empty sequence is returned.If the first positional argument is a callable object, the object will be called for every edge in the sequence. If it returns True, the edge will be included, otherwise it will be excluded.If the first positional argument is an iterable, it must return integers and they will be considered as indices of the current edge set (NOT the whole edge set of the graph -- the difference matters when one filters an edge set that has already been filtered by a previous invocation of EdgeSeq.select(). In this case, the indices do not refer directly to the edges of the graph but to the elements of the filtered edge sequence.If the first positional argument is an integer, all remaining arguments are expected to be integers. They are considered as indices of the current edge set again.\nKeyword arguments can be used to filter the edges based on their attributes and properties. The name of the keyword specifies the name of the attribute and the filtering operator, they should be concatenated by an underscore (_) character. Attribute names can also contain underscores, but operator names don't, so the operator is always the largest trailing substring of the keyword name that does not contain an underscore. Possible operators are:eq: equal tone: not equal tolt: less thangt: greater thanle: less than or equal toge: greater than or equal toin: checks if the value of an attribute is in a given listnotin: checks if the value of an attribute is not in a given list\nFor instance, if you want to filter edges with a numeric weight property larger than 50, you have to write:",
    "igraph: Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n. Inherited from EdgeSeq:Returns the attribute name list of the graph's edges",
    "igraph: Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n. Inherited from EdgeSeq:Returns the value of a given edge attribute for all edges.",
    "igraph: Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n. Inherited from EdgeSeq:Returns whether the edge sequence contains all the edges exactly once, in the order of their edge IDs.",
    "igraph: Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n. Inherited from EdgeSeq:Sets the value of a given edge attribute for all vertices",
    "igraph: Class that describes how the value of a given attribute should be retrieved.\nThe class contains the following members: name: the name of the attribute. This is also used when we are trying to get its value from a vertex/edge attribute of a graph. alt_name: alternative name of the attribute. This is used when we are trying to get its value from a Python dict or an igraph.Configuration object. If omitted at construction time, it will be equal to name. default: the default value of the attribute when none of the sources we try can provide a meaningful value. transform: optional transformation to be performed on the attribute value. If None or omitted, it defaults to the type of the default value. func: when given, this function will be called with an index in order to derive the value of the attribute. . Undocumented",
    "igraph: Matplotlib drawer object for dendrograms.. Constructs the drawer and associates it to the given Axes.",
    "igraph: Matplotlib drawer object for dendrograms.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Dendrogram in a matplotlib Axes.\nOther keyword arguments are passed to mpl.patches.Polygon.",
    "igraph: Static class that finds the object/backend drawer\nThis directory is used by the __plot__ functions.. Given a shape name, returns the corresponding shape drawer class",
    "igraph: Base class for attribute collector subclasses. Classes that inherit this class may use a declarative syntax to specify which vertex or edge attributes they intend to collect. See AttributeCollectorMeta for the details.. Returns the collected attributes of the vertex/edge with the given index.",
    "igraph: Base class for attribute collector subclasses. Classes that inherit this class may use a declarative syntax to specify which vertex or edge attributes they intend to collect. See AttributeCollectorMeta for the details.. Constructs a new attribute collector that uses the given vertex/edge sequence and the given dict as data sources.",
    "igraph: Base class for attribute collector subclasses. Classes that inherit this class may use a declarative syntax to specify which vertex or edge attributes they intend to collect. See AttributeCollectorMeta for the details.. Undocumented",
    "igraph: Matplotlib drawer object for matrices.. Constructs the drawer and associates it to the given Axes.",
    "igraph: Matplotlib drawer object for matrices.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
    "igraph: Triad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the following triad names: 003 -- the empty graph 012 -- a graph with a single directed edge (A --> B, C) 102 -- a graph with a single mutual edge (A <-> B, C) 021D -- the binary out-tree (A <-- B --> C) 021U -- the binary in-tree (A --> B <-- C) 021C -- the directed line (A --> B --> C) 111D -- A <-> B <-- C 111U -- A <-> B --> C 030T -- A --> B <-- C, A --> C 030C -- A <-- B <-- C, A --> C 201 -- A <-> B <-> C 120D -- A <-- B --> C, A <-> C 120U -- A --> B <-- C, A <-> C 120C -- A --> B --> C, A <-> C 210C -- A --> B <-> C, A <-> C 300 -- the complete graph (A <-> B <-> C, A <-> C) \nAttribute and item accessors are provided. Due to the syntax of Python, attribute names are not allowed to start with a number, therefore the triad names must be prepended with a lowercase t when accessing them as attributes. This is not necessary with the item accessor syntax.\n. Undocumented",
    "igraph: Triad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the following triad names: 003 -- the empty graph 012 -- a graph with a single directed edge (A --> B, C) 102 -- a graph with a single mutual edge (A <-> B, C) 021D -- the binary out-tree (A <-- B --> C) 021U -- the binary in-tree (A --> B <-- C) 021C -- the directed line (A --> B --> C) 111D -- A <-> B <-- C 111U -- A <-> B --> C 030T -- A --> B <-- C, A --> C 030C -- A <-- B <-- C, A --> C 201 -- A <-> B <-> C 120D -- A <-- B --> C, A <-> C 120U -- A --> B <-- C, A <-> C 120C -- A --> B --> C, A <-> C 210C -- A --> B <-> C, A <-> C 300 -- the complete graph (A <-> B <-> C, A <-> C) \nAttribute and item accessors are provided. Due to the syntax of Python, attribute names are not allowed to start with a number, therefore the triad names must be prepended with a lowercase t when accessing them as attributes. This is not necessary with the item accessor syntax.\n. Undocumented",
    "igraph: Triad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the following triad names: 003 -- the empty graph 012 -- a graph with a single directed edge (A --> B, C) 102 -- a graph with a single mutual edge (A <-> B, C) 021D -- the binary out-tree (A <-- B --> C) 021U -- the binary in-tree (A --> B <-- C) 021C -- the directed line (A --> B --> C) 111D -- A <-> B <-- C 111U -- A <-> B --> C 030T -- A --> B <-- C, A --> C 030C -- A <-- B <-- C, A --> C 201 -- A <-> B <-> C 120D -- A <-- B --> C, A <-> C 120U -- A --> B <-- C, A <-> C 120C -- A --> B --> C, A <-> C 210C -- A --> B <-> C, A <-> C 300 -- the complete graph (A <-> B <-> C, A <-> C) \nAttribute and item accessors are provided. Due to the syntax of Python, attribute names are not allowed to start with a number, therefore the triad names must be prepended with a lowercase t when accessing them as attributes. This is not necessary with the item accessor syntax.\n. Undocumented",
    "igraph: Triad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the following triad names: 003 -- the empty graph 012 -- a graph with a single directed edge (A --> B, C) 102 -- a graph with a single mutual edge (A <-> B, C) 021D -- the binary out-tree (A <-- B --> C) 021U -- the binary in-tree (A --> B <-- C) 021C -- the directed line (A --> B --> C) 111D -- A <-> B <-- C 111U -- A <-> B --> C 030T -- A --> B <-- C, A --> C 030C -- A <-- B <-- C, A --> C 201 -- A <-> B <-> C 120D -- A <-- B --> C, A <-> C 120U -- A --> B <-- C, A <-> C 120C -- A --> B --> C, A <-> C 210C -- A --> B <-> C, A <-> C 300 -- the complete graph (A <-> B <-> C, A <-> C) \nAttribute and item accessors are provided. Due to the syntax of Python, attribute names are not allowed to start with a number, therefore the triad names must be prepended with a lowercase t when accessing them as attributes. This is not necessary with the item accessor syntax.\n. Undocumented",
    "igraph: A palette suitable for coloring vertices when plotting a clustering.\nThis palette tries to make sure that the colors are easily distinguishable. This is achieved by using a set of base colors and their lighter and darker variants, depending on the number of elements in the palette.\nWhen the desired size of the palette is less than or equal to the number of base colors (denoted by n), only the bsae colors will be used. When the size of the palette is larger than n but less than 2*n, the base colors and their lighter variants will be used. Between 2*n and 3*n, the base colors and their lighter and darker variants will be used. Above 3*n, more darker and lighter variants will be generated, but this makes the individual colors less and less distinguishable.. overrides igraph.drawing.colors.PrecalculatedPalette.__init__\nCreates the palette backed by the given list. The list must contain RGBA quadruplets or color names, which will be resolved first by color_name_to_rgba(). Anything that is understood by color_name_to_rgba() is OK here.",
    "igraph: Static drawer class which draws nothing.\nThis class is used for graph vertices with unknown shapes. overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws nothing.",
    "igraph: Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods.. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs a new instance that will draw the given text on the given Cairo context.",
    "igraph: Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the text in the current bounding box of the drawer.\nSince the class itself is an instance of AbstractCairoDrawer, it has an attribute named bbox which will be used as a bounding box.",
    "igraph: Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods.. Draws the text by setting up an appropriate path on the Cairo context and filling it. x and y denote the coordinates where the drawing should start. If they are both None, the current position of the context will be used.\nVertical alignment settings are not taken into account in this method as the text is not drawn within a box.",
    "igraph: Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods.. Calculates the layout of the current text. x and y denote the coordinates where the drawing should start. If they are both None, the current position of the context will be used.\nVertical alignment settings are not taken into account in this method as the text is not drawn within a box.",
    "igraph: Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods.. Sets the text that will be drawn.\nIf text is None, it will be mapped to an empty string; otherwise, it will be converted to a string.",
    "igraph: Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods.. Returns the X-bearing, Y-bearing, width, height, X-advance and Y-advance of the text.\nFor multi-line text, the X-bearing and Y-bearing correspond to the first line, while the X-advance is extracted from the last line. and the Y-advance is the sum of all the Y-advances. The width and height correspond to the entire bounding box of the text.",
    "igraph: Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods.. Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.",
    "igraph: Abstract base class for vertex drawers that draw on a Cairo canvas.. overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given Cairo context and the given BoundingBox.",
    "igraph: Abstract base class for vertex drawers that draw on a Cairo canvas.. Inherited from AbstractVertexDrawer:Draws the given vertex.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Create and return a new object.  See help(type) for accurate signature.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nAdds edges to the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nAdds vertices to the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nGenerates a graph from its adjacency matrix.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns a list containing all the minimal s-t separators of a graph.\nA minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.\nReference: Anne Berry, Jean-Paul Bordat and Olivier Cogis: Generating all the minimal separators of a graph. In: Peter Widmayer, Gabriele Neyer and Stephan Eidenbenz (eds.): Graph-theoretic concepts in computer science, 1665, 167-172, 1999. Springer.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nReturns all the cuts between the source and target vertices in a directed graph.\nThis function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nReturns all minimum cuts between the source and target vertices in a directed graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Decides whether two given vertices are directly connected.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the list of articulation points in the graph.\nA vertex is an articulation point if its removal increases the number of connected components in the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the assortativity of the graph based on numeric properties of the vertices.\nThis coefficient is basically the correlation between the actual connectivity patterns of the vertices and the pattern expected from the distribution of the vertex types.\nSee equation (21) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition. The actual calculation is performed using equation (26) in the same paper for directed graphs, and equation (4) in Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701 (2002) for undirected graphs.\n",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the assortativity of a graph based on vertex degrees.\nSee assortativity() for the details. assortativity_degree() simply calls assortativity() with the vertex degrees as types.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the assortativity of the graph based on vertex categories.\nAssuming that the vertices belong to different categories, this function calculates the assortativity coefficient, which specifies the extent to which the connections stay within categories. The assortativity coefficient is one if all the connections stay within categories and minus one if all the connections join vertices of different categories. For a randomly connected network, it is asymptotically zero.\nSee equation (2) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition.\nReference: Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph based on asymmetric vertex types and connection probabilities.\nThis is the asymmetric variant of Preference(). A given number of vertices are generated. Every vertex is assigned to an \"incoming\" and an \"outgoing\" vertex type according to the given joint type probabilities. Finally, every vertex pair is evaluated and a directed edge is created between them with a probability depending on the \"outgoing\" type of the source vertex and the \"incoming\" type of the target vertex.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph from the Graph Atlas.\nReference: Ronald C. Read and Robin J. Wilson: An Atlas of Graphs. Oxford University Press, 1998.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. ",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates Kleinberg's authority score for the vertices of the graph",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the generators of the automorphism group of a graph using the BLISS isomorphism algorithm.\nThe generator set may not be minimal and may depend on the splitting heuristics. The generators are permutations represented using zero-based indexing.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the average path length in a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph based on the Barabási-Albert model.\nReference: Barabási, A-L and Albert, R. 1999. Emergence of scaling in random networks. Science, 286 509-512.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates or estimates the betweenness of vertices in a graph.\nAlso supports calculating betweenness with shortest path length cutoffs or considering shortest paths only from certain source vertices or to certain target vertices.\nKeyword arguments:",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Conducts a breadth first search (BFS) on the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Constructs a breadth first search (BFS) iterator of the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates bibliographic coupling scores for given vertices in a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the biconnected components of the graph.\nComponents containing a single vertex only are not considered as being biconnected.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nInternal function, undocumented.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nInternal function, undocumented.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the list of bridges in the graph.\nAn edge is a bridge if its removal increases the number of (weakly) connected components in the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.\nPassing the permutation returned here to permute_vertices() will transform the graph into its canonical form.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm and canonical permutations.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the list of edges needed to be added to the graph to make it chordal.\nA graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.\nThe chordal completion of a graph is the list of edges that needed to be added to the graph to make it chordal. It is an empty list if the graph is already chordal.\nNote that at the moment igraph does not guarantee that the returned chordal completion is minimal; there may exist a subset of the returned chordal completion that is still a valid chordal completion.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the clique number of the graph.\nThe clique number of the graph is the size of the largest clique.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns some or all cliques of the graph as a list of tuples.\nA clique is a complete subgraph -- a set of vertices where an edge is present between any two of them (excluding loops)",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the closeness centralities of given vertices in a graph.\nThe closeness centrality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the number of vertices minus one divided by the sum of the lengths of all geodesics from/to the given vertex.\nIf the graph is not connected, and there is no path between two vertices, the number of vertices is used instead the length of the geodesic. This is always longer than the longest possible geodesic.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates cocitation scores for given vertices in a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the cohesive block structure of the graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a CohesiveBlocks object. It is advised to use that.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCommunity structure detection based on the betweenness of the edges in the network. This algorithm was invented by M Girvan and MEJ Newman, see: M Girvan and MEJ Newman: Community structure in social and biological networks, Proc. Nat. Acad. Sci. USA 99, 7821-7826 (2002).\nThe idea is that the betweenness of the edges connecting two communities is typically high. So we gradually remove the edge with the highest betweenness from the network and recalculate edge betweenness after every removal, as long as all edges are removed.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nFinds the community structure of the graph according to the algorithm of Clauset et al based on the greedy optimization of modularity.\nThis is a bottom-up algorithm: initially every vertex belongs to a separate community, and communities are merged one by one. In every step, the two communities being merged are the ones which result in the maximal increase in modularity.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: A. Clauset, M. E. J. Newman and C. Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nFinds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.\nSee http://www.mapequation.org for a visualization of the algorithm or one of the references provided below. ",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nFinds the community structure of the graph according to the label propagation method of Raghavan et al.\nInitially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.\nNote that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.\nReference: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nA proper implementation of Newman's eigenvector community structure detection. Each split is done by maximizing the modularity regarding the original network. See the reference for details.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nFinds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nFinds the community structure of the graph according to the multilevel algorithm of Blondel et al. This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.\nReference: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks. J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the optimal modularity score of the graph and the corresponding community structure.\nThis function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nFinds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nFinds the community structure of the graph according to the random walk method of Latapy & Pons.\nThe basic idea of the algorithm is that short random walks tend to stay in the same community. The method provides a dendrogram.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the complementer of the graph",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the composition of two graphs.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the (strong or weak) connected components for a given graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a VertexClustering object. It is advised to use that.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates Burt's constraint scores for given vertices in a graph.\nBurt's constraint is higher if ego has less, or mutually stronger related (i.e. more redundant) contacts. Burt's measure of constraint, C[i], of vertex i's ego network V[i], is defined for directed and valued graphs as follows:\nC[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in V[], j != i)\nfor a graph of order (ie. number od vertices) N, where proportional tie strengths are defined as follows:\np[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i), a[i,j] are elements of A and the latter being the graph adjacency matrix.\nFor isolated vertices, constraint is undefined.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Undocumented (yet).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Undocumented (yet).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Creates a copy of the graph.\nAttributes are copied by reference; in other words, if you use mutable Python objects as attribute values, these objects will still be shared between the old and new graph. You can use `deepcopy()` from the `copy` module if you need a truly deep copy of the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Finds the coreness (shell index) of the vertices of the network.\nThe k-core of a graph is a maximal subgraph in which each vertex has at least degree k. (Degree here means the degree in the subgraph of course). The coreness of a vertex is k if it is a member of the k-core but not a member of the k + 1-core.\nReference: Vladimir Batagelj, Matjaz Zaversnik: An O(m) Algorithm for Core Decomposition of Networks.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the number of automorphisms of a graph using the BLISS isomorphism algorithm.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm and canonical permutations.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Determines the number of isomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Counts the multiplicities of the given edges.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Determines the number of subisomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a de Bruijn graph with parameters (m, n)\nA de Bruijn graph represents relationships between strings. An alphabet of m letters are used and strings of length n are considered. A vertex corresponds to every possible string and there is a directed edge from vertex v to vertex w if the string of v can be transformed into the string of w by removing its first letter and appending a letter to it.\nPlease note that the graph will have mn vertices and even more edges, so probably you don't want to supply too big numbers for m and n.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Decomposes the graph into subgraphs.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns some vertex degrees from the graph.\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph with a given degree sequence.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nRemoves edges from the graph.\nAll vertices will be kept, even if they lose all their edges. Nonexistent edges will be silently ignored.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Deletes vertices and all its edges from the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the density of the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Constructs a depth first search (DFS) iterator of the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the diameter of the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Subtracts the given graph from the original",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates shortest path lengths for given vertices in a graph.\nThe algorithm used for the calculations is selected automatically: a simple BFS is used for unweighted graphs, Dijkstra's algorithm is used when all the weights are non-negative. Otherwise, the Bellman-Ford algorithm is used if the number of requested source vertices is smaller than 100 and Johnson's algorithm is used otherwise.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the structural diversity index of the vertices.\nThe structural diversity index of a vertex is simply the (normalized) Shannon entropy of the weights of the edges incident on the vertex.\nThe measure is defined for undirected graphs only; edge directions are ignored.\nReference: Eagle N, Macy M and Claxton R: Network diversity and economic development, Science 328, 1029-1031, 2010.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the dominator tree from the given root node",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nDyad census, as defined by Holland and Leinhardt\nDyad census means classifying each pair of vertices of a directed graph into three categories: mutual, there is an edge from a to b and also from b to a; asymmetric, there is an edge either from a to b or from b to a but not the other way and null, no edges between a and b.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a DyadCensus object. It is advised to use that.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the eccentricities of given vertices in a graph.\nThe eccentricity of a vertex is calculated by measuring the shortest distance from (or to) the vertex, to (or from) all other vertices in the graph, and taking the maximum.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Counts the number of edges.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. ",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates or estimates the edge betweennesses in a graph.\nAlso supports calculating edge betweenness with shortest path length cutoffs or considering shortest paths only from certain source vertices or to certain target vertices.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the edge connectivity of the graph or between some vertices.\nThe edge connectivity between two given vertices is the number of edges that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of edge disjoint directed paths between the vertices. The edge connectivity of the graph is the minimal edge connectivity over all vertex pairs.\nThis method calculates the edge connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall edge connectivity is returned.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Undocumented",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the eigenvector centralities of the vertices in a graph.\nEigenvector centrality is a measure of the importance of a node in a network. It assigns relative scores to all nodes in the network based on the principle that connections from high-scoring nodes contribute more to the score of the node in question than equal connections from low-scoring nodes. In practice, the centralities are determined by calculating eigenvector corresponding to the largest positive eigenvalue of the adjacency matrix. In the undirected case, this function considers the diagonal entries of the adjacency matrix to be twice the number of self-loops on the corresponding vertex.\nIn the directed case, the left eigenvector of the adjacency matrix is calculated. In other words, the centrality of a vertex is proportional to the sum of centralities of vertices pointing to it.\nEigenvector centrality is meaningful only for connected graphs. Graphs that are not connected should be decomposed into connected components, and the eigenvector centrality calculated for each separately.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph based on the Erdős-Rényi model.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph based on a simple growing model with vertex types.\nA single vertex is added at each time step. This new vertex tries to connect to k vertices in the graph. The probability that such a connection is realized depends on the types of the vertices involved.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a famous graph based on its name.\nSeveral famous graphs are known to igraph including (but not limited to) the Chvatal graph, the Petersen graph or the Tutte graph. This method generates one of them based on its name (case insensitive). See the documentation of the C interface of igraph for the names available: https://igraph.org/c/doc.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns two vertex IDs whose distance equals the actual diameter of the graph.\nIf there are many shortest paths with the length of the diameter, it returns the first one it found.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates an approximately or exactly minimal feedback arc set.\nA feedback arc set is a set of edges whose removal makes the graph acyclic. Since this is always possible by removing all the edges, we are in general interested in removing the smallest possible number of edges, or an edge set with as small total weight as possible. This method calculates one such edge set. Note that the task is trivial for an undirected graph as it is enough to find a spanning tree and then remove all the edges not in the spanning tree. Of course it is more complicated for directed graphs.\nReference: Eades P, Lin X and Smyth WF: A fast and effective heuristic for the feedback arc set problem. In: Proc Inf Process Lett 319-323, 1993.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph based on the forest fire model\nThe forest fire model is a growing graph model. In every time step, a new vertex is added to the graph. The new vertex chooses an ambassador (or more than one if ambs > 1) and starts a simulated forest fire at its ambassador(s). The fire spreads through the edges. The spreading probability along an edge is given by fwprob. The fire may also spread backwards on an edge by probability fwprob*bwfactor. When the fire ended, the newly added vertex connects to the vertices ``burned'' in the previous fire.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a full graph (directed or undirected, with or without loops).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a full citation graph\nA full citation graph is a graph where the vertices are indexed from 0 to n − 1 and vertex i has a directed edge towards all vertices with an index less than i.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Finds a single fundamental cycle basis of the graph",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nReturns the adjacency matrix of a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates all of the shortest paths from/to a given node in a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nInternal function, undocumented.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns a path with the actual diameter of the graph.\nIf there are many shortest paths with the length of the diameter, it returns the first one it founds.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the edge list of a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the edge ID of an arbitrary edge between vertices v1 and v2",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the edge IDs of some edges between some vertices.\nThe method does not consider multiple edges; if there are multiple edges between a pair of vertices, only the ID of one of the edges is returned.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns all isomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the k shortest paths from/to a given node in a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the shortest path from a source vertex to a target vertex in a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the shortest path from a source vertex to a target vertex in a graph using the A-Star algorithm and a heuristic function.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the shortest paths from/to a given node in a graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns all subisomorphisms between the graph and another one using the LAD algorithm.\nThe optional domains argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns all subisomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the girth of the graph.\nThe girth of a graph is the length of the shortest circle in it.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nInternal function, undocumented.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a growing random graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the harmonic centralities of given vertices in a graph.\nThe harmonic centrality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the mean inverse distance to all other vertices.\nIf the graph is not connected, and there is no path between two vertices, the inverse distance is taken to be zero.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether the graph has multiple edges.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a regular hexagonal lattice.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates Kleinberg's hub score for the vertices of the graph",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the edges a given vertex is incident on.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the independence number of the graph.\nThe independence number of the graph is the size of the largest independent vertex set.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns some or all independent vertex sets of the graph as a list of tuples.\nTwo vertices are independent if there is no edge between them. Members of an independent vertex set are mutually independent.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns a subgraph spanned by the given vertices.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns whether the graph is acyclic (i.e. contains no cycles).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Decides whether the graph is biconnected.\nA graph is biconnected if it stays connected after the removal of any single vertex.\nNote that there are different conventions in use about whether to consider a graph consisting of two connected vertices to be biconnected. igraph does consider it biconnected.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Decides whether the graph is bipartite or not.\nVertices of a bipartite graph can be partitioned into two groups A and B in a way that all edges go between the two groups.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns whether the graph is chordal or not.\nA graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Decides whether the graph is connected.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether the graph is a DAG (directed acyclic graph).\nA DAG is a directed graph with no directed cycles.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether the graph is directed.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether a specific set of edges contain loop edges",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Decides whether the given vertex set is a minimal separator.\nA minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether an edge is a multiple edge.\nAlso works for a set of edges -- in this case, every edge is checked one by one. Note that if there are multiple edges going between a pair of vertices, there is always one of them that is not reported as multiple (only the others). This allows one to easily detect the edges that have to be deleted in order to make the graph free of multiple edges.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether an edge has an opposite pair.\nAlso works for a set of edges -- in this case, every edge is checked one by one. The result will be a list of booleans (or a single boolean if only an edge index is supplied), every boolean corresponding to an edge in the edge set supplied. True is returned for a given edge a --> b if there exists another edge b --> a in the original graph (not the given edge set!). All edges in an undirected graph are mutual. In case there are multiple edges between a and b, it is enough to have at least one edge in either direction to report all edges between them as mutual, so the multiplicity of edges do not matter.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Decides whether the removal of the given vertices disconnects the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether the graph is simple (no loop or multiple edges).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether the graph is a (directed or undirected) tree graph.\nFor directed trees, the function may require that the edges are oriented outwards from the root or inwards to the root, depending on the value of the mode argument.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph with a given isomorphism class.\nCurrently we support directed graphs of size 3 and 4, and undirected graphs of size 3, 4, 5 or 6. Use the isoclass() instance method to find the isomorphism class of a given graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the isomorphism class of the graph or its subgraph.\nIsomorphism class calculations are implemented only for directed graphs with 3 or 4 vertices, or undirected graphs with 3, 4, 5 or 6 vertices..",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether the graph is isomorphic to another graph.\nThe algorithm being used is selected using a simple heuristic:If one graph is directed and the other undirected, an exception is thrown.If the two graphs does not have the same number of vertices and edges, it returns with FalseIf the graphs have three or four vertices, then an O(1) algorithm is used with precomputed data.Otherwise if the graphs are directed, then the VF2 isomorphism algorithm is used (see isomorphic_vf2).Otherwise the BLISS isomorphism algorithm is used, see isomorphic_bliss.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a k-regular random graph\nA k-regular random graph is a random graph where each vertex has degree k. If the graph is directed, both the in-degree and the out-degree of each vertex will be k.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a Kautz graph with parameters (m, n)\nA Kautz graph is a labeled graph, vertices are labeled by strings of length n + 1 above an alphabet with m + 1 letters, with the restriction that every two consecutive letters in the string must be different. There is a directed edge from a vertex v to another vertex w if it is possible to transform the string of v into the string of w by removing the first letter and appending a letter to it.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the Laplacian matrix of a graph.\nThe Laplacian matrix is similar to the adjacency matrix, but the edges are denoted with -1 and the diagonal contains the node degrees.\nSymmetric normalized Laplacian matrices have 1 or 0 in their diagonals (0 for vertices with no edges), edges are denoted by 1 / sqrt(d_i * d_j) where d_i is the degree of node i.\nLeft-normalized and right-normalized Laplacian matrices are derived from the unnormalized Laplacian by scaling the row or the column sums to be equal to 1.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the largest cliques of the graph as a list of tuples.\nQuite intuitively a clique is considered largest if there is no clique with more vertices in the whole graph. All largest cliques are maximal (i.e. nonextendable) but not all maximal cliques are largest.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the largest independent vertex sets of the graph as a list of tuples.\nQuite intuitively an independent vertex set is considered largest if there is no other set with more vertices in the whole graph. All largest sets are maximal (i.e. nonextendable) but not all maximal sets are largest.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a regular square lattice.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Place the vertices of a bipartite graph in two layers.\nThe layout is created by placing the vertices in two rows, according to their types. The positions of the vertices within the rows are then optimized to minimize the number of edge crossings using the heuristic used by the Sugiyama layout algorithm.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices of the graph uniformly on a circle or a sphere.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.\nThe algorithm uses simulated annealing and a sophisticated energy function, which is unfortunately hard to parameterize for different graphs. The original publication did not disclose any parameter values, and the ones below were determined by experimentation.\nThe algorithm consists of two phases: an annealing phase and a fine-tuning phase. There is no simulated annealing in the second phase.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.\nThis is an algorithm suitable for quite large graphs, but it can be surprisingly slow for small ones (where the simpler force-based layouts like layout_kamada_kawai() or layout_fruchterman_reingold() are more useful.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.\nThis is a force directed layout, see Fruchterman, T. M. J. and Reingold, E. M.: Graph Drawing by Force-directed Placement. Software -- Practice and Experience, 21/11, 1129--1164, 1991",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.\ngraphopt uses physical analogies for defining attracting and repelling forces among the vertices and then the physical system is simulated until it reaches an equilibrium or the maximal number of iterations is reached.\nSee http://www.schmuhl.org/graphopt/ for the original graphopt.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices of a graph in a 2D or 3D grid.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices on a plane according to the Kamada-Kawai algorithm.\nThis is a force directed layout, see Kamada, T. and Kawai, S.: An Algorithm for Drawing General Undirected Graphs. Information Processing Letters, 31/1, 7--15, 1989.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices on a 2D plane according to the Large Graph Layout.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.\nThis layout requires a distance matrix, where the intersection of row i and column j specifies the desired distance between vertex i and vertex j. The algorithm will try to place the vertices in a way that approximates the distance relations prescribed in the distance matrix. igraph uses the classical multidimensional scaling by Torgerson (see reference below).\nFor unconnected graphs, the method will decompose the graph into weakly connected components and then lay out the components individually using the appropriate parts of the distance matrix.\nReference: Cox & Cox: Multidimensional Scaling (1994), Chapman and Hall, London.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices of the graph randomly.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.\nThis is a tree layout. If the given graph is not a tree, a breadth-first search is executed first to obtain a possible spanning tree.\nReference: EM Reingold, JS Tilford: Tidier Drawings of Trees. IEEE Transactions on Software Engineering 7:22, 223-228, 1981.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Circular Reingold-Tilford layout for trees.\nThis layout is similar to the Reingold-Tilford layout, but the vertices are placed in a circular way, with the root vertex in the center.\nSee layout_reingold_tilford for the explanation of the parameters.\nReference: EM Reingold, JS Tilford: Tidier Drawings of Trees. IEEE Transactions on Software Engineering 7:22, 223-228, 1981.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates a star-like layout for the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Uniform Manifold Approximation and Projection (UMAP).\nThis layout is a probabilistic algorithm that places vertices that are connected and have a short distance close by in the embedded space.\nReference: L McInnes, J Healy, J Melville: UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. arXiv:1802.03426.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph from LCF notation.\nLCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for 3-regular Hamiltonian graphs. It consists of three parameters, the number of vertices in the graph, a list of shifts giving additional edges to a cycle backbone and another integer giving how many times the shifts should be performed. See http://mathworld.wolfram.com/LCFNotation.html for details.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the line graph of the graph.\nThe line graph L(G) of an undirected graph is defined as follows: L(G) has one vertex for each edge in G and two vertices in L(G) are connected iff their corresponding edges in the original graph share an end point.\nThe line graph of a directed graph is slightly different: two vertices are connected by a directed edge iff the target of the first vertex's corresponding edge is the same as the source of the second vertex's corresponding edge.\nEdge i in the original graph will map to vertex i of the line graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Lists the triangles of the graph",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the maximum degree of a vertex set in the graph.\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nReturns the maximum flow between the source and target vertices.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a Flow object. It is advised to use that.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the value of the maximum flow between the source and target vertices.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the maximal cliques of the graph as a list of tuples.\nA maximal clique is a clique which can't be extended by adding any other vertex to it. A maximal clique is not necessarily one of the largest cliques in the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the maximal independent vertex sets of the graph as a list of tuples.\nA maximal independent vertex set is an independent vertex set which can't be extended by adding any other vertex to it. A maximal independent vertex set is not necessarily one of the largest independent vertex sets in the graph.\nReference: S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka: A new algorithm for generating all the maximal independent sets. SIAM J Computing, 6:505-517, 1977.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Conducts a maximum cardinality search on the graph. The function computes a rank alpha for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.\nMaximum cardinality search is useful in deciding the chordality of a graph: a graph is chordal if and only if any two neighbors of a vertex that are higher in rank than the original vertex are connected to each other.\nThe result of this function can be passed to is_chordal() to speed up the chordality computation if you also need the result of the maximum cardinality search for other purposes.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the minimum cut between the source and target vertices or within the whole graph.\nThe minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if the source and target are not given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated. For undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a Cut object. It is advised to use that.\n",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the minimum cut between the source and target vertices or within the whole graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Computes a minimum cycle basis of the graph",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns a list containing all separator vertex sets of minimum size.\nA vertex set is a separator if its removal disconnects the graph. This method lists all the separators for which no smaller separator set exists in the given graph.\nReference: Arkady Kanevsky: Finding all minimum-size separating vertex sets in a graph. Networks 23:533-541, 1993.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the modularity of the graph with respect to some vertex types.\nThe modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It is defined as Q = 1 ⁄ (2m)*sum(Aij − gamma*ki*kj ⁄ (2m)delta(ci, cj), i, j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, Ci and cj are the types of the two vertices (i and j), and gamma is a resolution parameter that defaults to 1 for the classical definition of modularity. delta(x, y) is one iff x = y, 0 otherwise.\nIf edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges incident on vertex i, kj is the total weight of edges incident on vertex j and m is the total edge weight in the graph.\nAttention: method overridden in Graph to allow VertexClustering objects as a parameter. This method is not strictly necessary, since the VertexClustering class provides a variable called modularity.\nReference: MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the modularity matrix of the graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Counts the number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. It is argued that the motif profile (ie. the number of different motifs in the graph) is characteristic for different types of networks and network function is related to the motifs in the graph.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nIn a big network the total number of motifs can be very large, so it takes a lot of time to find all of them. In such cases, a sampling method can be used. This function is capable of doing sampling via the cut_prob argument. This argument gives the probability that a branch of the motif search tree will not be explored.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Counts the total number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. This function estimates the total number of motifs in a graph without assigning isomorphism classes to them by extrapolating from a random sample of vertices.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Counts the total number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. This function counts the total number of motifs in a graph without assigning isomorphism classes to them.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. For each vertex specified by vertices, returns the vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. For each vertex specified by vertices, returns the number of vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns adjacent vertices to a given vertex.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the path length histogram of the graph Attention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Permutes the vertices of the graph according to the given permutation and returns the new graph.\nVertex k of the original graph will become vertex permutation[k] in the new graph. No validity checks are performed on the permutation vector.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the personalized PageRank values of a graph.\nThe personalized PageRank calculation is similar to the PageRank calculation, but the random walk is reset to a non-uniform distribution over the vertices in every step with probability 1 − damping instead of a uniform distribution.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the predecessors of a given vertex.\nEquivalent to calling the neighbors() method with type=\"in\".",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph based on vertex types and connection probabilities.\nThis is practically the non-growing variant of Establishment. A given number of vertices are generated. Every vertex is assigned to a vertex type according to the given type probabilities. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a tree from its Prüfer sequence.\nA Prüfer sequence is a unique sequence of integers associated with a labelled tree. A tree on n vertices can be represented by a sequence of n − 2 integers, each between 0 and n − 1 (inclusive).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the radius of the graph.\nThe radius of a graph is defined as the minimum eccentricity of its vertices (see eccentricity()).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Performs a random walk of a given length from a given node.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nReads a graph from a file conforming to the DIMACS minimum-cost flow file format.\nFor the exact description of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm\nRestrictions compared to the official description of the format:igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.Node indices start from 1. Only a single source and target node is allowed.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reads an UCINET DL file and creates a graph based on it.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reads an edge list from a file and creates a graph based on it.\nPlease note that the vertex indices are zero-based. A vertex of zero degree will be created for every integer that is in range but does not appear in the edgelist.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reads a GML file and creates a graph based on it.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reads a GraphDB format file and creates a graph based on it.\nGraphDB is a binary format, used in the graph database for isomorphism testing (see http://amalfi.dis.unina.it/graph/).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reads a GraphML format file and creates a graph based on it.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reads an .lgl file used by LGL.\nIt is also useful for creating graphs from \"named\" (and optionally weighted) edge lists.\nThis format is used by the Large Graph Layout program. See the documentation of LGL regarding the exact format description.\nLGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reads an .ncol file used by LGL.\nIt is also useful for creating graphs from \"named\" (and optionally weighted) edge lists.\nThis format is used by the Large Graph Layout program. See the repository of LGL for more information.\nLGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a bipartite graph from the degree sequences of its partitions.\nThis method implements a Havel-Hakimi style graph construction for biparite graphs. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the method parameter. The allowed edge types (i.e. whether multi-edges are allowed) are specified in the allowed_edge_types parameter. Self-loops are never created, since a graph with self-loops is not bipartite.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph from a degree sequence.\nThis method implements a Havel-Hakimi style graph construction from a given degree sequence. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the method parameter. The allowed edge types (i.e. whether multiple or loop edges are allowed) are specified in the allowed_edge_types parameter.\n",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph. This measure is calculated if mode is \"default\".\nPrior to igraph 0.6, another measure was implemented, defined as the probability of mutual connection between a vertex pair if we know that there is a (possibly non-mutual) connection between them. In other words, (unordered) vertex pairs are classified into three groups: (1) disconnected, (2) non-reciprocally connected and (3) reciprocally connected. The result is the size of group (3), divided by the sum of sizes of groups (2) and (3). This measure is calculated if mode is \"ratio\".",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Reverses the direction of some edges in the graph.\nThis function is a no-op for undirected graphs.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Randomly rewires the graph while preserving the degree distribution.\nPlease note that the rewiring is done \"in-place\", so the original graph will be modified. If you want to preserve the original graph, use the copy method before.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Rewires the edges of a graph with constant probability.\nEach endpoint of each edge of the graph will be rewired with a constant probability, given in the first argument.\nPlease note that the rewiring is done \"in-place\", so the original graph will be modified. If you want to preserve the original graph, use the copy method before.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a ring graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a graph based on a stochastic block model.\nA given number of vertices are generated. Every vertex is assigned to a vertex type according to the given block sizes. Vertices of the same type will be assigned consecutive vertex IDs. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved. The probabilities are taken from the preference matrix.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Dice similarity coefficient of vertices.\nThe Dice similarity coefficient of two vertices is twice the number of their common neighbors divided by the sum of their degrees. This coefficient is very similar to the Jaccard coefficient, but usually gives higher similarities than its counterpart.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Inverse log-weighted similarity coefficient of vertices.\nEach vertex is assigned a weight which is 1 / log(degree). The log-weighted similarity of two vertices is the sum of the weights of their common neighbors.\nNote that the presence of loop edges may yield counter-intuitive results. A node with a loop edge is considered to be a neighbor of itself twice (because there are two edge stems incident on the node). Adding a loop edge to a node may decrease its similarity to other nodes, but it may also increase it. For instance, if nodes A and B are connected but share no common neighbors, their similarity is zero. However, if a loop edge is added to B, then B itself becomes a common neighbor of A and B and thus the similarity of A and B will be increased. Consider removing loop edges explicitly before invoking this function using Graph.simplify().",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Jaccard similarity coefficient of vertices.\nThe Jaccard similarity coefficient of two vertices is the number of their common neighbors divided by the number of vertices that are adjacent to at least one of them.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Simplifies a graph by removing self-loops and/or multiple edges.\nFor example, suppose you have a graph with an edge attribute named weight. graph.simplify(combine_edges=max) will take the maximum of the weights of multiple edges and assign that weight to the collapsed edge. graph.simplify(combine_edges=sum) will take the sum of the weights. You can also write graph.simplify(combine_edges=dict(weight=\"sum\")) or graph.simplify(combine_edges=dict(weight=sum)), since sum is recognised both as a Python built-in function and as a string constant.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the minimum cut between the source and target vertices in a graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a star graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a non-growing graph with edge probabilities proportional to node fitnesses.\nThe algorithm randomly selects vertex pairs and connects them until the given number of edges are created. Each vertex is selected with a probability proportional to its fitness; for directed graphs, a vertex is selected as a source proportional to its out-fitness and as a target proportional to its in-fitness.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a non-growing graph with prescribed power-law degree distributions.\n",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the strength (weighted degree) of some vertices from the graph\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the strength (that is, the sum of the weights of all incident edges) of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Determines the indices of vertices which are in the same component as a given vertex.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns a subgraph spanned by the given edges.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether a subgraph of the graph is isomorphic to another graph.\nThe optional domains argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Checks whether a subgraph of the graph is isomorphic to another graph.\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Returns the successors of a given vertex.\nEquivalent to calling the neighbors() method with type=\"out\".",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Converts an undirected graph to directed.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Converts a tree graph into a Prüfer sequence.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Converts a directed graph to undirected.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates a possible topological sorting of the graph.\nReturns a partial sorting and issues a warning if the graph is not a directed acyclic graph.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nCalculates the average of the vertex transitivities of the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter.\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it simply takes the average local transitivity across the whole network.\nReference: D. J. Watts and S. Strogatz: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. In case of the local transitivity, this probability is calculated separately for each vertex.\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it calculates a transitivity value for each vertex individually.\nThe traditional local transitivity measure applies for unweighted graphs only. When the weights argument is given, this function calculates the weighted local transitivity proposed by Barrat et al (see references).\n",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the global transitivity (clustering coefficient) of the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. More precisely, this is the ratio of the triangles and connected triplets in the graph. The result is a single real number. Directed graphs are considered as undirected ones.\nNote that this measure is different from the local transitivity measure (see transitivity_local_undirected()) as it calculates a single value for the whole graph.\nReference: S. Wasserman and K. Faust: Social Network Analysis: Methods and Applications. Cambridge: Cambridge University Press, 1994.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a tree in which almost all vertices have the same number of children.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nTriad census, as defined by Davis and Leinhardt\nCalculating the triad census means classifying every triplets of vertices in a directed graph. A triplet can be in one of 16 states, these are listed in the documentation of the C interface of igraph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a TriadCensus object. It is advised to use that. The name of the triplet classes are also documented there.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Generates a regular triangular lattice.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Counts the number of vertices.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. ",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates a greedy vertex coloring for the graph based on some heuristics.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Calculates the vertex connectivity of the graph or between some vertices.\nThe vertex connectivity between two given vertices is the number of vertices that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of vertex disjoint directed paths between the vertices (apart from the source and target vertices of course). The vertex connectivity of the graph is the minimal vertex connectivity over all vertex pairs.\nThis method calculates the vertex connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall vertex connectivity is returned.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. This function generates networks with the small-world property based on a variant of the Watts-Strogatz model. The network is obtained by first creating a periodic undirected lattice, then rewiring both endpoints of each edge with probability p, while avoiding the creation of multi-edges.\nThis process differs from the original model of Watts and Strogatz (see reference) in that it rewires both endpoints of edges. Thus in the limit of p=1, we obtain a G(n,m) random graph with the same number of vertices and edges as the original lattice. In comparison, the original Watts-Strogatz model only rewires a single endpoint of each edge, thus the network does not become fully random even for <code>p=1</code>.\nFor appropriate choices of p, both models exhibit the property of simultaneously having short path lengths and high clustering.\nReference: Duncan J Watts and Steven H Strogatz: Collective dynamics of small world networks, Nature 393, 440-442, 1998",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. overridden in igraph.Graph\nWrites the graph in DIMACS format to the given file.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Writes the graph in DOT format to the given file.\nDOT is the format used by the GraphViz software package.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Writes the edge list of a graph to a file.\nDirected edges are written in (from, to) order.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Writes the graph in GML format to the given file.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Writes the graph to a GraphML file.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Writes the graph to a file in LEDA native format.\nThe LEDA format supports at most one attribute per vertex and edge. You can specify which vertex and edge attribute you want to use. Note that the name of the attribute is not saved in the LEDA file.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Writes the edge list of a graph to a file in .lgl format.\nNote that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call simplify() before saving.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Writes the edge list of a graph to a file in .ncol format.\nNote that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call simplify() before saving.",
    "igraph: Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.. Writes the graph in Pajek format to the given file.",
    "igraph: Static class for the implementation of custom getter/setter functions for configuration keys. Sets a boolean value in the given configuration object.",
    "igraph: Static class for the implementation of custom getter/setter functions for configuration keys. Sets a float value in the given configuration object.\nNote that float values are converted to strings in the configuration object, which may lead to some precision loss.",
    "igraph: Static class for the implementation of custom getter/setter functions for configuration keys. Sets an integer value in the given configuration object.",
    "igraph: Matplotlib-specific abstract edge drawer object.. Constructs the edge drawer.",
    "igraph: Matplotlib-specific abstract edge drawer object.. overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
    "igraph: Matplotlib-specific abstract edge drawer object.. Draws a loop edge.\nThe default implementation draws a small circle.",
    "igraph: Matplotlib-specific abstract edge drawer object.. overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nThe default implementation of this method draws undirected edges as straight lines. Loop edges are drawn as small circles.",
    "igraph: Matplotlib-specific abstract edge drawer object.. Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.",
    "igraph: Matplotlib-specific abstract edge drawer object.. Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge.",
    "igraph: Matplotlib backend-specific vertex drawer.. overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
    "igraph: Matplotlib backend-specific vertex drawer.. overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nBuild the Artist for a vertex and return it.",
    "igraph: Static class which draws triangles pointing down. overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a triangle on the Cairo context without stroking or filling it.",
    "igraph: Static class which draws triangles pointing down. overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the triangle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
    "igraph: Object whose interface is compatible with textwrap.TextWrapper but does no wrapping.. Undocumented",
    "igraph: Object whose interface is compatible with textwrap.TextWrapper but does no wrapping.. Undocumented",
    "igraph: Object whose interface is compatible with textwrap.TextWrapper but does no wrapping.. Undocumented",
    "igraph: Advanced gradient that consists of more than two base colors.\n. overrides igraph.drawing.colors.Palette.__init__\nCreates an advanced gradient palette",
    "igraph: Advanced gradient that consists of more than two base colors.\n. Inherited from Palette:Returns the number of colors in this palette",
    "igraph: Advanced gradient that consists of more than two base colors.\n. Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes",
    "igraph: Advanced gradient that consists of more than two base colors.\n. Inherited from Palette:Undocumented",
    "igraph: Advanced gradient that consists of more than two base colors.\n. Inherited from Palette:Clears the result cache.",
    "igraph: Advanced gradient that consists of more than two base colors.\n. Inherited from Palette:Returns the given color from the palette.",
    "igraph: Advanced gradient that consists of more than two base colors.\n. Inherited from Palette:Returns multiple colors from the palette.",
    "igraph: Abstract class that serves as a base class for anything that draws on a Cairo context within a given bounding box.\nA subclass of AbstractCairoDrawer is guaranteed to have an attribute named context that represents the Cairo context to draw on, and an attribute named bbox for the BoundingBox of the drawing area.. overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem, igraph.drawing.cairo.dendrogram.CairoDendrogramDrawer, igraph.drawing.cairo.graph.AbstractCairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer, igraph.drawing.cairo.polygon.CairoPolygonDrawer, igraph.drawing.cairo.text.CairoTextDrawer, igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer\nConstructs the drawer and associates it to the given Cairo context and the given BoundingBox.",
    "igraph: Abstract class that serves as a base class for anything that draws on a Cairo context within a given bounding box.\nA subclass of AbstractCairoDrawer is guaranteed to have an attribute named context that represents the Cairo context to draw on, and an attribute named bbox for the BoundingBox of the drawing area.. overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem\nSets the bounding box of the drawing area where this drawer will draw.",
    "igraph: Abstract class that serves as a base class for anything that draws on a Cairo context within a given bounding box.\nA subclass of AbstractCairoDrawer is guaranteed to have an attribute named context that represents the Cairo context to draw on, and an attribute named bbox for the BoundingBox of the drawing area.. Inherited from AbstractDrawer:Abstract method, must be implemented in derived classes.",
    "igraph: Generic histogram class for real numbers\n. Initializes the histogram with the given data set.",
    "igraph: Generic histogram class for real numbers\n. Plotting support",
    "igraph: Generic histogram class for real numbers\n. Undocumented",
    "igraph: Generic histogram class for real numbers\n. Adds a single number to the histogram.",
    "igraph: Generic histogram class for real numbers\n. Adds a single number or the elements of an iterable to the histogram.",
    "igraph: Generic histogram class for real numbers\n. Generator returning the bins of the histogram in increasing order",
    "igraph: Generic histogram class for real numbers\n. Clears the collected data",
    "igraph: Generic histogram class for real numbers\n. Returns the string representation of the histogram.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. Returns the cluster with the given index.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. overridden in igraph.VertexCover\nConstructs a cover with the given clusters.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. Iterates over the clusters in this cover.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. Returns the number of clusters in this cover.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. Returns a string representation of the cover.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. Returns the size of a given cluster.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. Returns the histogram of cluster sizes.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. Returns the size of given clusters.\nThe indices are given as positional arguments. If there are no positional arguments, the function will return the sizes of all clusters.",
    "igraph: Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n. Returns the summary of the cover.\nThe summary includes the number of items and clusters, and also the list of members for each of the clusters if the verbosity is nonzero.",
    "igraph: Object that represents a connection to a Gephi master server.. Undocumented",
    "igraph: Object that represents a connection to a Gephi master server.. Constructs a connection to a Gephi master server.\nThe connection object can be constructed either by specifying theurl directly, or by specifying the host, port andworkspace arguments.  The latter three are evaluated only ifurl is None; otherwise the url will take precedence.\nThe url argument does not have to include the operation (e.g.,?operation=updateGraph); the connection will take care of it.E.g., if you wish to connect to workspace 2 in a local Gephi instanceon port 7341, the correct form to use for the url is as follows:",
    "igraph: Object that represents a connection to a Gephi master server.. Undocumented",
    "igraph: Object that represents a connection to a Gephi master server.. Flushes all the pending operations to the Gephi master server in asingle request.",
    "igraph: Object that represents a connection to a Gephi master server.. Flushes all the pending operations to the Gephi master server in asingle request.",
    "igraph: Object that represents a connection to a Gephi master server.. Undocumented",
    "igraph: Object that represents a connection to a Gephi master server.. Sends the given raw data to the Gephi streaming master server in an HTTPPOST request.",
    "igraph: Static class, the ancestor of all vertex shape drawer classes.\nCustom shapes must implement at least the draw_path method of the class. The method must not stroke or fill, it should just set up the current Cairo path appropriately.. overridden in igraph.drawing.shapes.CircleDrawer, igraph.drawing.shapes.DiamondDrawer, igraph.drawing.shapes.DownTriangleDrawer, igraph.drawing.shapes.NullDrawer, igraph.drawing.shapes.RectangleDrawer, igraph.drawing.shapes.UpTriangleDrawer\nDraws the path of the shape on the given Cairo context, without stroking or filling it.\nThis method must be overridden in derived classes implementing custom shapes and declared as a static method using staticmethod(...).",
    "igraph: Static class, the ancestor of all vertex shape drawer classes.\nCustom shapes must implement at least the draw_path method of the class. The method must not stroke or fill, it should just set up the current Cairo path appropriately.. overridden in igraph.drawing.shapes.CircleDrawer, igraph.drawing.shapes.DiamondDrawer, igraph.drawing.shapes.DownTriangleDrawer, igraph.drawing.shapes.RectangleDrawer, igraph.drawing.shapes.UpTriangleDrawer\nDetermines where the shape centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nCan be overridden in derived classes. Must always be defined as a static method using staticmethod(...)",
    "igraph: Matplotlib drawer object for matrices.. Constructs the drawer and associates it to the given Axes.",
    "igraph: Matplotlib drawer object for matrices.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
    "igraph: Abstract base class for graph drawers that draw on a Cairo canvas.. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the graph drawer and associates it to the given Cairo context and the given BoundingBox.",
    "igraph: Abstract base class for graph drawers that draw on a Cairo canvas.. Inherited from AbstractGraphDrawer:Abstract method, must be implemented in derived classes.",
    "igraph: Fake module that raises an exception for everything. Undocumented",
    "igraph: Fake module that raises an exception for everything. Undocumented",
    "igraph: Fake module that raises an exception for everything. Constructor.",
    "igraph: Fake module that raises an exception for everything. Undocumented",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges by using an alpha value of zero (total transparency) at the source and an alpha value of one (full opacity) at the destination. The alpha value is interpolated in-between.. overrides igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer.__init__\nConstructs the edge drawer.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges by using an alpha value of zero (total transparency) at the source and an alpha value of one (full opacity) at the destination. The alpha value is interpolated in-between.. Inherited from AlphaVaryingEdgeDrawer:Draws a directed edge.",
    "igraph: Matplotlib drawer object for matrices.. Constructs the drawer and associates it to the given Axes.",
    "igraph: Matplotlib drawer object for matrices.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
    "igraph: Superclass of the embeddable shells supported by igraph. overridden in igraph.app.shell.ClassicPythonShell, igraph.app.shell.IDLEShell, igraph.app.shell.IPythonShell\nUndocumented",
    "igraph: Superclass of the embeddable shells supported by igraph. Returns the progress handler (if exists) or None (if not).",
    "igraph: Superclass of the embeddable shells supported by igraph. Returns the status handler (if exists) or None (if not).",
    "igraph: Superclass of the embeddable shells supported by igraph. Checks whether the shell supports progress bars.\nThis is done by checking for the existence of an attribute called _progress_handler.",
    "igraph: Superclass of the embeddable shells supported by igraph. Checks whether the shell supports status messages.\nThis is done by checking for the existence of an attribute called _status_handler.",
    "igraph: Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n. overrides igraph.drawing.colors.Palette.__init__\nCreates a gradient palette.",
    "igraph: Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n. Inherited from Palette:Returns the number of colors in this palette",
    "igraph: Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n. Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes",
    "igraph: Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n. Inherited from Palette:Undocumented",
    "igraph: Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n. Inherited from Palette:Clears the result cache.",
    "igraph: Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n. Inherited from Palette:Returns the given color from the palette.",
    "igraph: Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n. Inherited from Palette:Returns multiple colors from the palette.",
    "igraph: A class that can be used to portably generate formatted output to a terminal.\n. Create a TerminalController and initialize its attributes with appropriate values for the current terminal. term_stream is the stream that will be used for terminal output; if this stream is not a tty, then the terminal is assumed to be a dumb terminal (i.e., have no capabilities).",
    "igraph: A class that can be used to portably generate formatted output to a terminal.\n. Replace each $-substitutions in the given template string with the corresponding terminal control string (if it's defined) or '' (if it's not).",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). Undocumented",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). Undocumented",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). RunningMean(items=None, n=0.0, mean=0.0, sd=0.0)\nInitializes the running mean calculator.\nThere are two possible ways to initialize the calculator. First, one can provide an iterable of items; alternatively, one can specify the number of items, the mean and the standard deviation if we want to continue an interrupted calculation.",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). Undocumented",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). Undocumented",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). Undocumented",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). Undocumented",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). RunningMean.add(value, repeat=1)\nAdds the given value to the elements from which we calculate the mean and the standard deviation.",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). RunningMean.add(values)\nAdds the values in the given iterable to the elements from which we calculate the mean. Can also accept a single number. The left shift (<<) operator is aliased to this function, so you can use it to add elements as well:",
    "igraph: Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly). Resets the running mean calculator.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. overrides igraph.VertexClustering.__init__\nInitializes the cut.\nThis should not be called directly, everything is taken care of by the functions that return cuts.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. overridden in igraph.Flow\nUndocumented",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. overrides igraph.Clustering.__str__\nUndocumented",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. Inherited from VertexClustering:Plots the clustering to the given Cairo context or matplotlib Axes.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. Inherited from VertexClustering:Returns a VertexCover that contains the same clusters as this clustering.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. Inherited from VertexClustering:Returns a graph where each cluster is contracted into a single vertex.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. Inherited from VertexClustering:Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. Inherited from VertexClustering:Returns the largest cluster of the clustered graph.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. Inherited from VertexClustering:Recalculates the stored modularity value.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. Inherited from VertexClustering:Get the subgraph belonging to a given cluster.",
    "igraph: A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n. Inherited from VertexClustering:Gets all the subgraphs belonging to each of the clusters.",
    "igraph: Collection for hulls connecting vertex covers/clusters.\nThe class takes the normal arguments of a PathCollection, plus one argument called \"corner_radius\" that specifies how much to smoothen the polygon vertices into round corners. This argument can be a float or a sequence of floats, one for each hull to be drawn.. Undocumented",
    "igraph: Collection for hulls connecting vertex covers/clusters.\nThe class takes the normal arguments of a PathCollection, plus one argument called \"corner_radius\" that specifies how much to smoothen the polygon vertices into round corners. This argument can be a float or a sequence of floats, one for each hull to be drawn.. Undocumented",
    "igraph: Class implementing the default visualisation of a graph.\nThe default visualisation of a graph draws the nodes on a 2D plane according to a given Layout, then draws a straight or curved edge between nodes connected by edges. This is the visualisation used when one invokes the plot() function on a Graph object.\nSee Graph.__plot__() for the keyword arguments understood by this drawer.. overrides igraph.drawing.cairo.graph.AbstractCairoGraphDrawer.__init__\nConstructs the graph drawer and associates it to the given Cairo context and the given BoundingBox.",
    "igraph: Class implementing the default visualisation of a graph.\nThe default visualisation of a graph draws the nodes on a 2D plane according to a given Layout, then draws a straight or curved edge between nodes connected by edges. This is the visualisation used when one invokes the plot() function on a Graph object.\nSee Graph.__plot__() for the keyword arguments understood by this drawer.. overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.incident(..., mode=\"all\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"all\" as the mode argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Returns the list of vertex attribute names",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Returns a dict of attribute names and values for the vertex",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.betweenness()\nThis method calls the betweenness() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.closeness()\nThis method calls the closeness() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.constraint()\nThis method calls the constraint() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.degree()\nThis method calls the degree() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.delete_vertices()\nThis method calls the delete_vertices method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.distances()\nThis method calls the distances() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.diversity()\nThis method calls the diversity() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.eccentricity()\nThis method calls the eccentricity() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.get_shortest_paths()\nThis method calls the get_shortest_paths() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.incident(..., mode=\"in\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"in\" as the mode argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.incident()\nThis method calls the incident() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.indegree()\nThis method calls the indegree() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.is_minimal_separator()\nThis method calls the is_minimal_separator() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.is_separator()\nThis method calls the is_separator() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.neighbors()\nThis method calls the neighbors() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.incident(..., mode=\"out\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"out\" as the mode argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.outdegree()\nThis method calls the outdegree() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.pagerank()\nThis method calls the pagerank() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.personalized_pagerank()\nThis method calls the personalized_pagerank() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.predecessors()\nThis method calls the predecessors() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.strength()\nThis method calls the strength() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Proxy method to Graph.successors()\nThis method calls the successors() method of the Graph class with this vertex as the first argument, and returns the result.",
    "igraph: Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n. Updates the attributes of the vertex from dict/iterable E and F.\nIf E has a keys() method, it does: for k in E: self[k] = E[k]. If E lacks a keys() method, it does: for (k, v) in E: self[k] = v. In either case, this is followed by: for k in F: self[k] = F[k].\nThis method thus behaves similarly to the update() method of Python dictionaries.",
    "igraph: Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n − 1 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get.. overridden in igraph.drawing.colors.AdvancedGradientPalette, igraph.drawing.colors.GradientPalette, igraph.drawing.colors.PrecalculatedPalette, igraph.drawing.colors.RainbowPalette\nUndocumented",
    "igraph: Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n − 1 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get.. Returns the number of colors in this palette",
    "igraph: Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n − 1 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get.. Plots the colors of the palette on the given Cairo context/mpl Axes\nSupported keywork arguments in both Cairo and matplotlib are:orientation: the orientation of the palette. Must be one of the following values: left-right, bottom-top, right-left or top-bottom. Possible aliases: horizontal = left-right, vertical = bottom-top, lr = left-right, rl = right-left, tb = top-bottom, bt = bottom-top. The default is left-right.\nAdditional supported keyword arguments in Cairo are:border_width: line width of the border shown around the palette. If zero or negative, the border is turned off. Default is 1.grid_width: line width of the grid that separates palette cells. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 0.  Fractional widths are also allowed.\nKeyword arguments in matplotlib are passes to Axes.imshow.",
    "igraph: Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n − 1 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get.. Undocumented",
    "igraph: Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n − 1 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get.. Clears the result cache.\nThe return values of Palette.get are cached. Use this method to clear the cache.",
    "igraph: Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n − 1 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get.. Returns the given color from the palette.\nValues are cached: if the specific value given has already been looked up, its value will be returned from the cache instead of calculating it again. Use Palette.clear_cache to clear the cache if necessary.",
    "igraph: Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n − 1 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get.. Returns multiple colors from the palette.\nValues are cached: if the specific value given has already been looked upon, its value will be returned from the cache instead of calculating it again. Use Palette.clear_cache to clear the cache if necessary.",
    "igraph: Low-level representation of a vertex sequence.\nDon't use it directly, use igraph.VertexSeq instead.. Returns the attribute name list of the graph's vertices",
    "igraph: Low-level representation of a vertex sequence.\nDon't use it directly, use igraph.VertexSeq instead.. overridden in igraph.VertexSeq\nFor internal use only.",
    "igraph: Low-level representation of a vertex sequence.\nDon't use it directly, use igraph.VertexSeq instead.. Returns the value of a given vertex attribute for all vertices in a list.\nThe values stored in the list are exactly the same objects that are stored in the vertex attribute, meaning that in the case of mutable objects, the modification of the list element does affect the attribute stored in the vertex. In the case of immutable objects, modification of the list does not affect the attribute values.",
    "igraph: Low-level representation of a vertex sequence.\nDon't use it directly, use igraph.VertexSeq instead.. overridden in igraph.VertexSeq\nFor internal use only.",
    "igraph: Low-level representation of a vertex sequence.\nDon't use it directly, use igraph.VertexSeq instead.. Sets the value of a given vertex attribute for all vertices",
    "igraph: The hierarchical clustering (dendrogram) of some dataset.\nA hierarchical clustering means that we know not only the way the elements are separated into groups, but also the exact history of how individual elements were joined into larger subgroups.\n. overridden in igraph.VertexDendrogram\nCreates a hierarchical clustering.",
    "igraph: The hierarchical clustering (dendrogram) of some dataset.\nA hierarchical clustering means that we know not only the way the elements are separated into groups, but also the exact history of how individual elements were joined into larger subgroups.\n. overridden in igraph.VertexDendrogram\nDraws the dendrogram on the given Cairo context or matplotlib Axes.\nSupported keyword arguments are:orientation: the orientation of the dendrogram. Must be one of the following values: left-right, bottom-top, right-left or top-bottom. Individual elements are always placed at the former edge and merges are performed towards the latter edge. Possible aliases: horizontal = left-right, vertical = bottom-top, lr = left-right, rl = right-left, tb = top-bottom, bt = bottom-top. The default is left-right.",
    "igraph: The hierarchical clustering (dendrogram) of some dataset.\nA hierarchical clustering means that we know not only the way the elements are separated into groups, but also the exact history of how individual elements were joined into larger subgroups.\n. Undocumented",
    "igraph: The hierarchical clustering (dendrogram) of some dataset.\nA hierarchical clustering means that we know not only the way the elements are separated into groups, but also the exact history of how individual elements were joined into larger subgroups.\n. Formats the dendrogram in a foreign format.\nCurrently only the Newick format is supported.\nExample:",
    "igraph: The hierarchical clustering (dendrogram) of some dataset.\nA hierarchical clustering means that we know not only the way the elements are separated into groups, but also the exact history of how individual elements were joined into larger subgroups.\n. Sets the names of the nodes in the dendrogram",
    "igraph: The hierarchical clustering (dendrogram) of some dataset.\nA hierarchical clustering means that we know not only the way the elements are separated into groups, but also the exact history of how individual elements were joined into larger subgroups.\n. Returns the summary of the dendrogram.\nThe summary includes the number of leafs and branches, and also an ASCII art representation of the dendrogram unless it is too large.",
    "igraph: Graph drawer that sends/receives graphs to/from Cytoscape using CytoscapeRPC.\nThis graph drawer cooperates with Cytoscape using CytoscapeRPC. You need to install the CytoscapeRPC plugin first and start the XML-RPC server on a given port (port 9000 by default) from the appropriate Plugins submenu in Cytoscape.\nGraph, vertex and edge attributes are transferred to Cytoscape whenever possible (i.e. when a suitable mapping exists between a Python type and a Cytoscape type). If there is no suitable Cytoscape type for a Python type, the drawer will use a string attribute on the Cytoscape side and invoke str() on the Python attributes.\nIf an attribute to be created on the Cytoscape side already exists with a different type, an underscore will be appended to the attribute name to resolve the type conflict.\nYou can use the network_id attribute of this class to figure out the network ID of the last graph drawn with this drawer.. Returns a Cytoscape type that can be used to represent all the values in values and an appropriately converted copy of values that is suitable for an XML-RPC call.  Note that the string type in Cytoscape is used as a catch-all type; if no other type fits, attribute values will be converted to string and then posted to Cytoscape.\nNone entries are allowed in values, they will be ignored on the Cytoscape side.",
    "igraph: Graph drawer that sends/receives graphs to/from Cytoscape using CytoscapeRPC.\nThis graph drawer cooperates with Cytoscape using CytoscapeRPC. You need to install the CytoscapeRPC plugin first and start the XML-RPC server on a given port (port 9000 by default) from the appropriate Plugins submenu in Cytoscape.\nGraph, vertex and edge attributes are transferred to Cytoscape whenever possible (i.e. when a suitable mapping exists between a Python type and a Cytoscape type). If there is no suitable Cytoscape type for a Python type, the drawer will use a string attribute on the Cytoscape side and invoke str() on the Python attributes.\nIf an attribute to be created on the Cytoscape side already exists with a different type, an underscore will be appended to the attribute name to resolve the type conflict.\nYou can use the network_id attribute of this class to figure out the network ID of the last graph drawn with this drawer.. overrides igraph.drawing.baseclasses.AbstractXMLRPCDrawer.__init__\nConstructs a Cytoscape graph drawer using the XML-RPC interface of Cytoscape at the given URL.",
    "igraph: Graph drawer that sends/receives graphs to/from Cytoscape using CytoscapeRPC.\nThis graph drawer cooperates with Cytoscape using CytoscapeRPC. You need to install the CytoscapeRPC plugin first and start the XML-RPC server on a given port (port 9000 by default) from the appropriate Plugins submenu in Cytoscape.\nGraph, vertex and edge attributes are transferred to Cytoscape whenever possible (i.e. when a suitable mapping exists between a Python type and a Cytoscape type). If there is no suitable Cytoscape type for a Python type, the drawer will use a string attribute on the Cytoscape side and invoke str() on the Python attributes.\nIf an attribute to be created on the Cytoscape side already exists with a different type, an underscore will be appended to the attribute name to resolve the type conflict.\nYou can use the network_id attribute of this class to figure out the network ID of the last graph drawn with this drawer.. overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nSends the given graph to Cytoscape as a new network.",
    "igraph: Graph drawer that sends/receives graphs to/from Cytoscape using CytoscapeRPC.\nThis graph drawer cooperates with Cytoscape using CytoscapeRPC. You need to install the CytoscapeRPC plugin first and start the XML-RPC server on a given port (port 9000 by default) from the appropriate Plugins submenu in Cytoscape.\nGraph, vertex and edge attributes are transferred to Cytoscape whenever possible (i.e. when a suitable mapping exists between a Python type and a Cytoscape type). If there is no suitable Cytoscape type for a Python type, the drawer will use a string attribute on the Cytoscape side and invoke str() on the Python attributes.\nIf an attribute to be created on the Cytoscape side already exists with a different type, an underscore will be appended to the attribute name to resolve the type conflict.\nYou can use the network_id attribute of this class to figure out the network ID of the last graph drawn with this drawer.. Fetches the network with the given name from Cytoscape.\nWhen fetching networks from Cytoscape, the canonicalName attributes of vertices and edges are not converted by default. Use the keep_canonical_names parameter to retrieve these attributes as well.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Undocumented",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Track 'contains' event for mouse interactions.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nDraw each of the children, with some buffering mechanism.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Undocumented",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Get limits on x/y axes based on the graph layout data.\nThere is a small padding based on the size of the vertex marker to ensure it fits into the canvas.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Get list of edge label artists.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Get EdgeCollection artist.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Get HullCollection group/cluster/cover artists.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Get list of vertex label artists.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Get VertexCollection artist.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Track 'pick' event for mouse interactions.",
    "igraph: Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.. Set multiple parameters at once.\nThe same options can be used as in the igraph.plot function.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Creates a vertex clustering based on the value of a vertex attribute.\nVertices having the same attribute will correspond to the same cluster.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. overrides igraph.Clustering.__init__\nCreates a clustering object for a given graph.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Plots the clustering to the given Cairo context or matplotlib Axes.\nThis is done by calling Graph.__plot__() with the same arguments, but coloring the graph vertices according to the current clustering (unless overridden by the vertex_color argument explicitly).\nThis method understands all the positional and keyword arguments that are understood by Graph.__plot__(), only the differences will be highlighted here:mark_groups: whether to highlight some of the vertex groups by colored polygons. Besides the values accepted by Graph.__plot__ (i.e., a dict mapping colors to vertex indices, a list containing lists of vertex indices, or False), the following are also accepted:True: all the groups will be highlighted, the colors matching the corresponding color indices from the current palette (see the palette keyword argument of Graph.__plot__).A dict mapping cluster indices or tuples of vertex indices to color names.  The given clusters or vertex groups will be highlighted by the given colors.A list of cluster indices. This is equivalent to passing a dict mapping numeric color indices from the current palette to cluster indices; therefore, the cluster referred to by element i of the list will be highlighted by color i from the palette.The value of the plotting.mark_groups configuration key is also taken into account here; if that configuration key is True and mark_groups is not given explicitly, it will automatically be set to True.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.palette: the palette used to resolve numeric color indices to RGBA values. By default, this is an instance of ClusterColoringPalette.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. overrides igraph.Clustering.as_cover\nReturns a VertexCover that contains the same clusters as this clustering.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Returns a graph where each cluster is contracted into a single vertex.\nIn the resulting graph, vertex i represents cluster i in this clustering. Vertex i and j will be connected if there was at least one connected vertex pair (a, b) in the original graph such that vertex a was in cluster i and vertex b was in cluster j.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Returns the largest cluster of the clustered graph.\nThe largest cluster is a cluster for which no larger cluster exists in the clustering. It may also be known as the giant community if the clustering represents the result of a community detection function.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Recalculates the stored modularity value.\nThis method must be called before querying the modularity score of the clustering through the class member modularity or q if the graph has been modified (edges have been added or removed) since the creation of the VertexClustering object.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Get the subgraph belonging to a given cluster.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Gets all the subgraphs belonging to each of the clusters.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Returns the members of the specified cluster.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Iterates over the clusters in this clustering.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Returns the number of clusters.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Undocumented",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Compares this clustering to another one using some similarity or distance metric.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Returns the size of a given cluster.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Returns the histogram of cluster sizes.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Returns the size of given clusters.",
    "igraph: The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.. Inherited from Clustering:Returns the summary of the clustering.",
    "igraph: Static class which draws upright triangles. overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws an upright triangle on the Cairo context without stroking or filling it.",
    "igraph: Static class which draws upright triangles. overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the triangle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
    "igraph: Abstract vertex drawer object from which all concrete vertex drawer implementations are derived.. overridden in igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer, igraph.drawing.matplotlib.vertex.MatplotlibVertexDrawer, igraph.drawing.plotly.vertex.PlotlyVerticesDrawer\nConstructs the vertex drawer and associates it to the given palette.",
    "igraph: Abstract vertex drawer object from which all concrete vertex drawer implementations are derived.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given vertex.",
    "igraph: Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method.. Creates a new plot.",
    "igraph: Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method.. Adds an object to the plot.\nArguments not specified here are stored and passed to the object's plotting function when necessary. Since you are most likely interested in the arguments acceptable by graphs, see Graph.__plot__ for more details.",
    "igraph: Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method.. Sets the background color of the plot. None means a transparent background. You can use any color specification here that is understood by the get method of the current palette or by igraph.drawing.colors.color_name_to_rgb.",
    "igraph: Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method.. Marks the plot as dirty (should be redrawn)",
    "igraph: Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method.. Redraws the plot",
    "igraph: Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method.. Removes an object from the plot.\nIf the object has been added multiple times and no bounding box was specified, it removes the instance which occurs idxth in the list of identical instances of the object.",
    "igraph: Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method.. Saves the plot.",
    "igraph: Summary representation of a graph.\n. Constructs a summary representation of a graph.",
    "igraph: Summary representation of a graph.\n. Returns the summary representation as a string.",
    "igraph: Low-level representation of an edge sequence.\nDon't use it directly, use igraph.EdgeSeq instead.. Returns the attribute name list of the graph's edges",
    "igraph: Low-level representation of an edge sequence.\nDon't use it directly, use igraph.EdgeSeq instead.. overridden in igraph.EdgeSeq\nFor internal use only.",
    "igraph: Low-level representation of an edge sequence.\nDon't use it directly, use igraph.EdgeSeq instead.. Returns the value of a given edge attribute for all edges.",
    "igraph: Low-level representation of an edge sequence.\nDon't use it directly, use igraph.EdgeSeq instead.. Returns whether the edge sequence contains all the edges exactly once, in the order of their edge IDs.\nThis is used for optimizations in some of the edge selector routines.",
    "igraph: Low-level representation of an edge sequence.\nDon't use it directly, use igraph.EdgeSeq instead.. overridden in igraph.EdgeSeq\nFor internal use only.",
    "igraph: Low-level representation of an edge sequence.\nDon't use it directly, use igraph.EdgeSeq instead.. Sets the value of a given edge attribute for all vertices",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Returns the single instance of the configuration object.",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Checks whether the given configuration item is set.",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Deletes the given item from the configuration.\nIf the item has a default value, the default value is written back instead of the current value. Without a default value, the item is really deleted.",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Returns the given configuration item.",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Creates a new configuration instance.",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Sets the given configuration item.",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Checks if the configuration has a given key.",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Loads the configuration from the given file.",
    "igraph: Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   . Saves the configuration.",
    "igraph: Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n. Shorthand notation to select()\nThis method simply passes all its arguments to VertexSeq.select().",
    "igraph: Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n. Returns the list of all the vertex attributes in the graph associated to this vertex sequence.",
    "igraph: Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n. overrides igraph._igraph.VertexSeq.find\nReturns the first vertex of the vertex sequence that matches some criteria.\nThe selection criteria are equal to the ones allowed by VertexSeq.select. See VertexSeq.select for more details.\nFor instance, to find the first vertex with name foo in graph g:",
    "igraph: Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n. overrides igraph._igraph.VertexSeq.select\nSelects a subset of the vertex sequence based on some criteria\nThe selection criteria can be specified by the positional and the keyword arguments. Positional arguments are always processed before keyword arguments.If the first positional argument is None, an empty sequence is returned.If the first positional argument is a callable object, the object will be called for every vertex in the sequence. If it returns True, the vertex will be included, otherwise it will be excluded.If the first positional argument is an iterable, it must return integers and they will be considered as indices of the current vertex set (NOT the whole vertex set of the graph -- the difference matters when one filters a vertex set that has already been filtered by a previous invocation of VertexSeq.select(). In this case, the indices do not refer directly to the vertices of the graph but to the elements of the filtered vertex sequence.If the first positional argument is an integer, all remaining arguments are expected to be integers. They are considered as indices of the current vertex set again.\nKeyword arguments can be used to filter the vertices based on their attributes. The name of the keyword specifies the name of the attribute and the filtering operator, they should be concatenated by an underscore (_) character. Attribute names can also contain underscores, but operator names don't, so the operator is always the largest trailing substring of the keyword name that does not contain an underscore. Possible operators are:eq: equal tone: not equal tolt: less thangt: greater thanle: less than or equal toge: greater than or equal toin: checks if the value of an attribute is in a given listnotin: checks if the value of an attribute is not in a given list\nFor instance, if you want to filter vertices with a numeric age property larger than 200, you have to write:",
    "igraph: Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n. Inherited from VertexSeq:Returns the attribute name list of the graph's vertices",
    "igraph: Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n. Inherited from VertexSeq:Returns the value of a given vertex attribute for all vertices in a list.",
    "igraph: Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n. Inherited from VertexSeq:Sets the value of a given vertex attribute for all vertices",
    "igraph: Abstract class that serves as a base class for anything that draws an igraph object.. overridden in igraph.drawing.baseclasses.AbstractGraphDrawer, igraph.drawing.baseclasses.AbstractVertexDrawer, igraph.drawing.cairo.coord.CoordinateSystem, igraph.drawing.cairo.dendrogram.CairoDendrogramDrawer, igraph.drawing.cairo.graph.CairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer, igraph.drawing.cairo.polygon.CairoPolygonDrawer, igraph.drawing.cairo.text.CairoTextDrawer, igraph.drawing.cairo.vertex.CairoVertexDrawer, igraph.drawing.graph.CytoscapeGraphDrawer, igraph.drawing.matplotlib.dendrogram.MatplotlibDendrogramDrawer, igraph.drawing.matplotlib.histogram.MatplotlibHistogramDrawer, igraph.drawing.matplotlib.matrix.MatplotlibMatrixDrawer, igraph.drawing.matplotlib.palette.MatplotlibPaletteDrawer\nAbstract method, must be implemented in derived classes.",
    "igraph: Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n. Returns the list of edge attribute names",
    "igraph: Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n. Returns a dict of attribute names and values for the edge",
    "igraph: Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n. Proxy method to Graph.count_multiple()\nThis method calls the count_multiple method of the Graph class with this edge as the first argument, and returns the result.",
    "igraph: Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n. Proxy method to Graph.delete_edges()\nThis method calls the delete_edges method of the Graph class with this edge as the first argument, and returns the result.",
    "igraph: Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n. Proxy method to Graph.is_loop()\nThis method calls the is_loop method of the Graph class with this edge as the first argument, and returns the result.",
    "igraph: Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n. Proxy method to Graph.is_multiple()\nThis method calls the is_multiple method of the Graph class with this edge as the first argument, and returns the result.",
    "igraph: Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n. Proxy method to Graph.is_mutual()\nThis method calls the is_mutual method of the Graph class with this edge as the first argument, and returns the result.",
    "igraph: Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n. Updates the attributes of the edge from dict/iterable E and F.\nIf E has a keys() method, it does: for k in E: self[k] = E[k]. If E lacks a keys() method, it does: for (k, v) in E: self[k] = v. In either case, this is followed by: for k in F: self[k] = F[k].\nThis method thus behaves similarly to the update() method of Python dictionaries.",
    "igraph: Metaclass for attribute collector classes\nClasses that use this metaclass are intended to collect vertex/edge attributes from various sources (a Python dict, a vertex/edge sequence, default values from the igraph configuration and such) in a given order of precedence. See the module documentation for more details. This metaclass enables the user to use a simple declarative syntax to specify which attributes he is interested in. For each vertex/edge attribute, a corresponding class attribute must be defined with a value that describes the default value of that attribute if no other data source provides us with any suitable value. The default value can also be a tuple; in that case, the first element of the tuple is the actual default value, the second element is a converter function that will convert the attribute values to a format expected by the caller who uses the class being defined.\nThere is a special class attribute called _kwds_prefix; this is not used as an attribute declaration. It can contain a string which will be used to derive alternative names for the attributes when the attribute is accessed in a Python dict. This is useful in many situations; for instance, the default graph drawer would want to access the vertex colors using the color vertex attribute, but when it looks at the keyword arguments passed to the original call of igraph.Graph.__plot__, the vertex_color keyword argument should be looked up because we also have colors for the edges. _kwds_prefix will be prepended to the attribute names when they are looked up in a dict of keyword arguments.\nIf you require a more fine-tuned behaviour, you can assign an AttributeSpecification instance to a class attribute directly.See AlsoAttributeCollectorBase. Generates a simple class that has the given slots and nothing else",
    "igraph: Metaclass for attribute collector classes\nClasses that use this metaclass are intended to collect vertex/edge attributes from various sources (a Python dict, a vertex/edge sequence, default values from the igraph configuration and such) in a given order of precedence. See the module documentation for more details. This metaclass enables the user to use a simple declarative syntax to specify which attributes he is interested in. For each vertex/edge attribute, a corresponding class attribute must be defined with a value that describes the default value of that attribute if no other data source provides us with any suitable value. The default value can also be a tuple; in that case, the first element of the tuple is the actual default value, the second element is a converter function that will convert the attribute values to a format expected by the caller who uses the class being defined.\nThere is a special class attribute called _kwds_prefix; this is not used as an attribute declaration. It can contain a string which will be used to derive alternative names for the attributes when the attribute is accessed in a Python dict. This is useful in many situations; for instance, the default graph drawer would want to access the vertex colors using the color vertex attribute, but when it looks at the keyword arguments passed to the original call of igraph.Graph.__plot__, the vertex_color keyword argument should be looked up because we also have colors for the edges. _kwds_prefix will be prepended to the attribute names when they are looked up in a dict of keyword arguments.\nIf you require a more fine-tuned behaviour, you can assign an AttributeSpecification instance to a class attribute directly.See AlsoAttributeCollectorBase. Undocumented",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Returns whether there are any items associated to the givenkey.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Removes all the items associated to the given key.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Returns an arbitrary item associated to the given key. Raises KeyErrorif no such key exists.\nExample:>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])>>> d[\"spam\"]'eggs'",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Undocumented",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Iterates over the keys of the multidict.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Returns the number of distinct keys in this multidict.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Sets the item associated to the given key. Any values associated to thekey will be erased and replaced by value.\nExample:>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])>>> d[\"spam\"] = \"ham\">>> d[\"spam\"]'ham'",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Adds value to the list of items associated to key.\nExample:>>> d = multidict()>>> d.add(\"spam\", \"ham\")>>> d[\"spam\"]'ham'>>> d.add(\"spam\", \"eggs\")>>> d.getlist(\"spam\")['ham', 'eggs']",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Removes all the items from the multidict.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Returns an arbitrary item associated to the given key. If keydoes not exist or has zero associated items, default will bereturned.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Returns the list of values for the given key. An empty list willbe returned if there is no such key.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Iterates over (key, values) pairs where values is the listof values associated with key.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Returns a list of (key, values) pairs where values is the listof values associated with key.",
    "igraph: A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.. Undocumented",
    "igraph: IPython embedded shell interface.\nThis class allows igraph to be embedded in IPython's interactive shell.. overrides igraph.app.shell.Shell.__call__\nStarts the embedded shell.",
    "igraph: IPython embedded shell interface.\nThis class allows igraph to be embedded in IPython's interactive shell.. overrides igraph.app.shell.ConsoleProgressBarMixin.__init__\nConstructor.\nImports IPython's embedded shell with separator lines removed.",
    "igraph: IPython embedded shell interface.\nThis class allows igraph to be embedded in IPython's interactive shell.. Inherited from Shell:Returns the progress handler (if exists) or None (if not).",
    "igraph: IPython embedded shell interface.\nThis class allows igraph to be embedded in IPython's interactive shell.. Inherited from Shell:Returns the status handler (if exists) or None (if not).",
    "igraph: IPython embedded shell interface.\nThis class allows igraph to be embedded in IPython's interactive shell.. Inherited from Shell:Checks whether the shell supports progress bars.",
    "igraph: IPython embedded shell interface.\nThis class allows igraph to be embedded in IPython's interactive shell.. Inherited from Shell:Checks whether the shell supports status messages.",
    "igraph: Graph drawer that uses a pyplot.Axes as context. Constructs the graph drawer and associates it with the plotly Figure",
    "igraph: Graph drawer that uses a pyplot.Axes as context. overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
    "igraph: Class implementing a coordinate system object.\nCoordinate system objects are used when drawing plots which 2D or 3D coordinate system axes. This is an abstract class which must be extended in order to use it. In general, you'll only need the documentation of this class if you intend to implement an own coordinate system not present in igraph yet.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the coordinate system.\nThis method must be overridden in derived classes.",
    "igraph: Class implementing a coordinate system object.\nCoordinate system objects are used when drawing plots which 2D or 3D coordinate system axes. This is an abstract class which must be extended in order to use it. In general, you'll only need the documentation of this class if you intend to implement an own coordinate system not present in igraph yet.. overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem\nConverts local coordinates to the context coordinate system (given by the bounding box).\nThis method must be overridden in derived classes.",
    "igraph: Class implementing a coordinate system object.\nCoordinate system objects are used when drawing plots which 2D or 3D coordinate system axes. This is an abstract class which must be extended in order to use it. In general, you'll only need the documentation of this class if you intend to implement an own coordinate system not present in igraph yet.. Inherited from AbstractCairoDrawer:Constructs the drawer and associates it to the given Cairo context and the given BoundingBox.",
    "igraph: Class implementing a coordinate system object.\nCoordinate system objects are used when drawing plots which 2D or 3D coordinate system axes. This is an abstract class which must be extended in order to use it. In general, you'll only need the documentation of this class if you intend to implement an own coordinate system not present in igraph yet.. Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.",
    "igraph: Class that is used to draw polygons in Cairo.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property.. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs a new polygon drawer that draws on the given Cairo context.",
    "igraph: Class that is used to draw polygons in Cairo.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the polygon using the current stroke of the Cairo context.",
    "igraph: Class that is used to draw polygons in Cairo.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property.. Sets up a Cairo path for the outline of a polygon on the given Cairo context.",
    "igraph: Class that is used to draw polygons in Cairo.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property.. Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.",
    "igraph: Class that produces JSON event objects that stream an igraph graph to Gephi using the Gephi Graph Streaming API.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamer with the appropriate URL where Gephi is listening.\n. Constructs a Gephi graph streamer that will post graphs to agiven file-like object or a Gephi connection.\nencoder must either be None or an instance of json.JSONEncoderand it must contain the JSON encoder to be used when posting JSON objects.",
    "igraph: Class that produces JSON event objects that stream an igraph graph to Gephi using the Gephi Graph Streaming API.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamer with the appropriate URL where Gephi is listening.\n. Iterates over the JSON objects that build up the graph using theGephi graph streaming API. The objects returned from this function arePython objects; they must be formatted with json.dumps beforesending them to the destination.",
    "igraph: Class that produces JSON event objects that stream an igraph graph to Gephi using the Gephi Graph Streaming API.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamer with the appropriate URL where Gephi is listening.\n. Posts the given graph to the destination of the streamer using thegiven JSON encoder. When encoder is None, it falls back to thedefault JSON encoder of the streamer in the encoder property.\ndestination must be a file-like object or an instance ofGephiConnection.",
    "igraph: Class that produces JSON event objects that stream an igraph graph to Gephi using the Gephi Graph Streaming API.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamer with the appropriate URL where Gephi is listening.\n. Sends a single JSON event to the given destination using the givenJSON encoder.  When encoder is None, it falls back to thedefault JSON encoder of the streamer in the encoder property.\ndestination must be a file-like object or an instance ofGephiConnection.\nThe method flushes the destination after sending the event. If you wantto avoid this (e.g., because you are sending many events), setflush to False.",
    "igraph: Collection of vertex patches for plotting.\nThis class takes additional keyword arguments compared to PatchCollection:Parametersvertex_builderA list of vertex builders to construct the visual vertices. This is updated if the size of the vertices is changed.size_callbackA function to be triggered after vertex sizes are changed. Typically this redraws the edges.. Undocumented",
    "igraph: Collection of vertex patches for plotting.\nThis class takes additional keyword arguments compared to PatchCollection:Parametersvertex_builderA list of vertex builders to construct the visual vertices. This is updated if the size of the vertices is changed.size_callbackA function to be triggered after vertex sizes are changed. Typically this redraws the edges.. Get vertex sizes.\nIf width and height are unequal, get the largest of the two.",
    "igraph: Collection of vertex patches for plotting.\nThis class takes additional keyword arguments compared to PatchCollection:Parametersvertex_builderA list of vertex builders to construct the visual vertices. This is updated if the size of the vertices is changed.size_callbackA function to be triggered after vertex sizes are changed. Typically this redraws the edges.. Same as get_size.",
    "igraph: Collection of vertex patches for plotting.\nThis class takes additional keyword arguments compared to PatchCollection:Parametersvertex_builderA list of vertex builders to construct the visual vertices. This is updated if the size of the vertices is changed.size_callbackA function to be triggered after vertex sizes are changed. Typically this redraws the edges.. Set vertex sizes.\nThis rescales the current vertex symbol/path linearly, using this value as the largest of width and height.",
    "igraph: Collection of vertex patches for plotting.\nThis class takes additional keyword arguments compared to PatchCollection:Parametersvertex_builderA list of vertex builders to construct the visual vertices. This is updated if the size of the vertices is changed.size_callbackA function to be triggered after vertex sizes are changed. Typically this redraws the edges.. Same as set_size.",
    "igraph: Collection of vertex patches for plotting.\nThis class takes additional keyword arguments compared to PatchCollection:Parametersvertex_builderA list of vertex builders to construct the visual vertices. This is updated if the size of the vertices is changed.size_callbackA function to be triggered after vertex sizes are changed. Typically this redraws the edges.. Undocumented",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges as tapered lines that are wider at the source and narrow at the destination.. overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges as tapered lines that are wider at the source and narrow at the destination.. Inherited from AbstractCairoEdgeDrawer:Constructs the edge drawer.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges as tapered lines that are wider at the source and narrow at the destination.. Inherited from AbstractCairoEdgeDrawer:Draws a loop edge.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges as tapered lines that are wider at the source and narrow at the destination.. Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge.",
    "igraph: Class representing a rectangle.. Undocumented",
    "igraph: Class representing a rectangle.. Undocumented",
    "igraph: Class representing a rectangle.. Undocumented",
    "igraph: Class representing a rectangle.. Creates a rectangle.\nThe corners of the rectangle can be specified by either a tuple (four items, two for each corner, respectively), four separate numbers (X and Y coordinates for each corner) or two separate numbers (width and height, the upper left corner is assumed to be at (0,0))",
    "igraph: Class representing a rectangle.. overridden in igraph.drawing.utils.BoundingBox\nExpands this rectangle to include itself and another completely while still being as small as possible.\nExample:",
    "igraph: Class representing a rectangle.. Undocumented",
    "igraph: Class representing a rectangle.. Undocumented",
    "igraph: Class representing a rectangle.. Sets the Y coordinate of the bottom edge of the box",
    "igraph: Class representing a rectangle.. Contracts the rectangle by the given margins.",
    "igraph: Class representing a rectangle.. Sets the coordinates of the corners.",
    "igraph: Class representing a rectangle.. Expands the rectangle by the given margins.",
    "igraph: Class representing a rectangle.. Sets the height of the rectangle by adjusting the bottom edge.",
    "igraph: Class representing a rectangle.. Returns the intersection of this rectangle with another.\nExample:",
    "igraph: Class representing a rectangle.. Returns True if the two rectangles have no intersection.\nExample:",
    "igraph: Class representing a rectangle.. Returns True if the rectangle is empty (i.e. it has zero width and height).\nExample:",
    "igraph: Class representing a rectangle.. Sets the X coordinate of the left side of the box",
    "igraph: Class representing a rectangle.. Moves the center of the box to the given X coordinate",
    "igraph: Class representing a rectangle.. Moves the center of the box to the given Y coordinate",
    "igraph: Class representing a rectangle.. Sets the X coordinate of the right side of the box",
    "igraph: Class representing a rectangle.. Sets the shape of the rectangle (width, height).",
    "igraph: Class representing a rectangle.. Sets the Y coordinate of the top edge of the box",
    "igraph: Class representing a rectangle.. Translates the rectangle in-place.\nExample:",
    "igraph: Class representing a rectangle.. Returns the union of this rectangle with another.\nThe resulting rectangle is the smallest rectangle that contains both rectangles.\nExample:",
    "igraph: Class representing a rectangle.. Sets the width of the rectangle by adjusting the right edge.",
    "igraph: Abstract edge drawer object from which all concrete edge drawer implementations are derived.. overridden in igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer, igraph.drawing.cairo.edge.CairoArrowEdgeDrawer, igraph.drawing.cairo.edge.TaperedEdgeDrawer, igraph.drawing.matplotlib.edge.MatplotlibEdgeDrawer, igraph.drawing.plotly.edge.PlotlyEdgeDrawer\nDraws a directed edge.",
    "igraph: Abstract edge drawer object from which all concrete edge drawer implementations are derived.. overridden in igraph.drawing.cairo.edge.AbstractCairoEdgeDrawer, igraph.drawing.matplotlib.edge.MatplotlibEdgeDrawer, igraph.drawing.plotly.edge.PlotlyEdgeDrawer\nDraws an undirected edge.",
    "igraph: Abstract edge drawer object from which all concrete edge drawer implementations are derived.. Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.",
    "igraph: Abstract edge drawer object from which all concrete edge drawer implementations are derived.. Get the rotation angle of the label to align with the edge.",
    "igraph: Default Cairo drawer object for matrices.. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
    "igraph: Default Cairo drawer object for matrices.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a Cairo context.",
    "igraph: Default Cairo drawer object for matrices.. Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Creates a matrix filled with the given value",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Creates an identity matrix.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Creates a matrix filled with zeros.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Adds the given value to the matrix.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Checks whether a given matrix is equal to another one",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Returns a single item, a row or a column of the matrix",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Returns a hash value for a matrix.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. In-place addition of a matrix or scalar.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Initializes a matrix.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. In-place subtraction of a matrix or scalar.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Support for iteration.\nThis is actually implemented as a generator, so there is no need for a separate iterator class. The generator returns copies of the rows in the matrix as lists to avoid messing around with the internals. Feel free to do anything with the copies, the changes won't be reflected in the original matrix.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Returns the number of rows in the matrix.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Checks whether a given matrix is not equal to another one",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Plots the matrix to the given Cairo context or matplotlib Axes.\nBesides the usual self-explanatory plotting parameters (context, bbox, palette), it accepts the following keyword arguments:style: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the matrix are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the matrix should be square or not. Default is True.grid_width: line width of the grid shown on the matrix. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the matrix. If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the matrix being plotted. If it is another matrix, the values of that matrix are shown in the cells. In this case, the shape of the value matrix must match the shape of the matrix being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.\nIf only the row names or the column names are given and the matrix is square-shaped, the same names are used for both column and row names.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Undocumented",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Sets a single item, a row or a column of the matrix",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Undocumented",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Subtracts the given value from the matrix.",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Returns the maximum of the matrix along the given dimension",
    "igraph: Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).. Returns the minimum of the matrix along the given dimension",
    "igraph: Undocumented. Undocumented",
    "igraph: Undocumented. Undocumented",
    "igraph: Undocumented. Get arrow sizes for the edges (directed only).",
    "igraph: Undocumented. Same as get_arrow_size.",
    "igraph: Undocumented. Get arrow widths for the edges (directed only).",
    "igraph: Undocumented. Same as get_arrow_width.",
    "igraph: Undocumented. Set arrow sizes.",
    "igraph: Undocumented. Same as set_arrow_size",
    "igraph: Undocumented. Set arrow widths.",
    "igraph: Undocumented. Same as set_arrow_width",
    "igraph: Undocumented. Undocumented",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Undocumented",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Undocumented",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Undocumented",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Constructor.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Undocumented",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Undocumented",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Undocumented",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Appends a new point to the layout",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Returns the boundaries of the layout.\nThe boundaries are the minimum and maximum coordinates along all dimensions.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Returns the bounding box of the layout.\nThe bounding box of the layout is the smallest box enclosing all the points in the layout.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Centers the layout around the given point.\nThe point itself can be supplied as multiple unnamed arguments, as a simple unnamed list or as a keyword argument. This operation moves the centroid of the layout to the given point. If no point is supplied, defaults to the origin of the coordinate system.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Returns the centroid of the layout.\nThe centroid of the layout is the arithmetic mean of the points in the layout.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Creates an exact copy of the layout.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Fits the layout into the given bounding box.\nThe layout will be modified in-place.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Mirrors the layout along the given dimension(s)",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Rotates the layout by the given degrees on the plane defined by the given two dimensions.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Scales the layout.\nScaling parameters can be provided either through the scale keyword argument or through plain unnamed arguments. If a single integer or float is given, it is interpreted as a uniform multiplier to be applied on all dimensions. If it is a list or tuple, its length must be equal to the number of dimensions in the layout, and each element must be an integer or float describing the scaling coefficient in one of the dimensions.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Converts a planar layout to a radial one\nThis method applies only to 2D layouts. The X coordinate of the layout is transformed to an angle, with min(x) corresponding to the parameter called min_angle and max(y) corresponding to max_angle. Angles are given in degrees, zero degree corresponds to the direction pointing upwards. The Y coordinate is interpreted as a radius, with min(y) belonging to the minimum and max(y) to the maximum radius given in the arguments.\nThis is not a fully generic polar coordinate transformation, but it is fairly useful in creating radial tree layouts from ordinary top-down ones (that's why the Y coordinate belongs to the radius). It can also be used in conjunction with the Fruchterman-Reingold layout algorithm via its miny and maxy parameters (see Graph.layout_fruchterman_reingold()) to produce radial layouts where the radius belongs to some property of the vertices.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Performs an arbitrary transformation on the layout\nAdditional positional and keyword arguments are passed intact to the given function.",
    "igraph: Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n. Translates the layout.\nThe translation vector can be provided either through the v keyword argument or through plain unnamed arguments. If unnamed arguments are used, the vector can be supplied as a single list (or tuple) or just as a series of arguments. In all cases, the translation vector must have the same number of dimensions as the layout.",
    "igraph: A 2-line progress bar.\n. Undocumented",
    "igraph: A 2-line progress bar.\n. Clears the progress bar (i.e. removes it from the screen)",
    "igraph: A 2-line progress bar.\n. Updates the progress bar.",
    "igraph: A 2-line progress bar.\n. Updates the message of the progress bar.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. overrides igraph.drawing.utils.Rectangle.__ior__\nReplaces this bounding box with the union of itself and another.\nExample:",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Takes the union of this bounding box with another.\nThe result is a bounding box which encloses both bounding boxes.\nExample:",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Undocumented",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Undocumented",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Undocumented",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Creates a rectangle.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Undocumented",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Undocumented",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Sets the Y coordinate of the bottom edge of the box",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Contracts the rectangle by the given margins.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Sets the coordinates of the corners.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Expands the rectangle by the given margins.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Sets the height of the rectangle by adjusting the bottom edge.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Returns the intersection of this rectangle with another.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Returns True if the two rectangles have no intersection.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Returns True if the rectangle is empty (i.e. it has zero width and height).",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Sets the X coordinate of the left side of the box",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Moves the center of the box to the given X coordinate",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Moves the center of the box to the given Y coordinate",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Sets the X coordinate of the right side of the box",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Sets the shape of the rectangle (width, height).",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Sets the Y coordinate of the top edge of the box",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Translates the rectangle in-place.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Returns the union of this rectangle with another.",
    "igraph: Class representing a bounding box (a rectangular area) that encloses some objects.. Inherited from Rectangle:Sets the width of the rectangle by adjusting the right edge.",
    "igraph: Graph drawer that sends a graph to a file-like object (e.g., socket, URL connection, file) using the Gephi graph streaming format.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamingDrawer with the appropriate URL where Gephi is listening.\nThe connection property exposes the GephiConnection that the drawer uses. The drawer also has a property called streamer which exposes the underlying GephiGraphStreamer that is responsible for generating the JSON objects, encoding them and writing them to a file-like object. If you want to customize the encoding process, this is the object where you can tweak things to your taste.. Constructs a Gephi graph streaming drawer that will post graphs to the given Gephi connection. If conn is None, the remaining arguments of the constructor are forwarded intact to the constructor of GephiConnection in order to create a connection. This means that any of the following are valid:GephiGraphStreamingDrawer() will construct a drawer that connects to workspace 0 of the local Gephi instance on port 8080.GephiGraphStreamingDrawer(workspace=2) will connect to workspace 2 of the local Gephi instance on port 8080.GephiGraphStreamingDrawer(port=1234) will connect to workspace 0 of the local Gephi instance on port 1234.GephiGraphStreamingDrawer(host=\"remote\", port=1234, workspace=7) will connect to workspace 7 of the Gephi instance on host remote, port 1234.GephiGraphStreamingDrawer(url=\"http://remote:1234/workspace7) is the same as above, but with an explicit URL.",
    "igraph: Graph drawer that sends a graph to a file-like object (e.g., socket, URL connection, file) using the Gephi graph streaming format.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamingDrawer with the appropriate URL where Gephi is listening.\nThe connection property exposes the GephiConnection that the drawer uses. The drawer also has a property called streamer which exposes the underlying GephiGraphStreamer that is responsible for generating the JSON objects, encoding them and writing them to a file-like object. If you want to customize the encoding process, this is the object where you can tweak things to your taste.. overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nDraws (i.e. sends) the given graph to the destination of the drawer using the Gephi graph streaming API.\nThe following keyword arguments are allowed:encoder lets one specify an instance of json.JSONEncoder that will be used to encode the JSON objects.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. overrides igraph.Cover.__init__\nCreates a cover object for a given graph.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. overridden in igraph.CohesiveBlocks\nPlots the cover to the given Cairo context or matplotlib Axes.\nThis is done by calling Graph.__plot__() with the same arguments, but drawing nice colored blobs around the vertex groups.\nThis method understands all the positional and keyword arguments that are understood by Graph.__plot__(), only the differences will be highlighted here:mark_groups: whether to highlight the vertex clusters by colored polygons. Besides the values accepted by Graph.__plot__ (i.e., a dict mapping colors to vertex indices, a list containing lists of vertex indices, or False), the following are also accepted:True: all the clusters will be highlighted, the colors matching the corresponding color indices from the current palette (see the palette keyword argument of Graph.__plot__).A dict mapping cluster indices or tuples of vertex indices to color names.  The given clusters or vertex groups will be highlighted by the given colors.A list of cluster indices. This is equivalent to passing a dict mapping numeric color indices from the current palette to cluster indices; therefore, the cluster referred to by element i of the list will be highlighted by color i from the palette.The value of the plotting.mark_groups configuration key is also taken into account here; if that configuration key is True and mark_groups is not given explicitly, it will automatically be set to True.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.palette: the palette used to resolve numeric color indices to RGBA values. By default, this is an instance of ClusterColoringPalette.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Get the subgraph belonging to a given cluster.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Gets all the subgraphs belonging to each of the clusters.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Inherited from Cover:Returns the cluster with the given index.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Inherited from Cover:Iterates over the clusters in this cover.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Inherited from Cover:Returns the number of clusters in this cover.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Inherited from Cover:Returns a string representation of the cover.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Inherited from Cover:Returns the size of a given cluster.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Inherited from Cover:Returns the histogram of cluster sizes.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Inherited from Cover:Returns the size of given clusters.",
    "igraph: The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.. Inherited from Cover:Returns the summary of the cover.",
    "igraph: Class representing a point on the 2D plane.. Constructs a point from polar coordinates.\nradius is the distance of the point from the origin; angle is the angle between the X axis and the vector pointing to the point from the origin.",
    "igraph: Class representing a point on the 2D plane.. Adds the coordinates of a point to another one",
    "igraph: Class representing a point on the 2D plane.. Divides the coordinates by a scalar",
    "igraph: Class representing a point on the 2D plane.. Multiplies the coordinates by a scalar",
    "igraph: Class representing a point on the 2D plane.. Subtracts the coordinates of a point to another one",
    "igraph: Class representing a point on the 2D plane.. Returns the polar coordinate representation of the point.",
    "igraph: Class representing a point on the 2D plane.. Returns the distance of the point from another one.\nExample:",
    "igraph: Class representing a point on the 2D plane.. Linearly interpolates between the coordinates of this point and another one.",
    "igraph: Class representing a point on the 2D plane.. Returns the length of the vector pointing from the origin to this point.",
    "igraph: Class representing a point on the 2D plane.. Normalizes the coordinates of the point s.t. its length will be 1 after normalization. Returns the normalized point.",
    "igraph: Class representing a point on the 2D plane.. Returns the squared length of the vector pointing from the origin to this point.",
    "igraph: Class representing a point on the 2D plane.. Returns the point that is at a given distance from this point towards another one.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges by varying the alpha value of the specified edge color between the source and the destination.. overrides igraph.drawing.cairo.edge.AbstractCairoEdgeDrawer.__init__\nConstructs the edge drawer.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges by varying the alpha value of the specified edge color between the source and the destination.. overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges by varying the alpha value of the specified edge color between the source and the destination.. Inherited from AbstractCairoEdgeDrawer:Draws a loop edge.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges by varying the alpha value of the specified edge color between the source and the destination.. Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge.",
    "igraph: Default Cairo drawer object for palettes. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
    "igraph: Default Cairo drawer object for palettes. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nTODO",
    "igraph: Default Cairo drawer object for palettes. Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.",
    "igraph: Default Cairo drawer object for histograms. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
    "igraph: Default Cairo drawer object for histograms. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nTODO",
    "igraph: Default Cairo drawer object for histograms. Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.",
    "igraph: IDLE embedded shell interface.\nThis class allows igraph to be embedded in IDLE (the Tk Python IDE).. overrides igraph.app.shell.Shell.__call__\nStarts the shell",
    "igraph: IDLE embedded shell interface.\nThis class allows igraph to be embedded in IDLE (the Tk Python IDE).. Constructor.\nImports IDLE's embedded shell. The implementation of this method is ripped from idlelib.PyShell.main() after removing the unnecessary parts.",
    "igraph: IDLE embedded shell interface.\nThis class allows igraph to be embedded in IDLE (the Tk Python IDE).. Inherited from Shell:Returns the progress handler (if exists) or None (if not).",
    "igraph: IDLE embedded shell interface.\nThis class allows igraph to be embedded in IDLE (the Tk Python IDE).. Inherited from Shell:Returns the status handler (if exists) or None (if not).",
    "igraph: IDLE embedded shell interface.\nThis class allows igraph to be embedded in IDLE (the Tk Python IDE).. Inherited from Shell:Checks whether the shell supports progress bars.",
    "igraph: IDLE embedded shell interface.\nThis class allows igraph to be embedded in IDLE (the Tk Python IDE).. Inherited from Shell:Checks whether the shell supports status messages.",
    "igraph: Class implementing a 2D Descartes coordinate system object.. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nInitializes the coordinate system.",
    "igraph: Class implementing a 2D Descartes coordinate system object.. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.bbox.setter\nSets the bounding box of the coordinate system",
    "igraph: Class implementing a 2D Descartes coordinate system object.. Sets the lower and upper bounds of the X and Y values",
    "igraph: Class implementing a 2D Descartes coordinate system object.. overrides igraph.drawing.cairo.coord.CoordinateSystem.draw\nDraws the coordinate system.",
    "igraph: Class implementing a 2D Descartes coordinate system object.. overrides igraph.drawing.cairo.coord.CoordinateSystem.local_to_context\nConverts local coordinates to the context coordinate system (given by the bounding box).",
    "igraph: The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.. overrides igraph.Dendrogram.__init__\nCreates a dendrogram object for a given graph.",
    "igraph: The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.. overrides igraph.Dendrogram.__plot__\nDraws the vertex dendrogram on the given Cairo context or matplotlib Axes\nSee Dendrogram.__plot__ for the list of supported keyword arguments.",
    "igraph: The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.. Cuts the dendrogram at the given level and returns a corresponding VertexClustering object.",
    "igraph: The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.. Undocumented",
    "igraph: The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.. Inherited from Dendrogram:Undocumented",
    "igraph: The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.. Inherited from Dendrogram:Formats the dendrogram in a foreign format.",
    "igraph: The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.. Inherited from Dendrogram:Sets the names of the nodes in the dendrogram",
    "igraph: The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.. Inherited from Dendrogram:Returns the summary of the dendrogram.",
    "igraph: Object that implements the Gephi graph streaming API format and returns Python objects corresponding to the events defined in the API.. Generates a Python object corresponding to the event that adds an edgewith the given source, target, directednessr and attributes in the Gephigraph streaming API.",
    "igraph: Object that implements the Gephi graph streaming API format and returns Python objects corresponding to the events defined in the API.. Generates a Python object corresponding to the event that adds a nodewith the given identifier and attributes in the Gephi graph streaming API.\nExample:",
    "igraph: Object that implements the Gephi graph streaming API format and returns Python objects corresponding to the events defined in the API.. Generates a Python object corresponding to the event that changes theattributes of some edge in the Gephi graph streaming API. The given attributesare merged into the existing ones; use C{None} as the attribute value todelete a given attribute.\nExample:",
    "igraph: Object that implements the Gephi graph streaming API format and returns Python objects corresponding to the events defined in the API.. Generates a Python object corresponding to the event that changes theattributes of some node in the Gephi graph streaming API. The given attributesare merged into the existing ones; use C{None} as the attribute value todelete a given attribute.\nExample:",
    "igraph: Object that implements the Gephi graph streaming API format and returns Python objects corresponding to the events defined in the API.. Generates a Python object corresponding to the event that deletes anedge with the given identifier in the Gephi graph streaming API.\nExample:",
    "igraph: Object that implements the Gephi graph streaming API format and returns Python objects corresponding to the events defined in the API.. Generates a Python object corresponding to the event that deletes anode with the given identifier in the Gephi graph streaming API.\nExample:",
    "igraph: Cairo-specific abstract edge drawer object.. overridden in igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer\nConstructs the edge drawer.",
    "igraph: Cairo-specific abstract edge drawer object.. Draws a loop edge.\nThe default implementation draws a small circle.",
    "igraph: Cairo-specific abstract edge drawer object.. overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nThe default implementation of this method draws undirected edges as straight lines. Loop edges are drawn as small circles.",
    "igraph: Cairo-specific abstract edge drawer object.. Inherited from AbstractEdgeDrawer:Draws a directed edge.",
    "igraph: Cairo-specific abstract edge drawer object.. Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.",
    "igraph: Cairo-specific abstract edge drawer object.. Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge.",
    "igraph: A palette that returns colors from a pre-calculated list of colors. overrides igraph.drawing.colors.Palette.__init__\nCreates the palette backed by the given list. The list must contain RGBA quadruplets or color names, which will be resolved first by color_name_to_rgba(). Anything that is understood by color_name_to_rgba() is OK here.",
    "igraph: A palette that returns colors from a pre-calculated list of colors. Inherited from Palette:Returns the number of colors in this palette",
    "igraph: A palette that returns colors from a pre-calculated list of colors. Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes",
    "igraph: A palette that returns colors from a pre-calculated list of colors. Inherited from Palette:Undocumented",
    "igraph: A palette that returns colors from a pre-calculated list of colors. Inherited from Palette:Clears the result cache.",
    "igraph: A palette that returns colors from a pre-calculated list of colors. Inherited from Palette:Returns the given color from the palette.",
    "igraph: A palette that returns colors from a pre-calculated list of colors. Inherited from Palette:Returns multiple colors from the palette.",
    "igraph: Result of fitting a power-law to a vector of samples\n. Undocumented",
    "igraph: Result of fitting a power-law to a vector of samples\n. Undocumented",
    "igraph: Result of fitting a power-law to a vector of samples\n. Undocumented",
    "igraph: Result of fitting a power-law to a vector of samples\n. Returns the summary of the power law fit.",
    "igraph: Dyad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the names mutual (or mut), asymmetric (or asy or asym or asymm) and null.\n. Undocumented",
    "igraph: Dyad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the names mutual (or mut), asymmetric (or asy or asym or asymm) and null.\n. Undocumented",
    "igraph: Dyad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the names mutual (or mut), asymmetric (or asy or asym or asymm) and null.\n. Undocumented",
    "igraph: Dyad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the names mutual (or mut), asymmetric (or asy or asym or asymm) and null.\n. Undocumented",
    "igraph: Dyad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the names mutual (or mut), asymmetric (or asy or asym or asymm) and null.\n. Converts the dyad census to a dict using the known dyad names.",
    "igraph: Graph drawer that uses a pyplot.Axes as context. Constructs the graph drawer and associates it with the mpl Axes",
    "igraph: Graph drawer that uses a pyplot.Axes as context. overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
    "igraph: A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n. Checks whether item already has an ID or not.",
    "igraph: A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n. Retrieves the ID corresponding to item. Generates a new ID for item if it is the first time we request an ID for it.",
    "igraph: A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n. Creates a new unique ID generator. id_generator specifies how do we assign new IDs to elements that do not have an ID yet. If it is None, elements will be assigned integer identifiers starting from 0. If it is an integer, elements will be assigned identifiers starting from the given integer. If it is an iterator or generator, its next() method will be called every time a new ID is needed.",
    "igraph: A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n. Returns the number of items.",
    "igraph: A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n. Overrides the ID for item.",
    "igraph: A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n. Returns the reverse mapping, i.e., the one that maps from generated IDs to their corresponding objects",
    "igraph: A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n. Returns the values stored so far. If the generator generates items according to the standard sorting order, the values returned will be exactly in the order they were added. This holds for integer IDs for instance (but for many other ID generators as well).",
    "igraph: Static class which draws diamonds (i.e. rhombuses). overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a rhombus on the Cairo context without stroking or filling it.",
    "igraph: Static class which draws diamonds (i.e. rhombuses). overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the rhombus centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
    "igraph: Mixin class for console shells that support a progress bar.. overridden in igraph.app.shell.ClassicPythonShell, igraph.app.shell.IPythonShell\nUndocumented",
    "igraph: Static class which draws circular vertices. overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a circular path on the Cairo context without stroking or filling it.\nHeight is ignored, it is the width that determines the diameter of the circle.",
    "igraph: Static class which draws circular vertices. overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the circle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
    "igraph: Class that is used to draw polygons in matplotlib.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property.. Constructs a new polygon drawer that draws on the given Matplotlib axes.",
    "igraph: Class that is used to draw polygons in matplotlib.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property.. Draws a polygon to the associated axes.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. overrides igraph.VertexCover.__init__\nConstructs a new cohesive block structure for the given graph.\nIf any of blocks, cohesion or parent is None, all the arguments will be ignored and Graph.cohesive_blocks() will be called to calculate the cohesive blocks. Otherwise, these three variables should describe the *result* of a cohesive block structure calculation. Chances are that you never have to construct CohesiveBlocks instances directly, just use Graph.cohesive_blocks().",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. overrides igraph.VertexCover.__plot__\nPlots the cohesive block structure to the given Cairo context or matplotlib Axes.\nSince a CohesiveBlocks instance is also a VertexCover, keyword arguments accepted by VertexCover.__plot__() are also accepted here. The only difference is that the vertices are colored according to their maximal cohesions by default, and groups are marked by colored blobs except the last group which encapsulates the whole graph.\nSee the documentation of VertexCover.__plot__() for more details.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Returns the cohesion of the group with the given index.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Returns the list of cohesion values for each group.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Returns a new graph that describes the hierarchical relationships between the groups.\nThe new graph will be a directed tree; an edge will point from vertex i to vertex j if group i is a superset of group j. In other words, the edges point downwards.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Finds the maximum cohesion score among all the groups that contain the given vertex.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. For each vertex in the graph, returns the maximum cohesion score among all the groups that contain the vertex.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Returns the parent group index of the group with the given index or None if the given group is the root.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Returns the list of parent group indices for each group or None if the given group is the root.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Inherited from VertexCover:Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Inherited from VertexCover:Get the subgraph belonging to a given cluster.",
    "igraph: The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.. Inherited from VertexCover:Gets all the subgraphs belonging to each of the clusters.",
    "igraph: Abstract drawer that uses a remote service via XML-RPC to draw something on a remote display.. overridden in igraph.drawing.graph.CytoscapeGraphDrawer\nConstructs an abstract drawer using the XML-RPC service at the given URL.",
    "igraph: Abstract drawer that uses a remote service via XML-RPC to draw something on a remote display.. Inherited from AbstractDrawer:Abstract method, must be implemented in derived classes.",
    "igraph: Abstract class that serves as a base class for anything that draws an igraph.Graph.. Helper method that ensures that layout is an instance of Layout. If it is not, the method will try to convert it to a Layout according to the following rules:If layout is a string, it is assumed to be a name of an igraph layout, and it will be passed on to the layout method of the given graph if graph is not None.If layout is None and graph has a \"layout\" attribute, call this same function with the value of that attribute.If layout is None and graph does not have a \"layout\" attribute, the layout method of graph will be invoked with no parameters, which will call the default layout algorithm.Otherwise, layout will be passed on to the constructor of Layout. This handles lists of lists, lists of tuples and such.\nIf layout is already a Layout instance, it will still be copied and a copy will be returned. This is because graph drawers are allowed to transform the layout for their purposes, and we don't want the transformation to propagate back to the caller.",
    "igraph: Abstract class that serves as a base class for anything that draws an igraph.Graph.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nAbstract method, must be implemented in derived classes.",
    "igraph: Default Cairo drawer object for dendrograms.. overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the drawer and associates it to the given palette.",
    "igraph: Default Cairo drawer object for dendrograms.. overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Dendrogram in a Cairo context.",
    "igraph: Default Cairo drawer object for dendrograms.. Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges by using an alpha value of one (full opacity) at the source and an alpha value of zero (total transparency) at the destination. The alpha value is interpolated in-between.. overrides igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer.__init__\nConstructs the edge drawer.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges by using an alpha value of one (full opacity) at the source and an alpha value of zero (total transparency) at the destination. The alpha value is interpolated in-between.. Inherited from AlphaVaryingEdgeDrawer:Draws a directed edge.",
    "igraph: Static class that resolves shape names to their corresponding shape drawer classes.\nClasses that are derived from ShapeDrawer in this module are automatically registered by ShapeDrawerDirectory when the module is loaded for the first time.. Registers the given shape drawer class under the given names.",
    "igraph: Static class that resolves shape names to their corresponding shape drawer classes.\nClasses that are derived from ShapeDrawer in this module are automatically registered by ShapeDrawerDirectory when the module is loaded for the first time.. Registers all ShapeDrawer classes in the given namespace",
    "igraph: Static class that resolves shape names to their corresponding shape drawer classes.\nClasses that are derived from ShapeDrawer in this module are automatically registered by ShapeDrawerDirectory when the module is loaded for the first time.. Given a shape name, returns the corresponding shape drawer class",
    "igraph: Static class that resolves shape names to their corresponding shape drawer classes.\nClasses that are derived from ShapeDrawer in this module are automatically registered by ShapeDrawerDirectory when the module is loaded for the first time.. Given a shape name, returns the corresponding shape drawer class or the given default shape drawer if the shape name is unknown.",
    "igraph: Plotly backend-specific vertex drawer.. overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
    "igraph: Plotly backend-specific vertex drawer.. overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nDraws the given vertex.",
    "igraph: Plotly backend-specific vertex drawer.. Undocumented",
    "igraph: A flow of a given graph.\nThis is a simple class used to represent flows returned by Graph.maxflow. It has the following attributes: graph - the graph on which this flow is defined value - the value (capacity) of the flow flow - the flow values on each edge. For directed graphs, this is simply a list where element i corresponds to the flow on edge i. For undirected graphs, the direction of the flow is not constrained (since the edges are undirected), hence positive flow always means a flow from the smaller vertex ID to the larger, while negative flow means a flow from the larger vertex ID to the smaller. cut - edge IDs in the minimal cut corresponding to the flow. partition - vertex IDs in the parts created after removing edges in the cut es - an edge selector restricted to the edges in the cut. \nThis class is usually not instantiated directly, everything is taken care of by Graph.maxflow.\n. overrides igraph.Cut.__init__\nInitializes the flow.\nThis should not be called directly, everything is taken care of by Graph.maxflow.",
    "igraph: A flow of a given graph.\nThis is a simple class used to represent flows returned by Graph.maxflow. It has the following attributes: graph - the graph on which this flow is defined value - the value (capacity) of the flow flow - the flow values on each edge. For directed graphs, this is simply a list where element i corresponds to the flow on edge i. For undirected graphs, the direction of the flow is not constrained (since the edges are undirected), hence positive flow always means a flow from the smaller vertex ID to the larger, while negative flow means a flow from the larger vertex ID to the smaller. cut - edge IDs in the minimal cut corresponding to the flow. partition - vertex IDs in the parts created after removing edges in the cut es - an edge selector restricted to the edges in the cut. \nThis class is usually not instantiated directly, everything is taken care of by Graph.maxflow.\n. overrides igraph.Cut.__repr__\nUndocumented",
    "igraph: A flow of a given graph.\nThis is a simple class used to represent flows returned by Graph.maxflow. It has the following attributes: graph - the graph on which this flow is defined value - the value (capacity) of the flow flow - the flow values on each edge. For directed graphs, this is simply a list where element i corresponds to the flow on edge i. For undirected graphs, the direction of the flow is not constrained (since the edges are undirected), hence positive flow always means a flow from the smaller vertex ID to the larger, while negative flow means a flow from the larger vertex ID to the smaller. cut - edge IDs in the minimal cut corresponding to the flow. partition - vertex IDs in the parts created after removing edges in the cut es - an edge selector restricted to the edges in the cut. \nThis class is usually not instantiated directly, everything is taken care of by Graph.maxflow.\n. overrides igraph.Cut.__str__\nUndocumented",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.Adjacency\nGenerates a graph from its adjacency matrix.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Creates a bipartite graph from a bipartite adjacency matrix.\nExample:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a type attribute afterwards.\nExamples:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Generates a graph from one or two dataframes.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Constructs a graph from a dict-of-dicts representation.\nEach key can be an integer or a string and represent a vertex. Each value is a dict representing edges (outgoing if the graph is directed) from that vertex. Each dict key is an integer/string for a target vertex, such that an edge will be created between those two vertices. Integers are interpreted as vertex_ids from 0 (as used in igraph), strings are interpreted as vertex names, in which case vertices are given separate numeric ids. Each value is a dictionary of edge attributes for that edge.\nExample:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Constructs a graph from a list-of-dictionaries representation.\nThis function is useful when you have two lists of dictionaries, one for vertices and one for edges, each containing their attributes (e.g. name, weight). Of course, the edge dictionary must also contain two special keys that indicate the source and target vertices connected by that edge. Non-list iterables should work as long as they yield dictionaries or dict-like objects (they should have the 'items' and '__getitem__' methods). For instance, a database query result is likely to be fit as long as it's iterable and yields dict-like objects with every iteration.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Converts the graph from graph-tool",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Converts the graph from networkx\nVertex names will be stored as a vertex_attr_hashable attribute (usually \"_nx_name\", but see below). Because igraph stored vertices in an ordered manner, vertices will get new IDs from 0 up. In case of multigraphs, each edge will have an \"_nx_multiedge_key\" attribute, to distinguish edges that connect the same two vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Generates a full bipartite graph (directed or undirected, with or without loops).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Generates a random geometric graph.\nThe algorithm drops the vertices randomly on the 2D unit square and connects them if they are closer to each other than the given radius. The coordinates of the vertices are stored in the vertex attributes x and y.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Deprecated alias to Graph.Biadjacency().",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Constructs a graph from a dict-of-lists representation.\nThis function is used to construct a graph from a dictionary of lists. Other, non-list sequences (e.g. tuples) and lazy iterators are are accepted. For each key x, its corresponding value must be a sequence of multiple values y: the edge (x,y) will be created in the graph. x and y must be either one of:two integers: the vertices with those ids will be connectedtwo strings: the vertices with those names will be connected\nIf names are used, the order of vertices is not guaranteed, and each vertex will be given the vertex_name_attr attribute.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Generates a random bipartite graph with the given number of vertices and edges (if m is given), or with the given number of vertices and the given connection probability (if p is given).\nIf m is given but p is not, the generated graph will have n1 vertices of type 1, n2 vertices of type 2 and m randomly selected edges between them. If p is given but m is not, the generated graph will have n1 vertices of type 1 and n2 vertices of type 2, and each edge will exist between them with probability p.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Unified reading function for graphs.\nThis method tries to identify the format of the graph given in the first parameter and calls the corresponding reader method.\nThe remaining arguments are passed to the reader method without any changes.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Constructs a graph based on an adjacency matrix from the given file.\nAdditional positional and keyword arguments not mentioned here are passed intact to Graph.Adjacency.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.Read_DIMACS\nReads a graph from a file conforming to the DIMACS minimum-cost flow file format.\nFor the exact definition of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm.\nRestrictions compared to the official description of the format are as follows:igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.Node indices start from 1. Only a single source and target node is allowed.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Reads a graph from a zipped GraphML file.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Reads a graph from Python pickled format",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Reads a graph from compressed Python pickled format, uncompressing it on-the-fly.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Constructs a graph from a list-of-tuples representation.\nThis representation assumes that the edges of the graph are encoded in a list of tuples (or lists). Each item in the list must have at least two elements, which specify the source and the target vertices of the edge. The remaining elements (if any) specify the edge attributes of that edge, where the names of the edge attributes originate from the edge_attrs list. The names of the vertices will be stored in the vertex attribute given by vertex_name_attr.\nThe default parameters of this function are suitable for creating unweighted graphs from lists where each item contains the source vertex and the target vertex. If you have a weighted graph, you can use items where the third item contains the weight of the edge by setting edge_attrs to \"weight\" or [\"weight\"]. If you have even more edge attributes, add them to the end of each item in the edges list and also specify the corresponding edge attribute names in edge_attrs as a list.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Generates a graph from its weighted adjacency matrix.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Copies the graph and extends the copy depending on the type of the other object given.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Graph intersection operator.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns True if the graph has at least one vertex, False otherwise.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Coercion rules.\nThis method is needed to allow the graph to react to additions with lists, tuples, integers, strings, vertices, edges and so on.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. In-place addition (disjoint union).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. __init__(n=0, edges=None, directed=False, graph_attrs=None, vertex_attrs=None, edge_attrs=None)\nConstructs a graph from scratch.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. In-place subtraction (difference).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Copies exact replicas of the original graph an arbitrary number of times.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Graph union operator.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Plots the graph to the given Cairo context or matplotlib Axes.\nThe visual style of vertices and edges can be modified at three places in the following order of precedence (lower indices override higher indices):Keyword arguments of this function (or of plot() which is passed intact to Graph.__plot__().Vertex or edge attributes, specified later in the list of keyword arguments.igraph-wide plotting defaults (see igraph.config.Configuration)Built-in defaults.\nE.g., if the vertex_size keyword attribute is not present, but there exists a vertex attribute named size, the sizes of the vertices will be specified by that attribute.\nBesides the usual self-explanatory plotting parameters (context, bbox, palette), it accepts the following keyword arguments:autocurve: whether to use curves instead of straight lines for multiple edges on the graph plot. This argument may be True or False; when omitted, True is assumed for graphs with less than 10.000 edges and False otherwise.drawer_factory: a subclass of AbstractCairoGraphDrawer which will be used to draw the graph. You may also provide a function here which takes two arguments: the Cairo context to draw on and a bounding box (an instance of BoundingBox). If this keyword argument is missing, igraph will use the default graph drawer which should be suitable for most purposes. It is safe to omit this keyword argument unless you need to use a specific graph drawer.keep_aspect_ratio: whether to keep the aspect ratio of the layout that igraph calculates to place the nodes. True means that the layout will be scaled proportionally to fit into the bounding box where the graph is to be drawn but the aspect ratio will be kept the same (potentially leaving empty space next to, below or above the graph). False means that the layout will be scaled independently along the X and Y axis in order to fill the entire bounding box. The default is False.layout: the layout to be used. If not an instance of Layout, it will be passed to layout to calculate the layout. Note that if you want a deterministic layout that does not change with every plot, you must either use a deterministic layout function (like GraphBase.layout_circle) or calculate the layout in advance and pass a Layout object here.margin: the top, right, bottom, left margins as a 4-tuple. If it has less than 4 elements or is a single float, the elements will be re-used until the length is at least 4.mark_groups: whether to highlight some of the vertex groups by colored polygons. This argument can be one of the following:False: no groups will be highlightedTrue: only valid if the object plotted is a VertexClustering or VertexCover. The vertex groups in the clutering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette. If used when plotting a graph, it will throw an error.A dict mapping tuples of vertex indices to color names. The given vertex groups will be highlighted by the given colors.A list containing pairs or an iterable yielding pairs, where the first element of each pair is a list of vertex indices and the second element is a color.A VertexClustering or VertexCover instance. The vertex groups in the clustering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.vertex_size: size of the vertices. The corresponding vertex attribute is called size. The default is 10. Vertex sizes are measured in the unit of the Cairo context on which igraph is drawing.vertex_color: color of the vertices. The corresponding vertex attribute is color, the default is red.  Colors can be specified either by common X11 color names (see the source code of igraph.drawing.colors for a list of known colors), by 3-tuples of floats (ranging between 0 and 255 for the R, G and B components), by CSS-style string specifications (#rrggbb) or by integer color indices of the specified palette.vertex_frame_color: color of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is frame_color, the default is black. See vertex_color for the possible ways of specifying a color.vertex_frame_width: the width of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is frame_width. The default is 1. Vertex frame widths are measured in the unit of the Cairo context on which igraph is drawing.vertex_shape: shape of the vertices. Alternatively it can be specified by the shape vertex attribute. Possibilities are: square, {circle}, {triangle}, {triangle-down} or hidden. See the source code of igraph.drawing for a list of alternative shape names that are also accepted and mapped to these.vertex_label: labels drawn next to the vertices. The corresponding vertex attribute is label.vertex_label_dist: distance of the midpoint of the vertex label from the center of the corresponding vertex. The corresponding vertex attribute is label_dist.vertex_label_color: color of the label. Corresponding vertex attribute: label_color. See vertex_color for color specification syntax.vertex_label_size: font size of the label, specified in the unit of the Cairo context on which we are drawing. Corresponding vertex attribute: label_size.vertex_label_angle: the direction of the line connecting the midpoint of the vertex with the midpoint of the label. This can be used to position the labels relative to the vertices themselves in conjunction with vertex_label_dist. Corresponding vertex attribute: label_angle. The default is -math.pi/2.vertex_order: drawing order of the vertices. This must be a list or tuple containing vertex indices; vertices are then drawn according to this order.vertex_order_by: an alternative way to specify the drawing order of the vertices; this attribute is interpreted as the name of a vertex attribute, and vertices are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (True, False, \"asc\" and \"desc\" are accepted values).edge_color: color of the edges. The corresponding edge attribute is color, the default is red. See vertex_color for color specification syntax.edge_curved: whether the edges should be curved. Positive numbers correspond to edges curved in a counter-clockwise direction, negative numbers correspond to edges curved in a clockwise direction. Zero represents straight edges. True is interpreted as 0.5, False is interpreted as 0. The default is 0 which makes all the edges straight.edge_width: width of the edges in the default unit of the Cairo context on which we are drawing. The corresponding edge attribute is width, the default is 1.edge_arrow_size: arrow size of the edges. The corresponding edge attribute is arrow_size, the default is 1.edge_arrow_width: width of the arrowhead on the edge. The corresponding edge attribute is arrow_width, the default is 1.edge_order: drawing order of the edges. This must be a list or tuple containing edge indices; edges are then drawn according to this order.edge_order_by: an alternative way to specify the drawing order of the edges; this attribute is interpreted as the name of an edge attribute, and edges are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (True, False, \"asc\" and \"desc\" are accepted values).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Support for pickling.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns a string representation of the graph.\nBehind the scenes, this method constructs a GraphSummary instance and invokes its __str__ method with a verbosity of 1 and attribute printing turned off.\nSee the documentation of GraphSummary for more details about the output.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Removes the given object(s) from the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Adds a single edge to the graph.\nKeyword arguments (except the source and target arguments) will be assigned to the edge as attributes.\nThe performance cost of adding a single edge or several edges to a graph is similar. Thus, when adding several edges, a single add_edges() call is more efficient than multiple add_edge() calls.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.add_edges\nAdds some edges to the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Adds a single vertex to the graph. Keyword arguments will be assigned as vertex attributes. Note that name as a keyword argument is treated specially; if a graph has name as a vertex attribute, it allows one to refer to vertices by their names in most places where igraph expects a vertex ID.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.add_vertices\nAdds some vertices to the graph.\nNote that if n is a sequence of strings, indicating the names of the new vertices, and attributes has a key name, the two conflict. In that case the attribute will be applied.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.all_st_cuts\nReturns all the cuts between the source and target vertices in a directed graph.\nThis function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.\nReference: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351-372, 1996.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.all_st_mincuts\nReturns all the mincuts between the source and target vertices in a directed graph.\nThis function lists all minimum edge-cuts between a source and a target vertex.\nReference: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351-372, 1996.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns a directed copy of this graph. Arguments are passed on to GraphBase.to_directed() that is invoked on the copy.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns an undirected copy of this graph. Arguments are passed on to GraphBase.to_undirected() that is invoked on the copy.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.biconnected_components\nCalculates the biconnected components of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.bipartite_projection\nProjects a bipartite graph into two one-mode graphs. Edge directions are ignored while projecting.\nExamples:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.bipartite_projection_size\nCalculates the number of vertices and edges in the bipartite projections of this graph according to the specified vertex types. This is useful if you have a bipartite graph and you want to estimate the amount of memory you would need to calculate the projections themselves.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Calculates the biconnected components of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Clears the graph, deleting all vertices, edges, and attributes.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Deprecated alias to Graph.connected_components().",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.cohesive_blocks\nCalculates the cohesive block structure of the graph.\nCohesive blocking is a method of determining hierarchical subsets of graph vertices based on their structural cohesion (i.e. vertex connectivity). For a given graph G, a subset of its vertices S is said to be maximally k-cohesive if there is no superset of S with vertex connectivity greater than or equal to k. Cohesive blocking is a process through which, given a k-cohesive set of vertices, maximally l-cohesive subsets are recursively identified with l > k. Thus a hierarchy of vertex subsets is obtained in the end, with the entire graph G at its root.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_edge_betweenness\nCommunity structure based on the betweenness of the edges in the network.\nThe idea is that the betweenness of the edges connecting two communities is typically high, as many of the shortest paths between nodes in separate communities go through them. So we gradually remove the edge with the highest betweenness and recalculate the betweennesses after every removal. This way sooner or later the network falls of to separate components. The result of the clustering will be represented by a dendrogram.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_fastgreedy\nCommunity structure based on the greedy optimization of modularity.\nThis algorithm merges individual nodes into communities in a way that greedily maximizes the modularity score of the graph. It can be proven that if no merge can increase the current modularity score, the algorithm can be stopped since no further increase can be achieved.\nThis algorithm is said to run almost in linear time on sparse graphs.\nReference: A Clauset, MEJ Newman and C Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_infomap\nFinds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.\n",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_label_propagation\nFinds the community structure of the graph according to the label propagation method of Raghavan et al.\nInitially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.\nNote that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al. on how to come up with an aggregated community structure.\nAlso note that the community _labels_ (numbers) have no semantic meaning and igraph is free to re-number communities. If you use fixed labels, igraph may still re-number the communities, but co-community membership constraints will be respected: if you had two vertices with fixed labels that belonged to the same community, they will still be in the same community at the end. Similarly, if you had two vertices with fixed labels that belonged to different communities, they will still be in different communities at the end.\nReference: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_leading_eigenvector\nNewman's leading eigenvector method for detecting community structure.\nThis is the proper implementation of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.\nReference: MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_leiden\nFinds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman.\nReference: Traag, V. A., Waltman, L., & van Eck, N. J. (2019). From Louvain to Leiden: guaranteeing well-connected communities. Scientific Reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_multilevel\nCommunity structure based on the multilevel algorithm of Blondel et al.\nThis is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrunk to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity anymore after shrinking the communities to vertices.\nThis algorithm is said to run almost in linear time on sparse graphs.\nReference: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008). http://arxiv.org/abs/0803.0476",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_optimal_modularity\nCalculates the optimal modularity score of the graph and the corresponding community structure.\nThis function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_spinglass\nFinds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt.\n",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.community_walktrap\nCommunity detection algorithm of Latapy & Pons, based on random walks.\nThe basic idea of the algorithm is that short random walks tend to stay in the same community. The result of the clustering will be represented as a dendrogram.\nReference: Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Calculates the (strong or weak) connected components for a given graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.connected_components\nCalculates the (strong or weak) connected components for a given graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns the number of automorphisms of the graph.\nThis function simply calls count_isomorphisms_vf2 with the graph itgraph. See count_isomorphisms_vf2 for an explanation of the parameters.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Calculates the degree distribution of the graph.\nUnknown keyword arguments are directly passed to GraphBase.degree.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.delete_edges\nDeletes some edges from the graph.\nThe set of edges to be deleted is determined by the positional and keyword arguments. If the function is called without any arguments, all edges are deleted. If any keyword argument is present, or the first positional argument is callable, an edge sequence is derived by calling EdgeSeq.select with the same positional and keyword arguments. Edges in the derived edge sequence will be removed. Otherwise, the first positional argument is considered as follows:\nDeprecation notice: delete_edges(None) has been replaced by delete_edges() - with no arguments - since igraph 0.8.3.None - deletes all edges (deprecated since 0.8.3)a single integer - deletes the edge with the given IDa list of integers - deletes the edges denoted by the given IDsa list of 2-tuples - deletes the edges denoted by the given source-target vertex pairs. When multiple edges are present between a given source-target vertex pair, only one is removed.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Conducts a depth first search (DFS) on the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Creates the disjoint union of two (or more) graphs.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.dyad_census\nCalculates the dyad census of the graph.\nDyad census means classifying each pair of vertices of a directed graph into three categories: mutual (there is an edge from a to b and also from b to a), asymmetric (there is an edge from a to b or from b to a but not the other way round) and null (there is no connection between a and b).\nReference: Holland, P.W. and Leinhardt, S. A Method for Detecting Structure in Sociometric Data. American Journal of Sociology, 70, 492-513, 1970.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.get_adjacency\nReturns the adjacency matrix of a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns the adjacency matrix of a graph as a SciPy CSR matrix.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns the adjacency list representation of the graph.\nThe adjacency list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the neighbors of the given vertex.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Calculates all the simple paths from a given node to some other nodes (or all of them) in a graph.\nA path is simple if its vertices are unique, i.e. no vertex is visited more than once.\nNote that potentially there are exponentially many paths between two vertices of a graph, especially if your graph is lattice-like. In this case, you may run out of memory when using this function.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns all the automorphisms of the graph\nThis function simply calls get_isomorphisms_vf2 with the graph itgraph. See get_isomorphisms_vf2 for an explanation of the parameters.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.get_biadjacency\nReturns the bipartite adjacency matrix of a bipartite graph. The bipartite adjacency matrix is an n times m matrix, where n and m are the number of vertices in the two vertex classes.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Export edges with attributes to pandas.DataFrame\nIf you want to use source and target vertex IDs as index, you can do:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Deprecated alias to Graph.get_biadjacency().",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns the incidence list representation of the graph.\nThe incidence list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the IDs of the incident edges of the given vertex.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Export vertices with attributes to pandas.DataFrame\nIf you want to use vertex names as index, you can do:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.gomory_hu_tree\nCalculates the Gomory-Hu tree of an undirected graph with optional edge capacities.\nThe Gomory-Hu tree is a concise representation of the value of all the maximum flows (or minimum cuts) in a graph. The vertices of the tree correspond exactly to the vertices of the original graph in the same order. Edges of the Gomory-Hu tree are annotated by flow values.  The value of the maximum flow (or minimum cut) between an arbitrary (u,v) vertex pair in the original graph is then given by the minimum flow value (i.e. edge annotation) along the shortest path between u and v in the Gomory-Hu tree.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns the in-degrees in a list.\nSee GraphBase.degree for possible arguments.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Creates the intersection of two (or more) graphs.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns whether the graph is named.\nA graph is named if and only if it has a \"name\" vertex attribute.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns whether the graph is weighted.\nA graph is weighted if and only if it has a \"weight\" edge attribute.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns some k-cores of the graph.\nThe method accepts an arbitrary number of arguments representing the desired indices of the k-cores to be returned. The arguments can also be lists or tuples. The result is a single Graph object if an only integer argument was given, otherwise the result is a list of Graph objects representing the desired k-cores in the order the arguments were specified. If no argument is given, returns all k-cores in increasing order of k.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns the layout of the graph according to a layout algorithm.\nParameters and keyword arguments not specified here are passed to the layout algorithm directly. See the documentation of the layout algorithms for the explanation of these parameters.\nRegistered layout names understood by this method are:auto, automatic: automatic layout (see Graph.layout_auto)bipartite: bipartite layout (see GraphBase.layout_bipartite)circle, circular: circular layout (see GraphBase.layout_circle)dh, davidson_harel: Davidson-Harel layout (see GraphBase.layout_davidson_harel)drl: DrL layout for large graphs (see GraphBase.layout_drl)drl_3d: 3D DrL layout for large graphs (see GraphBase.layout_drl)fr, fruchterman_reingold: Fruchterman-Reingold layout (see GraphBase.layout_fruchterman_reingold).fr_3d, fr3d, fruchterman_reingold_3d: 3D Fruchterman- Reingold layout (see GraphBase.layout_fruchterman_reingold).grid: regular grid layout in 2D (see GraphBase.layout_grid)grid_3d: regular grid layout in 3D (see GraphBase.layout_grid)graphopt: the graphopt algorithm (see GraphBase.layout_graphopt)kk, kamada_kawai: Kamada-Kawai layout (see GraphBase.layout_kamada_kawai)kk_3d, kk3d, kamada_kawai_3d: 3D Kamada-Kawai layout (see GraphBase.layout_kamada_kawai)lgl, large, large_graph: Large Graph Layout (see GraphBase.layout_lgl)mds: multidimensional scaling layout (see GraphBase.layout_mds)random: random layout (see GraphBase.layout_random)random_3d: random 3D layout (see GraphBase.layout_random)rt, tree, reingold_tilford: Reingold-Tilford tree layout (see GraphBase.layout_reingold_tilford)rt_circular, reingold_tilford_circular: circular Reingold-Tilford tree layout (see GraphBase.layout_reingold_tilford_circular)sphere, spherical, circle_3d, circular_3d: spherical layout (see GraphBase.layout_circle)star: star layout (see GraphBase.layout_star)sugiyama: Sugiyama layout (see Graph.layout_sugiyama)",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Chooses and runs a suitable layout function based on simple topological properties of the graph.\nThis function tries to choose an appropriate layout function for the graph using the following rules:If the graph has an attribute called layout, it will be used. It may either be a Layout instance, a list of coordinate pairs, the name of a layout function, or a callable function which generates the layout when called with the graph as a parameter.Otherwise, if the graph has vertex attributes called x and y, these will be used as coordinates in the layout. When a 3D layout is requested (by setting dim to 3), a vertex attribute named z will also be needed.Otherwise, if the graph is connected and has at most 100 vertices, the Kamada-Kawai layout will be used (see GraphBase.layout_kamada_kawai()).Otherwise, if the graph has at most 1000 vertices, the Fruchterman-Reingold layout will be used (see GraphBase.layout_fruchterman_reingold()).If everything else above failed, the DrL layout algorithm will be used (see GraphBase.layout_drl()).\nAll the arguments of this function except dim are passed on to the chosen layout function (in case we have to call some layout function).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Places the vertices using a layered Sugiyama layout.\nThis is a layered layout that is most suitable for directed acyclic graphs, although it works on undirected or cyclic graphs as well.\nEach vertex is assigned to a layer and each layer is placed on a horizontal line. Vertices within the same layer are then permuted using the barycenter heuristic that tries to minimize edge crossings.\nDummy vertices will be added on edges that span more than one layer. The returned layout therefore contains more rows than the number of nodes in the original graph; the extra rows correspond to the dummy vertices.\n",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.maxflow\nReturns a maximum flow between the given source and target vertices in a graph.\nA maximum flow from source to target is an assignment of non-negative real numbers to the edges of the graph, satisfying two properties:For each edge, the flow (i.e. the assigned number) is not more than the capacity of the edge (see the capacity argument)For every vertex except the source and the target, the incoming flow is the same as the outgoing flow.\nThe value of the flow is the incoming flow of the target or the outgoing flow of the source (which are equal). The maximum flow is the maximum possible such value.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Finds a maximum matching in a bipartite graph.\nA maximum matching is a set of edges such that each vertex is incident on at most one matched edge and the number (or weight) of such edges in the set is as large as possible.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.mincut\nCalculates the minimum cut between the given source and target vertices or within the whole graph.\nThe minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if neither the source nor the target are given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated.\nFor undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.modularity\nCalculates the modularity score of the graph with respect to a given clustering.\nThe modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It's defined as Q = 1 ⁄ (2m)*sum(Aij − gamma*ki*kj ⁄ (2m)delta(ci, cj), i, j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, and Ci and cj are the types of the two vertices (i and j), and gamma is a resolution parameter that defaults to 1 for the classical definition of modularity. delta(x, y) is one iff x = y, 0 otherwise.\nIf edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges adjacent to vertex i, kj is the total weight of edges adjacent to vertex j and m is the total edge weight in the graph.\nReference: MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns the out-degrees in a list.\nSee GraphBase.degree for possible arguments.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Calculates the PageRank values of a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.path_length_hist\nReturns the path length histogram of the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Deprecated alias to Graph.distances().",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Calculates a minimum spanning tree for a graph.\nReference: Prim, R.C. Shortest connection networks and some generalizations. Bell System Technical Journal 36:1389-1401, 1957.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.st_mincut\nCalculates the minimum cut between the source and target vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Returns the summary of the graph.\nThe output of this method is similar to the output of the __str__ method. If verbosity is zero, only the header line is returned (see __str__ for more details), otherwise the header line and the edge list is printed.\nBehind the scenes, this method constructs a GraphSummary object and invokes its __str__ method.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Export graph to dictionary of dicts of edge attributes\nThis function is the reverse of Graph.DictDict.\nExample:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Export graph as two lists of dictionaries, for vertices and edges.\nThis function is the reverse of Graph.DictList.\nExample:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Converts the graph to graph-tool\nData types: graph-tool only accepts specific data types. See the following web page for a list:\nhttps://graph-tool.skewed.de/static/doc/quickstart.html\nNote: because of the restricted data types in graph-tool, vertex and edge attributes require to be type-consistent across all vertices or edges. If you set the property for only some vertices/edges, the other will be tagged as None in igraph, so they can only be converted to graph-tool with the type 'object' and any other conversion will fail.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Export graph to a dictionary of lists (or other sequences).\nThis function is the reverse of Graph.ListDict.\nExample:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Converts the graph to networkx format.\nigraph has ordered vertices and edges, but networkx does not. To keep track of the original order, the '_igraph_index' vertex property is added to both vertices and edges.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Export graph to a list of edge tuples\nThis function is the reverse of Graph.TupleList.\nExample:",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.transitivity_avglocal_undirected\nCalculates the average of the vertex transitivities of the graph.\nIn the unweighted case, the transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter. The calculation is slightly more involved for weighted graphs; in this case, weights are taken into account according to the formula of Barrat et al (see the references).\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it simply takes the average local transitivity across the whole network.\n",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.triad_census\nCalculates the triad census of the graph.\nReference: Davis, J.A. and Leinhardt, S. The Structure of Positive Interpersonal Relations in Small Groups. In: J. Berger (Ed.), Sociological Theories in Progress, Volume 2, 218-251. Boston: Houghton Mifflin (1972).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Creates the union of two (or more) graphs.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Unified writing function for graphs.\nThis method tries to identify the format of the graph given in the first parameter (based on extension) and calls the corresponding writer method.\nThe remaining arguments are passed to the writer method without any changes.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Writes the adjacency matrix of the graph to the given file\nAll the remaining arguments not mentioned here are passed intact to Graph.get_adjacency.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. overrides igraph.GraphBase.write_dimacs\nWrites the graph in DIMACS format to the given file.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Writes the graph to a zipped GraphML file.\nThe library uses the gzip compression algorithm, so the resulting file can be unzipped with regular gzip uncompression (like gunzip or zcat from Unix command line) or the Python gzip module.\nUses a temporary file to store intermediate GraphML data, so make sure you have enough free space to store the unzipped GraphML file as well.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Saves the graph in Python pickled format",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Saves the graph in Python pickled format, compressed with gzip.\nSaving in this format is a bit slower than saving in a Python pickle without compression, but the final file takes up much less space on the hard drive.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Saves the graph as an SVG (Scalable Vector Graphics) file\nThe file will be Inkscape (http://inkscape.org) compatible. In Inkscape, as nodes are rearranged, the edges auto-update.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Create and return a new object.  See help(type) for accurate signature.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns a list containing all the minimal s-t separators of a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Decides whether two given vertices are directly connected.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the list of articulation points in the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the assortativity of the graph based on numeric properties of the vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the assortativity of a graph based on vertex degrees.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the assortativity of the graph based on vertex categories.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph based on asymmetric vertex types and connection probabilities.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph from the Graph Atlas.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:No summary",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates Kleinberg's authority score for the vertices of the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the generators of the automorphism group of a graph using the BLISS isomorphism algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the average path length in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph based on the Barabási-Albert model.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates or estimates the betweenness of vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Conducts a breadth first search (BFS) on the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Constructs a breadth first search (BFS) iterator of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates bibliographic coupling scores for given vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the list of bridges in the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the list of edges needed to be added to the graph to make it chordal.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the clique number of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns some or all cliques of the graph as a list of tuples.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the closeness centralities of given vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates cocitation scores for given vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the complementer of the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the composition of two graphs.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates Burt's constraint scores for given vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Undocumented (yet).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Undocumented (yet).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Creates a copy of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Finds the coreness (shell index) of the vertices of the network.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the number of automorphisms of a graph using the BLISS isomorphism algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Determines the number of isomorphisms between the graph and another one",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Counts the multiplicities of the given edges.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Determines the number of subisomorphisms between the graph and another one",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a de Bruijn graph with parameters (m, n)",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Decomposes the graph into subgraphs.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns some vertex degrees from the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph with a given degree sequence.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Deletes vertices and all its edges from the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the density of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Constructs a depth first search (DFS) iterator of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the diameter of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Subtracts the given graph from the original",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates shortest path lengths for given vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the structural diversity index of the vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the dominator tree from the given root node",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the eccentricities of given vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Counts the number of edges.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:No summary",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates or estimates the edge betweennesses in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the edge connectivity of the graph or between some vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Undocumented",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the eigenvector centralities of the vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph based on the Erdős-Rényi model.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph based on a simple growing model with vertex types.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a famous graph based on its name.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns two vertex IDs whose distance equals the actual diameter of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates an approximately or exactly minimal feedback arc set.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph based on the forest fire model",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a full graph (directed or undirected, with or without loops).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a full citation graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Finds a single fundamental cycle basis of the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates all of the shortest paths from/to a given node in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns a path with the actual diameter of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the edge list of a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the edge ID of an arbitrary edge between vertices v1 and v2",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the edge IDs of some edges between some vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns all isomorphisms between the graph and another one",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the k shortest paths from/to a given node in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the shortest path from a source vertex to a target vertex in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the shortest path from a source vertex to a target vertex in a graph using the A-Star algorithm and a heuristic function.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the shortest paths from/to a given node in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns all subisomorphisms between the graph and another one using the LAD algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns all subisomorphisms between the graph and another one",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the girth of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a growing random graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the harmonic centralities of given vertices in a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether the graph has multiple edges.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a regular hexagonal lattice.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates Kleinberg's hub score for the vertices of the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the edges a given vertex is incident on.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the independence number of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns some or all independent vertex sets of the graph as a list of tuples.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns a subgraph spanned by the given vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns whether the graph is acyclic (i.e. contains no cycles).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Decides whether the graph is biconnected.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Decides whether the graph is bipartite or not.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns whether the graph is chordal or not.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Decides whether the graph is connected.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether the graph is a DAG (directed acyclic graph).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether the graph is directed.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether a specific set of edges contain loop edges",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Decides whether the given vertex set is a minimal separator.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether an edge is a multiple edge.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether an edge has an opposite pair.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Decides whether the removal of the given vertices disconnects the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether the graph is simple (no loop or multiple edges).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether the graph is a (directed or undirected) tree graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph with a given isomorphism class.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the isomorphism class of the graph or its subgraph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether the graph is isomorphic to another graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a k-regular random graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a Kautz graph with parameters (m, n)",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the Laplacian matrix of a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the largest cliques of the graph as a list of tuples.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the largest independent vertex sets of the graph as a list of tuples.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a regular square lattice.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Place the vertices of a bipartite graph in two layers.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices of the graph uniformly on a circle or a sphere.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices of a graph in a 2D or 3D grid.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices on a plane according to the Kamada-Kawai algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices on a 2D plane according to the Large Graph Layout.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices of the graph randomly.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Circular Reingold-Tilford layout for trees.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates a star-like layout for the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Uniform Manifold Approximation and Projection (UMAP).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph from LCF notation.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the line graph of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Lists the triangles of the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the maximum degree of a vertex set in the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the value of the maximum flow between the source and target vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the maximal cliques of the graph as a list of tuples.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the maximal independent vertex sets of the graph as a list of tuples.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Conducts a maximum cardinality search on the graph. The function computes a rank alpha for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the minimum cut between the source and target vertices or within the whole graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Computes a minimum cycle basis of the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns a list containing all separator vertex sets of minimum size.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the modularity matrix of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Counts the number of motifs in the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Counts the total number of motifs in the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Counts the total number of motifs in the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:For each vertex specified by vertices, returns the vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:For each vertex specified by vertices, returns the number of vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist...",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns adjacent vertices to a given vertex.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Permutes the vertices of the graph according to the given permutation and returns the new graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the personalized PageRank values of a graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the predecessors of a given vertex.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph based on vertex types and connection probabilities.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a tree from its Prüfer sequence.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the radius of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Performs a random walk of a given length from a given node.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reads an UCINET DL file and creates a graph based on it.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reads an edge list from a file and creates a graph based on it.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reads a GML file and creates a graph based on it.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reads a GraphDB format file and creates a graph based on it.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reads a GraphML format file and creates a graph based on it.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reads an .lgl file used by LGL.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reads an .ncol file used by LGL.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj).",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a bipartite graph from the degree sequences of its partitions.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph from a degree sequence.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph...",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Reverses the direction of some edges in the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Randomly rewires the graph while preserving the degree distribution.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Rewires the edges of a graph with constant probability.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a ring graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a graph based on a stochastic block model.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Dice similarity coefficient of vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Inverse log-weighted similarity coefficient of vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Jaccard similarity coefficient of vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Simplifies a graph by removing self-loops and/or multiple edges.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a star graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a non-growing graph with edge probabilities proportional to node fitnesses.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a non-growing graph with prescribed power-law degree distributions.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the strength (weighted degree) of some vertices from the graph",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Determines the indices of vertices which are in the same component as a given vertex.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns a subgraph spanned by the given edges.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether a subgraph of the graph is isomorphic to another graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Checks whether a subgraph of the graph is isomorphic to another graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Returns the successors of a given vertex.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Converts an undirected graph to directed.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Converts a tree graph into a Prüfer sequence.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Converts a directed graph to undirected.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates a possible topological sorting of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the global transitivity (clustering coefficient) of the graph.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a tree in which almost all vertices have the same number of children.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Generates a regular triangular lattice.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Counts the number of vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:No summary",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates a greedy vertex coloring for the graph based on some heuristics.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Calculates the vertex connectivity of the graph or between some vertices.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:This function generates networks with the small-world property based on a variant of the Watts-Strogatz model. The network is obtained by first creating a periodic undirected lattice, then rewiring both endpoints of each edge with probability ...",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Writes the graph in DOT format to the given file.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Writes the edge list of a graph to a file.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Writes the graph in GML format to the given file.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Writes the graph to a GraphML file.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Writes the graph to a file in LEDA native format.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Writes the edge list of a graph to a file in .lgl format.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Writes the edge list of a graph to a file in .ncol format.",
    "igraph: Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n. Inherited from GraphBase:Writes the graph in Pajek format to the given file.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges as arrows.. overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges as arrows.. Inherited from AbstractCairoEdgeDrawer:Constructs the edge drawer.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges as arrows.. Inherited from AbstractCairoEdgeDrawer:Draws a loop edge.",
    "igraph: Edge drawer implementation that draws undirected edges as straight lines and directed edges as arrows.. Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge.",
    "igraph: The default vertex drawer implementation of igraph.. overrides igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given Cairo context and the given BoundingBox.",
    "igraph: The default vertex drawer implementation of igraph.. overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nDraws the given vertex.",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Initializes the matching.",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Undocumented",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Undocumented",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Undocumented",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Returns an edge sequence that contains the edges in the matching.\nIf there are multiple edges between a pair of matched vertices, only one of them will be returned.",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Returns whether the given vertex is matched to another one.",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Returns whether the matching is maximal.\nA matching is maximal when it is not possible to extend it any more with extra edges; in other words, unmatched vertices in the graph must be adjacent to matched vertices only.",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Returns the vertex a given vertex is matched to.",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Sets the matching vector.",
    "igraph: A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n. Undocumented",
    "igraph: Matplotlib-specific abstract edge drawer object.. Constructs the edge drawer.",
    "igraph: Matplotlib-specific abstract edge drawer object.. Undocumented",
    "igraph: Matplotlib-specific abstract edge drawer object.. overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
    "igraph: Matplotlib-specific abstract edge drawer object.. overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.",
    "igraph: Matplotlib-specific abstract edge drawer object.. Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.",
    "igraph: Matplotlib-specific abstract edge drawer object.. Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge.",
    "igraph: Classic Python shell interface.\nThis class allows igraph to be embedded in Python's shell.. overrides igraph.app.shell.Shell.__call__\nStarts the embedded shell.",
    "igraph: Classic Python shell interface.\nThis class allows igraph to be embedded in Python's shell.. overrides igraph.app.shell.ConsoleProgressBarMixin.__init__\nConstructor.\nImports Python's classic shell",
    "igraph: Classic Python shell interface.\nThis class allows igraph to be embedded in Python's shell.. Inherited from Shell:Returns the progress handler (if exists) or None (if not).",
    "igraph: Classic Python shell interface.\nThis class allows igraph to be embedded in Python's shell.. Inherited from Shell:Returns the status handler (if exists) or None (if not).",
    "igraph: Classic Python shell interface.\nThis class allows igraph to be embedded in Python's shell.. Inherited from Shell:Checks whether the shell supports progress bars.",
    "igraph: Classic Python shell interface.\nThis class allows igraph to be embedded in Python's shell.. Inherited from Shell:Checks whether the shell supports status messages.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. Returns the members of the specified cluster.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. overridden in igraph.VertexClustering\nConstructor.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. Iterates over the clusters in this clustering.\nThis method will return a generator that generates the clusters one by one.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. Returns the number of clusters.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. overridden in igraph.Cut\nUndocumented",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. overridden in igraph.VertexClustering\nReturns a Cover that contains the same clusters as this clustering.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. Compares this clustering to another one using some similarity or distance metric.\nThis is a convenience method that simply calls compare_communities with the two clusterings as arguments. Any extra positional or keyword argument is also forwarded to compare_communities.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. Returns the size of a given cluster.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. Returns the histogram of cluster sizes.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. Returns the size of given clusters.\nThe indices are given as positional arguments. If there are no positional arguments, the function will return the sizes of all clusters.",
    "igraph: Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n. Returns the summary of the clustering.\nThe summary includes the number of items and clusters, and also the list of members for each of the clusters if the verbosity is nonzero.",
    "littleballoffur: An implementation of random node sampling. Nodes are sampled with uniform probability. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of degree based sampling. Nodes are sampled proportional to the degree centrality of nodes. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of PageRank based sampling. Nodes are sampled proportional to the PageRank score of nodes. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of random edge sampling. Edges are sampled with the same uniform probability randomly. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of random node-edge sampling. The algorithm first randomly samples a node. From this node it samples an edge with a neighbor. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of hybrid node-edge sampling. The algorithm alternates between two sampling methods. (A) Random uniform edge sampling. (B) The algorithm first randomly samples a node. From this node it samples an edge with a neighbor. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of random edge sampling with edge set induction. The algorithm randomly samples edges with a fixed probability. Edges between nodes which are already in the sample are retained with an induction step. For details about the algorithm see this paper.",
    "littleballoffur: Class to read benchmark datasets for the sampling task.",
    "littleballoffur: An implementation of exploration sampling by a diffusion branching process. A simple diffusion which creates an induced subgraph by an incrementally diffusion. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of exploration sampling by a diffusion branching process. A simple diffusion which creates an induced tree by an incrementally diffusion. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of forest fire sampling. The procedure is a stochastic snowball sampling method where the expansion is proportional to the burning probability. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of spiky ball sampling. The procedure is a filtered breadth-first search sampling method where the expansion is is performed over a random subset of neighbors. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of node sampling by common neighbor aware random walks. The random walker is biased to visit neighbors that have a lower number of common neighbors. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of node sampling by non back-tracking random walks. The process generates a random walk in which the random walker cannot make steps backwards. This way the tottering behaviour of random walkers can be avoided. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of node sampling by loop-erased random walks. The random walkers samples a fixed number of nodes. Only edges that connect so far unconnected nodes to the sampled node set are added to the edge set (cycles are erased). The resulting graph is always an undirected tree. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of node sampling by random walks. A simple random walker which creates an induced subgraph by walking around. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of node sampling by random walks with restart. The process is a discrete random walker on nodes which teleports back to the staring node with a fixed probability. This results in a connected subsample from the original input graph. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of node sampling by Metropolis Hastings random walks. The random walker has a probabilistic acceptance condition for adding new nodes to the sampled node set. This constraint can be parametrized by the rejection constraint exponent. The sampled graph is always connected. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of node sampling by snow ball search. Starting from a source node the algorithm places a fixed number of neighbors in a queue of nodes to explore. The expansion goes on until the target number of sampled vertices is reached. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of circulated neighbor random walk sampling. The process simulates a random walker. Vertices of a neighbourhood are randomly reshuffled after all of them is sampled from the vicinity of a node. This way the walker can escape closely knit communities. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of node sampling by breadth first search. The starting node is selected randomly and neighbors are added to the queue by shuffling them randomly.",
    "littleballoffur: An implementation of node sampling by depth first search. The starting node is selected randomly and neighbors are added to the last in first out queue by shuffling them randomly.",
    "littleballoffur: An implementation of node sampling by random walks with jumps. The process is a discrete random walker on nodes which teleports back to a random node with a fixed probability. This might result in a disconnected subsample from the original input graph. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of community structure preserving expansion sampling. Starting with a random source node the procedure chooses a node which is connected to the already sampled nodes. This node is the one with the largest community expansion score. The extracted subgraph is always connected. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of frontier sampling. A fixed number of random walkers traverses the graph and the walkers which make a step are selected randomly. The procedure might result in a disconnected graph as the walks might never connect with each other. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of random node-neighbor sampling. The process uniformly samples a fixed number of nodes first. Later it induces the neighboring nodes as the node set and the edges between all of the nodes. For details about the algorithm see this paper.",
    "littleballoffur: An implementation of shortest path sampling. The procedure samples pairs of nodes and chooses a random shortest path between them. Vertices and edges on this shortest path are added to the induces subgraph that is extracted. For details about the algorithm see this paper.",
    "networkx: Modify graph to prevent further change by adding or removing\nnodes or edges., Node and edge data can still be modified.",
    "networkx: Represents a planar graph with its planar embedding., The planar embedding is given by a combinatorial embedding ., Neighbor ordering:, In comparison to a usual graph structure, the embedding also stores the\norder of all neighbors for every vertex.\nThe order of the neighbors can be given in clockwise (cw) direction or\ncounterclockwise (ccw) direction. This order is stored as edge attributes\nin the underlying directed graph. For the edge (u, v) the edge attribute\n‘cw’ is set to the neighbor of u that follows immediately after v in\nclockwise direction., In order for a PlanarEmbedding to be valid it must fulfill multiple\nconditions. It is possible to check if these conditions are fulfilled with\nthe method check_structure() .\nThe conditions are:, As long as a PlanarEmbedding is invalid only the following methods should\nbe called:, Even though the graph is a subclass of nx.DiGraph, it can still be used\nfor algorithms that require undirected graphs, because the method is_directed() is overridden. This is possible, because a valid\nPlanarGraph must have edges in both directions., Half edges:, In methods like add_half_edge the term “half-edge” is used, which is\na term that is used in doubly connected edge lists . It is used\nto emphasize that the edge is only in one direction and there exists\nanother half-edge in the opposite direction.\nWhile conventional edges always have two faces (including outer face) next\nto them, it is possible to assign each half-edge exactly one face.\nFor a half-edge (u, v) that is oriented such that u is below v then the\nface that belongs to (u, v) is to the right of this half-edge., Examples, Create an embedding of a star graph (compare nx.star_graph(3) ):, Alternatively the same embedding can also be defined in counterclockwise\norientation. The following results in exactly the same PlanarEmbedding:, After creating a graph, it is possible to validate that the PlanarEmbedding\nobject is correct:",
    "networkx: Determines the triadic census of a directed graph., The triadic census is a count of how many of the 16 possible types of\ntriads are present in a directed graph. If a list of nodes is passed, then\nonly those triads are taken into account which have elements of nodelist in them.",
    "networkx: Returns a maximum branching from G.",
    "networkx: Returns the tree corresponding to the given Prüfer sequence., A Prüfer sequence is a list of n - 2 numbers between 0 and n - 1, inclusive. The tree corresponding to a given Prüfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence.",
    "networkx: Returns bipartite node sets of graph G., Raises an exception if the graph is not bipartite or if the input\ngraph is disconnected and thus more than one valid solution exists.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
    "networkx: Compute the eigenvector centrality for the graph G., Eigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node \\(i\\) is the \\(i\\) -th element of a left eigenvector associated with the eigenvalue \\(\\lambda\\) of maximum modulus that is positive. Such an eigenvector \\(x\\) is\ndefined up to a multiplicative constant by the equation, where \\(A\\) is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to, That is, adding the eigenvector centralities of the predecessors of \\(i\\) one obtains the eigenvector centrality of \\(i\\) multiplied by \\(\\lambda\\) . In the case of undirected graphs, \\(x\\) also solves the familiar\nright-eigenvector equation \\(Ax = \\lambda x\\) ., By virtue of the Perron–Frobenius theorem [1] , if G is strongly\nconnected there is a unique eigenvector \\(x\\) , and all its entries\nare strictly positive., If G is not strongly connected there might be several left\neigenvectors associated with \\(\\lambda\\) , and some of their elements\nmight be zero.",
    "networkx: Returns the algebraic connectivity of an undirected graph., The algebraic connectivity of a connected undirected graph is the second\nsmallest eigenvalue of its Laplacian matrix.",
    "networkx: Generate nodes in strongly connected components of graph.",
    "networkx: Returns a set of edges which constitutes\nthe minimum edge cover of the graph., The smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered.",
    "networkx: Returns adjacency matrix of G.",
    "networkx: Returns the Null graph with no nodes or edges., See empty_graph for the use of create_using.",
    "networkx: Find shortest weighted path lengths in G from a source node., Compute the shortest path length between source and all other\nreachable nodes for a weighted graph.",
    "networkx: Returns the Effective graph resistance of G., Also known as the Kirchhoff index., The effective graph resistance is defined as the sum\nof the resistance distance of every node pair in G [1] ., If weight is not provided, then a weight of 1 is used for all edges., The effective graph resistance of a disconnected graph is infinite.",
    "networkx: Returns True if G is aperiodic., A directed graph is aperiodic if there is no integer k > 1 that\ndivides the length of every cycle in the graph.",
    "networkx: Compute the Adamic-Adar index of all node pairs in ebunch., Adamic-Adar index of u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .\nThis index leads to zero-division for nodes only connected via self-loops.\nIt is intended to be used when no self-loops are present.",
    "networkx: Incremental closeness centrality for nodes., Compute closeness centrality for nodes using level-based work filtering\nas described in Incremental Algorithms for Closeness Centrality by Sariyuce et al., Level-based work filtering detects unnecessary updates to the closeness\ncentrality and filters them out., —\nFrom “Incremental Algorithms for Closeness Centrality”:, Theorem 1: Let \\(G = (V, E)\\) be a graph and u and v be two vertices in V\nsuch that there is no edge (u, v) in E. Let \\(G' = (V, E \\cup uv)\\) Then \\(cc[s] = cc'[s]\\) if and only if \\(\\left|dG(s, u) - dG(s, v)\\right| \\leq 1\\) ., Where \\(dG(u, v)\\) denotes the length of the shortest path between\ntwo vertices u, v in a graph G, cc[s] is the closeness centrality for a\nvertex s in V, and cc’[s] is the closeness centrality for a\nvertex s in V, with the (u, v) edge added.\n—, We use Theorem 1 to filter out updates when adding or removing an edge.\nWhen adding an edge (u, v), we compute the shortest path lengths from all\nother nodes to u and to v before the node is added. When removing an edge,\nwe compute the shortest path lengths after the edge is removed. Then we\napply Theorem 1 to use previously computed closeness centrality for nodes\nwhere \\(\\left|dG(s, u) - dG(s, v)\\right| \\leq 1\\) . This works only for\nundirected, unweighted graphs; the distance argument is not supported., Closeness centrality [1] of a node u is the reciprocal of the\nsum of the shortest path distances from u to all n-1 other nodes.\nSince the sum of distances depends on the number of nodes in the\ngraph, closeness is normalized by the sum of minimum possible\ndistances n-1 ., where d(v,u) is the shortest-path distance between v and u ,\nand n is the number of nodes in the graph., Notice that higher values of closeness indicate higher centrality.",
    "networkx: Returns a random simple graph with spectrum resembling that of G, This algorithm, called Spectral Graph Forge (SGF), computes the\neigenvectors of a given graph adjacency matrix, filters them and\nbuilds a random graph with a similar eigenstructure.\nSGF has been proved to be particularly useful for synthesizing\nrealistic social networks and it can also be used to anonymize\ngraph sensitive data.",
    "networkx: Utility for creating a random regular expander., Returns a random \\(d\\) -regular graph on \\(n\\) nodes which is an expander\ngraph with very good probability.",
    "networkx: Parse Pajek format graph from string or iterable.",
    "networkx: Returns the core number for each node., A k-core is a maximal subgraph that contains nodes of degree k or more., The core number of a node is the largest value k of a k-core containing\nthat node.",
    "networkx: Returns a generator of sets of nodes, one set for each biconnected\ncomponent of the graph, Biconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph. Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.  The\nremoval of articulation points will increase the number of connected\ncomponents of the graph., Notice that by convention a dyad is considered a biconnected component.",
    "networkx: Swap three edges in a directed graph while keeping the node degrees fixed., A directed edge swap swaps three edges such that a -> b -> c -> d becomes\na -> c -> b -> d. This pattern of swapping allows all possible states with the\nsame in- and out-degree distribution in a directed graph to be reached., If the swap would create parallel edges (e.g. if a -> c already existed in the\nprevious example), another attempt is made to find a suitable trio of edges.",
    "networkx: Read graph in adjacency list format from path.",
    "networkx: Generate a single line of the bipartite graph G in edge list format.",
    "networkx: Return an approximation to the minimum Steiner tree of a graph., The minimum Steiner tree of G w.r.t a set of terminal_nodes (also S )\nis a tree within G that spans those nodes and has minimum size (sum of\nedge weights) among all such trees., The approximation algorithm is specified with the method keyword\nargument. All three available algorithms produce a tree whose weight is\nwithin a (2-(2/l)) factor of the weight of the optimal Steiner tree,\nwhere l is the minimum number of leaf nodes across all possible Steiner\ntrees.",
    "networkx: Tests to see if a graph is k-edge-connected., Is it impossible to disconnect the graph by removing fewer than k edges?\nIf so, then G is k-edge-connected.",
    "networkx: Bisect the graph using the Fiedler vector., This method uses the Fiedler vector to bisect a graph.\nThe partition is defined by the nodes which are associated with\neither positive or negative values in the vector.",
    "networkx: Yield the lowest common ancestor for sets of pairs in a tree.",
    "networkx: Returns True if some directed graph can realize the in- and out-degree\nsequences.",
    "networkx: Returns the Panther similarity of nodes in the graph G to node v ., Panther is a similarity metric that says “two objects are considered\nto be similar if they frequently appear on the same paths.” [1] .",
    "networkx: Returns mixing matrix for attribute.",
    "networkx: Find simple chordless cycles of a graph., A simplecycle is a closed path where no node appears twice.  In a simple\ncycle, a chord is an additional edge between two nodes in the cycle.  A chordlesscycle is a simple cycle without chords.  Said differently, a\nchordless cycle is a cycle C in a graph G where the number of edges in the\ninduced graph G[C] is equal to the length of C ., Note that some care must be taken in the case that G is not a simple graph\nnor a simple digraph.  Some authors limit the definition of chordless cycles\nto have a prescribed minimum length; we do not., In a directed graph, two chordless cycles are distinct if they are not\ncyclic permutations of each other.  In an undirected graph, two chordless\ncycles are distinct if they are not cyclic permutations of each other nor of\nthe other’s reversal., Optionally, the cycles are bounded in length., We use an algorithm strongly inspired by that of Dias et al [1] .  It has\nbeen modified in the following ways:",
    "networkx: Position nodes in two straight lines.",
    "networkx: Compute the degree centrality for nodes in a bipartite network., The degree centrality for a node v is the fraction of nodes\nconnected to it.",
    "networkx: Returns the Bethe Hessian matrix of G., The Bethe Hessian is a family of matrices parametrized by r, defined as\nH(r) = (r^2 - 1) I - r A + D where A is the adjacency matrix, D is the\ndiagonal matrix of node degrees, and I is the identify matrix. It is equal\nto the graph laplacian when the regularizer r = 1., The default choice of regularizer should be the ratio [2]",
    "networkx: Returns the graph complement of G.",
    "networkx: Returns the projection of B onto one of its node sets., Returns the graph G that is the projection of the bipartite graph B\nonto the specified nodes. They retain their attributes and are connected\nin G if they have a common neighbor in B.",
    "networkx: Given two undirected (or free) trees t1 and t2 ,\nthis routine will determine if they are isomorphic.\nIt returns the isomorphism, a mapping of the nodes of t1 onto the nodes\nof t2 , such that two trees are then identical., Note that two trees may have more than one isomorphism, and this\nroutine just returns one valid mapping.",
    "networkx: GED (graph edit distance) calculation: advanced interface., Graph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions., Graph edit distance is defined as minimum cost of edit path.",
    "networkx: Find shortest weighted paths in G from a source node., Compute shortest path between source and all other reachable\nnodes for a weighted graph.",
    "networkx: Generate nodes in a depth-first-search post-ordering starting at source.",
    "networkx: Return the Broadcast Center of the tree G ., The broadcast center of a graph G denotes the set of nodes having\nminimum broadcast time [1] . This is a linear algorithm for determining\nthe broadcast center of a tree with N nodes, as a by-product it also\ndetermines the broadcast time from the broadcast center.",
    "networkx: Generator for the n_th Mycielski Graph., The Mycielski family of graphs is an infinite set of graphs. \\(M_1\\) is the singleton graph, \\(M_2\\) is two vertices with an\nedge, and, for \\(i > 2\\) , \\(M_i\\) is the Mycielskian of \\(M_{i-1}\\) ., More information can be found at http://mathworld.wolfram.com/MycielskiGraph.html",
    "networkx: Returns HITS hubs and authorities values for nodes., The HITS algorithm computes two numbers for a node.\nAuthorities estimates the node value based on the incoming links.\nHubs estimates the node value based on outgoing links.",
    "networkx: Returns the transitive closure of a directed acyclic graph., This function is faster than the function transitive_closure , but fails\nif the graph has a cycle., The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a non-null path from v to w in G.",
    "networkx: Position nodes using Kamada-Kawai path-length cost-function.",
    "networkx: Compute the value and the node partition of a minimum (s, t)-cut., Use the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow.",
    "networkx: A read-only union of two dict MultiAdjacencies., The two input dict-of-dict-of-dict-of-dicts represent the union of G.succ and G.pred for MultiDiGraphs. Return values are UnionAdjacency.\nThe inner level of dict is read-write. But the outer levels are read-only.",
    "networkx: Returns the local constraint on the node u with respect to\nthe node v in the graph G ., Formally, the local constraint on u with respect to v , denoted \\(\\ell(u, v)\\) , is defined by, where \\(N(v)\\) is the set of neighbors of \\(v\\) and \\(p_{uv}\\) is the\nnormalized mutual weight of the (directed or undirected) edges\njoining \\(u\\) and \\(v\\) , for each vertex \\(u\\) and \\(v\\)  [1] . The mutual\nweight of \\(u\\) and \\(v\\) is the sum of the weights of edges joining\nthem (edge weights are assumed to be one if the graph is\nunweighted).",
    "networkx: Returns the Mycielskian of a simple, undirected graph G, The Mycielskian of graph preserves a graph’s triangle free\nproperty while increasing the chromatic number by 1., The Mycielski Operation on a graph, \\(G=(V, E)\\) , constructs a new\ngraph with \\(2|V| + 1\\) nodes and \\(3|E| + |V|\\) edges., The construction is as follows:, Let \\(V = {0, ..., n-1}\\) . Construct another vertex set \\(U = {n, ..., 2n}\\) and a vertex, w .\nConstruct a new graph, M , with vertices \\(U \\bigcup V \\bigcup w\\) .\nFor edges, \\((u, v) \\in E\\) add edges \\((u, v), (u, v + n)\\) , and \\((u + n, v)\\) to M. Finally, for all vertices \\(u \\in U\\) , add\nedge \\((u, w)\\) to M., The Mycielski Operation can be done multiple times by repeating the above\nprocess iteratively., More information can be found at https://en.wikipedia.org/wiki/Mycielskian",
    "networkx: Returns a graph from a dictionary of lists.",
    "networkx: Returns the (m,n)-tadpole graph; C_m connected to P_n ., This graph on m+n nodes connects a cycle of size m to a path of length n .\nIt looks like a tadpole. It is also called a kite graph or a dragon graph., ( Sourcecode , png )",
    "networkx: Generate a single line of the graph G in adjacency list format.",
    "networkx: Returns the Lollipop Graph; K_m connected to P_n ., This is the Barbell Graph without the right barbell., ( Sourcecode , png )",
    "networkx: A read-only Mapping of Mappings with filtering criteria\nfor nodes and edges., It is a view into a dict-of-dict-of-dict-of-dict data structure,\nand it selects nodes and edges that satisfy specific criteria\ndefined by NODE_OK and EDGE_OK , respectively.",
    "networkx: Color a graph using various strategies of greedy graph coloring., Attempts to color a graph using as few colors as possible, where no\nneighbors of a node can have same color as the node itself. The\ngiven strategy determines the order in which nodes are colored., The strategies are described in [1] , and smallest-last is based on [2] .",
    "networkx: Find a maximum single-commodity flow using the shortest augmenting path\nalgorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has a running time of \\(O(n^2 m)\\) for \\(n\\) nodes and \\(m\\) edges.",
    "networkx: Returns False if graphs are definitely not isomorphic., True does NOT guarantee isomorphism.",
    "networkx: Returns a directed graph with the given degree sequences.",
    "networkx: Returns a tree or list of trees chosen randomly., Returns one or more (depending on number_of_trees )\nunlabeled trees with n nodes drawn uniformly at random.",
    "networkx: Compute betweenness centrality for nodes in a bipartite network., Betweenness centrality of a node v is the sum of the\nfraction of all-pairs shortest paths that pass through v ., Values of betweenness are normalized by the maximum possible\nvalue which for bipartite graphs is limited by the relative size\nof the two node sets [1] ., Let n be the number of nodes in the node set U and m be the number of nodes in the node set V , then\nnodes in U are normalized by dividing by, where, and nodes in V are normalized by dividing by, where,",
    "networkx: Returns the modularity of the given partition of the graph., Modularity is defined in [1] as, where \\(m\\) is the number of edges (or sum of all edge weights as in [5] ), \\(A\\) is the adjacency matrix of G , \\(k_i\\) is the (weighted) degree of \\(i\\) , \\(\\gamma\\) is the resolution parameter, and \\(\\delta(c_i, c_j)\\) is 1 if \\(i\\) and \\(j\\) are in the same community else 0., According to [2] (and verified by some algebra) this can be reduced to, where the sum iterates over all communities \\(c\\) , \\(m\\) is the number of edges, \\(L_c\\) is the number of intra-community links for community \\(c\\) , \\(k_c\\) is the sum of degrees of the nodes in community \\(c\\) ,\nand \\(\\gamma\\) is the resolution parameter., The resolution parameter sets an arbitrary tradeoff between intra-group\nedges and inter-group edges. More complex grouping patterns can be\ndiscovered by analyzing the same network with multiple values of gamma\nand then combining the results [3] . That said, it is very common to\nsimply use gamma=1. More on the choice of gamma is in [4] ., The second formula is the one actually used in calculation of the modularity.\nFor directed graphs the second formula replaces \\(k_c\\) with \\(k^{in}_c k^{out}_c\\) .",
    "networkx: Iterate over edges in a depth-first-search (DFS)., Perform a depth-first-search over the nodes of G and yield\nthe edges in order. This may not generate all edges in G (see edge_dfs ).",
    "networkx: Write a graph G in GML format to the file or file handle path .",
    "networkx: Returns dict of predecessors for the path from source to all nodes in G.",
    "networkx: Returns a pydot graph from a NetworkX graph N.",
    "networkx: Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs., The algorithm has a running time of \\(O(mn)\\) where \\(n\\) is the number of\nnodes and \\(m\\) is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights.",
    "networkx: Return flattened version of (possibly nested) iterable object.",
    "networkx: Find the best partition of a graph using the Louvain Community Detection\nAlgorithm., Louvain Community Detection Algorithm is a simple method to extract the community\nstructure of a network. This is a heuristic method based on modularity optimization. [1], The algorithm works in 2 steps. On the first step it assigns every node to be\nin its own community and then for each node it tries to find the maximum positive\nmodularity gain by moving each node to all of its neighbor communities. If no positive\ngain is achieved the node remains in its original community., The modularity gain obtained by moving an isolated node \\(i\\) into a community \\(C\\) can\neasily be calculated by the following formula (combining [1]  [2] and some algebra):, where \\(m\\) is the size of the graph, \\(k_{i,in}\\) is the sum of the weights of the links\nfrom \\(i\\) to nodes in \\(C\\) , \\(k_i\\) is the sum of the weights of the links incident to node \\(i\\) , \\(\\Sigma_{tot}\\) is the sum of the weights of the links incident to nodes in \\(C\\) and \\(\\gamma\\) is the resolution parameter., For the directed case the modularity gain can be computed using this formula according to [3], where \\(k_i^{out}\\) , \\(k_i^{in}\\) are the outer and inner weighted degrees of node \\(i\\) and \\(\\Sigma_{tot}^{in}\\) , \\(\\Sigma_{tot}^{out}\\) are the sum of in-going and out-going links incident\nto nodes in \\(C\\) ., The first phase continues until no individual move can improve the modularity., The second phase consists in building a new network whose nodes are now the communities\nfound in the first phase. To do so, the weights of the links between the new nodes are given by\nthe sum of the weight of the links between nodes in the corresponding two communities. Once this\nphase is complete it is possible to reapply the first phase creating bigger communities with\nincreased modularity., The above two phases are executed until no modularity gain is achieved (or is less than\nthe threshold , or until max_levels is reached)., Be careful with self-loops in the input graph. These are treated as\npreviously reduced communities – as if the process had been started\nin the middle of the algorithm. Large self-loop edge weights thus\nrepresent strong communities and in practice may be hard to add\nother nodes to.  If your input graph edge weights for self-loops\ndo not represent already reduced communities you may want to remove\nthe self-loops before inputting that graph.",
    "networkx: Compute weighted shortest path length and predecessors., Uses Dijkstra’s Method to obtain the shortest weighted paths\nand return dictionaries of predecessors for each node and\ndistance for each node from the source .",
    "networkx: Returns True if G has a path from source to target .",
    "networkx: Returns the growing network (GN) digraph with n nodes., The GN graph is built by adding nodes one at a time with a link to one\npreviously added node.  The target node for the link is chosen with\nprobability based on degree.  The default attachment kernel is a linear\nfunction of the degree of a node., The graph is always a (directed) tree.",
    "networkx: Compute the group betweenness centrality for a group of nodes., Group betweenness centrality of a group of nodes \\(C\\) is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in \\(C\\), where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|C)\\) is the number of\nthose paths passing through some node in group \\(C\\) . Note that \\((s, t)\\) are not members of the group ( \\(V-C\\) is the set of nodes\nin \\(V\\) that are not in \\(C\\) ).",
    "networkx: Return a string of the LaTeX/TikZ code to draw G, This function produces just the code for the tikzpicture\nwithout any enclosing environment.",
    "networkx: Draw the graph G using Matplotlib., Draw the graph with Matplotlib with options for node positions,\nlabeling, titles, and many other drawing features.\nSee draw() for simple drawing without labels or axes.",
    "networkx: Parse lines of an edge list representation of a graph.",
    "networkx: A read-only Mapping of Mappings with filtering criteria for nodes and edges., It is a view into a dict-of-dict-of-dict-of-dict data structure, and it selects nodes\nand edges that meet specific criteria defined by NODE_OK and EDGE_OK .",
    "networkx: Returns a filter function that hides specific multi-directed edges.",
    "networkx: Returns a random shell graph for the constructor given.",
    "networkx: Generates a random simple graph with the given joint degree dictionary.",
    "networkx: Returns normalized cumulative distribution from discrete distribution.",
    "networkx: Returns a Waxman random graph., The Waxman random graph model places n nodes uniformly at random\nin a rectangular domain. Each pair of nodes at distance d is\njoined by an edge with probability, This function implements both Waxman models, using the L keyword\nargument.",
    "networkx: Returns a view of G with hidden nodes and edges., The resulting subgraph filters out node nodes and edges edges .\nFiltered out nodes also filter out any of their edges.",
    "networkx: Filter class to show specific nodes.",
    "networkx: Returns an iterator of all the layers in breadth-first search traversal.",
    "networkx: Write NetworkX graph G to Graphviz dot format on path.",
    "networkx: Converts a many-to-one mapping into a one-to-many mapping., many_to_one must be a dictionary whose keys and values are all hashable ., The return value is a dictionary mapping values from many_to_one to sets of keys from many_to_one that have that value., Examples",
    "networkx: Returns True if some pseudograph can realize the sequence., Every nonnegative integer sequence with an even sum is pseudographical\n(see [1] ).",
    "networkx: Returns graph from adjacency data format.",
    "networkx: Partition created by iteratively removing the highest edge betweenness edge., This algorithm works by calculating the edge betweenness for all\nedges and removing the edge with the highest value. It is then\ndetermined whether the graph has been broken into at least number_of_sets connected components.\nIf not the process is repeated.",
    "networkx: Generate edges in a minimum spanning forest of an undirected\nweighted graph., A minimum spanning tree is a subgraph of the graph (a tree)\nwith the minimum sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph.",
    "networkx: Generate lines in Pajek graph format.",
    "networkx: Write graph in Pajek format to path.",
    "networkx: An AtlasView is a Read-only Mapping of Mappings., It is a View into a dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter level is read-only.",
    "networkx: Returns a lower bound on the diameter of the graph G., The function computes a lower bound on the diameter (i.e., the maximum eccentricity)\nof a directed or undirected graph G. The procedure used varies depending on the graph\nbeing directed or not., If G is an undirected graph, then the function uses the 2-sweep algorithm [1] .\nThe main idea is to pick the farthest node from a random node and return its eccentricity., Otherwise, if G is a directed graph, the function uses the 2-dSweep algorithm [2] ,\nThe procedure starts by selecting a random source node \\(s\\) from which it performs a\nforward and a backward BFS. Let \\(a_1\\) and \\(a_2\\) be the farthest nodes in the forward and\nbackward cases, respectively. Then, it computes the backward eccentricity of \\(a_1\\) using\na backward BFS and the forward eccentricity of \\(a_2\\) using a forward BFS.\nFinally, it returns the best lower bound between the two., In both cases, the time complexity is linear with respect to the size of G.",
    "networkx: Returns a uniform random intersection graph.",
    "networkx: Iterate over all spanning trees of a graph in either increasing or\ndecreasing cost., Notes, This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges) as well as a modified Kruskal’s Algorithm\nto generate minimum spanning trees which respect the partition of edges.\nFor spanning trees with the same weight, ties are broken arbitrarily., References",
    "networkx: Returns the Estrada index of a the graph G., The Estrada Index is a topological index of folding or 3D “compactness” ( [1] ).",
    "networkx: Add a cycle to the Graph G_to_add_to.",
    "networkx: Returns a simple random graph with the given degree sequence., If the maximum degree \\(d_m\\) in the sequence is \\(O(m^{1/4})\\) then the\nalgorithm produces almost uniform random graphs in \\(O(m d_m)\\) time\nwhere \\(m\\) is the number of edges.",
    "networkx: Generate all simple paths in the graph G from source to target., A simple path is a path with no repeated nodes.",
    "networkx: Overlap weighted projection of B onto one of its node sets., The overlap weighted projection is the projection of the bipartite\nnetwork B onto the specified nodes with weights representing\nthe Jaccard index between the neighborhoods of the two nodes in the\noriginal bipartite network [1] :, or if the parameter ‘jaccard’ is False, the fraction of common\nneighbors by minimum of both nodes degree in the original\nbipartite graph [1] :, The nodes retain their attributes and are connected in the resulting\ngraph if have an edge to a common node in the original bipartite graph.",
    "networkx: Compute the reciprocity in a directed graph., The reciprocity of a directed graph is defined as the ratio\nof the number of edges pointing in both directions to the total\nnumber of edges in the graph.\nFormally, \\(r = |{(u,v) \\in G|(v,u) \\in G}| / |{(u,v) \\in G}|\\) ., The reciprocity of a single node u is defined similarly,\nit is the ratio of the number of edges in both directions to\nthe total number of edges attached to node u.",
    "networkx: Yield the articulation points, or cut vertices, of a graph., An articulation point or cut vertex is any node whose removal (along with\nall its incident edges) increases the number of connected components of\na graph.  An undirected connected graph without articulation points is\nbiconnected. Articulation points belong to more than one biconnected\ncomponent of a graph., Notice that by convention a dyad is considered a biconnected component.",
    "networkx: Returns all of the neighbors of a node in the graph., If the graph is directed returns predecessors as well as successors.",
    "networkx: Returns a Newman–Watts–Strogatz small-world graph.",
    "networkx: Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs., The algorithm has a running time of \\(O(mn)\\) where \\(n\\) is the number of\nnodes and \\(m\\) is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights., If a negative cycle is detected, you can use find_negative_cycle() to return the cycle and examine it. Shortest paths are not defined when\na negative cycle exists because once reached, the path can cycle forever\nto build up arbitrarily low weights.",
    "networkx: Returns the eccentricity of nodes in G., The eccentricity of a node v is the maximum distance from v to\nall other nodes in G.",
    "networkx: A read-only union of two inner dicts of MultiAdjacencies., The two input dict-of-dict-of-dicts represent the union of G.succ[node] and G.pred[node] for MultiDiGraphs.\nReturn values are UnionAtlas.\nThe inner level of dict is read-write. But the outer levels are read-only.",
    "networkx: Compute the generalized degree for nodes., For each node, the generalized degree shows how many edges of given\ntriangle multiplicity the node is connected to. The triangle multiplicity\nof an edge is the number of triangles an edge participates in. The\ngeneralized degree of node \\(i\\) can be written as a vector \\(\\mathbf{k}_i=(k_i^{(0)}, \\dotsc, k_i^{(N-2)})\\) where \\(k_i^{(j)}\\) is the number of edges attached to node \\(i\\) that\nparticipate in \\(j\\) triangles.",
    "networkx: Returns the number of edges in the graph., This function wraps the G.number_of_edges function.",
    "networkx: Read graph in GraphML format from path.",
    "networkx: Draw the graph G with a random layout., This is a convenience function equivalent to:",
    "networkx: Compute the average bipartite clustering coefficient., A clustering coefficient for the whole graph is the average,, where n is the number of nodes in G ., Similar measures for the two bipartite sets can be defined [1], where X is a bipartite set of G .",
    "networkx: Returns a list of nodes in a shortest path between source and target\nusing the A* (“A-star”) algorithm., There may be more than one shortest path.  This returns only one.",
    "networkx: Compute the eigenvector centrality for the graph G., Eigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node \\(i\\) is the \\(i\\) -th element of a left eigenvector associated with the eigenvalue \\(\\lambda\\) of maximum modulus that is positive. Such an eigenvector \\(x\\) is\ndefined up to a multiplicative constant by the equation, where \\(A\\) is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to, That is, adding the eigenvector centralities of the predecessors of \\(i\\) one obtains the eigenvector centrality of \\(i\\) multiplied by \\(\\lambda\\) . In the case of undirected graphs, \\(x\\) also solves the familiar\nright-eigenvector equation \\(Ax = \\lambda x\\) ., By virtue of the Perron–Frobenius theorem [1] , if G is strongly\nconnected there is a unique eigenvector \\(x\\) , and all its entries\nare strictly positive., If G is not strongly connected there might be several left\neigenvectors associated with \\(\\lambda\\) , and some of their elements\nmight be zero.",
    "networkx: Returns the diameter of the graph G., The diameter is the maximum eccentricity.",
    "networkx: Returns eigenvalues of the modularity matrix of G.",
    "networkx: Returns a SubGraph view of G showing only nodes in nbunch., The induced subgraph of a graph on a set of nodes N is the\ngraph with nodes N and edges from G which have both ends in N.",
    "networkx: Returns the small-world coefficient (sigma) of the given graph., The small-world coefficient is defined as:\nsigma = C/Cr / L/Lr\nwhere C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Cr and Lr are respectively the average\nclustering coefficient and average shortest path length of an equivalent\nrandom graph., A graph is commonly classified as small-world if sigma>1.",
    "networkx: Returns a \\(G_{n,p}\\) random graph, also known as an Erdős-Rényi graph\nor a binomial graph., The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) .",
    "networkx: Draw a planar networkx graph G with planar layout., This is a convenience function equivalent to:",
    "networkx: Returns a directed view of the graph graph ., Identical to graph.to_directed(as_view=True)\nNote that graph.to_directed defaults to as_view=False while this function always provides a view.",
    "networkx: Returns the node boundary of nbunch1 ., The node boundary of a set S with respect to a set T is the\nset of nodes v in T such that for some u in S , there is an\nedge joining u to v . If T is not specified, it is assumed to\nbe the set of all nodes not in S .",
    "networkx: Return the metric closure of a graph., The metric closure of a graph G is the complete graph in which each edge\nis weighted by the shortest path distance between the nodes in G .",
    "networkx: Returns a cycle with negative total weight if it exists., Bellman-Ford is used to find shortest_paths. That algorithm\nstops if there exists a negative cycle. This algorithm\npicks up from there and returns the found negative cycle., The cycle consists of a list of nodes in the cycle order. The last\nnode equals the first to make it a cycle.\nYou can look up the edge weights in the original graph. In the case\nof multigraphs the relevant edge is the minimal weight edge between\nthe nodes in the 2-tuple., If the graph has no negative cycle, a NetworkXError is raised.",
    "networkx: Decorator to generate a random.Random instance (or equiv)., This decorator processes random_state_argument using nx.utils.create_py_random_state() .\nThe input value can be a seed (integer), or a random number generator:",
    "networkx: ",
    "networkx: Compute node connectivity between all pairs of nodes., Pairwise or local node connectivity between two distinct and nonadjacent\nnodes is the minimum number of nodes that must be removed (minimum\nseparating cutset) to disconnect them. By Menger’s theorem, this is equal\nto the number of node independent paths (paths that share no nodes other\nthan source and target). Which is what we compute in this function., This algorithm is a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs.",
    "networkx: Returns the Google matrix of the graph.",
    "networkx: Returns the min cardinality edge cover of the graph as a set of edges., A smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered. This function follows that process. A maximum matching\nalgorithm can be specified for the first step of the algorithm.\nThe resulting set may return a set with one 2-tuple for each edge,\n(the usual case) or with both 2-tuples (u,v) and (v,u) for\neach edge. The latter is only done when a bipartite matching algorithm\nis specified as matching_algorithm .",
    "networkx: Return True if graph is directed.",
    "networkx: Returns an iterator of successors in breadth-first-search from source.",
    "networkx: Returns the average connectivity of a graph G., The average connectivity bar{kappa} of a graph G is the average\nof local node connectivity over all pairs of nodes of G [1] .",
    "networkx: Returns an m by n hexagonal lattice graph., The hexagonal lattice graph is a graph whose nodes and edges are\nthe hexagonal tiling of the plane., The returned graph will have m rows and n columns of hexagons. Odd numbered columns are shifted up relative to even numbered columns., Positions of nodes are computed by default or with_positionsisTrue .\nNode positions creating the standard embedding in the plane\nwith sidelength 1 and are stored in the node attribute ‘pos’. pos=nx.get_node_attributes(G,'pos') creates a dict ready for drawing.",
    "networkx: Returns a intersection graph with randomly chosen attribute sets for\neach node that are of equal size (k).",
    "networkx: Returns a NodeView over the graph nodes., This function wraps the G.nodes property.",
    "networkx: Returns the subgraph centrality for each node of G., Subgraph centrality  of a node n is the sum of weighted closed\nwalks of all lengths starting and ending at node n . The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ( [1] ).",
    "networkx: Returns a maximum spanning arborescence from G.",
    "networkx: Returns eigenvalues of the Laplacian of G",
    "networkx: Returns the edge expansion between two node sets., The edge expansion is the quotient of the cut size and the smaller\nof the cardinalities of the two sets. [1]",
    "networkx: Returns data in adjacency format that is suitable for JSON serialization\nand use in JavaScript documents.",
    "networkx: Returns a maximum (s, t)-flow of minimum cost., G is a digraph with edge costs and capacities. There is a source\nnode s and a sink node t. This function finds a maximum flow from\ns to t whose total cost is minimized.",
    "networkx: Returns node connectivity for a graph or digraph G., Node connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local node\nconnectivity: the minimum number of nodes that must be removed to break\nall paths from source to target in G.",
    "networkx: Returns a filter function that hides specific directed edges.",
    "networkx: Compute the in-degree centrality for nodes., The in-degree centrality for a node v is the fraction of nodes its\nincoming edges are connected to.",
    "networkx: Check if a graph is AT-free., The method uses the find_asteroidal_triple method to recognize\nan AT-free graph. If no asteroidal triple is found the graph is\nAT-free and True is returned. If at least one asteroidal triple is\nfound the graph is not AT-free and False is returned.",
    "networkx: Returns the strong product of G and H., The strong product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\(u==v\\) and \\((x,y)\\) is an edge in \\(H\\) , or \\(x==y\\) and \\((u,v)\\) is an edge in \\(G\\) , or \\((u,v)\\) is an edge in \\(G\\) and \\((x,y)\\) is an edge in \\(H\\) .",
    "networkx: Compute current-flow betweenness centrality for nodes., Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths., Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] .",
    "networkx: Returns an iterator over nodes with self loops., A node with a self loop has an edge with both ends adjacent\nto that node.",
    "networkx: Returns the rooted tree corresponding to the given nested tuple., The nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, () . A tree with k subtrees is represented\nby a tuple of length k in which each element is the nested tuple\nrepresentation of a subtree.",
    "networkx: Returns the Frucht Graph., The Frucht Graph is the smallest cubical graph whose\nautomorphism group consists only of the identity element [1] .\nIt has 12 nodes and 18 edges and no nontrivial symmetries.\nIt is planar and Hamiltonian [2] .",
    "networkx: Creates a new graph from an adjacency matrix given as a SciPy sparse\narray.",
    "networkx: Returns the disjoint union of all graphs., This operation forces distinct integer node labels starting with 0\nfor the first graph in the list and numbering consecutively.",
    "networkx: Returns a filter function that hides specific nodes.",
    "networkx: Returns the 3-regular Platonic Cubical Graph, The skeleton of the cube (the nodes and edges) form a graph, with 8\nnodes, and 12 edges. It is a special case of the hypercube graph.\nIt is one of 5 Platonic graphs, each a skeleton of its\nPlatonic solid [1] .\nSuch graphs arise in parallel processing in computers.",
    "networkx: Returns the k-corona of G., The k-corona is the subgraph of nodes in the k-core which have\nexactly k neighbors in the k-core.",
    "networkx: A generator of all possible triads in G.",
    "networkx: Compute the average degree connectivity of graph., The average degree connectivity is the average nearest neighbor degree of\nnodes with degree k. For weighted graphs, an analogous measure can\nbe computed using the weighted average neighbors degree defined in [1] , for a node i , as, where s_i is the weighted degree of node i , w_{ij} is the weight of the edge that links i and j ,\nand N(i) are the neighbors of node i .",
    "networkx: Returns the reverse directed graph of G.",
    "networkx: Returns the average degree of the neighborhood of each node., In an undirected graph, the neighborhood N(i) of node i contains the\nnodes that are connected to i by an edge., For directed graphs, N(i) is defined according to the parameter source :, The average neighborhood degree of a node i is, where N(i) are the neighbors of node i and k_j is\nthe degree of node j which belongs to N(i) . For weighted\ngraphs, an analogous measure can be defined [1] ,, where s_i is the weighted degree of node i , w_{ij} is the weight of the edge that links i and j and N(i) are the neighbors of node i .",
    "networkx: Generate weakly connected components of G.",
    "networkx: Make a tree for the given degree sequence., A tree has #nodes-#edges=1 so\nthe degree sequence must have\nlen(deg_sequence)-sum(deg_sequence)/2=1",
    "networkx: Returns the graph that results from contracting u and v ., Node contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes.",
    "networkx: Determines whether a node is an isolate., An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.",
    "networkx: Returns transitive reduction of a directed graph, The transitive reduction of G = (V,E) is a graph G- = (V,E-) such that\nfor all v,w in V there is an edge (v,w) in E- if and only if (v,w) is\nin E and there is no path from v to w in G with length greater than 1.",
    "networkx: Write the graph G in multiline adjacency list format to path",
    "networkx: Returns all minimum-cost edit paths transforming G1 to G2., Graph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions.",
    "networkx: Returns the shortest path from source to target in a weighted graph G.",
    "networkx: Generate nodes in a depth-first-search pre-ordering starting at source.",
    "networkx: Returns the Voronoi cells centered at center_nodes with respect\nto the shortest-path distance metric., If \\(C\\) is a set of nodes in the graph and \\(c\\) is an element of \\(C\\) ,\nthe Voronoi cell centered at a node \\(c\\) is the set of all nodes \\(v\\) that are closer to \\(c\\) than to any other center node in \\(C\\) with\nrespect to the shortest-path distance metric. [1], For directed graphs, this will compute the “outward” Voronoi cells,\nas defined in [1] , in which distance is measured from the center\nnodes to the target node. For the “inward” Voronoi cells, use the DiGraph.reverse() method to reverse the orientation of the\nedges before invoking this function on the directed graph.",
    "networkx: Newman’s weighted projection of B onto one of its node sets., The collaboration weighted projection is the projection of the\nbipartite network B onto the specified nodes with weights assigned\nusing Newman’s collaboration model [1] :, where u and v are nodes from the bottom bipartite node set,\nand k is a node of the top node set.\nThe value d_k is the degree of node k in the bipartite\nnetwork and delta_{u}^{k} is 1 if node u is\nlinked to node k in the original bipartite graph or 0 otherwise., The nodes retain their attributes and are connected in the resulting\ngraph if have an edge to a common node in the original bipartite\ngraph.",
    "networkx: Compute current-flow closeness centrality for nodes., Current-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality.",
    "networkx: Returns a minimum weight cycle basis for G, Minimum weight means a cycle basis for which the total weight\n(length for unweighted graphs) of all the cycles is minimum.",
    "networkx: Returns the k-core of G., A k-core is a maximal subgraph that contains nodes of degree k or more.",
    "networkx: Returns the total weight of all spanning trees of G ., Kirchoff’s Tree Matrix Theorem [1] , [2] states that the determinant of any\ncofactor of the Laplacian matrix of a graph is the number of spanning trees\nin the graph. For a weighted Laplacian matrix, it is the sum across all\nspanning trees of the multiplicative weight of each tree. That is, the\nweight of each tree is the product of its edge weights., For unweighted graphs, the total weight equals the number of spanning trees in G ., For directed graphs, the total weight follows by summing over all directed\nspanning trees in G that start in the root node [3] .",
    "networkx: Computes the node redundancy coefficients for the nodes in the bipartite\ngraph G ., The redundancy coefficient of a node v is the fraction of pairs of\nneighbors of v that are both linked to other nodes. In a one-mode\nprojection these nodes would be linked together even if v were\nnot there., More formally, for any vertex v , the redundancy coefficient of `v` is\ndefined by, where N(v) is the set of neighbors of v in G .",
    "networkx: Returns the composition of all graphs., Composition is the simple union of the node sets and edge sets.\nThe node sets of the supplied graphs need not be disjoint.",
    "networkx: Returns an approximate maximum independent set., Independent set or stable set is a set of vertices in a graph, no two of\nwhich are adjacent. That is, it is a set I of vertices such that for every\ntwo vertices in I, there is no edge connecting the two. Equivalently, each\nedge in the graph has at most one endpoint in I. The size of an independent\nset is the number of vertices it contains [1] ., A maximum independent set is a largest independent set for a given graph G\nand its size is denoted \\(\\alpha(G)\\) . The problem of finding such a set is called\nthe maximum independent set problem and is an NP-hard optimization problem.\nAs such, it is unlikely that there exists an efficient algorithm for finding\na maximum independent set of a graph., The Independent Set algorithm is based on [2] .",
    "networkx: Returns a NetworkX graph from a dot file on path.",
    "networkx: Read a graph as list of edges with numeric weights.",
    "networkx: Returns the circular ladder graph \\(CL_n\\) of length n., \\(CL_n\\) consists of two concentric n-cycles in which\neach of the n pairs of concentric nodes are joined by an edge., Node labels are the integers 0 to n-1, ( Sourcecode , png )",
    "networkx: Returns iterator of node-attribute pairs for all edges in G.",
    "networkx: Returns a Watts–Strogatz small-world graph.",
    "networkx: Compute current-flow betweenness centrality for subsets of nodes., Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths., Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] .",
    "networkx: Returns a numpy.random.RandomState or numpy.random.Generator instance\ndepending on input.",
    "networkx: Returns an iterator of predecessors in breadth-first-search from source.",
    "networkx: Create node positions using pydot and Graphviz.",
    "networkx: Returns the specified power of a graph., The \\(k`th power of a simple graph :math:`G\\) , denoted \\(G^k\\) , is a\ngraph on the same set of nodes in which two distinct nodes \\(u\\) and \\(v\\) are adjacent in \\(G^k\\) if and only if the shortest path\ndistance between \\(u\\) and \\(v\\) in \\(G\\) is at most \\(k\\) .",
    "networkx: Generate an ordering (permutation) of the graph nodes to make\na sparse matrix., Uses the Cuthill-McKee heuristic (based on breadth-first search) [1] .",
    "networkx: Returns a random graph with given expected degrees., Given a sequence of expected degrees \\(W=(w_0,w_1,\\ldots,w_{n-1})\\) of length \\(n\\) this algorithm assigns an edge between node \\(u\\) and\nnode \\(v\\) with probability",
    "networkx: Returns a Hamiltonian path in the given tournament graph., Each tournament has a Hamiltonian path. If furthermore, the\ntournament is strongly connected, then the returned Hamiltonian path\nis a Hamiltonian cycle (by joining the endpoints of the path).",
    "networkx: Compute the trophic differences of the edges of a directed graph., The trophic difference \\(x_ij\\) for each edge is defined in Johnson et al. [1] as:, Where \\(s_i\\) is the trophic level of node \\(i\\) .",
    "networkx: Returns the 3-regular Platonic Tetrahedral graph., Tetrahedral graph has 4 nodes and 6 edges. It is a\nspecial case of the complete graph, K4, and wheel graph, W4.\nIt is one of the 5 platonic graphs [1] .",
    "networkx: Returns True if and only if G is Eulerian., A graph is Eulerian if it has an Eulerian circuit. An Eulerian\ncircuit is a closed walk that includes each edge of a graph exactly\nonce., Graphs with isolated vertices (i.e. vertices with zero degree) are not\nconsidered to have Eulerian circuits. Therefore, if the graph is not\nconnected (or not strongly connected, for directed graphs), this function\nreturns False.",
    "networkx: Returns the triad graph with the given name., Each string in the following tuple is a valid triad name:, Each triad name corresponds to one of the possible valid digraph on\nthree nodes.",
    "networkx: Returns a minimum weight full matching of the bipartite graph G ., Let \\(G = ((U, V), E)\\) be a weighted bipartite graph with real weights \\(w : E \\to \\mathbb{R}\\) . This function then produces a matching \\(M \\subseteq E\\) with cardinality, which minimizes the sum of the weights of the edges included in the\nmatching, \\(\\sum_{e \\in M} w(e)\\) , or raises an error if no such\nmatching exists., When \\(\\lvert U \\rvert = \\lvert V \\rvert\\) , this is commonly\nreferred to as a perfect matching; here, since we allow \\(\\lvert U \\rvert\\) and \\(\\lvert V \\rvert\\) to differ, we\nfollow Karp [1] and refer to the matching as full .",
    "networkx: Compute load centrality for nodes., The load centrality of a node is the fraction of all shortest\npaths that pass through that node.",
    "networkx: Finds communities in a graph using the Girvan–Newman method.",
    "networkx: A directed, breadth-first-search of edges in G , beginning at source ., Yield the edges of G in a breadth-first-search order continuing until\nall edges are generated.",
    "networkx: Returns a random permutation of the nodes of G as a list., G is a NetworkX graph. colors is ignored.",
    "networkx: Returns the number of nodes in the graph., This function wraps the G.number_of_nodes function.",
    "networkx: Returns a list of the nodes of G in decreasing order by\ndegree., G is a NetworkX graph. colors is ignored.",
    "networkx: Return the Moral Graph, Returns the moralized graph of a given directed graph.",
    "networkx: Returns a deque of the nodes of G , “smallest” last., Specifically, the degrees of each node are tracked in a bucket queue.\nFrom this, the node of minimum degree is repeatedly popped from the\ngraph, updating its neighbors’ degrees., G is a NetworkX graph. colors is ignored., This implementation of the strategy runs in \\(O(n + m)\\) time\n(ignoring polylogarithmic factors), where \\(n\\) is the number of nodes\nand \\(m\\) is the number of edges., This strategy is related to strategy_independent_set() : if we\ninterpret each node removed as an independent set of size one, then\nthis strategy chooses an independent set of size one instead of a\nmaximal independent set.",
    "networkx: Returns a minimum branching from G.",
    "networkx: Returns a random graph with the given degree sequence., The configuration model generates a random pseudograph (graph with\nparallel edges and self loops) by randomly assigning edges to\nmatch the given degree sequence.",
    "networkx: Returns communities in G as detected by asynchronous label\npropagation., The asynchronous label propagation algorithm is described in [1] . The algorithm is probabilistic and the found communities may\nvary on different executions., The algorithm proceeds as follows. After initializing each node with\na unique label, the algorithm repeatedly sets the label of a node to\nbe the label that appears most frequently among that nodes\nneighbors. The algorithm halts when each node has the label that\nappears most frequently among its neighbors. The algorithm is\nasynchronous because each node is updated without waiting for\nupdates on the remaining nodes., This generalized version of the algorithm in [1] accepts edge\nweights.",
    "networkx: Returns the edge connectivity of the graph or digraph G., The edge connectivity is equal to the minimum number of edges that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local edge\nconnectivity: the minimum number of edges that must be removed to\nbreak all paths from source to target in G.",
    "networkx: Compute a bipartite clustering coefficient for nodes., The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :, where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v ., The mode selects the function for c_{uv} which can be:, dot :, min :, max :",
    "networkx: Stratifies a DAG into generations., A topological generation is node collection in which ancestors of a node in each\ngeneration are guaranteed to be in a previous generation, and any descendants of\na node are guaranteed to be in a following generation. Nodes are guaranteed to\nbe in the earliest possible generation that they can belong to.",
    "networkx: A read-only Mapping of Mappings with filtering criteria for nodes and edges., It is a view into a dict-of-dict-of-dict data structure, and it selects nodes\nand edges that satisfy specific criteria defined by NODE_OK and EDGE_OK ,\nrespectively.",
    "networkx: Returns a SciPy sparse array using attributes from G., If only G is passed in, then the adjacency matrix is constructed., Let A be a discrete set of values for the node attribute node_attr . Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in G and consider the value\nof the edge attribute edge_attr .  If ua and va are the values of the\nnode attribute node_attr for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va).",
    "networkx: Returns an iterator over the edges of an Eulerian circuit in G ., An Eulerian circuit is a closed walk that includes each edge of a\ngraph exactly once.",
    "networkx: Determines whether the graph G is a regular graph., A regular graph is a graph where each vertex has the same degree. A\nregular digraph is a graph where the indegree and outdegree of each\nvertex are equal.",
    "networkx: Returns a random lobster graph., A lobster is a tree that reduces to a caterpillar when pruning all\nleaf nodes. A caterpillar is a tree that reduces to a path graph\nwhen pruning all leaf nodes; setting p2 to zero produces a caterpillar., This implementation iterates on the probabilities p1 and p2 to add\nedges at levels 1 and 2, respectively. Graphs are therefore constructed\niteratively with uniform randomness at each level rather than being selected\nuniformly at random from the set of all possible lobsters.",
    "networkx: Find a maximal matching in the graph., A matching is a subset of edges in which no node occurs more than once.\nA maximal matching cannot add more edges and still be a matching.",
    "networkx: Iterate over local bridges of G optionally computing the span, A local bridge is an edge whose endpoints have no common neighbors.\nThat is, the edge is not part of a triangle in the graph., The span of a local bridge is the shortest path length between\nthe endpoints if the local bridge is removed.",
    "networkx: Decides whether the given tournament is strongly connected., This function is more theoretically efficient than the is_strongly_connected() function., The given graph must be a tournament, otherwise this function’s\nbehavior is undefined.",
    "networkx: s -> (s0, s1), (s1, s2), (s2, s3), …",
    "networkx: Returns a random regular expander graph on \\(n\\) nodes with degree \\(d\\) ., An expander graph is a sparse graph with strong connectivity properties. [1], More precisely the returned graph is a \\((n, d, \\lambda)\\) -expander with \\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\) , close to the Alon-Boppana bound. [2], In the case where \\(\\epsilon = 0\\) it returns a Ramanujan graph.\nA Ramanujan graph has spectral gap almost as large as possible,\nwhich makes them excellent expanders. [3]",
    "networkx: Partition created by removing the highest edge current flow betweenness edge., This algorithm works by calculating the edge current flow\nbetweenness for all edges and removing the edge with the\nhighest value. It is then determined whether the graph has\nbeen broken into at least number_of_sets connected\ncomponents. If not the process is repeated.",
    "networkx: Returns a connected caveman graph of l cliques of size k ., The connected caveman graph is formed by creating n cliques of size k , then a single edge in each clique is rewired to a node in an\nadjacent clique.",
    "networkx: Compute shortest path between source\nand all other nodes reachable from source.",
    "networkx: Returns the graph adjacency matrix as a NumPy array.",
    "networkx: Write graph G in single-line adjacency-list format to path.",
    "networkx: Return list of ints from sequence of integral numbers., All elements of the sequence must satisfy int(element) == element\nor a ValueError is raised. Sequence is iterated through once., If sequence is a list, the non-int values are replaced with ints.\nSo, no new list is created",
    "networkx: Returns the \\(m\\) by \\(n\\) triangular lattice graph., The triangular lattice graph is a two-dimensional grid graph in\nwhich each square unit has a diagonal edge (each grid unit has a chord)., The returned graph has \\(m\\) rows and \\(n\\) columns of triangles. Rows and\ncolumns include both triangles pointing up and down. Rows form a strip\nof constant height. Columns form a series of diamond shapes, staggered\nwith the columns on either side. Another way to state the size is that\nthe nodes form a grid of m+1 rows and (n+1)//2 columns.\nThe odd row nodes are shifted horizontally relative to the even rows., Directed graph types have edges pointed up or right., Positions of nodes are computed by default or with_positionsisTrue .\nThe position of each node (embedded in a euclidean plane) is stored in\nthe graph using equilateral triangles with sidelength 1.\nThe height between rows of nodes is thus \\(\\sqrt(3)/2\\) .\nNodes lie in the first quadrant with the node \\((0, 0)\\) at the origin.",
    "networkx: Returns the random partition graph with a partition of sizes., A partition graph is a graph of communities with sizes defined by\ns in sizes. Nodes in the same group are connected with probability\np_in and nodes of different groups are connected with probability\np_out.",
    "networkx: Returns the edge boundary of nbunch1 ., The edge boundary of a set S with respect to a set T is the\nset of edges ( u , v ) such that u is in S and v is in T .\nIf T is not specified, it is assumed to be the set of all nodes\nnot in S .",
    "networkx: Read a bipartite graph from a list of edges.",
    "networkx: Returns a labeled rooted forest with n nodes., The returned forest is chosen uniformly at random using a\ngeneralization of Prüfer sequences [1] in the form described in [2] .",
    "networkx: Returns the small-world coefficient (omega) of a graph, The small-world coefficient of a graph G is:, omega = Lr/L - C/Cl, where C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Lr is the average shortest path length\nof an equivalent random graph and Cl is the average clustering coefficient\nof an equivalent lattice graph., The small-world coefficient (omega) measures how much G is like a lattice\nor a random graph. Negative values mean G is similar to a lattice whereas\npositive values mean G is a random graph.\nValues close to 0 mean that G has small-world characteristics.",
    "networkx: Returns a minimum spanning tree or forest on an undirected graph G .",
    "networkx: Returns True if G is a forest., A forest is a graph with no undirected cycles., For directed graphs, G is a forest if the underlying graph is a forest.\nThe underlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph.",
    "networkx: Compute the group closeness centrality for a group of nodes., Group closeness centrality of a group of nodes \\(S\\) is a measure\nof how close the group is to the other nodes in the graph., where \\(V\\) is the set of nodes, \\(d_{S, v}\\) is the distance of\nthe group \\(S\\) from \\(v\\) defined as above. ( \\(V-S\\) is the set of nodes\nin \\(V\\) that are not in \\(S\\) ).",
    "networkx: Returns the volume of a set of nodes., The volume of a set S is the sum of the (out-)degrees of nodes\nin S (taking into account parallel edges in multigraphs). [1]",
    "networkx: Compute harmonic centrality for nodes., Harmonic centrality [1] of a node u is the sum of the reciprocal\nof the shortest path distances from all other nodes to u, where d(v,u) is the shortest-path distance between v and u ., If sources is given as an argument, the returned harmonic centrality\nvalues are calculated as the sum of the reciprocals of the shortest\npath distances from the nodes specified in sources to u instead\nof from all nodes to u ., Notice that higher values indicate higher centrality.",
    "networkx: Create node positions for G using Graphviz.",
    "networkx: Estimates the average clustering coefficient of G., The local clustering of each node in G is the fraction of triangles\nthat actually exist over all possible triangles in its neighborhood.\nThe average clustering coefficient of a graph G is the mean of\nlocal clusterings., This function finds an approximate average clustering coefficient\nfor G by repeating n times (defined in trials ) the following\nexperiment: choose a node at random, choose two of its neighbors\nat random, and check if they are connected. The approximate\ncoefficient is the fraction of triangles found over the number\nof trials [1] .",
    "networkx: Returns the circulant graph \\(Ci_n(x_1, x_2, ..., x_m)\\) with \\(n\\) nodes., The circulant graph \\(Ci_n(x_1, ..., x_m)\\) consists of \\(n\\) nodes \\(0, ..., n-1\\) such that node \\(i\\) is connected to nodes \\((i + x) \\mod n\\) and \\((i - x) \\mod n\\) for all \\(x\\) in \\(x_1, ..., x_m\\) . Thus \\(Ci_n(1)\\) is a cycle graph., ( Sourcecode , png )",
    "networkx: Iterates over all the nodes of G in “saturation order” (also\nknown as “DSATUR”)., G is a NetworkX graph. colors is a dictionary mapping nodes of G to colors, for those nodes that have already been colored.",
    "networkx: Read graph in LEDA format from string or iterable.",
    "networkx: Draw the nodes of the graph G., This draws only the nodes of the graph G.",
    "networkx: Return True iff G is semi-Eulerian., G is semi-Eulerian if it has an Eulerian path but no Eulerian circuit.",
    "networkx: Provides an equitable coloring for nodes of G ., Attempts to color a graph using num_colors colors, where no neighbors of\na node can have same color as the node itself and the number of nodes with\neach color differ by at most 1. num_colors must be greater than the\nmaximum degree of G . The algorithm is described in [1] and has\ncomplexity O(num_colors * n**2).",
    "networkx: Parse lines of a graph adjacency list representation.",
    "networkx: Returns a connected Watts–Strogatz small-world graph., Attempts to generate a connected graph by repeated generation of\nWatts–Strogatz small-world graphs.  An exception is raised if the maximum\nnumber of tries is exceeded.",
    "networkx: Returns a new graph that contains only the nodes and the edges that exist in\nall graphs.",
    "networkx: Returns the conductance of two sets of nodes., The conductance is the quotient of the cut size and the smaller of\nthe volumes of the two sets. [1]",
    "networkx: Returns a random triad from a directed graph.",
    "networkx: Returns local edge connectivity for nodes s and t in G., Local edge connectivity for two nodes s and t is the minimum number\nof edges that must be removed to disconnect them., This is a flow based implementation of edge connectivity. We compute the\nmaximum flow on an auxiliary digraph build from the original\nnetwork (see below for details). This is equal to the local edge\nconnectivity because the value of a maximum s-t-flow is equal to the\ncapacity of a minimum s-t-cut (Ford and Fulkerson theorem) [1] .",
    "networkx: Creates a summary graph based on attributes and connectivity., This function uses the Summarization by Grouping Nodes on Attributes\nand Pairwise edges (SNAP) algorithm for summarizing a given\ngraph by grouping nodes by node attributes and their edge attributes\ninto supernodes in a summary graph.  This name SNAP should not be\nconfused with the Stanford Network Analysis Project (SNAP)., Here is a high-level view of how this algorithm works:, 2) Iteratively split groups until all nodes in each group have edges\nto nodes in the same groups. That is, until all the groups are homogeneous\nin their member nodes’ edges to other groups.  For example,\nif all the nodes in group A only have edge to nodes in group B, then the\ngroup is homogeneous and does not need to be split. If all nodes in group B\nhave edges with nodes in groups {A, C}, but some also have edges with other\nnodes in B, then group B is not homogeneous and needs to be split into\ngroups have edges with {A, C} and a group of nodes having\nedges with {A, B, C}.  This way, viewers of the summary graph can\nassume that all nodes in the group have the exact same node attributes and\nthe exact same edges., 3) Build the output summary graph, where the groups are represented by\nsuper-nodes. Edges represent the edges shared between all the nodes in each\nrespective groups., A SNAP summary graph can be used to visualize graphs that are too large to display\nor visually analyze, or to efficiently identify sets of similar nodes with similar connectivity\npatterns to other sets of similar nodes based on specified node and/or edge attributes in a graph.",
    "networkx: Compute the average clustering coefficient for the graph G., The clustering coefficient for the graph is the average,, where \\(n\\) is the number of nodes in G .",
    "networkx: Returns True if the graph is connected, False otherwise.",
    "networkx: Returns a soft random geometric graph in the unit cube., The soft random geometric graph [1] model places n nodes uniformly at\nrandom in the unit cube in dimension dim . Two nodes of distance, dist ,\ncomputed by the p -Minkowski distance metric are joined by an edge with\nprobability p_dist if the computed distance metric value of the nodes\nis at most radius , otherwise they are not joined., Edges within radius of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) .",
    "networkx: Find k-clique communities in graph using the percolation method., A k-clique community is the union of all cliques of size k that\ncan be reached through adjacent (sharing k-1 nodes) k-cliques.",
    "networkx: Returns a junction tree of a given graph., A junction tree (or clique tree) is constructed from a (un)directed graph G.\nThe tree is constructed based on a moralized and triangulated version of G.\nThe tree’s nodes consist of maximal cliques and sepsets of the revised graph.\nThe sepset of two cliques is the intersection of the nodes of these cliques,\ne.g. the sepset of (A,B,C) and (A,C,E,F) is (A,C). These nodes are often called\n“variables” in this literature. The tree is bipartite with each sepset\nconnected to its two cliques., Junction Trees are not unique as the order of clique consideration determines\nwhich sepsets are included., The junction tree algorithm consists of five steps [1] :",
    "networkx: Read graph in multi-line adjacency list format from path.",
    "networkx: Returns incidence matrix of G., The incidence matrix assigns each row to a node and each column to an edge.\nFor a standard incidence matrix a 1 appears wherever a row’s node is\nincident on the column’s edge.  For an oriented incidence matrix each\nedge is assigned an orientation (arbitrarily for undirected and aligning to\ndirection for directed).  A -1 appears for the source (tail) of an edge and\n1 for the destination (head) of the edge.  The elements are zero otherwise.",
    "networkx: Creates a directed graph D from an undirected graph G to compute flow\nbased node connectivity., For an undirected graph G having n nodes and m edges we derive a\ndirected graph D with 2n nodes and 2m+n arcs by replacing each\noriginal node v with two nodes vA , vB linked by an (internal)\narc in D. Then for each edge ( u , v ) in G we add two arcs ( uB , vA )\nand ( vB , uA ) in D. Finally we set the attribute capacity = 1 for each\narc in D [1] ., For a directed graph having n nodes and m arcs we derive a\ndirected graph D with 2n nodes and m+n arcs by replacing each\noriginal node v with two nodes vA , vB linked by an (internal)\narc ( vA , vB ) in D. Then for each arc ( u , v ) in G we add one\narc ( uB , vA ) in D. Finally we set the attribute capacity = 1 for\neach arc in D., A dictionary with a mapping between nodes in the original graph and the\nauxiliary digraph is stored as a graph attribute: D.graph[‘mapping’]., References",
    "networkx: Returns the chordal cycle graph on p nodes., The returned graph is a cycle graph on p nodes with chords joining each\nvertex x to its inverse modulo p . This graph is a (mildly explicit)\n3-regular expander [1] ., p  must be a prime number.",
    "networkx: Iterate over all spanning arborescences of a graph in either increasing or\ndecreasing cost., Notes, This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges). It generates minimum spanning\narborescences using a modified Edmonds’ Algorithm which respects the\npartition of edges. For arborescences with the same weight, ties are\nbroken arbitrarily., References",
    "networkx: Returns the maximal clique graph of the given graph., The nodes of the maximal clique graph of G are the cliques of G and an edge joins two cliques if the cliques are not disjoint.",
    "networkx: Checks whether the given directed joint degree input is realizable",
    "networkx: Return the CCPA score for each pair of nodes., Compute the Common Neighbor and Centrality based Parameterized Algorithm(CCPA)\nscore of all node pairs in ebunch., CCPA score of u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) , \\(\\Gamma(v)\\) denotes the\nset of neighbors of \\(v\\) , \\(\\alpha\\) is  parameter varies between [0,1], \\(N\\) denotes\ntotal number of nodes in the Graph and \\({d}_{uv}\\) denotes shortest distance\nbetween \\(u\\) and \\(v\\) ., This algorithm is based on two vital properties of nodes, namely the number\nof common neighbors and their centrality. Common neighbor refers to the common\nnodes between two nodes. Centrality refers to the prestige that a node enjoys\nin a network.",
    "networkx: Returns scaled position array to (-scale, scale) in all axes., The function acts on NumPy arrays which hold position information.\nEach position is one row of the array. The dimension of the space\nequals the number of columns. Each coordinate in one column., To rescale, the mean (center) is subtracted from each axis separately.\nThen all values are scaled so that the largest magnitude value\nfrom all axes equals scale (thus, the aspect ratio is preserved).\nThe resulting NumPy Array is returned (order of rows unchanged).",
    "networkx: Find shortest weighted paths and lengths from a source node., Compute the shortest path length between source and all other\nreachable nodes for a weighted graph., Uses Dijkstra’s algorithm to compute shortest paths and lengths\nbetween a source and all other reachable nodes in a weighted graph.",
    "networkx: Returns coappearance network of characters in the novel Les Miserables., References",
    "networkx: Return a Visibility Graph of an input Time Series., A visibility graph converts a time series into a graph. The constructed graph\nuses integer nodes to indicate which event in the series the node represents.\nEdges are formed as follows: consider a bar plot of the series and view that\nas a side view of a landscape with a node at the top of each bar. An edge\nmeans that the nodes can be connected by a straight “line-of-sight” without\nbeing obscured by any bars between the nodes., The resulting graph inherits several properties of the series in its structure.\nThereby, periodic series convert into regular graphs, random series convert\ninto random graphs, and fractal series convert into scale-free networks [1] .",
    "networkx: Return True if matching is a maximal matching of G, A maximal matching in a graph is a matching in which adding any\nedge would cause the set to no longer be a valid matching.",
    "networkx: Returns the spectral bipartivity.",
    "networkx: Yields partitions for each level of the Louvain Community Detection Algorithm, Louvain Community Detection Algorithm is a simple method to extract the community\nstructure of a network. This is a heuristic method based on modularity optimization. [1], The partitions at each level (step of the algorithm) form a dendrogram of communities.\nA dendrogram is a diagram representing a tree and each level represents\na partition of the G graph. The top level contains the smallest communities\nand as you traverse to the bottom of the tree the communities get bigger\nand the overall modularity increases making the partition better., Each level is generated by executing the two phases of the Louvain Community\nDetection Algorithm., Be careful with self-loops in the input graph. These are treated as\npreviously reduced communities – as if the process had been started\nin the middle of the algorithm. Large self-loop edge weights thus\nrepresent strong communities and in practice may be hard to add\nother nodes to.  If your input graph edge weights for self-loops\ndo not represent already reduced communities you may want to remove\nthe self-loops before inputting that graph.",
    "networkx: Returns a cycle found via depth-first traversal., The cycle is a list of edges indicating the cyclic path.\nOrientation of directed edges is controlled by orientation .",
    "networkx: Returns True if graph is frozen.",
    "networkx: Returns the Ladder graph of length n., This is two paths of n nodes, with\neach pair connected by a single edge., Node labels are the integers 0 to 2*n - 1., ( Sourcecode , png )",
    "networkx: Compute the ratio of within- and inter-cluster common neighbors\nof all node pairs in ebunch., For two nodes u and v , if a common neighbor w belongs to the\nsame community as them, w is considered as within-cluster common\nneighbor of u and v . Otherwise, it is considered as\ninter-cluster common neighbor of u and v . The ratio between the\nsize of the set of within- and inter-cluster common neighbors is\ndefined as the WIC measure. [1]",
    "networkx: Returns a random k -out graph with preferential attachment., A random k -out graph with preferential attachment is a\nmultidigraph generated by the following algorithm., For more information on this model of random graph, see [1].",
    "networkx: Return the cubic graph specified in LCF notation., LCF (Lederberg-Coxeter-Fruchte) notation[R8553aaaa836a-1]_ is a compressed\nnotation used in the generation of various cubic Hamiltonian\ngraphs of high symmetry. See, for example, dodecahedral_graph , desargues_graph , heawood_graph and pappus_graph ., Nodes are drawn from range(n) . Each node n_i is connected with\nnode n_i+shift%n where shift is given by cycling through\nthe input shift_list  repeat s times.",
    "networkx: Returns adjacency representation of graph as a dictionary of dictionaries.",
    "networkx: Returns a random.Random instance depending on input.",
    "networkx: Compute shortest path lengths in the graph.",
    "networkx: Returns a dictionary representation of mixing matrix.",
    "networkx: Compute the out-degree centrality for nodes., The out-degree centrality for a node v is the fraction of nodes its\noutgoing edges are connected to.",
    "networkx: Read a graph from a list of edges.",
    "networkx: Returns the Tutte polynomial of G, This function computes the Tutte polynomial via an iterative version of\nthe deletion-contraction algorithm., The Tutte polynomial T_G(x,y) is a fundamental graph polynomial invariant in\ntwo variables. It encodes a wide array of information related to the\nedge-connectivity of a graph; “Many problems about graphs can be reduced to\nproblems of finding and evaluating the Tutte polynomial at certain values” [1] .\nIn fact, every deletion-contraction-expressible feature of a graph is a\nspecialization of the Tutte polynomial [2] (see Notes for examples)., There are several equivalent definitions; here are three:, Def 1 (rank-nullity expansion): For G an undirected graph, n(G) the\nnumber of vertices of G , E the edge set of G , V the vertex set of G , and c(A) the number of connected components of the graph with vertex\nset V and edge set A  [3] :, Def 2 (spanning tree expansion): Let G be an undirected graph, T a spanning\ntree of G , and E the edge set of G . Let E have an arbitrary strict\nlinear order L . Let B_e be the unique minimal nonempty edge cut of \\(E \\setminus T \\cup {e}\\) . An edge e is internally active with respect to T and L if e is the least edge in B_e according to the linear order L . The internal activity of T (denoted i(T) ) is the number of edges\nin \\(E \\setminus T\\) that are internally active with respect to T and L .\nLet P_e be the unique path in \\(T \\cup {e}\\) whose source and target vertex\nare the same. An edge e is externally active with respect to T and L if e is the least edge in P_e according to the linear order L . The\nexternal activity of T (denoted e(T) ) is the number of edges in \\(E \\setminus T\\) that are externally active with respect to T and L .\nThen [4]  [5] :, Def 3 (deletion-contraction recurrence): For G an undirected graph, G-e the graph obtained from G by deleting edge e , G/e the graph obtained\nfrom G by contracting edge e , k(G) the number of cut-edges of G ,\nand l(G) the number of self-loops of G :",
    "networkx: Returns whether or not the specified path exists., For it to return True, every node on the path must exist and\neach consecutive pair must be connected via one or more edges.",
    "networkx: Returns a random \\(d\\) -regular graph on \\(n\\) nodes., A regular graph is a graph where each node has the same number of neighbors., The resulting graph has no self-loops or parallel edges.",
    "networkx: Returns the radius of the graph G., The radius is the minimum eccentricity.",
    "networkx: Returns the normalized size of the cut between two sets of nodes., The normalized cut size is the cut size times the sum of the\nreciprocal sizes of the volumes of the two sets. [1]",
    "networkx: Returns a read-only view of G ., The graph G and its attributes are not copied but viewed through the new graph object\nof the same class as G (or of the class specified in create_using ).",
    "networkx: A read-only union of dict Adjacencies as a Map of Maps of Maps., The two input dict-of-dict-of-dicts represent the union of G.succ and G.pred . Return values are UnionAtlas\nThe inner level of dict is read-write. But the\nmiddle and outer levels are read-only., succ : a dict-of-dict-of-dict {node: nbrdict}\npred : a dict-of-dict-of-dict {node: nbrdict}\nThe keys for the two dicts should be the same",
    "networkx: Returns a copy of the graph G with all of the edges removed.",
    "networkx: Returns a \\(G_{n,m}\\) random graph., In the \\(G_{n,m}\\) model, a graph is chosen uniformly at random from the set\nof all graphs with \\(n\\) nodes and \\(m\\) edges., This algorithm should be faster than gnm_random_graph() for dense\ngraphs.",
    "networkx: Returns False if graphs are definitely not isomorphic.\nTrue does NOT guarantee isomorphism.",
    "networkx: Returns the average shortest path length., The average shortest path length is, where V is the set of nodes in G , d(s,t) is the shortest path from s to t ,\nand n is the number of nodes in G .",
    "networkx: Returns the number of spanning trees in G ., A spanning tree for an undirected graph is a tree that connects\nall nodes in the graph. For a directed graph, the analog of a\nspanning tree is called a (spanning) arborescence. The arborescence\nincludes a unique directed path from the root node to each other node.\nThe graph must be weakly connected, and the root must be a node\nthat includes all nodes as successors [3] . Note that to avoid\ndiscussing sink-roots and reverse-arborescences, we have reversed\nthe edge orientation from [3] and use the in-degree laplacian., This function (when weight is None ) returns the number of\nspanning trees for an undirected graph and the number of\narborescences from a single root node for a directed graph.\nWhen weight is the name of an edge attribute which holds the\nweight value of each edge, the function returns the sum over\nall trees of the multiplicative weight of each tree. That is,\nthe weight of the tree is the product of its edge weights., Kirchoff’s Tree Matrix Theorem states that any cofactor of the\nLaplacian matrix of a graph is the number of spanning trees in the\ngraph. (Here we use cofactors for a diagonal entry so that the\ncofactor becomes the determinant of the matrix with one row\nand its matching column removed.) For a weighted Laplacian matrix,\nthe cofactor is the sum across all spanning trees of the\nmultiplicative weight of each tree. That is, the weight of each\ntree is the product of its edge weights. The theorem is also\nknown as Kirchhoff’s theorem [1] and the Matrix-Tree theorem [2] ., For directed graphs, a similar theorem (Tutte’s Theorem) holds with\nthe cofactor chosen to be the one with row and column removed that\ncorrespond to the root. The cofactor is the number of arborescences\nwith the specified node as root. And the weighted version gives the\nsum of the arborescence weights with root root . The arborescence\nweight is the product of its edge weights.",
    "networkx: Returns a random geometric graph in the unit cube of dimensions dim ., The random geometric graph model places n nodes uniformly at\nrandom in the unit cube. Two nodes are joined by an edge if the\ndistance between the nodes is at most radius ., Edges are determined using a KDTree when SciPy is available.\nThis reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) .",
    "networkx: Returns the Wiener index of the given graph., The Wiener index of a graph is the sum of the shortest-path\n(weighted) distances between each pair of reachable nodes.\nFor pairs of nodes in undirected graphs, only one orientation\nof the pair is counted.",
    "networkx: Returns new graph with edges that exist in either G or H but not both., The node sets of H and G must be the same.",
    "networkx: The MappedQueue class implements a min-heap with removal and update-priority., The min heap uses heapq as well as custom written _siftup and _siftdown\nmethods to allow the heap positions to be tracked by an additional dict\nkeyed by element to position. The smallest element can be popped in O(1) time,\nnew elements can be pushed in O(log n) time, and any element can be removed\nor updated in O(log n) time. The queue cannot contain duplicate elements\nand an attempt to push an element already in the queue will have no effect., MappedQueue complements the heapq package from the python standard\nlibrary. While MappedQueue is designed for maximum compatibility with\nheapq, it adds element removal, lookup, and priority update.",
    "networkx: Position nodes using Fruchterman-Reingold force-directed algorithm., The algorithm simulates a force-directed representation of the network\ntreating edges as springs holding nodes close, while treating nodes\nas repelling objects, sometimes called an anti-gravity force.\nSimulation continues until the positions are close to an equilibrium., There are some hard-coded values: minimal distance between\nnodes (0.01) and “temperature” of 0.1 to ensure nodes don’t fly away.\nDuring the simulation, k helps determine the distance between nodes,\nthough scale and center determine the size and place after\nrescaling occurs at the end of the simulation., Fixing some nodes doesn’t allow them to move in the simulation.\nIt also turns off the rescaling feature at the simulation’s end.\nIn addition, setting scale to None turns off rescaling.",
    "networkx: Returns the number of nonisomorphic trees",
    "networkx: Returns a list of the frequency of each degree value.",
    "networkx: Returns the average local efficiency of the graph., The efficiency of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The local\nefficiency of a node in the graph is the average global efficiency of the\nsubgraph induced by the neighbors of the node. The average local\nefficiency is the average of the local efficiencies of each node [1] .",
    "networkx: Find a minimum cost flow satisfying all demands in digraph G., This is a capacity scaling successive shortest augmenting path algorithm., G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.",
    "networkx: Examines whether G1 and G2 are isomorphic.",
    "networkx: Draw the graph G with a spectral 2D layout., This is a convenience function equivalent to:, For more information about how node positions are determined, see spectral_layout .",
    "networkx: Read graph in GraphML format from string.",
    "networkx: Returns the shortest path length from source to target\nin a weighted graph.",
    "networkx: Auxiliary digraph for computing flow based edge connectivity, If the input graph is undirected, we replace each edge ( u ,`v`) with\ntwo reciprocal arcs ( u , v ) and ( v , u ) and then we set the attribute\n‘capacity’ for each arc to 1. If the input graph is directed we simply\nadd the ‘capacity’ attribute. Part of algorithm 1 in [1] ., References",
    "networkx: Returns a filter function that shows specific multi-directed edges.",
    "networkx: Returns the graph adjacency matrix as a SciPy sparse array.",
    "networkx: Returns the Krackhardt Kite Social Network., A 10 actor social network introduced by David Krackhardt\nto illustrate different centrality measures [1] .",
    "networkx: Returns a list of nodes in a shortest path between source and target.",
    "networkx: Returns a random graph from the geometric soft configuration model., The \\(\\mathbb{S}^1\\) model [1] is the geometric soft configuration model\nwhich is able to explain many fundamental features of real networks such as\nsmall-world property, heteregenous degree distributions, high level of\nclustering, and self-similarity., In the geometric soft configuration model, a node \\(i\\) is assigned two hidden\nvariables: a hidden degree \\(\\kappa_i\\) , quantifying its popularity, influence,\nor importance, and an angular position \\(\\theta_i\\) in a circle abstracting the\nsimilarity space, where angular distances between nodes are a proxy for their\nsimilarity. Focusing on the angular position, this model is often called\nthe \\(\\mathbb{S}^1\\) model (a one-dimensional sphere). The circle’s radius is\nadjusted to \\(R = N/2\\pi\\) , where \\(N\\) is the number of nodes, so that the density\nis set to 1 without loss of generality., The connection probability between any pair of nodes increases with\nthe product of their hidden degrees (i.e., their combined popularities),\nand decreases with the angular distance between the two nodes.\nSpecifically, nodes \\(i\\) and \\(j\\) are connected with the probability, \\(p_{ij} = \\frac{1}{1 + \\frac{d_{ij}^\\beta}{\\left(\\mu \\kappa_i \\kappa_j\\right)^{\\max(1, \\beta)}}}\\), where \\(d_{ij} = R\\Delta\\theta_{ij}\\) is the arc length of the circle between\nnodes \\(i\\) and \\(j\\) separated by an angular distance \\(\\Delta\\theta_{ij}\\) .\nParameters \\(\\mu\\) and \\(\\beta\\) (also called inverse temperature) control the\naverage degree and the clustering coefficient, respectively., It can be shown [2] that the model undergoes a structural phase transition\nat \\(\\beta=1\\) so that for \\(\\beta<1\\) networks are unclustered in the thermodynamic\nlimit (when \\(N\\to \\infty\\) ) whereas for \\(\\beta>1\\) the ensemble generates\nnetworks with finite clustering coefficient., The \\(\\mathbb{S}^1\\) model can be expressed as a purely geometric model \\(\\mathbb{H}^2\\) in the hyperbolic plane [3] by mapping the hidden degree of\neach node into a radial coordinate as, \\(r_i = \\hat{R} - \\frac{2 \\max(1, \\beta)}{\\beta \\zeta} \\ln \\left(\\frac{\\kappa_i}{\\kappa_0}\\right)\\), where \\(\\hat{R}\\) is the radius of the hyperbolic disk and \\(\\zeta\\) is the curvature,, \\(\\hat{R} = \\frac{2}{\\zeta} \\ln \\left(\\frac{N}{\\pi}\\right)\n- \\frac{2\\max(1, \\beta)}{\\beta \\zeta} \\ln (\\mu \\kappa_0^2)\\), The connection probability then reads, \\(p_{ij} = \\frac{1}{1 + \\exp\\left({\\frac{\\beta\\zeta}{2} (x_{ij} - \\hat{R})}\\right)}\\), where, \\(x_{ij} = r_i + r_j + \\frac{2}{\\zeta} \\ln \\frac{\\Delta\\theta_{ij}}{2}\\), is a good approximation of the hyperbolic distance between two nodes separated\nby an angular distance \\(\\Delta\\theta_{ij}\\) with radial coordinates \\(r_i\\) and \\(r_j\\) .\nFor \\(\\beta > 1\\) , the curvature \\(\\zeta = 1\\) , for \\(\\beta < 1\\) , \\(\\zeta = \\beta^{-1}\\) .",
    "networkx: Returns a dominating set that approximates the minimum weight node\ndominating set.",
    "networkx: Position nodes on a circle.",
    "networkx: A simple algorithm to find all k-edge-connected components in a graph., Constructing the auxiliary graph (which may take some time) allows for the\nk-edge-ccs to be found in linear time for arbitrary k., Notes, This implementation is based on [1] . The idea is to construct an auxiliary\ngraph from which the k-edge-ccs can be extracted in linear time. The\nauxiliary graph is constructed in \\(O(|V|\\cdot F)\\) operations, where F is the\ncomplexity of max flow. Querying the components takes an additional \\(O(|V|)\\) operations. This algorithm can be slow for large graphs, but it handles an\narbitrary k and works for both directed and undirected inputs., The undirected case for k=1 is exactly connected components.\nThe undirected case for k=2 is exactly bridge connected components.\nThe directed case for k=1 is exactly strongly connected components., References, Examples, The auxiliary graph is primarily used for k-edge-ccs but it\ncan also speed up the queries of k-edge-subgraphs by refining the\nsearch space.",
    "networkx: Returns oriented tree constructed from a depth-first-search from source.",
    "networkx: Returns the attribute matrix using attributes from G as a numpy array., If only G is passed in, then the adjacency matrix is constructed., Let A be a discrete set of values for the node attribute node_attr . Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in G and consider the value\nof the edge attribute edge_attr .  If ua and va are the values of the\nnode attribute node_attr for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va).",
    "networkx: Determines whether the graph G is a regular expander. [1], An expander graph is a sparse graph with strong connectivity properties., More precisely, this helper checks whether the graph is a\nregular \\((n, d, \\lambda)\\) -expander with \\(\\lambda\\) close to\nthe Alon-Boppana bound and given by \\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\) . [2], In the case where \\(\\epsilon = 0\\) then if the graph successfully passes the test\nit is a Ramanujan graph. [3], A Ramanujan graph has spectral gap almost as large as possible, which makes them\nexcellent expanders.",
    "networkx: Calculate barycenter of a connected graph, optionally with edge weights., The barycenter a connected graph \\(G\\) is the subgraph induced by the set of its nodes \\(v\\) minimizing the objective function, where \\(d_G\\) is the (possibly weighted) pathlength .\nThe barycenter is also called the median . See [West01] , p. 78.",
    "networkx: Compute a k-factor of G, A k-factor of a graph is a spanning k-regular subgraph.\nA spanning k-regular subgraph of G is a subgraph that contains\neach vertex of G and a subset of the edges of G such that each\nvertex has degree k.",
    "networkx: Position nodes in a spiral layout.",
    "networkx: Compute a partitioning of the graphs nodes and the corresponding cut value., Use a greedy one exchange strategy to find a locally maximal cut\nand its value, it works by finding the best node (one that gives\nthe highest gain to the cut value) to add to the current cut\nand repeats this process until no improvement can be made.",
    "networkx: Draw the graph G with a spring layout., This is a convenience function equivalent to:",
    "networkx: Returns an approximation for node connectivity for a graph or digraph G., Node connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. By Menger’s theorem,\nthis is equal to the number of node independent paths (paths that\nshare no nodes other than source and target)., If source and target nodes are provided, this function returns the\nlocal node connectivity: the minimum number of nodes that must be\nremoved to break all paths from source to target in G., This algorithm is based on a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs.",
    "networkx: Computes local node connectivity for nodes s and t., Local node connectivity for two non adjacent nodes s and t is the\nminimum number of nodes that must be removed (along with their incident\nedges) to disconnect them., This is a flow based implementation of node connectivity. We compute the\nmaximum flow on an auxiliary digraph build from the original input\ngraph (see below for details).",
    "networkx: Returns Davis Southern women social network., This is a bipartite graph., References",
    "networkx: Position nodes according to breadth-first search algorithm.",
    "networkx: Returns the chromatic polynomial of G, This function computes the chromatic polynomial via an iterative version of\nthe deletion-contraction algorithm., The chromatic polynomial X_G(x) is a fundamental graph polynomial\ninvariant in one variable. Evaluating X_G(k) for an natural number k enumerates the proper k-colorings of G ., There are several equivalent definitions; here are three:, Def 1 (explicit formula):\nFor G an undirected graph, c(G) the number of connected components of G , E the edge set of G , and G(S) the spanning subgraph of G with\nedge set S  [1] :, Def 2 (interpolating polynomial):\nFor G an undirected graph, n(G) the number of vertices of G , k_0=0 ,\nand k_i the number of distinct ways to color the vertices of G with i unique colors (for i a natural number at most n(G) ), X_G(x) is the\nunique Lagrange interpolating polynomial of degree n(G) through the points (0,k_0),(1,k_1),dots,(n(G),k_{n(G)})  [2] ., Def 3 (chromatic recurrence):\nFor G an undirected graph, G-e the graph obtained from G by deleting\nedge e , G/e the graph obtained from G by contracting edge e , n(G) the number of vertices of G , and e(G) the number of edges of G  [3] :, This formulation is also known as the Fundamental Reduction Theorem [4] .",
    "networkx: Parse GML graph from a string or iterable.",
    "networkx: Return the directed combinatorial Laplacian matrix of G., The graph directed combinatorial Laplacian is the matrix, where P is the transition matrix of the graph and Phi a matrix\nwith the Perron vector of P in the diagonal and zeros elsewhere [1] ., Depending on the value of walk_type, P can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank).",
    "networkx: Parse lines of an edge list representation of a bipartite graph.",
    "networkx: Returns the resistance distance between pairs of nodes in graph G., The resistance distance between two nodes of a graph is akin to treating\nthe graph as a grid of resistors with a resistance equal to the provided\nweight [1] , [2] ., If weight is not provided, then a weight of 1 is used for all edges., If two nodes are the same, the resistance distance is zero.",
    "networkx: Returns the inverse line graph of graph G., If H is a graph, and G is the line graph of H, such that G = L(H).\nThen H is the inverse line graph of G., Not all graphs are line graphs and these do not have an inverse line graph.\nIn these cases this function raises a NetworkXError.",
    "networkx: Returns the Platonic Dodecahedral graph., The dodecahedral graph has 20 nodes and 30 edges. The skeleton of the\ndodecahedron forms a graph. It is one of 5 Platonic graphs [1] .\nIt can be described in LCF notation as: [10,7,4,-4,-7,10,-4,7,-7,4]^2  [2] .",
    "networkx: Convert an undirected graph to bytes in sparse6 format.",
    "networkx: Returns False if graphs are definitely not isomorphic., True does NOT guarantee isomorphism.",
    "networkx: Returns the minimum vertex cover corresponding to the given maximum\nmatching of the bipartite graph G .",
    "networkx: Find the prominent group of size \\(k\\) in graph \\(G\\) . The prominence of the\ngroup is evaluated by the group betweenness centrality., Group betweenness centrality of a group of nodes \\(C\\) is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in \\(C\\), where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|C)\\) is the number of\nthose paths passing through some node in group \\(C\\) . Note that \\((s, t)\\) are not members of the group ( \\(V-C\\) is the set of nodes\nin \\(V\\) that are not in \\(C\\) ).",
    "networkx: Compute edge load., WARNING: This concept of edge load has not been analysed\nor discussed outside of NetworkX that we know of.\nIt is based loosely on load_centrality in the sense that\nit counts the number of shortest paths which cross each edge.\nThis function is for demonstration and testing purposes.",
    "networkx: Returns the intersection array of a distance-regular graph., Given a distance-regular graph G with integers b_i, c_i,i = 0,….,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x., A distance regular graph’s intersection array is given by,\n[b_0,b_1,…..b_{d-1};c_1,c_2,…..c_d]",
    "networkx: Position nodes uniformly at random in the unit square., For every node, a position is generated by choosing each of dim\ncoordinates uniformly at random on the interval [0.0, 1.0)., NumPy ( http://scipy.org ) is required for this function.",
    "networkx: Returns the line graph of the graph or digraph G ., The line graph of a graph G has a node for each edge in G and an\nedge joining those nodes if the two edges in G share a common node. For\ndirected graphs, nodes are adjacent exactly when the edges they represent\nform a directed path of length two., The nodes of the line graph are 2-tuples of nodes in the original graph (or\n3-tuples for multigraphs, with the key of the edge as the third element)., For information about self-loops and more discussion, see the Notes section below.",
    "networkx: Returns the number of weakly connected components in G.",
    "networkx: Compute the non-randomness of graph G., The first returned value nr is the sum of non-randomness values of all\nedges within the graph (where the non-randomness of an edge tends to be\nsmall when the two nodes linked by that edge are from two different\ncommunities)., The second computed value nr_rd is a relative measure that indicates\nto what extent graph G is different from random graphs in terms\nof probability. When it is close to 0, the graph tends to be more\nlikely generated by an Erdos Renyi model.",
    "networkx: Draw the edges of the graph G., This draws only the edges of the graph G.",
    "networkx: Compute shortest paths between all nodes.",
    "networkx: Generate nodes in strongly connected components of graph., Recursive version of algorithm.",
    "networkx: Returns the longest path length in a DAG",
    "networkx: Returns True if communities is a partition of the nodes of G ., A partition of a universe set is a family of pairwise disjoint sets\nwhose union is the entire universe set.",
    "networkx: Return a copy of G completed to a chordal graph, Adds edges to a copy of G to create a chordal graph. A graph G=(V,E) is\ncalled chordal if for each cycle with length bigger than 3, there exist\ntwo non-adjacent nodes connected by an edge (called a chord).",
    "networkx: Swap two edges in the graph while keeping the node degrees fixed., A double-edge swap removes two randomly chosen edges u-v and x-y\nand creates the new edges u-x and v-y:, If either the edge u-x or v-y already exist no swap is performed\nand another attempt is made to find a suitable edge pair.",
    "networkx: Returns the growing network with copying (GNC) digraph with n nodes., The GNC graph is built by adding nodes one at a time with a link to one\npreviously added node (chosen uniformly at random) and to all of that\nnode’s successors.",
    "networkx: Returns an approximate minimum weighted vertex cover., The set of nodes returned by this function is guaranteed to be a\nvertex cover, and the total weight of the set is guaranteed to be at\nmost twice the total weight of the minimum weight vertex cover. In\nother words,, where \\(S\\) is the vertex cover returned by this function, \\(S^*\\) is the vertex cover of minimum weight out of all vertex\ncovers of the graph, and \\(w\\) is the function that computes the\nsum of the weights of each node in that given set.",
    "networkx: Returns the edges disjoint paths between source and target., Edge disjoint paths are paths that do not share any edge. The\nnumber of edge disjoint paths between source and target is equal\nto their edge connectivity.",
    "networkx: Write graph G as a list of edges with numeric weights.",
    "networkx: Position nodes in concentric circles.",
    "networkx: Find a maximum single-commodity flow using Dinitz’ algorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has a running time of \\(O(n^2 m)\\) for \\(n\\) nodes and \\(m\\) edges [1] .",
    "networkx: Determine if z is a minimal d-separator for x and y ., A d-separator, z , in a DAG is a set of nodes that blocks\nall paths from nodes in set x to nodes in set y .\nA minimal d-separator is a d-separator z such that removing\nany subset of nodes makes it no longer a d-separator., Note: This function checks whether z is a d-separator AND is\nminimal. One can use the function is_d_separator to only check if z is a d-separator. See examples below.",
    "networkx: Returns the quotient graph of G under the specified equivalence\nrelation on nodes.",
    "networkx: Compute betweenness centrality for edges., Betweenness centrality of an edge \\(e\\) is the sum of the\nfraction of all-pairs shortest paths that pass through \\(e\\), where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|e)\\) is the number of\nthose paths passing through edge \\(e\\)  [2] .",
    "networkx: Returns communities in G as detected by fast label propagation., The fast label propagation algorithm is described in [1] . The algorithm is\nprobabilistic and the found communities may vary in different executions., The algorithm operates as follows. First, the community label of each node is\nset to a unique label. The algorithm then repeatedly updates the labels of\nthe nodes to the most frequent label in their neighborhood. In case of ties,\na random label is chosen from the most frequent labels., The algorithm maintains a queue of nodes that still need to be processed.\nInitially, all nodes are added to the queue in a random order. Then the nodes\nare removed from the queue one by one and processed. If a node updates its label,\nall its neighbors that have a different label are added to the queue (if not\nalready in the queue). The algorithm stops when the queue is empty.",
    "networkx: Returns True if the graph is semiconnected, False otherwise., A graph is semiconnected if and only if for any pair of nodes, either one\nis reachable from the other, or they are mutually reachable., This function uses a theorem that states that a DAG is semiconnected\nif for any topological sort, for node \\(v_n\\) in that sort, there is an\nedge \\((v_i, v_{i+1})\\) . That allows us to check if a non-DAG G is\nsemiconnected by condensing the graph: i.e. constructing a new graph H with nodes being the strongly connected components of G , and edges\n(scc_1, scc_2) if there is a edge \\((v_1, v_2)\\) in G for some \\(v_1 \\in scc_1\\) and \\(v_2 \\in scc_2\\) . That results in a DAG, so we compute\nthe topological sort of H and check if for every \\(n\\) there is an edge \\((scc_n, scc_{n+1})\\) .",
    "networkx: Finds a dominating set for the graph G., A dominating set for a graph with node set V is a subset D of V such that every node not in D is adjacent to at least one\nmember of D  [1] .",
    "networkx: Returns a caveman graph of l cliques of size k .",
    "networkx: Returns a number of unlabeled rooted trees uniformly at random, Returns one or more (depending on number_of_trees )\nunlabeled rooted trees with n nodes drawn uniformly\nat random.",
    "networkx: Returns the growing network with redirection (GNR) digraph with n nodes and redirection probability p ., The GNR graph is built by adding nodes one at a time with a link to one\npreviously added node.  The previous target node is chosen uniformly at\nrandom.  With probability p the link is instead “redirected” to the\nsuccessor node of the target., The graph is always a (directed) tree.",
    "networkx: Returns a bipartite random graph., This is a bipartite version of the binomial (Erdős-Rényi) graph.\nThe graph is composed of two partitions. Set A has nodes 0 to\n(n - 1) and set B has nodes n to (n + m - 1).",
    "networkx: Position nodes in layers of straight lines.",
    "networkx: Return a dictionary of scaled positions keyed by node",
    "networkx: Returns True if G has no edges.",
    "networkx: Returns communicability between all pairs of nodes in G., The communicability between pairs of nodes in G is the sum of\nwalks of different lengths starting at node u and ending at node v.",
    "networkx: Generate lines in the “network text” format, This works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented., This notation is original to networkx, although it is simple enough that it\nmay be known in existing literature. See #5602 for details. The procedure\nis summarized as follows:, 1. Given a set of source nodes (which can be specified, or automatically\ndiscovered via finding the (strongly) connected components and choosing one\nnode with minimum degree from each), we traverse the graph in depth first\norder., 4. The children of each node (wrt the directed DFS tree) are drawn\nunderneath and to the right of it. In the case that a child node has already\nbeen drawn the connection is replaced with an ellipsis (”…”) to indicate\nthat there is one or more connections represented elsewhere., 5. If a maximum depth is specified, an edge to nodes past this maximum\ndepth will be represented by an ellipsis., 6. If a a node has a truthy “collapse” value, then we do not traverse past\nthat node.",
    "networkx: Returns dictionary of successors in depth-first-search from source.",
    "networkx: Returns an random graph based on the specified kernel., The algorithm chooses each of the \\([n(n-1)]/2\\) possible edges with\nprobability specified by a kernel \\(\\kappa(x,y)\\)  [1] .  The kernel \\(\\kappa(x,y)\\) must be a symmetric (in \\(x,y\\) ), non-negative,\nbounded function.",
    "networkx: Find the shortest path in G connecting specified nodes, This function allows approximate solution to the traveling salesman\nproblem on networks that are not complete graphs and/or where the\nsalesman does not need to visit all nodes., This function proceeds in two steps. First, it creates a complete\ngraph using the all-pairs shortest_paths between nodes in nodes .\nEdge weights in the new graph are the lengths of the paths\nbetween each pair of nodes in the original graph.\nSecond, an algorithm (default: christofides for undirected and asadpour_atsp for directed) is used to approximate the minimal Hamiltonian\ncycle on this new graph. The available algorithms are:, Once the Hamiltonian Cycle is found, this function post-processes to\naccommodate the structure of the original graph. If cycle is False ,\nthe biggest weight edge is removed to make a Hamiltonian path.\nThen each edge on the new complete graph used for that analysis is\nreplaced by the shortest_path between those nodes on the original graph.\nIf the input graph G includes edges with weights that do not adhere to\nthe triangle inequality, such as when G is not a complete graph (i.e\nlength of non-existent edges is infinity), then the returned path may\ncontain some repeating nodes (other than the starting node).",
    "networkx: Returns the k-shell of G., The k-shell is the subgraph induced by nodes with core number k.\nThat is, nodes in the k-core that are not in the (k+1)-core.",
    "networkx: Returns number of strongly connected components in graph.",
    "networkx: Returns the directed Laplacian matrix of G., The graph directed Laplacian is the matrix, where I is the identity matrix, P is the transition matrix of the\ngraph, and Phi a matrix with the Perron vector of P in the diagonal and\nzeros elsewhere [1] ., Depending on the value of walk_type, P can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank).",
    "networkx: ",
    "networkx: Approximate a solution of the traveling salesman problem, Compute a 3/2-approximation of the traveling salesman problem\nin a complete undirected graph using Christofides [1] algorithm.",
    "networkx: Returns the Platonic Icosahedral graph., The icosahedral graph has 12 nodes and 30 edges. It is a Platonic graph\nwhose nodes have the connectivity of the icosahedron. It is undirected,\nregular and Hamiltonian [1] .",
    "networkx: Tests to see if an edge in a graph is locally k-edge-connected., Is it impossible to disconnect s and t by removing fewer than k edges?\nIf so, then s and t are locally k-edge-connected in G.",
    "networkx: Find a maximum single-commodity flow using the highest-label\npreflow-push algorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has a running time of \\(O(n^2 \\sqrt{m})\\) for \\(n\\) nodes and \\(m\\) edges.",
    "networkx: Returns a random bipartite graph G_{n,m,k}., Produces a bipartite graph chosen randomly out of the set of all graphs\nwith n top nodes, m bottom nodes, and k edges.\nThe graph is composed of two sets of nodes.\nSet A has nodes 0 to (n - 1) and set B has nodes n to (n + m - 1).",
    "networkx: Compute the squares clustering coefficient for nodes., For each node return the fraction of possible squares that exist at\nthe node [1], where \\(q_v(u,w)\\) are the number of common neighbors of \\(u\\) and \\(w\\) other than \\(v\\) (ie squares), and \\(a_v(u,w) = (k_u -\n(1+q_v(u,w)+\\theta_{uv})) + (k_w - (1+q_v(u,w)+\\theta_{uw}))\\) , where \\(\\theta_{uw} = 1\\) if \\(u\\) and \\(w\\) are connected and 0\notherwise. [2]",
    "networkx: Generate GraphML lines for G",
    "networkx: Returns True if some multigraph can realize the sequence.",
    "networkx: Compute node connectivity between source and target., Pairwise or local node connectivity between two distinct and nonadjacent\nnodes is the minimum number of nodes that must be removed (minimum\nseparating cutset) to disconnect them. By Menger’s theorem, this is equal\nto the number of node independent paths (paths that share no nodes other\nthan source and target). Which is what we compute in this function., This algorithm is a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs.",
    "networkx: Returns a directed_random graph with the given degree sequences., The configuration model generates a random directed pseudograph\n(graph with parallel edges and self loops) by randomly assigning\nedges to match the given degree sequences.",
    "networkx: Compute a random partitioning of the graph nodes and its cut value., A partitioning is calculated by observing each node\nand deciding to add it to the partition with probability p ,\nreturning a random cut and its corresponding value (the\nsum of weights of edges connecting different partitions).",
    "networkx: Returns the graph adjacency matrix as a Pandas DataFrame.",
    "networkx: Return True iff G has an Eulerian path., An Eulerian path is a path in a graph which uses each edge of a graph\nexactly once. If source is specified, then this function checks\nwhether an Eulerian path that starts at node source exists.",
    "networkx: Returns True if G is a branching., A branching is a directed forest with maximum in-degree equal to 1.",
    "networkx: Returns the Gomory-Hu tree of an undirected graph G., A Gomory-Hu tree of an undirected graph with capacities is a\nweighted tree that represents the minimum s-t cuts for all s-t\npairs in the graph., It only requires n-1 minimum cut computations instead of the\nobvious n(n-1)/2 . The tree represents all s-t cuts as the\nminimum cut value among any pair of nodes is the minimum edge\nweight in the shortest path between the two nodes in the\nGomory-Hu tree., The Gomory-Hu tree also has the property that removing the\nedge with the minimum weight in the shortest path between\nany two nodes leaves two connected components that form\na partition of the nodes in G that defines the minimum s-t\ncut., See Examples section below for details.",
    "networkx: Creates a new bipartite graph from a biadjacency matrix given as a\nSciPy sparse array.",
    "networkx: Returns the Cartesian product of G and H., The Cartesian product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v),(x,y))\\) if and only if either \\(u\\) is equal to \\(x\\) and both \\(v\\) and \\(y\\) are adjacent in \\(H\\) or if \\(v\\) is equal to \\(y\\) and\nboth \\(u\\) and \\(x\\) are adjacent in \\(G\\) .",
    "networkx: Compute graph transitivity, the fraction of all possible triangles\npresent in G., Possible triangles are identified by the number of “triads”\n(two edges with a shared vertex)., The transitivity is",
    "networkx: Returns the number of connected components.",
    "networkx: Compute a random graph by swapping edges of a given graph.",
    "networkx: Compute the Laplacian centrality for nodes in the graph G ., The Laplacian Centrality of a node i is measured by the drop in the\nLaplacian Energy after deleting node i from the graph. The Laplacian Energy\nis the sum of the squared eigenvalues of a graph’s Laplacian matrix., Where \\(E_L (G)\\) is the Laplacian energy of graph G ,\nE_L (G_i) is the Laplacian energy of graph G after deleting node i and \\(\\lambda_i\\) are the eigenvalues of G ’s Laplacian matrix.\nThis formula shows the normalized value. Without normalization,\nthe numerator on the right side is returned.",
    "networkx: Compute degree assortativity of graph., Assortativity measures the similarity of connections\nin the graph with respect to the node degree., This is the same as degree_assortativity_coefficient but uses the\npotentially faster scipy.stats.pearsonr function.",
    "networkx: Find a maximum single-commodity flow using Boykov-Kolmogorov algorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has worse case complexity \\(O(n^2 m |C|)\\) for \\(n\\) nodes, \\(m\\) edges, and \\(|C|\\) the cost of the minimum cut [1] . This implementation\nuses the marking heuristic defined in [2] which improves its running\ntime in many practical problems.",
    "networkx: Iterates over edges in a beam search., The beam search is a generalized breadth-first search in which only\nthe “best” w neighbors of the current node are enqueued, where w is the beam width and “best” is an application-specific\nheuristic. In general, a beam search with a small beam width might\nnot visit each node in the graph.",
    "networkx: Returns a graph from Pandas DataFrame containing an edge list., The Pandas DataFrame should contain at least two columns of node names and\nzero or more columns of edge attributes. Each row will be processed as one\nedge instance., Note: This function iterates over DataFrame.values, which is not\nguaranteed to retain the data type across columns in the row. This is only\na problem if your row is entirely numeric and a mix of ints and floats. In\nthat case, all values will be returned as floats. See the\nDataFrame.iterrows documentation for an example.",
    "networkx: Combine graphs G and H. The names of nodes must be unique., A name collision between the graphs will raise an exception., A renaming facility is provided to avoid name collisions.",
    "networkx: Write G in GraphML XML format to path, This function uses the LXML framework and should be faster than\nthe version using the xml library.",
    "networkx: Returns a set of nodes of minimum cardinality that disconnect source\nfrom target in G., This function returns the set of nodes of minimum cardinality that,\nif removed, would destroy all paths among source and target in G.",
    "networkx: Find a maximum single-commodity flow.",
    "networkx: Returns the Prüfer sequence of the given tree., A Prüfer sequence is a list of n - 2 numbers between 0 and n - 1, inclusive. The tree corresponding to a given Prüfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence.",
    "networkx: Create node positions for G using Graphviz.",
    "networkx: Computes node disjoint paths between source and target., Node disjoint paths are paths that only share their first and last\nnodes. The number of node independent paths between two nodes is\nequal to their local node connectivity.",
    "networkx: Generate connected components.",
    "networkx: Returns the Kneser Graph with parameters n and k ., The Kneser Graph has nodes that are k-tuples (subsets) of the integers\nbetween 0 and n-1 . Nodes are adjacent if their corresponding sets are disjoint.",
    "networkx: Returns the Schultz Index (of the first kind) of G, The Schultz Index  [3] of a graph is the sum over all node pairs of\ndistances times the sum of degrees. Consider an undirected graph G .\nFor each node pair (u,v) compute dist(u,v)*(deg(u)+deg(v) where dist is the shortest path length between two nodes and deg is the degree of a node., The Schultz Index is the sum of these quantities over all (unordered)\npairs of nodes.",
    "networkx: Iterate over edges in a depth-first-search (DFS) labeled by type.",
    "networkx: Write G in GEXF format to path., “GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics” [1] ., Node attributes are checked according to the version of the GEXF\nschemas used for parameters which are not user defined,\ne.g. visualization ‘viz’ [2] . See example for usage.",
    "networkx: Write NetworkX graph G to Graphviz dot format on path.",
    "networkx: Generate a windmill graph.\nA windmill graph is a graph of n cliques each of size k that are all\njoined at one node.\nIt can be thought of as taking a disjoint union of n cliques of size k ,\nselecting one point from each, and contracting all of the selected points.\nAlternatively, one could generate n cliques of size k-1 and one node\nthat is connected to all other nodes in the graph.",
    "networkx: Generates antichains from a directed acyclic graph (DAG)., An antichain is a subset of a partially ordered set such that any\ntwo elements in the subset are incomparable.",
    "networkx: Returns an oriented tree constructed from of a breadth-first-search\nstarting at source.",
    "networkx: Decorator to generate a numpy RandomState or Generator instance., The decorator processes the argument indicated by random_state_argument using nx.utils.create_random_state() .\nThe argument value can be a seed (integer), or a numpy.random.RandomState or numpy.random.RandomState instance or ( None or numpy.random ).\nThe latter two options use the global random number generator for numpy.random ., The returned instance is a numpy.random.RandomState or numpy.random.Generator .",
    "networkx: Returns True if G has weighted edges.",
    "networkx: Returns an approximate solution to the traveling salesman problem., This function uses simulated annealing to approximate the minimal cost\ncycle through the nodes. Starting from a suboptimal solution, simulated\nannealing perturbs that solution, occasionally accepting changes that make\nthe solution worse to escape from a locally optimal solution. The chance\nof accepting such changes decreases over the iterations to encourage\nan optimal result.  In summary, the function returns a cycle starting\nat source for which the total cost is minimized. It also returns the cost., The chance of accepting a proposed change is related to a parameter called\nthe temperature (annealing has a physical analogue of steel hardening\nas it cools). As the temperature is reduced, the chance of moves that\nincrease cost goes down.",
    "networkx: Returns communicability between all pairs of nodes in G., Communicability between pair of node (u,v) of node in G is the sum of\nwalks of different lengths starting at node u and ending at node v.",
    "networkx: Returns a branching obtained through a greedy algorithm., This algorithm is wrong, and cannot give a proper optimal branching.\nHowever, we include it for pedagogical reasons, as it can be helpful to\nsee what its outputs are., The output is a branching, and possibly, a spanning arborescence. However,\nit is not guaranteed to be optimal in either case.",
    "networkx: Returns a graph from a list of edges.",
    "networkx: Edmonds algorithm [1] for finding optimal branchings and spanning\narborescences., This algorithm can find both minimum and maximum spanning arborescences and\nbranchings., Notes, While this algorithm can find a minimum branching, since it isn’t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs., References",
    "networkx: Returns a bipartite graph from two given degree sequences using a\nHavel-Hakimi style construction., The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from the set A are connected to nodes in the set B by\nconnecting the highest degree nodes in set A to the highest degree\nnodes in set B until all stubs are connected.",
    "networkx: Returns a random value chosen from the Zipf distribution., The return value is an integer drawn from the probability distribution, where \\(\\zeta(\\alpha, x_{\\min})\\) is the Hurwitz zeta function.",
    "networkx: Returns a random cograph with \\(2 ^ n\\) nodes., A cograph is a graph containing no path on four vertices.\nCographs or \\(P_4\\) -free graphs can be obtained from a single vertex\nby disjoint union and complementation operations., This generator starts off from a single vertex and performs disjoint\nunion and full join operations on itself.\nThe decision on which operation will take place is random.",
    "networkx: Return an iterator over the edges of an Eulerian path in G .",
    "networkx: Returns an arbitrary element of iterable without removing it., This is most useful for “peeking” at an arbitrary element of a set,\nbut can be used for any list, dictionary, etc., as well.",
    "networkx: Returns a bipartite graph from two given degree sequences using\nan alternating Havel-Hakimi style construction., The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from the set A are connected to nodes in the set B by\nconnecting the highest degree nodes in set A to alternatively the\nhighest and the lowest degree nodes in set B until all stubs are\nconnected.",
    "networkx: Returns a geographical threshold graph., The geographical threshold graph model places \\(n\\) nodes uniformly at\nrandom in a rectangular domain.  Each node \\(u\\) is assigned a weight \\(w_u\\) . Two nodes \\(u\\) and \\(v\\) are joined by an edge if, where r is the distance between u and v , p_dist is any function of r , and \\(\\theta\\) as the threshold parameter. p_dist is used to\ngive weight to the distance between nodes when deciding whether or not\nthey should be connected. The larger p_dist is, the more prone nodes\nseparated by r are to be connected, and vice versa.",
    "networkx: Returns a set of edges of minimum cardinality that disconnects G., If source and target nodes are provided, this function returns the\nset of edges of minimum cardinality that, if removed, would break\nall paths among source and target in G. If not, it returns a set of\nedges of minimum cardinality that disconnects G.",
    "networkx: Decides whether there is a path from s to t in the\ntournament., This function is more theoretically efficient than the reachability\nchecks than the shortest path algorithms in networkx.algorithms.shortest_paths ., The given graph must be a tournament, otherwise this function’s\nbehavior is undefined.",
    "networkx: Returns the Paley \\(\\frac{(p-1)}{2}\\) -regular graph on \\(p\\) nodes., The returned graph is a graph on \\(\\mathbb{Z}/p\\mathbb{Z}\\) with edges between \\(x\\) and \\(y\\) if and only if \\(x-y\\) is a nonzero square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) ., If \\(p \\equiv 1  \\pmod 4\\) , \\(-1\\) is a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) and therefore \\(x-y\\) is a square if and\nonly if \\(y-x\\) is also a square, i.e the edges in the Paley graph are symmetric., If \\(p \\equiv 3 \\pmod 4\\) , \\(-1\\) is not a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) and therefore either \\(x-y\\) or \\(y-x\\) is a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) but not both., Note that a more general definition of Paley graphs extends this construction\nto graphs over \\(q=p^n\\) vertices, by using the finite field \\(F_q\\) instead of \\(\\mathbb{Z}/p\\mathbb{Z}\\) .\nThis construction requires to compute squares in general finite fields and is\nnot what is implemented here (i.e paley_graph(25) does not return the true\nPaley graph associated with \\(5^2\\) ).",
    "networkx: Returns the s-metric [1] of graph., The s-metric is defined as the sum of the products deg(u)*deg(v) for every edge (u,v) in G .",
    "networkx: Returns a branching representing all (overlapping) paths from\nroot nodes to leaf nodes in the given directed acyclic graph., As described in networkx.algorithms.tree.recognition , a branching is a directed forest in which each node has at most one\nparent. In other words, a branching is a disjoint union of arborescences . For this function, each node of in-degree zero in G becomes a root of one of the arborescences, and there will be\none leaf node for each distinct path from that root to a leaf node\nin G ., Each node v in G with k parents becomes k distinct nodes in\nthe returned branching, one for each parent, and the sub-DAG rooted\nat v is duplicated for each copy. The algorithm then recurses on\nthe children of each copy of v .",
    "networkx: Returns all nodes reachable from source in G .",
    "networkx: Position nodes using the eigenvectors of the graph Laplacian., Using the unnormalized Laplacian, the layout shows possible clusters of\nnodes which are an approximation of the ratio cut. If dim is the number of\ndimensions then the positions are the entries of the dim eigenvectors\ncorresponding to the ascending eigenvalues starting from the second one.",
    "networkx: Returns a threshold subgraph that is close to largest in G ., The threshold graph will contain the largest degree node in G.",
    "networkx: Returns the number of selfloop edges., A selfloop edge has the same node at both ends.",
    "networkx: Returns the sociological triad type for a triad.",
    "networkx: Returns True if G is a threshold graph.",
    "networkx: ",
    "networkx: Returns a set of nodes of minimum cardinality that disconnects G., If source and target nodes are provided, this function returns the\nset of nodes of minimum cardinality that, if removed, would destroy\nall paths among source and target in G. If not, it returns a set\nof nodes of minimum cardinality that disconnects G.",
    "networkx: Returns a filter function that always evaluates to True.",
    "networkx: Returns the Tutte graph., The Tutte graph is a cubic polyhedral, non-Hamiltonian graph. It has\n46 nodes and 69 edges.\nIt is a counterexample to Tait’s conjecture that every 3-regular polyhedron\nhas a Hamiltonian cycle.\nIt can be realized geometrically from a tetrahedron by multiply truncating\nthree of its vertices [1] .",
    "networkx: Returns the Gutman Index for the graph G ., The Gutman Index measures the topology of networks, especially for molecule\nnetworks of atoms connected by bonds [1] . It is also called the Schultz Index\nof the second kind [2] ., Consider an undirected graph G with node set V .\nThe Gutman Index of a graph is the sum over all (unordered) pairs of nodes\nof nodes (u,v) , with distance dist(u,v) and degrees deg(u) and deg(v) , of dist(u,v)*deg(u)*deg(v)",
    "networkx: Returns the maximum cardinality matching of the bipartite graph G .",
    "networkx: Find the cost of a minimum cost flow satisfying all demands in digraph G., G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.",
    "networkx: Returns the maximum cardinality matching in the given bipartite graph., This function is simply an alias for hopcroft_karp_matching() .",
    "networkx: Make a NetworkX graph from a known data structure., The preferred way to call this is automatically\nfrom the class constructor, instead of the equivalent",
    "networkx: Returns the Heawood Graph, a (3,6) cage., The Heawood Graph is an undirected graph with 14 nodes and 21 edges,\nnamed after Percy John Heawood [1] .\nIt is cubic symmetric, nonplanar, Hamiltonian, and can be represented\nin LCF notation as [5,-5]^7  [2] .\nIt is the unique (3,6)-cage: the regular cubic graph of girth 6 with\nminimal number of vertices [3] .",
    "networkx: Given two rooted trees t1 and t2 ,\nwith roots root1 and root2 respectively\nthis routine will determine if they are isomorphic., These trees may be either directed or undirected,\nbut if they are directed, all edges should flow from the root., It returns the isomorphism, a mapping of the nodes of t1 onto the nodes\nof t2 , such that two trees are then identical., Note that two trees may have more than one isomorphism, and this\nroutine just returns one valid mapping.",
    "networkx: Generate nodes in strongly connected components of graph.",
    "networkx: Returns the coverage and performance of a partition of G., The coverage of a partition is the ratio of the number of\nintra-community edges to the total number of edges in the graph., The performance of a partition is the number of\nintra-community edges plus inter-community non-edges divided by the total\nnumber of potential edges., This algorithm has complexity \\(O(C^2 + L)\\) where C is the number of communities and L is the number of links.",
    "networkx: Returns a graph from a dictionary of dictionaries.",
    "networkx: Compute a maximum-weighted matching of G., A matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges.",
    "networkx: Returns a treewidth decomposition using the Minimum Fill-in heuristic., The heuristic chooses a node from the graph, where the number of edges\nadded turning the neighborhood of the chosen node into clique is as\nsmall as possible.",
    "networkx: Returns True if and only if G is a tournament., A tournament is a directed graph, with neither self-loops nor\nmulti-edges, in which there is exactly one directed edge joining\neach pair of distinct nodes.",
    "networkx: Generates the attracting components in G ., An attracting component in a directed graph G is a strongly connected\ncomponent with the property that a random walker on the graph will never\nleave the component, once it enters the component., The nodes in attracting components can also be thought of as recurrent\nnodes.  If a random walker enters the attractor containing the node, then\nthe node will be visited infinitely often., To obtain induced subgraphs on each component use: (G.subgraph(c).copy()forcinattracting_components(G))",
    "networkx: Attempts the specified number of double-edge swaps in the graph G ., A double-edge swap removes two randomly chosen edges (u,v) and (x,y) and creates the new edges (u,x) and (v,y) :, If either (u,x) or (v,y) already exist, then no swap is performed\nso the actual number of swapped edges is always at most  nswap .",
    "networkx: Returns all minimum k cutsets of an undirected graph G., This implementation is based on Kanevsky’s algorithm [1] for finding all\nminimum-size node cut-sets of an undirected graph G; ie the set (or sets)\nof nodes of cardinality equal to the node connectivity of G. Thus if\nremoved, would break G into two or more connected components.",
    "networkx: Returns Zachary’s Karate Club graph., Each node in the returned graph has a node attribute ‘club’ that\nindicates the name of the club to which the member represented by that node\nbelongs, either ‘Mr. Hi’ or ‘Officer’. Each edge has a weight based on the\nnumber of contexts in which that edge’s incident node members interacted., References, Examples, To get the name of the club to which a node belongs:",
    "networkx: Checks if nbunch is a dominating set for G ., A dominating set for a graph with node set V is a subset D of V such that every node not in D is adjacent to at least one\nmember of D  [1] .",
    "networkx: Returns the girth of the graph., The girth of a graph is the length of its shortest cycle, or infinity if\nthe graph is acyclic. The algorithm follows the description given on the\nWikipedia page [1] , and runs in time O(mn) on a graph with m edges and n\nnodes.",
    "networkx: View of G applying a filter on nodes and edges., subgraph_view provides a read-only view of the input graph that excludes\nnodes and edges based on the outcome of two filter functions filter_node and filter_edge ., The filter_node function takes one argument — the node — and returns True if the node should be included in the subgraph, and False if it\nshould not be included., The filter_edge function takes two (or three arguments if G is a\nmulti-graph) — the nodes describing an edge, plus the edge-key if\nparallel edges are possible — and returns True if the edge should be\nincluded in the subgraph, and False if it should not be included., Both node and edge filter functions are called on graph elements as they\nare queried, meaning there is no up-front cost to creating the view.",
    "networkx: Returns True if and only if G is locally (k,l) -connected., A graph is locally (k,l) -connected if for each edge (u,v) in the\ngraph there are at least l edge-disjoint paths of length at most k joining u to v .",
    "networkx: Returns the PageRank of the nodes in the graph., PageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages.",
    "networkx: Returns the size of the largest maximal clique containing each given node., Returns a single or list depending on input nodes.\nAn optional list of cliques can be input if already computed.",
    "networkx: Returns a random graph using Barabási–Albert preferential attachment, A graph of \\(n\\) nodes is grown by attaching new nodes each with \\(m\\) edges that are preferentially attached to existing nodes with high degree.",
    "networkx: Compute node connectivity between all pairs of nodes of G.",
    "networkx: Read graph in GML format from path .",
    "networkx: Read a simple undirected graph in graph6 format from bytes.",
    "networkx: Compute the lowest common ancestor of the given pair of nodes.",
    "networkx: Compute the number of triangles., Finds the number of triangles that include a node as one vertex.",
    "networkx: Returns the directed modularity matrix of G., The modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the expected adjacency matrix, assuming that the graph\nis described by the configuration model., More specifically, the element B_ij of B is defined as, where \\(k_i^{in}\\) is the in degree of node i, and \\(k_j^{out}\\) is the out degree\nof node j, with m the number of edges in the graph. When weight is set\nto a name of an attribute edge, Aij, k_i, k_j and m are computed using\nits value.",
    "networkx: Find shortest weighted paths and lengths from a given set of\nsource nodes., Uses Dijkstra’s algorithm to compute the shortest paths and lengths\nbetween one of the source nodes and the given target , or all other\nreachable nodes if not specified, for a weighted graph.",
    "networkx: Returns the full join of graphs G and H., Full join is the union of G and H in which all edges between\nG and H are added.\nThe node sets of G and H must be disjoint,\notherwise an exception is raised.",
    "networkx: Find simple cycles (elementary circuits) of a graph., A simplecycle , or elementarycircuit , is a closed path where\nno node appears twice.  In a directed graph, two simple cycles are distinct\nif they are not cyclic permutations of each other.  In an undirected graph,\ntwo simple cycles are distinct if they are not cyclic permutations of each\nother nor of the other’s reversal., Optionally, the cycles are bounded in length.  In the unbounded case, we use\na nonrecursive, iterator/generator version of Johnson’s algorithm [1] .  In\nthe bounded case, we use a version of the algorithm of Gupta and\nSuzumura[R155c03fc9e2e-2]_. There may be better algorithms for some cases [3]  [4]  [5] ., The algorithms of Johnson, and Gupta and Suzumura, are enhanced by some\nwell-known preprocessing techniques.  When G is directed, we restrict our\nattention to strongly connected components of G, generate all simple cycles\ncontaining a certain node, remove that node, and further decompose the\nremainder into strongly connected components.  When G is undirected, we\nrestrict our attention to biconnected components, generate all simple cycles\ncontaining a particular edge, remove that edge, and further decompose the\nremainder into biconnected components., Note that multigraphs are supported by this function – and in undirected\nmultigraphs, a pair of parallel edges is considered a cycle of length 2.\nLikewise, self-loops are considered to be cycles of length 1.  We define\ncycles as sequences of nodes; so the presence of loops and parallel edges\ndoes not change the number of simple cycles in a graph.",
    "networkx: Iterate through the graph to compute all v-structures., V-structures are triples in the directed graph where\ntwo parent nodes point to the same child and the two parent nodes\nare not adjacent.",
    "networkx: Returns total cost associated with specified path and weight",
    "networkx: Returns True if and only if nodes form a simple path in G ., A simple path in a graph is a nonempty sequence of nodes in which\nno node appears more than once in the sequence, and each adjacent\npair of nodes in the sequence is adjacent in the graph.",
    "networkx: Test directed graph for strong connectivity., A directed graph is strongly connected if and only if every vertex in\nthe graph is reachable from every other vertex.",
    "networkx: Find shortest weighted paths in G from a given set of source\nnodes., Compute shortest path between any of the source nodes and all other\nreachable nodes for a weighted graph.",
    "networkx: Returns all cliques in an undirected graph., This function returns an iterator over cliques, each of which is a\nlist of nodes. The iteration is ordered by cardinality of the\ncliques: first all cliques of size one, then all cliques of size\ntwo, etc.",
    "networkx: Returns a single element from a weighted sample., The input is a dictionary of items with weights as values.",
    "networkx: Returns the graph that results from contracting the specified edge., Edge contraction identifies the two endpoints of the edge as a single node\nincident to any edge that was incident to the original two nodes. A graph\nthat results from edge contraction is called a minor of the original\ngraph.",
    "networkx: Returns the maximum cardinality matching of the bipartite graph G ., A matching is a set of edges that do not share any nodes. A maximum\ncardinality matching is a matching with the most edges possible. It\nis not always unique. Finding a matching in a bipartite graph can be\ntreated as a networkx flow problem., The functions hopcroft_karp_matching and maximum_matching are aliases of the same function.",
    "networkx: Optimal partitioning of a weighted tree using the Lukes algorithm., This algorithm partitions a connected, acyclic graph featuring integer\nnode weights and float edge weights. The resulting clusters are such\nthat the total weight of the nodes in each cluster does not exceed\nmax_size and that the weight of the edges that are cut by the partition\nis minimum. The algorithm is based on [1] .",
    "networkx: Defines a “ring of cliques” graph., A ring of cliques graph is consisting of cliques, connected through single\nlinks. Each clique is a complete graph.",
    "networkx: Compute all shortest simple paths in the graph.",
    "networkx: Returns a NetworkX graph from a Pydot graph.",
    "networkx: Decorator to allow number of nodes or container of nodes., With this decorator, the specified argument can be either a number or a container\nof nodes. If it is a number, the nodes used are range(n) .\nThis allows nx.complete_graph(50) in place of nx.complete_graph(list(range(50))) .\nAnd it also allows nx.complete_graph(any_list_of_nodes) .",
    "networkx: Generate lists of edges for all simple paths in G from source to target., A simple path is a path with no repeated nodes.",
    "networkx: Returns a copy of the graph G with the nodes relabeled using\nconsecutive integers.",
    "networkx: Returns the size of the cut between two sets of nodes., A cut is a partition of the nodes of a graph into two sets. The cut size is the sum of the weights of the edges “between” the two\nsets of nodes.",
    "networkx: Generate node degree-degree pairs for edges in G.",
    "networkx: Decorator to mark algorithms as not implemented",
    "networkx: Compute the shortest path lengths to target from all reachable nodes.",
    "networkx: Returns dictionary representation of mixing matrix for degree.",
    "networkx: Returns a new rooted tree made by joining rooted_trees, Constructs a new tree by joining each tree in rooted_trees .\nA new root node is added and connected to each of the roots\nof the input trees. While copying the nodes from the trees,\nrelabeling to integers occurs. If the label_attribute is provided,\nthe old node labels will be stored in the new tree under this attribute.",
    "networkx: Compute the closeness centrality for nodes in a bipartite network., The closeness of a node is the distance to all other nodes in the\ngraph or in the case that the graph is not connected to all other nodes\nin the connected component containing that node.",
    "networkx: Return a dictionary of subgraph hashes by node., Dictionary keys are nodes in G , and values are a list of hashes.\nEach hash corresponds to a subgraph rooted at a given node u in G .\nLists of subgraph hashes are sorted in increasing order of depth from\ntheir root node, with the hash at index i corresponding to a subgraph\nof nodes at most i edges distance from u. Thus, each list will contain iterations elements - a hash for a subgraph at each depth. If include_initial_labels is set to True , each list will additionally\nhave contain a hash of the initial node label (or equivalently a\nsubgraph of depth 0) prepended, totalling iterations+1 elements., The function iteratively aggregates and hashes neighborhoods of each node.\nThis is achieved for each step by replacing for each node its label from\nthe previous iteration with its hashed 1-hop neighborhood aggregate.\nThe new node label is then appended to a list of node labels for each\nnode., To aggregate neighborhoods for a node \\(u\\) at each step, all labels of\nnodes adjacent to \\(u\\) are concatenated. If the edge_attr parameter is set,\nlabels for each neighboring node are prefixed with the value of this attribute\nalong the connecting edge from this neighbor to node \\(u\\) . The resulting string\nis then hashed to compress this information into a fixed digest size., Thus, at the \\(i\\) -th iteration, nodes within \\(i\\) hops influence any given\nhashed node label. We can therefore say that at depth \\(i\\) for node \\(u\\) we have a hash for a subgraph induced by the \\(i\\) -hop neighborhood of \\(u\\) ., The output can be used to to create general Weisfeiler-Lehman graph kernels,\nor generate features for graphs or nodes - for example to generate ‘words’ in\na graph as seen in the ‘graph2vec’ algorithm.\nSee [1] & [2] respectively for details., Hashes are identical for isomorphic subgraphs and there exist strong\nguarantees that non-isomorphic graphs will get different hashes.\nSee [1] for details., If no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash.",
    "networkx: Compresses neighborhoods around high-degree nodes, Reduces the number of edges to high-degree nodes by adding compressor nodes\nthat summarize multiple edges of the same type to high-degree nodes (nodes\nwith a degree greater than a given threshold).  Dedensification also has\nthe added benefit of reducing the number of edges around high-degree nodes.\nThe implementation currently supports graphs with a single edge type.",
    "networkx: Returns the non-neighbors of the node in the graph.",
    "networkx: Returns the perfectly balanced r -ary tree of height h ., ( Sourcecode , png )",
    "networkx: Calculate dispersion between u and v in G ., A link between two actors ( u and v ) has a high dispersion when their\nmutual ties ( s and t ) are not well connected with each other.",
    "networkx: Return eigenvalues of the normalized Laplacian of G",
    "networkx: Compute shortest paths and lengths in a weighted graph G., Uses Bellman-Ford algorithm for shortest paths.",
    "networkx: Compute the reciprocity for the whole graph., See the doc of reciprocity for the definition.",
    "networkx: Returns a tree with a power law degree distribution.",
    "networkx: Finds all bridge-connected components G.",
    "networkx: Returns the Path graph P_n of linearly connected nodes., ( Sourcecode , png )",
    "networkx: Returns the complete multipartite graph with the specified subset sizes., ( Sourcecode , png )",
    "networkx: Returns a random bipartite graph from two given degree sequences.",
    "networkx: Compose graph G with H by combining nodes and edges into a single graph., The node sets and edges sets do not need to be disjoint., Composing preserves the attributes of nodes and edges.\nAttribute values from H take precedent over attribute values from G.",
    "networkx: Assigns every node a (x, y) position based on the given embedding, The algorithm iteratively inserts nodes of the input graph in a certain\norder and rearranges previously inserted nodes so that the planar drawing\nstays valid. This is done efficiently by only maintaining relative\npositions during the node placements and calculating the absolute positions\nat the end. For more information see [1] .",
    "networkx: Returns a navigable small-world graph., A navigable small-world graph is a directed grid with additional long-range\nconnections that are chosen randomly.",
    "networkx: Returns a relaxed caveman graph., A relaxed caveman graph starts with l cliques of size k .  Edges are\nthen randomly rewired with probability p to link different cliques.",
    "networkx: Returns the House graph (square with triangle on top), The house graph is a simple undirected graph with\n5 nodes and 6 edges [1] .",
    "networkx: Returns the Modular product of G and H., The modular product of G and H is the graph \\(M = G \\nabla H\\) ,\nconsisting of the node set \\(V(M) = V(G) \\times V(H)\\) that is the Cartesian\nproduct of the node sets of G and H . Further, M contains an edge ((u, v), (x, y)):, More formally:",
    "networkx: Returns the dominance frontiers of all nodes of a directed graph.",
    "networkx: Node classification by Harmonic function, Function for computing Harmonic function algorithm by Zhu et al.",
    "networkx: Returns minimum cardinality edge dominating set.",
    "networkx: Returns a list of all triads for each triad type in a directed graph.\nThere are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\nnodes, they will be classified as a particular triad type if their connections\nare as follows:, Refer to the example gallery for visual examples of the triad types.",
    "networkx: Returns the normalized Laplacian matrix of G., The normalized graph Laplacian is the matrix, where L is the graph Laplacian and D is the diagonal matrix of\nnode degrees [1] .",
    "networkx: Returns True if G has negatively weighted edges.",
    "networkx: Compute shortest paths in the graph.",
    "networkx: Returns the Barbell Graph: two complete graphs connected by a path., ( Sourcecode , png )",
    "networkx: Return sample sequence of length n from a given discrete distribution\nor discrete cumulative distribution., One of the following must be specified., distribution = histogram of values, will be normalized, cdistribution = normalized discrete cumulative distribution",
    "networkx: Test directed graph for weak connectivity., A directed graph is weakly connected if and only if the graph\nis connected when the direction of the edge between nodes is ignored., Note that if a graph is strongly connected (i.e. the graph is connected\neven when we account for directionality), it is by definition weakly\nconnected as well.",
    "networkx: Compute the resource allocation index of all node pairs in ebunch., Resource allocation index of u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .",
    "networkx: Returns the global reaching centrality of a directed graph., The global reaching centrality of a weighted directed graph is the\naverage over all nodes of the difference between the local reaching\ncentrality of the node and the greatest local reaching centrality of\nany node in the graph [1] . For more information on the local\nreaching centrality, see local_reaching_centrality() .\nInformally, the local reaching centrality is the proportion of the\ngraph that is reachable from the neighbors of the node.",
    "networkx: Returns a new graph that contains the edges that exist in G but not in H., The node sets of H and G must be the same.",
    "networkx: Returns the boundary expansion of the set S ., The boundary expansion is the quotient of the size\nof the node boundary and the cardinality of S . [1]",
    "networkx: Return a low cost cycle starting at source and its cost., This approximates a solution to the traveling salesman problem.\nIt finds a cycle of all the nodes that a salesman can visit in order\nto visit many nodes while minimizing total distance.\nIt uses a simple greedy algorithm.\nIn essence, this function returns a large cycle given a source point\nfor which the total cost of the cycle is minimized.",
    "networkx: Add a path to the Graph G_to_add_to.",
    "networkx: Draw the graph G with a Kamada-Kawai force-directed layout., This is a convenience function equivalent to:",
    "networkx: Returns the longest path in a directed acyclic graph (DAG)., If G has edges with weight attribute the edge data are used as\nweight values.",
    "networkx: Create node positions using Pydot and Graphviz., Returns a dictionary of positions keyed by node.",
    "networkx: Returns the skeleton of the truncated Platonic tetrahedron., The truncated tetrahedron is an Archimedean solid with 4 regular hexagonal faces,\n4 equilateral triangle faces, 12 nodes and 18 edges. It can be constructed by truncating\nall 4 vertices of a regular tetrahedron at one third of the original edge length [1] .",
    "networkx: Returns the union of all graphs., The graphs must be disjoint, otherwise an exception is raised.",
    "networkx: Find the value of maximum single-commodity flow.",
    "networkx: Compute closeness centrality for nodes., Closeness centrality [1] of a node u is the reciprocal of the\naverage shortest path distance to u over all n-1 reachable nodes., where d(v,u) is the shortest-path distance between v and u ,\nand n-1 is the number of nodes reachable from u . Notice that the\ncloseness distance function computes the incoming distance to u for directed graphs. To use outward distance, act on G.reverse() ., Notice that higher values of closeness indicate higher centrality., Wasserman and Faust propose an improved formula for graphs with\nmore than one connected component. The result is “a ratio of the\nfraction of actors in the group who are reachable, to the average\ndistance” from the reachable actors [2] . You might think this\nscale factor is inverted but it is not. As is, nodes from small\ncomponents receive a smaller closeness value. Letting N denote\nthe number of nodes in the graph,",
    "networkx: Find communities in G using greedy modularity maximization., This implementation is O(n^4), much slower than alternatives, but it is\nprovided as an easy-to-understand reference implementation., Greedy modularity maximization begins with each node in its own community\nand joins the pair of communities that most increases modularity until no\nsuch pair exists., This function maximizes the generalized modularity, where resolution is the resolution parameter, often expressed as \\(\\gamma\\) .\nSee modularity() .",
    "networkx: Returns the Corona product of G and H., The corona product of \\(G\\) and \\(H\\) is the graph \\(C = G \\circ H\\) obtained by\ntaking one copy of \\(G\\) , called the center graph, \\(|V(G)|\\) copies of \\(H\\) ,\ncalled the outer graph, and making the \\(i\\) -th vertex of \\(G\\) adjacent to\nevery vertex of the \\(i\\) -th copy of \\(H\\) , where \\(1 ≤ i ≤ |V(G)|\\) .",
    "networkx: Returns the planted l-partition graph., This model partitions a graph with n=l*k vertices in\nl groups with k vertices each. Vertices of the same\ngroup are linked with a probability p_in, and vertices\nof different groups are linked with probability p_out.",
    "networkx: Compute the percolation centrality for nodes., Percolation centrality of a node \\(v\\) , at a given time, is defined\nas the proportion of ‘percolated paths’ that go through that node., This measure quantifies relative impact of nodes based on their\ntopological connectivity, as well as their percolation states., Percolation states of nodes are used to depict network percolation\nscenarios (such as during infection transmission in a social network\nof individuals, spreading of computer viruses on computer networks, or\ntransmission of disease over a network of towns) over time. In this\nmeasure usually the percolation state is expressed as a decimal\nbetween 0.0 and 1.0., When all nodes are in the same percolated state this measure is\nequivalent to betweenness centrality.",
    "networkx: Compute the cost of the flow given by flowDict on graph G., Note that this function does not check for the validity of the\nflow flowDict. This function will fail if the graph G and the\nflow don’t have the same edge set.",
    "networkx: Iterate over edges in a breadth-first-search starting at source.",
    "networkx: Compute the Katz centrality for the graph G., Katz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node \\(i\\) is, where \\(A\\) is the adjacency matrix of graph G with eigenvalues \\(\\lambda\\) ., The parameter \\(\\beta\\) controls the initial centrality and, Katz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors., Extra weight can be provided to immediate neighbors through the\nparameter \\(\\beta\\) .  Connections made with distant neighbors\nare, however, penalized by an attenuation factor \\(\\alpha\\) which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1] .",
    "networkx: Return the complete graph K_n with n nodes., A complete graph on n nodes means that all pairs\nof distinct nodes have an edge connecting them., ( Sourcecode , png )",
    "networkx: Returns the local reaching centrality of a node in a directed\ngraph., The local reaching centrality of a node in a directed graph is the\nproportion of other nodes reachable from that node [1] .",
    "networkx: Return a small maze with a cycle., This is the maze used in Sedgewick, 3rd Edition, Part 5, Graph\nAlgorithms, Chapter 18, e.g. Figure 18.2 and following [1] .\nNodes are numbered 0,..,7",
    "networkx: Generate a random graph with the given joint independent edge degree and\ntriangle degree sequence., This uses a configuration model-like approach to generate a random graph\n(with parallel edges and self-loops) by randomly assigning edges to match\nthe given joint degree sequence., The joint degree sequence is a list of pairs of integers of the form \\([(d_{1,i}, d_{1,t}), \\dotsc, (d_{n,i}, d_{n,t})]\\) . According to this list,\nvertex \\(u\\) is a member of \\(d_{u,t}\\) triangles and has \\(d_{u, i}\\) other\nedges. The number \\(d_{u,t}\\) is the triangle degree of \\(u\\) and the number \\(d_{u,i}\\) is the independent edge degree .",
    "networkx: Returns the approximate k-component structure of a graph G., A k -component is a maximal subgraph of a graph G that has, at least,\nnode connectivity k : we need to remove at least k nodes to break it\ninto more components. k -components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth., This implementation is based on the fast heuristics to approximate\nthe k -component structure of a graph [1] . Which, in turn, it is based on\na fast approximation algorithm for finding good lower bounds of the number\nof node independent paths between two nodes [2] .",
    "networkx: Generates community sets determined by label propagation, Finds communities in G using a semi-synchronous label propagation\nmethod [1] . This method combines the advantages of both the synchronous\nand asynchronous models. Not implemented for directed graphs.",
    "networkx: Returns the shortest weighted path from source to target in G., Uses Dijkstra’s Method to compute the shortest weighted path\nbetween two nodes in a graph.",
    "networkx: Returns a generator of lists of edges, one list for each biconnected\ncomponent of the input graph., Biconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph.  Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.\nHowever, each edge belongs to one, and only one, biconnected component., Notice that by convention a dyad is considered a biconnected component.",
    "networkx: Returns communities in G as detected by Fluid Communities algorithm., The asynchronous fluid communities algorithm is described in [1] . The algorithm is based on the simple idea of fluids interacting\nin an environment, expanding and pushing each other. Its initialization is\nrandom, so found communities may vary on different executions., The algorithm proceeds as follows. First each of the initial k communities\nis initialized in a random vertex in the graph. Then the algorithm iterates\nover all vertices in a random order, updating the community of each vertex\nbased on its own community and the communities of its neighbors. This\nprocess is performed several times until convergence.\nAt all times, each community has a total density of 1, which is equally\ndistributed among the vertices it contains. If a vertex changes of\ncommunity, vertex densities of affected communities are adjusted\nimmediately. When a complete iteration over all vertices is done, such that\nno vertex changes the community it belongs to, the algorithm has converged\nand returns., This is the original version of the algorithm described in [1] .\nUnfortunately, it does not support weighted graphs yet.",
    "networkx: Returns True if deg_sequence can be realized by a simple graph., The validation is done using the Erdős-Gallai theorem [EG1960] .",
    "networkx: Returns a random maximal independent set guaranteed to contain\na given set of nodes., An independent set is a set of nodes such that the subgraph\nof G induced by these nodes contains no edges. A maximal\nindependent set is an independent set such that it is not possible\nto add a new node and still get an independent set.",
    "networkx: Compute the group out-degree centrality for a group of nodes., Group out-degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members by outgoing edges.",
    "networkx: Returns eigenvalues of the adjacency matrix of G.",
    "networkx: Node classification by Local and Global Consistency, Function for computing Local and global consistency algorithm by Zhou et al.",
    "networkx: Returns a NetworkX graph from a dot file on path.",
    "networkx: Returns the Moebius-Kantor graph., The Möbius-Kantor graph is the cubic symmetric graph on 16 nodes.\nIts LCF notation is [5,-5]^8, and it is isomorphic to the generalized\nPetersen graph [1] .",
    "networkx: Returns True if G is an arborescence., An arborescence is a directed tree with maximum in-degree equal to 1.",
    "networkx: Compute the largest clique and largest independent set in G ., This can be used to estimate bounds for the 2-color\nRamsey number R(2;s,t) for G ., This is a recursive implementation which could run into trouble\nfor large recursions. Note that self-loop edges are ignored.",
    "networkx: Returns True if the graph is distance regular, False otherwise., A connected graph G is distance-regular if for any nodes x,y\nand any integers i,j=0,1,…,d (where d is the graph\ndiameter), the number of vertices at distance i from x and\ndistance j from y depends only on i,j and the graph distance\nbetween x and y, independently of the choice of x and y.",
    "networkx: Write the latex code to draw the graph(s) onto path ., This convenience function creates the latex drawing code as a string\nand writes that to a file ready to be compiled when as_document is True\nor ready to be import ed or include ed into your main LaTeX document., The path argument can be a string filename or a file handle to write to.",
    "networkx: Returns the chain decomposition of a graph., The chain decomposition of a graph with respect a depth-first\nsearch tree is a set of cycles or paths derived from the set of\nfundamental cycles of the tree in the following manner. Consider\neach fundamental cycle with respect to the given tree, represented\nas a list of edges beginning with the nontree edge oriented away\nfrom the root of the tree. For each fundamental cycle, if it\noverlaps with any previous fundamental cycle, just take the initial\nnon-overlapping segment, which is a path instead of a cycle. Each\ncycle or path is called a chain . For more information, see [1] .",
    "networkx: Returns an iterable over nodes in G in the order given by a\nbreadth-first or depth-first traversal., traversal must be one of the strings 'dfs' or 'bfs' ,\nrepresenting depth-first traversal or breadth-first traversal,\nrespectively., The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence., G is a NetworkX graph. colors is ignored.",
    "networkx: Draw the graph G with Matplotlib., Draw the graph as a simple representation with no node\nlabels or edge labels and using the full Matplotlib figure area\nand no axis labels by default.  See draw_networkx() for more\nfull-featured drawing that allows title, axis labels etc.",
    "networkx: Returns a new graph that contains only the nodes and the edges that exist in\nboth G and H.",
    "networkx: Finds set of edges to k-edge-connect G., Adding edges from the augmentation to G make it impossible to disconnect G\nunless k or more edges are removed. This function uses the most efficient\nfunction available (depending on the value of k and if the problem is\nweighted or unweighted) to search for a minimum weight subset of available\nedges that k-edge-connects G. In general, finding a k-edge-augmentation is\nNP-hard, so solutions are not guaranteed to be minimal. Furthermore, a\nk-edge-augmentation may not exist.",
    "networkx: Returns the Petersen graph., The Peterson graph is a cubic, undirected graph with 10 nodes and 15 edges [1] .\nJulius Petersen constructed the graph as the smallest counterexample\nagainst the claim that a connected bridgeless cubic graph\nhas an edge colouring with three colours [2] .",
    "networkx: Returns the score sequence for the given tournament graph., The score sequence is the sorted list of the out-degrees of the\nnodes of the graph.",
    "networkx: Repeatedly remove cliques from the graph., Results in a \\(O(|V|/(\\log |V|)^2)\\) approximation of maximum clique\nand independent set. Returns the largest independent set found, along\nwith found maximal cliques.",
    "networkx: Find shortest weighted paths and lengths between all nodes.",
    "networkx: Returns a labeled rooted tree with n nodes., The returned tree is chosen uniformly at random from all labeled rooted trees.",
    "networkx: Returns a maximum spanning tree or forest on an undirected graph G .",
    "networkx: A directed, depth-first-search of edges in G , beginning at source ., Yield the edges of G in a depth-first-search order continuing until\nall edges are generated.",
    "networkx: Creates a directed prefix tree from a list of paths., Usually the paths are described as strings or lists of integers., A “prefix tree” represents the prefix structure of the strings.\nEach node represents a prefix of some string. The root represents\nthe empty prefix with children for the single letter prefixes which\nin turn have children for each double letter prefix starting with\nthe single letter corresponding to the parent node, and so on., More generally the prefixes do not need to be strings. A prefix refers\nto the start of a sequence. The root has children for each one element\nprefix and they have children for each two element prefix that starts\nwith the one element sequence of the parent, and so on., Note that this implementation uses integer nodes with an attribute.\nEach node has an attribute “source” whose value is the original element\nof the path to which this node corresponds. For example, suppose paths consists of one path: “can”. Then the nodes [1,2,3] which represent\nthis path have “source” values “c”, “a” and “n”., All the descendants of a node have a common prefix in the sequence/path\nassociated with that node. From the returned tree, the prefix for each\nnode can be constructed by traversing the tree up to the root and\naccumulating the “source” values along the way., The root node is always 0 and has “source” attribute None .\nThe root is the only node with in-degree zero.\nThe nil node is always -1 and has “source” attribute \"NIL\" .\nThe nil node is the only node with out-degree zero.",
    "networkx: Returns the nonexistent edges in the graph.",
    "networkx: Returns the Hoffman-Singleton Graph., The Hoffman–Singleton graph is a symmetrical undirected graph\nwith 50 nodes and 175 edges.\nAll indices lie in Z%5 : that is, the integers mod 5 [1] .\nIt is the only regular graph of vertex degree 7, diameter 2, and girth 5.\nIt is the unique (7,5)-cage graph and Moore graph, and contains many\ncopies of the Petersen graph [2] .",
    "networkx: Returns the k-truss of G ., The k-truss is the maximal induced subgraph of G which contains at least\nthree vertices where every edge is incident to at least k-2 triangles.",
    "networkx: Determines whether the graph G is a k-regular graph., A k-regular graph is a graph where each vertex has degree k.",
    "networkx: Returns the set of nodes in the component of graph containing node n.",
    "networkx: Find all-pairs shortest path lengths using Floyd’s algorithm.",
    "networkx: Read an undirected graph in sparse6 format from path.",
    "networkx: Compute shortest path lengths between all nodes in a weighted graph.",
    "networkx: An MultiAdjacencyView is a Read-only Map of Maps of Maps of Maps., It is a View into a dict-of-dict-of-dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter levels are read-only.",
    "networkx: Return True if matching is a valid matching of G, A matching in a graph is a set of edges in which no two distinct\nedges share a common endpoint. Each node is incident to at most one\nedge in the matching. The edges are said to be independent.",
    "networkx: Compute degree assortativity of graph., Assortativity measures the similarity of connections\nin the graph with respect to the node degree.",
    "networkx: Compute the Jaccard coefficient of all node pairs in ebunch., Jaccard coefficient of nodes u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .",
    "networkx: Generates a random undirected graph resembling the Internet AS network",
    "networkx: Transforms a graph into an Eulerian graph., If G is Eulerian the result is G as a MultiGraph, otherwise the result is a smallest\n(in terms of the number of edges) multigraph whose underlying simple graph is G .",
    "networkx: Returns the minimum maximal matching of G. That is, out of all maximal\nmatchings of the graph G, the smallest is returned.",
    "networkx: Returns a pygraphviz graph from a NetworkX graph N.",
    "networkx: Generate lines of GEXF format representation of G., “GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics” [1] .",
    "networkx: Returns an approximate solution to the traveling salesman problem., This approximate solution is one of the best known approximations for the\nasymmetric traveling salesman problem developed by Asadpour et al, [1] . The algorithm first solves the Held-Karp relaxation to find a lower\nbound for the weight of the cycle. Next, it constructs an exponential\ndistribution of undirected spanning trees where the probability of an\nedge being in the tree corresponds to the weight of that edge using a\nmaximum entropy rounding scheme. Next we sample that distribution \\(2 \\lceil \\ln n \\rceil\\) times and save the minimum sampled tree once the\ndirection of the arcs is added back to the edges. Finally, we augment\nthen short circuit that graph to find the approximate tour for the\nsalesman.",
    "networkx: Position nodes without edge intersections.",
    "networkx: Returns a filter function that shows specific undirected edges.",
    "networkx: Convert a Python literal to the value it represents.",
    "networkx: Returns the graph edge list as a Pandas DataFrame.",
    "networkx: Compute the resource allocation index of all node pairs in\nebunch using community information., For two nodes \\(u\\) and \\(v\\) , this function computes the resource\nallocation index considering only common neighbors belonging to the\nsame community as \\(u\\) and \\(v\\) . Mathematically,, where \\(f(w)\\) equals 1 if \\(w\\) belongs to the same community as \\(u\\) and \\(v\\) or 0 otherwise and \\(\\Gamma(u)\\) denotes the set of\nneighbors of \\(u\\) .",
    "networkx: Compute the CD index for node within the graph G ., Calculates the CD index for the given node of the graph,\nconsidering only its predecessors who have the time attribute\nsmaller than or equal to the time attribute of the node plus time_delta .",
    "networkx: Returns the Harary graph with given numbers of nodes and edges., The Harary graph \\(H_{n,m}\\) is the graph that maximizes node connectivity\nwith \\(n\\) nodes and \\(m\\) edges., This maximum node connectivity is known to be floor( \\(2m/n\\) ). [1]",
    "networkx: Draw networkx graph G with shell layout., This is a convenience function equivalent to:",
    "networkx: Returns the n -dimensional hypercube graph., The nodes are the integers between 0 and 2**n-1 , inclusive., For more information on the hypercube graph, see the Wikipedia\narticle Hypercube graph .",
    "networkx: Returns the hierarchically constructed Dorogovtsev-Goltsev-Mendes graph., The Dorogovtsev-Goltsev-Mendes [1] procedure produces a scale-free graph\ndeterministically with the following properties for a given n :\n- Total number of nodes = 3*(3**n+1)/2 - Total number of edges = 3**(n+1), ( Sourcecode , png )",
    "networkx: Returns a stochastic block model graph., This model partitions the nodes in blocks of arbitrary sizes, and places\nedges between pairs of nodes independently, with a probability that depends\non the blocks.",
    "networkx: Returns an iterable over nodes in G in the order given by a\ndepth-first traversal., The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence., G is a NetworkX graph. colors is ignored.",
    "networkx: Convert a value to a Python literal in GML representation.",
    "networkx: Compute shortest path between source and all other reachable\nnodes for a weighted graph.",
    "networkx: Returns the Diamond graph, The Diamond Graph is  planar undirected graph with 4 nodes and 5 edges.\nIt is also sometimes known as the double triangle graph or kite graph [1] .",
    "networkx: Generate a single entry of the graph G in GML format.",
    "networkx: Checks whether the given joint degree dictionary is realizable., A joint degree dictionary is a dictionary of dictionaries, in\nwhich entry joint_degrees[k][l] is an integer representing the\nnumber of edges joining nodes of degree k with nodes of degree l . Such a dictionary is realizable as a simple graph if and only\nif the following conditions are satisfied.",
    "networkx: Returns the Fiedler vector of a connected undirected graph., The Fiedler vector of a connected undirected graph is the eigenvector\ncorresponding to the second smallest eigenvalue of the Laplacian matrix\nof the graph.",
    "networkx: Returns global parameters for a given intersection array., Given a distance-regular graph G with integers b_i, c_i,i = 0,….,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x., Thus, a distance regular graph has the global parameters,\n[[c_0,a_0,b_0],[c_1,a_1,b_1],……,[c_d,a_d,b_d]] for the\nintersection array  [b_0,b_1,…..b_{d-1};c_1,c_2,…..c_d]\nwhere a_i+b_i+c_i=k , k= degree of every vertex.",
    "networkx: Returns a NetworkX Graph or DiGraph from a PyGraphviz graph.",
    "networkx: Computes the shortest path lengths between all nodes in G .",
    "networkx: Returns a generator of nodes in topologically sorted order., A topological sort is a nonunique permutation of the nodes of a\ndirected graph such that an edge from u to v implies that u\nappears before v in the topological sort order. This ordering is\nvalid only if the graph has no directed cycles.",
    "networkx: Returns the Harary graph with given node connectivity and node number., The Harary graph \\(H_{k,n}\\) is the graph that minimizes the number of\nedges needed with given node connectivity \\(k\\) and node number \\(n\\) ., This smallest number of edges is known to be ceil( \\(kn/2\\) ) [1] .",
    "networkx: Returns the s-metric [1] of graph., The s-metric is defined as the sum of the products deg(u)*deg(v) for every edge (u,v) in G .",
    "networkx: Return an isomorphic mapping between G1 and G2 if it exists.",
    "networkx: Compute the Katz centrality for the nodes of the graph G., Katz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node \\(i\\) is, where \\(A\\) is the adjacency matrix of graph G with eigenvalues \\(\\lambda\\) ., The parameter \\(\\beta\\) controls the initial centrality and, Katz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors., Extra weight can be provided to immediate neighbors through the\nparameter \\(\\beta\\) .  Connections made with distant neighbors\nare, however, penalized by an attenuation factor \\(\\alpha\\) which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1] .",
    "networkx: Find a minimum cost flow satisfying all demands in digraph G., This is a primal network simplex algorithm that uses the leaving\narc rule to prevent cycling., G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.",
    "networkx: Returns adjacency representation of graph as a dictionary of lists.",
    "networkx: Write a simple undirected graph to a path in graph6 format.",
    "networkx: Sample a random spanning tree using the edges weights of G ., This function supports two different methods for determining the\nprobability of the graph. If multiplicative=True , the probability\nis based on the product of edge weights, and if multiplicative=False it is based on the sum of the edge weight. However, since it is\neasier to determine the total weight of all spanning trees for the\nmultiplicative version, that is significantly faster and should be used if\npossible. Additionally, setting weight to None will cause a spanning tree\nto be selected with uniform probability., The function uses algorithm A8 in [1] .",
    "networkx: Decide whether a graph has any bridges., A bridge in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.",
    "networkx: Return the rooted product of graphs G and H rooted at root in H., A new graph is constructed representing the rooted product of\nthe inputted graphs, G and H, with a root in H.\nA rooted product duplicates H for each nodes in G with the root\nof H corresponding to the node in G. Nodes are renamed as the direct\nproduct of G and H. The result is a subgraph of the cartesian product.",
    "networkx: Returns the two-dimensional grid graph., The grid graph has each node connected to its four nearest neighbors.",
    "networkx: Returns True if the graph G is a triad, else False.",
    "networkx: Returns GED (graph edit distance) between graphs G1 and G2., Graph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2.",
    "networkx: Returns the condensation of G., The condensation of G is the graph with each of the strongly connected\ncomponents contracted into a single node.",
    "networkx: Returns a minimum spanning arborescence from G.",
    "networkx: Compute the group in-degree centrality for a group of nodes., Group in-degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members by incoming edges.",
    "networkx: Returns an edge view of edges incident to nodes in nbunch., Return all edges if nbunch is unspecified or nbunch=None., For digraphs, edges=out_edges, This function wraps the G.edges property.",
    "networkx: Returns the lexicographic product of G and H., The lexicographical product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set\nthat is the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\((u,v)\\) is an edge in \\(G\\) or \\(u==v\\) and \\((x,y)\\) is an edge in \\(H\\) .",
    "networkx: Returns a filter function that shows specific multi-undirected edges.",
    "networkx: Read graph in LEDA format from path.",
    "networkx: Returns True if there exists a negative edge cycle anywhere in G.",
    "networkx: Returns eigenvalues of the Bethe Hessian matrix of G.",
    "networkx: Returns all maximal cliques in an undirected graph., For each node n , a maximal clique for n is a largest complete\nsubgraph containing n . The largest maximal clique is sometimes\ncalled the maximum clique ., This function returns an iterator over cliques, each of which is a\nlist of nodes. It is an iterative implementation, so should not\nsuffer from recursion depth issues., This function accepts a list of nodes and only the maximal cliques\ncontaining all of these nodes are returned. It can considerably speed up\nthe running time if some specific cliques are desired.",
    "networkx: Returns a filter function that hides specific multi-undirected edges.",
    "networkx: Returns the Kemeny constant of the given graph., The Kemeny constant (or Kemeny’s constant) of a graph G can be computed by regarding the graph as a Markov chain.\nThe Kemeny constant is then the expected number of time steps\nto transition from a starting state i to a random destination state\nsampled from the Markov chain’s stationary distribution.\nThe Kemeny constant is independent of the chosen initial state [1] ., The Kemeny constant measures the time needed for spreading\nacross a graph. Low values indicate a closely connected graph\nwhereas high values indicate a spread-out graph., If weight is not provided, then a weight of 1 is used for all edges., Since G represents a Markov chain, the weights must be positive.",
    "networkx: Returns an iterator over selfloop edges., A selfloop edge has the same node at both ends.",
    "networkx: Find simple cycles (elementary circuits) of a directed graph., A simplecycle , or elementarycircuit , is a closed path where\nno node appears twice. Two elementary circuits are distinct if they\nare not cyclic permutations of each other., This version uses a recursive algorithm to build a list of cycles.\nYou should probably use the iterator version called simple_cycles().\nWarning: This recursive version uses lots of RAM!\nIt appears in NetworkX for pedagogical value.",
    "networkx: Returns the Chvátal Graph, The Chvátal Graph is an undirected graph with 12 nodes and 24 edges [1] .\nIt has 370 distinct (directed) Hamiltonian cycles, giving a unique generalized\nLCF notation of order 4, two of order 6 , and 43 of order 1 [2] .",
    "networkx: Returns an undirected view of the graph graph ., Identical to graph.to_undirected(as_view=True)\nNote that graph.to_undirected defaults to as_view=False while this function always provides a view.",
    "networkx: Return the Broadcast Time of the tree G ., The minimum broadcast time of a node is defined as the minimum amount\nof time required to complete broadcasting starting from the\noriginator. The broadcast time of a graph is the maximum over\nall nodes of the minimum broadcast time from that node [1] .\nThis function returns the minimum broadcast time of node .\nIf node is None the broadcast time for the graph is returned.",
    "networkx: Returns the node expansion of the set S ., The node expansion is the quotient of the size of the node\nboundary of S and the cardinality of S . [1]",
    "networkx: Returns consecutive approximations of GED (graph edit distance)\nbetween graphs G1 and G2., Graph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2.",
    "networkx: Compute the trophic levels of nodes., The trophic level of a node \\(i\\) is, where \\(k^{in}_i\\) is the in-degree of i, and nodes with \\(k^{in}_i = 0\\) have \\(s_i = 1\\) by convention., These are calculated using the method outlined in Levine [1] .",
    "networkx: Returns a list of edges in the graph.",
    "networkx: Returns a \\(G_{n,p}\\) random graph, also known as an Erdős-Rényi graph or\na binomial graph.",
    "networkx: Generate a Gaussian random partition graph., A Gaussian random partition graph is created by creating k partitions\neach with a size drawn from a normal distribution with mean s and variance\ns/v. Nodes are connected within clusters with probability p_in and\nbetween clusters with probability p_out[1]",
    "networkx: Returns a weighted projection of B onto one of its node sets., The weighted projected graph is the projection of the bipartite\nnetwork B onto the specified nodes with weights representing the\nnumber of shared neighbors or the ratio between actual shared\nneighbors and possible shared neighbors if ratioisTrue  [1] .\nThe nodes retain their attributes and are connected in the resulting\ngraph if they have an edge to a common node in the original graph.",
    "networkx: Returns True if deg_sequence can be realized by a simple graph., The validation proceeds using the Havel-Hakimi theorem [havel1955] , [hakimi1962] , [CL1996] .\nWorst-case run time is \\(O(s)\\) where \\(s\\) is the sum of the sequence.",
    "networkx: Find all-pairs shortest path lengths using Floyd’s algorithm., This algorithm for finding shortest paths takes advantage of\nmatrix representations of a graph and works well for dense\ngraphs where all-pairs shortest path lengths are desired.\nThe results are returned as a NumPy array, distance[i, j],\nwhere i and j are the indexes of two nodes in nodelist.\nThe entry distance[i, j] is the distance along a shortest\npath from i to j. If no path exists the distance is Inf.",
    "networkx: Parse lines of a multiline adjacency list representation of a graph.",
    "networkx: Returns True if the graph is biconnected, False otherwise., A graph is biconnected if, and only if, it cannot be disconnected by\nremoving only one node (and all edges incident on that node).  If\nremoving a node increases the number of disconnected components\nin the graph, that node is called an articulation point, or cut\nvertex.  A biconnected graph has no articulation points.",
    "networkx: Generates nodes in each maximal k-edge-connected subgraph in G.",
    "networkx: Check if nodes are equal., Equality here means equal as Python objects.\nNode data must match if included.\nThe order of nodes is not relevant.",
    "networkx: Add a star to Graph G_to_add_to., The first node in nodes_for_star is the middle of the star.\nIt is connected to all other nodes.",
    "networkx: Returns the Platonic Octahedral graph., The octahedral graph is the 6-node 12-edge Platonic graph having the\nconnectivity of the octahedron [1] . If 6 couples go to a party,\nand each person shakes hands with every person except his or her partner,\nthen this graph describes the set of handshakes that take place;\nfor this reason it is also called the cocktail party graph [2] .",
    "networkx: Creates a full r-ary tree of n nodes., Sometimes called a k-ary, n-ary, or m-ary tree.\n“… all non-leaf nodes have exactly r children and all levels\nare full except for some rightmost position of the bottom level\n(if a leaf at the bottom level is missing, then so are all of the\nleaves to its right.” [1], ( Sourcecode , png )",
    "networkx: Draw edge labels.",
    "networkx: Returns a right-stochastic representation of directed graph G ., A right-stochastic graph is a weighted digraph in which for each\nnode, the sum of the weights of all the out-edges of that node is\n1. If the graph is already weighted (for example, via a ‘weight’\nedge attribute), the reweighting takes that into account.",
    "networkx: Returns the n -dimensional grid graph., The dimension n is the length of the list dim and the size in\neach dimension is the value of the corresponding list element.",
    "networkx: Returns the shortest weighted path length in G from source to target., Uses Dijkstra’s Method to compute the shortest weighted path length\nbetween two nodes in a graph.",
    "networkx: Relabel graph using “label” node keyword for node label.",
    "networkx: Select a list of influential nodes in a graph using VoteRank algorithm, VoteRank [1] computes a ranking of the nodes in a graph G based on a\nvoting scheme. With VoteRank, all nodes vote for each of its in-neighbors\nand the node with the highest votes is elected iteratively. The voting\nability of out-neighbors of elected nodes is decreased in subsequent turns.",
    "networkx: Find shortest weighted path lengths in G from a given set of\nsource nodes., Compute the shortest path length between any of the source nodes and\nall other reachable nodes for a weighted graph.",
    "networkx: Returns True if G is a tree., A tree is a connected graph with no undirected cycles., For directed graphs, G is a tree if the underlying graph is a tree. The\nunderlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph.",
    "networkx: A read-only union of two atlases (dict-of-dict)., The two dict-of-dicts represent the inner dict of\nan Adjacency: G.succ[node] and G.pred[node] .\nThe inner level of dict of both hold attribute key:value\npairs and is read-write. But the outer level is read-only.",
    "networkx: Returns all maximal cliques of a chordal graph., The algorithm breaks the graph in connected components and performs a\nmaximum cardinality search in each component to get the cliques.",
    "networkx: Write a bipartite graph as a list of edges.",
    "networkx: Weighted projection of B with a user-specified weight function., The bipartite network B is projected on to the specified nodes\nwith weights computed by a user-specified function.  This function\nmust accept as a parameter the neighborhood sets of two nodes and\nreturn an integer or a float., The nodes retain their attributes and are connected in the resulting graph\nif they have an edge to a common node in the original graph.",
    "networkx: Generates lists of nonisomorphic trees",
    "networkx: Returns the center of the graph G., The center is the set of nodes with eccentricity equal to radius.",
    "networkx: Return True if matching is a perfect matching for G, A perfect matching in a graph is a matching in which exactly one edge\nis incident upon each vertex.",
    "networkx: Compute shortest paths between all nodes in a weighted graph.",
    "networkx: Returns the tensor product of G and H., The tensor product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\((u,x)\\) is an edge in \\(G\\) and \\((v,y)\\) is an edge in \\(H\\) ., Tensor product is sometimes also referred to as the categorical product,\ndirect product, cardinal product or conjunction.",
    "networkx: Returns a random tournament graph on n nodes.",
    "networkx: Generates a random simple directed graph with the joint degree.",
    "networkx: Returns Florentine families graph., References",
    "networkx: Iterate over edges in a breadth-first search., The breadth-first search begins at source and enqueues the\nneighbors of newly visited nodes specified by the neighbors function.",
    "networkx: Read graph in Pajek format from path.",
    "networkx: Compute assortativity for node attributes., Assortativity measures the similarity of connections\nin the graph with respect to the given attribute.",
    "networkx: Returns density of bipartite graph B.",
    "networkx: Get edge attributes from graph",
    "networkx: Returns a scale-free directed graph.",
    "networkx: Returns the rich-club coefficient of the graph G ., For each degree k , the rich-club coefficient is the ratio of the\nnumber of actual to the number of potential edges for nodes with\ndegree greater than k :, where N_k is the number of nodes with degree larger than k , and E_k is the number of edges among those nodes.",
    "networkx: Compute the clustering coefficient for nodes., For unweighted graphs, the clustering of a node \\(u\\) is the fraction of possible triangles through that node that exist,, where \\(T(u)\\) is the number of triangles through node \\(u\\) and \\(deg(u)\\) is the degree of \\(u\\) ., For weighted graphs, there are several ways to define clustering [1] .\nthe one used here is defined\nas the geometric average of the subgraph edge weights [2] ,, The edge weights \\(\\hat{w}_{uv}\\) are normalized by the maximum weight\nin the network \\(\\hat{w}_{uv} = w_{uv}/\\max(w)\\) ., The value of \\(c_u\\) is assigned to 0 if \\(deg(u) < 2\\) ., Additionally, this weighted definition has been generalized to support negative edge weights [3] ., For directed graphs, the clustering is similarly defined as the fraction\nof all possible directed triangles or geometric average of the subgraph\nedge weights for unweighted and weighted directed graph respectively [4] ., where \\(T(u)\\) is the number of directed triangles through node \\(u\\) , \\(deg^{tot}(u)\\) is the sum of in degree and out degree of \\(u\\) and \\(deg^{\\leftrightarrow}(u)\\) is the reciprocal degree of \\(u\\) .",
    "networkx: Returns a filter function that shows specific directed edges.",
    "networkx: Read simple undirected graphs in graph6 format from path.",
    "networkx: Latticize the given graph by swapping edges.",
    "networkx: Returns a labeled tree on n nodes chosen uniformly at random., Generating uniformly distributed random Prüfer sequences and\nconverting them into the corresponding trees is a straightforward\nmethod of generating uniformly distributed random labeled trees.\nThis function implements this method.",
    "networkx: Return the Trivial graph with one node (with label 0) and no edges., ( Sourcecode , png )",
    "networkx: Returns a random intersection graph with independent probabilities\nfor connections between node and attribute sets.",
    "networkx: Return the wheel graph, The wheel graph consists of a hub node connected to a cycle of (n-1) nodes., ( Sourcecode , png )",
    "networkx: Returns True if the graph G is a directed acyclic graph (DAG) or\nFalse if not.",
    "networkx: An AdjacencyView is a Read-only Map of Maps of Maps., It is a View into a dict-of-dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter levels are read-only.",
    "networkx: Returns graph number i from the Graph Atlas., For more information, see graph_atlas_g() .",
    "networkx: Find the Maximum Clique, Finds the \\(O(|V|/(log|V|)^2)\\) apx of maximum clique/independent set\nin the worst case.",
    "networkx: Returns an iterable over nodes in G in the order given by a\nbreadth-first traversal., The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence., G is a NetworkX graph. colors is ignored.",
    "networkx: Dijkstra’s algorithm for shortest paths using bidirectional search.",
    "networkx: Returns the effective size of all nodes in the graph G ., The effective size of a node’s ego network is based on the concept\nof redundancy. A person’s ego network has redundancy to the extent\nthat her contacts are connected to each other as well. The\nnonredundant part of a person’s relationships is the effective\nsize of her ego network [1] .  Formally, the effective size of a\nnode \\(u\\) , denoted \\(e(u)\\) , is defined by, where \\(N(u)\\) is the set of neighbors of \\(u\\) and \\(p_{uw}\\) is the\nnormalized mutual weight of the (directed or undirected) edges\njoining \\(u\\) and \\(v\\) , for each vertex \\(u\\) and \\(v\\)  [1] . And \\(m_{vw}\\) is the mutual weight of \\(v\\) and \\(w\\) divided by \\(v\\) highest mutual\nweight with any of its neighbors. The mutual weight of \\(u\\) and \\(v\\) is the sum of the weights of edges joining them (edge weights are\nassumed to be one if the graph is unweighted)., For the case of unweighted and undirected graphs, Borgatti proposed\na simplified formula to compute effective size [2], where t is the number of ties in the ego network (not including\nties to ego) and n is the number of nodes (excluding ego).",
    "networkx: Read graph in GEXF format from path., “GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics” [1] .",
    "networkx: Iterator over isolates in the graph., An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.",
    "networkx: Returns a degree view of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of all nodes., This function wraps the G.degree property.",
    "networkx: Build a residual network and initialize a zero flow., The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G ., For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] ., The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
    "networkx: Returns a spanner of the given graph with the given stretch., A spanner of a graph G = (V, E) with stretch t is a subgraph\nH = (V, E_S) such that E_S is a subset of E and the distance between\nany pair of nodes in H is at most t times the distance between the\nnodes in G.",
    "networkx: Decorator to ensure clean opening and closing of files.",
    "networkx: Draw the graph G with a circular layout., This is a convenience function equivalent to:",
    "networkx: Compute betweenness centrality for a subset of nodes., where \\(S\\) is the set of sources, \\(T\\) is the set of targets, \\(\\sigma(s, t)\\) is the number of shortest \\((s, t)\\) -paths,\nand \\(\\sigma(s, t|v)\\) is the number of those paths\npassing through some  node \\(v\\) other than \\(s, t\\) .\nIf \\(s = t\\) , \\(\\sigma(s, t) = 1\\) ,\nand if \\(v \\in {s, t}\\) , \\(\\sigma(s, t|v) = 0\\)  [2] .",
    "networkx: Returns a \\(G_{n,p}\\) random graph, also known as an Erdős-Rényi graph\nor a binomial graph., The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) .",
    "networkx: Returns the empty graph with n nodes and zero edges., ( Sourcecode , png )",
    "networkx: Returns equivalence classes of relation when applied to iterable ., The equivalence classes, or blocks, consist of objects from iterable which are all equivalent. They are defined to be equivalent if the relation function returns True when passed any two objects from that\nclass, and False otherwise. To define an equivalence relation the\nfunction must be reflexive, symmetric and transitive.",
    "networkx: Sets edge attributes from a given value or dictionary of values.",
    "networkx: Return the lowest common ancestor of all pairs or the provided pairs",
    "networkx: Returns mixing matrix for attribute.",
    "networkx: A deprecated name for join_trees, Returns a new rooted tree with a root node joined with the roots\nof each of the given rooted trees.",
    "networkx: Returns the total weight of a branching., You must access this function through the networkx.algorithms.tree module.",
    "networkx: Returns the k-crust of G., The k-crust is the graph G with the edges of the k-core removed\nand isolated nodes found after the removal of edges are also removed.",
    "networkx: Edmonds algorithm [1] for finding optimal branchings and spanning\narborescences., This algorithm can find both minimum and maximum spanning arborescences and\nbranchings., Notes, While this algorithm can find a minimum branching, since it isn’t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs., References",
    "networkx: Returns data in tree format that is suitable for JSON serialization\nand use in JavaScript documents.",
    "networkx: Returns a generator of _all_ topological sorts of the directed graph G., A topological sort is a nonunique permutation of the nodes such that an\nedge from u to v implies that u appears before v in the topological sort\norder.",
    "networkx: Returns subgraph communicability for all pairs of nodes in G., Communicability betweenness measure makes use of the number of walks\nconnecting every pair of nodes as the basis of a betweenness centrality\nmeasure.",
    "networkx: Compute current-flow closeness centrality for nodes., Current-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality.",
    "networkx: Returns a \\(G_{n,p}\\) random graph, also known as an Erdős-Rényi graph\nor a binomial graph., The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) .",
    "networkx: Returns the subgraph induced on nodes in nbunch.",
    "networkx: Return whether node sets x and y are d-separated by z .",
    "networkx: Returns the k-component structure of a graph G., A k -component is a maximal subgraph of a graph G that has, at least,\nnode connectivity k : we need to remove at least k nodes to break it\ninto more components. k -components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth.",
    "networkx: Returns the number of attracting components in G .",
    "networkx: Returns an undirected graph using the duplication-divergence model., A graph of n nodes is created by duplicating the initial nodes\nand retaining edges incident to the original nodes with a retention\nprobability p .",
    "networkx: Compute the shortest-path betweenness centrality for nodes., Betweenness centrality of a node \\(v\\) is the sum of the\nfraction of all-pairs shortest paths that pass through \\(v\\), where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths,  and \\(\\sigma(s, t|v)\\) is the number of\nthose paths  passing through some  node \\(v\\) other than \\(s, t\\) .\nIf \\(s = t\\) , \\(\\sigma(s, t) = 1\\) , and if \\(v \\in {s, t}\\) , \\(\\sigma(s, t|v) = 0\\)  [2] .",
    "networkx: Randomly generate sample_size paths of length path_length .",
    "networkx: Generate the nodes in the unique lexicographical topological sort order., Generates a unique ordering of nodes by first sorting topologically (for which there are often\nmultiple valid orderings) and then additionally by sorting lexicographically., A topological sort arranges the nodes of a directed graph so that the\nupstream node of each directed edge precedes the downstream node.\nIt is always possible to find a solution for directed graphs that have no cycles.\nThere may be more than one valid solution., Lexicographical sorting is just sorting alphabetically. It is used here to break ties in the\ntopological sort and to determine a single, unique ordering.  This can be useful in comparing\nsort results., The lexicographical order can be customized by providing a function to the key= parameter.\nThe definition of the key function is the same as used in python’s built-in sort() .\nThe function takes a single argument and returns a key to use for sorting purposes., Lexicographical sorting can fail if the node names are un-sortable. See the example below.\nThe solution is to provide a function to the key= argument that returns sortable keys.",
    "networkx: Check if graphs are equal., Equality here means equal as Python objects (not isomorphism).\nNode, edge and graph data must match.",
    "networkx: Returns the Binomial Tree of order n., The binomial tree of order 0 consists of a single node. A binomial tree of order k\nis defined recursively by linking two binomial trees of order k-1: the root of one is\nthe leftmost child of the root of the other., ( Sourcecode , png )",
    "networkx: Returns the modularity matrix of G., The modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the average adjacency matrix, assuming that the graph\nis described by the configuration model., More specifically, the element B_ij of B is defined as, where k_i is the degree of node i, and where m is the number of edges\nin the graph. When weight is set to a name of an attribute edge, Aij, k_i,\nk_j and m are computed using its value.",
    "networkx: Returns graph from tree data format.",
    "networkx: View of G with edge directions reversed, reverse_view returns a read-only view of the input graph where\nedge directions are reversed., Identical to digraph.reverse(copy=False)",
    "networkx: Create a bipartite graph with a preferential attachment model from\na given single degree sequence., The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes starting with node len(aseq).\nThe number of nodes in set B is random.",
    "networkx: Generate a single line of the graph G in multiline adjacency list format.",
    "networkx: Returns a minimal d-separating set between x and y if possible, A d-separating set in a DAG is a set of nodes that blocks all\npaths between the two sets of nodes, x and y . This function\nconstructs a d-separating set that is “minimal”, meaning no nodes can\nbe removed without it losing the d-separating property for x and y .\nIf no d-separating sets exist for x and y , this returns None ., In a DAG there may be more than one minimal d-separator between two\nsets of nodes. Minimal d-separators are not always unique. This function\nreturns one minimal d-separator, or None if no d-separator exists., Uses the algorithm presented in [1] . The complexity of the algorithm\nis \\(O(m)\\) , where \\(m\\) stands for the number of edges in\nthe subgraph of G consisting of only the ancestors of x and y .\nFor full details, see [1] .",
    "networkx: Holme and Kim algorithm for growing graphs with powerlaw\ndegree distribution and approximate average clustering.",
    "networkx: Decides whether a set of edges is a valid edge cover of the graph., Given a set of edges, whether it is an edge covering can\nbe decided if we just check whether all nodes of the graph\nhas an edge from the set, incident on it.",
    "networkx: Generate edges in a maximum spanning forest of an undirected\nweighted graph., A maximum spanning tree is a subgraph of the graph (a tree)\nwith the maximum possible sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph.",
    "networkx: Returns all maximal cliques in a graph., For each node v , a maximal clique for v is a largest complete\nsubgraph containing v . The largest maximal clique is sometimes\ncalled the maximum clique ., This function returns an iterator over cliques, each of which is a\nlist of nodes. It is a recursive implementation, so may suffer from\nrecursion depth issues, but is included for pedagogical reasons.\nFor a non-recursive implementation, see find_cliques() ., This function accepts a list of nodes and only the maximal cliques\ncontaining all of these nodes are returned. It can considerably speed up\nthe running time if some specific cliques are desired.",
    "networkx: Generate a single line of the graph G in edge list format.",
    "networkx: Get node attributes from graph",
    "networkx: Returns the treewidth of the chordal graph G.",
    "networkx: Yields all the possible mappings between G1 and G2.",
    "networkx: Returns the Desargues Graph, The Desargues Graph is a non-planar, distance-transitive cubic graph\nwith 20 nodes and 30 edges [1] .\nIt is a symmetric graph. It can be represented in LCF notation\nas [5,-5,9,-9]^5 [2] .",
    "networkx: Returns the common neighbors of two nodes in a graph.",
    "networkx: Partition a graph into two blocks using the Kernighan–Lin\nalgorithm., This algorithm partitions a network into two sets by iteratively\nswapping pairs of nodes to reduce the edge cut between the two sets.  The\npairs are chosen according to a modified form of Kernighan-Lin [1] , which\nmoves node individually, alternating between sides to keep the bisection\nbalanced.",
    "networkx: Return the star graph, The star graph consists of one center node connected to n outer nodes., ( Sourcecode , png )",
    "networkx: Returns a thresholded random geometric graph in the unit cube., The thresholded random geometric graph [1] model places n nodes\nuniformly at random in the unit cube of dimensions dim . Each node u is assigned a weight \\(w_u\\) . Two nodes u and v are\njoined by an edge if they are within the maximum connection distance, radius computed by the p -Minkowski distance and the summation of\nweights \\(w_u\\) + \\(w_v\\) is greater than or equal\nto the threshold parameter theta ., Edges within radius of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) .",
    "networkx: Returns an approximate solution to the traveling salesman problem., This function uses threshold accepting methods to approximate the minimal cost\ncycle through the nodes. Starting from a suboptimal solution, threshold\naccepting methods perturb that solution, accepting any changes that make\nthe solution no worse than increasing by a threshold amount. Improvements\nin cost are accepted, but so are changes leading to small increases in cost.\nThis allows the solution to leave suboptimal local minima in solution space.\nThe threshold is decreased slowly as iterations proceed helping to ensure\nan optimum. In summary, the function returns a cycle starting at source for which the total cost is minimized.",
    "networkx: Returns a forest or list of forests selected at random., Returns one or more (depending on number_of_forests )\nunlabeled rooted forests with n nodes, and with no more than q nodes per tree, drawn uniformly at random.\nThe “roots” graph attribute identifies the roots of the forest.",
    "networkx: Return the Turan Graph, The Turan Graph is a complete multipartite graph on \\(n\\) nodes\nwith \\(r\\) disjoint subsets. That is, edges connect each node to\nevery node not in its subset., Given \\(n\\) and \\(r\\) , we create a complete multipartite graph with \\(r-(n \\mod r)\\) partitions of size \\(n/r\\) , rounded down, and \\(n \\mod r\\) partitions of size \\(n/r+1\\) , rounded down., ( Sourcecode , png )",
    "networkx: Returns data in Cytoscape JSON format (cyjs).",
    "networkx: Returns an extended Barabási–Albert model graph., An extended Barabási–Albert model graph is a random graph constructed\nusing preferential attachment. The extended model allows new edges,\nrewired edges or new nodes. Based on the probabilities \\(p\\) and \\(q\\) with \\(p + q < 1\\) , the growing behavior of the graph is determined as:, 1) With \\(p\\) probability, \\(m\\) new edges are added to the graph,\nstarting from randomly chosen existing nodes and attached preferentially at the other end., 2) With \\(q\\) probability, \\(m\\) existing edges are rewired\nby randomly choosing an edge and rewiring one end to a preferentially chosen node., 3) With \\((1 - p - q)\\) probability, \\(m\\) new nodes are added to the graph\nwith edges attached preferentially., When \\(p = q = 0\\) , the model behaves just like the Barabási–Alber model.",
    "networkx: Write graph as a list of edges.",
    "networkx: Returns the immediate dominators of all nodes of a directed graph.",
    "networkx: Returns the biadjacency matrix of the bipartite graph G., Let G=(U,V,E) be a bipartite graph with node sets U=u_{1},...,u_{r} and V=v_{1},...,v_{s} . The biadjacency\nmatrix [1] is the r x s matrix B in which b_{i,j}=1 if, and only if, (u_i,v_j)inE . If the parameter weight is\nnot None and matches the name of an edge attribute, its value is\nused instead of 1.",
    "networkx: Returns transitive closure of a graph, The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a path from v to w in G., Handling of paths from v to v has some flexibility within this definition.\nA reflexive transitive closure creates a self-loop for the path\nfrom v to v of length 0. The usual transitive closure creates a\nself-loop only if a cycle exists (a path from v to v with length > 0).\nWe also allow an option for no self-loops.",
    "networkx: Find the size of a large clique in a graph., A clique is a subset of nodes in which each pair of nodes is\nadjacent. This function is a heuristic for finding the size of a\nlarge clique in the graph.",
    "networkx: Relabel the nodes of the graph G according to a given mapping., The original node ordering may not be preserved if copy is False and the\nmapping includes overlap between old and new labels.",
    "networkx: Returns a generator of all possible sets of 3 nodes in a DiGraph.",
    "networkx: Returns the edges of the cut-set of a minimum (s, t)-cut., This function returns the set of edges of minimum cardinality that,\nif removed, would destroy all paths among source and target in G.\nEdge weights are not considered. See minimum_cut() for\ncomputing minimum cuts considering edge weights.",
    "networkx: Returns the periphery of the graph G., The periphery is the set of nodes with eccentricity equal to the diameter.",
    "networkx: Returns True if nodes and G/nodes are a bipartition of G.",
    "networkx: Returns a graph from a 2D NumPy array., The 2D NumPy array is interpreted as an adjacency matrix for the graph.",
    "networkx: Returns the number of isolates in the graph., An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.",
    "networkx: Returns a list of cycles which form a basis for cycles of G., A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as “exclusive or” of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff’s Laws.",
    "networkx: Uses Johnson’s Algorithm to compute shortest paths., Johnson’s Algorithm finds a shortest path between each pair of\nnodes in a weighted graph even if negative weights are present.",
    "networkx: Compute the second order centrality for nodes of G., The second order centrality of a given node is the standard deviation of\nthe return times to that node of a perpetual random walk on G:",
    "networkx: Returns True if G consists of a single attracting component.",
    "networkx: Returns a random graph using the partial duplication model.",
    "networkx: Returns the SimRank similarity of nodes in the graph G ., SimRank is a similarity metric that says “two objects are considered\nto be similar if they are referenced by similar objects.” [1] ., The pseudo-code definition from the paper is:, where G is the graph, u is the source, v is the target,\nand C is a float decay or importance factor between 0 and 1., The SimRank algorithm for determining node similarity is defined in [2] .",
    "networkx: Returns graph from node-link data format.\nUseful for de-serialization from JSON.",
    "networkx: Generates nodes in each maximal k-edge-connected component in G.",
    "networkx: Returns the Laplacian matrix of G., The graph Laplacian is the matrix L = D - A, where\nA is the adjacency matrix and D is the diagonal matrix of node degrees.",
    "networkx: Returns the flow hierarchy of a directed network., Flow hierarchy is defined as the fraction of edges not participating\nin cycles in a directed graph [1] .",
    "networkx: Compute current-flow betweenness centrality for edges using subsets\nof nodes., Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths., Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] .",
    "networkx: Find a maximum weight clique in G., A clique in a graph is a set of nodes such that every two distinct nodes\nare adjacent.  The weight of a clique is the sum of the weights of its\nnodes.  A maximum weight clique of graph G is a clique C in G such that\nno clique in G has weight greater than the weight of C.",
    "networkx: Returns the cycle graph \\(C_n\\) of cyclically connected nodes., \\(C_n\\) is a path with its two end-nodes connected., ( Sourcecode , png )",
    "networkx: Returns the weighted minimum edge cut using the Stoer-Wagner algorithm., Determine the minimum edge cut of a connected graph using the\nStoer-Wagner algorithm. In weighted cases, all weights must be\nnonnegative., The running time of the algorithm depends on the type of heaps used:",
    "networkx: Returns a graph from Pandas DataFrame., The Pandas DataFrame is interpreted as an adjacency matrix for the graph.",
    "networkx: Compute the spectral_ordering of a graph., The spectral ordering of a graph is an ordering of its nodes where nodes\nin the same weakly connected components appear contiguous and ordered by\ntheir corresponding elements in the Fiedler vector of the component.",
    "networkx: Compute assortativity for numerical node attributes., Assortativity measures the similarity of connections\nin the graph with respect to the given numeric attribute.",
    "networkx: Returns the degrees of the two node sets in the bipartite graph B.",
    "networkx: Returns a treewidth decomposition using the Minimum Degree heuristic., The heuristic chooses the nodes according to their degree, i.e., first\nthe node with the lowest degree is chosen, then the graph is updated\nand the corresponding node is removed. Next, a new node with the lowest\ndegree is chosen, and so on.",
    "networkx: A decorator to apply a map to arguments before calling the function, This class provides a decorator that maps (transforms) arguments of the function\nbefore the function is called. Thus for example, we have similar code\nin many functions to determine whether an argument is the number of nodes\nto be created, or a list of nodes to be handled. The decorator provides\nthe code to accept either – transforming the indicated argument into a\nlist of nodes before the actual function is called., This decorator class allows us to process single or multiple arguments.\nThe arguments to be processed can be specified by string, naming the argument,\nor by index, specifying the item in the args list.",
    "networkx: Generate an ordering (permutation) of the graph nodes to make\na sparse matrix., Uses the reverse Cuthill-McKee heuristic (based on breadth-first search) [1] .",
    "networkx: Computes the extendability of a graph., The extendability of a graph is defined as the maximum \\(k\\) for which G is \\(k\\) -extendable. Graph G is \\(k\\) -extendable if and only if G has a\nperfect matching and every set of \\(k\\) independent edges can be extended\nto a perfect matching in G .",
    "networkx: Returns dictionary of predecessors in depth-first-search from source.",
    "networkx: Returns the number of walks connecting each pair of nodes in G, A walk is a sequence of nodes in which each adjacent pair of nodes\nin the sequence is adjacent in the graph. A walk can repeat the same\nedge and go in the opposite direction just as people can walk on a\nset of paths, but standing still is not counted as part of the walk., This function only counts the walks with walk_length edges. Note that\nthe number of nodes in the walk sequence is one more than walk_length .\nThe number of walks can grow very quickly on a larger graph\nand with a larger walk length.",
    "networkx: Convert a simple undirected graph to bytes in graph6 format.",
    "networkx: Returns a random graph using dual Barabási–Albert preferential attachment, A graph of \\(n\\) nodes is grown by attaching new nodes each with either \\(m_1\\) edges (with probability \\(p\\) ) or \\(m_2\\) edges (with probability \\(1-p\\) ) that\nare preferentially attached to existing nodes with high degree.",
    "networkx: Returns the Margulis-Gabber-Galil undirected MultiGraph on n^2 nodes., The undirected MultiGraph is regular with degree 8 . Nodes are integer\npairs. The second-largest eigenvalue of the adjacency matrix of the graph\nis at most 5sqrt{2} , regardless of n .",
    "networkx: Compute the shortest path lengths from source to all reachable nodes.",
    "networkx: Returns all nodes having a path to source in G .",
    "networkx: ",
    "networkx: Returns a view of the subgraph induced by the specified edges., The induced subgraph contains each edge in edges and each\nnode incident to any of those edges.",
    "networkx: Compute shortest path to target from all nodes that reach target.",
    "networkx: Find an asteroidal triple in the given graph., An asteroidal triple is a triple of non-adjacent vertices such that\nthere exists a path between any two of them which avoids the closed\nneighborhood of the third. It checks all independent triples of vertices\nand whether they are an asteroidal triple or not. This is done with the\nhelp of a data structure called a component structure.\nA component structure encodes information about which vertices belongs to\nthe same connected component when the closed neighborhood of a given vertex\nis removed from the graph. The algorithm used to check is the trivial\none, outlined in [1] , which has a runtime of \\(O(|V||\\overline{E} + |V||E|)\\) , where the second term is the\ncreation of the component structure.",
    "networkx: Returns a two-coloring of the graph., Raises an exception if the graph is not bipartite.",
    "networkx: Compute the shortest path length between source and all other\nreachable nodes for a weighted graph.",
    "networkx: Reconstruct a path from source to target using the predecessors\ndict as returned by floyd_warshall_predecessor_and_distance",
    "networkx: Compute the value of a minimum (s, t)-cut., Use the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow.",
    "networkx: Generates an interval graph for a list of intervals given., In graph theory, an interval graph is an undirected graph formed from a set\nof closed intervals on the real line, with a vertex for each interval\nand an edge between vertices whose intervals intersect.\nIt is the intersection graph of the intervals., More information can be found at: https://en.wikipedia.org/wiki/Interval_graph",
    "networkx: Compute a bipartite clustering coefficient for nodes., The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :, where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v ., The mode selects the function for c_{uv} which can be:, dot :, min :, max :",
    "networkx: Compute the trophic incoherence parameter of a graph., Trophic coherence is defined as the homogeneity of the distribution of\ntrophic distances: the more similar, the more coherent. This is measured by\nthe standard deviation of the trophic differences and referred to as the\ntrophic incoherence parameter \\(q\\) by [1].",
    "networkx: Returns True if and only if the given graph is strongly\nregular., An undirected graph is strongly regular if, Each strongly regular graph is a distance-regular graph.\nConversely, if a distance-regular graph has diameter two, then it is\na strongly regular graph. For more information on distance-regular\ngraphs, see is_distance_regular() .",
    "networkx: Return Weisfeiler Lehman (WL) graph hash., The function iteratively aggregates and hashes neighborhoods of each node.\nAfter each node’s neighbors are hashed to obtain updated node labels,\na hashed histogram of resulting labels is returned as the final hash., Hashes are identical for isomorphic graphs and strong guarantees that\nnon-isomorphic graphs will get different hashes. See [1] for details., If no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash.",
    "networkx: Returns a filter function that hides specific undirected edges.",
    "networkx: Return latex code to draw the graph(s) in Gbunch, The TikZ drawing utility in LaTeX is used to draw the graph(s).\nIf Gbunch is a graph, it is drawn in a figure environment.\nIf Gbunch is an iterable of graphs, each is drawn in a subfigure environment\nwithin a single figure environment., If as_document is True, the figure is wrapped inside a document environment\nso that the resulting string is ready to be compiled by LaTeX. Otherwise,\nthe string is ready for inclusion in a larger tex document using \\include or \\input statements.",
    "networkx: Returns the Pappus graph., The Pappus graph is a cubic symmetric distance-regular graph with 18 nodes\nand 27 edges. It is Hamiltonian and can be represented in LCF notation as\n[5,7,-7,7,-7,-5]^3 [1] .",
    "networkx: Compute the bipartite clustering of G., Robins and Alexander [1] defined bipartite clustering coefficient as\nfour times the number of four cycles C_4 divided by the number of\nthree paths L_3 in a bipartite graph:",
    "networkx: Returns edge list of node pairs within radius of each other.",
    "networkx: Returns the bipartite clique graph corresponding to G ., In the returned bipartite graph, the “bottom” nodes are the nodes of G and the “top” nodes represent the maximal cliques of G .\nThere is an edge from node v to clique C in the returned graph\nif and only if v is an element of C .",
    "networkx: Convert a dictionary of dictionaries to a numpy array\nwith optional mapping.",
    "networkx: Returns the length of the shortest path between source and target using\nthe A* (“A-star”) algorithm.",
    "networkx: Compute shortest paths between all nodes in a weighted graph.",
    "networkx: Returns the set of induced nodes in the path from s to t.",
    "networkx: Returns the efficiency of a pair of nodes in a graph., The efficiency of a pair of nodes is the multiplicative inverse of the\nshortest path distance between the nodes [1] . Returns 0 if no path\nbetween nodes.",
    "networkx: Returns the n-Sudoku graph. The default value of n is 3., The n-Sudoku graph is a graph with n^4 vertices, corresponding to the\ncells of an n^2 by n^2 grid. Two distinct vertices are adjacent if and\nonly if they belong to the same row, column, or n-by-n box.",
    "networkx: Creates a nice text representation of a graph, This works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented.",
    "networkx: Compute the group degree centrality for a group of nodes., Group degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members.",
    "networkx: Combine graphs G and H. The nodes are assumed to be unique (disjoint)., This algorithm automatically relabels nodes to avoid name collisions.",
    "networkx: Returns all nodes at a fixed distance from source in G .",
    "networkx: Write graph G to given path in sparse6 format.",
    "networkx: Compute the preferential attachment score of all node pairs in ebunch., Preferential attachment score of u and v is defined as, where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .",
    "networkx: Returns the skeleton of the truncated cube., The truncated cube is an Archimedean solid with 14 regular\nfaces (6 octagonal and 8 triangular), 36 edges and 24 nodes [1] .\nThe truncated cube is created by truncating (cutting off) the tips\nof the cube one third of the way into each edge [2] .",
    "networkx: Create a NetworkX graph from a dictionary in cytoscape JSON format.",
    "networkx: Returns dictionary representation of mixing matrix for attribute.",
    "networkx: Returns a nested tuple representation of the given tree., The nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, () . A tree with k subtrees is represented\nby a tuple of length k in which each element is the nested tuple\nrepresentation of a subtree.",
    "networkx: Returns a simple graph with given degree sequence constructed\nusing the Havel-Hakimi algorithm.",
    "networkx: Draw node labels on the graph G.",
    "networkx: Returns the layer of each vertex in an onion decomposition of the graph., The onion decomposition refines the k-core decomposition by providing\ninformation on the internal organization of each k-shell. It is usually\nused alongside the corenumbers .",
    "networkx: Check if a graph is planar and return a counterexample or an embedding., A graph is planar iff it can be drawn in a plane without\nany edge intersections.",
    "networkx: Returns the complete bipartite graph K_{n_1,n_2} ., The graph is composed of two partitions with nodes 0 to (n1 - 1)\nin the first and nodes n1 to (n1 + n2 - 1) in the second.\nEach node in the first is connected to each node in the second.",
    "networkx: Returns the graph that results from contracting u and v ., Node contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes.",
    "networkx: Read an undirected graph in sparse6 format from string.",
    "networkx: Returns True if and only if G is planar., A graph is planar iff it can be drawn in a plane without\nany edge intersections.",
    "networkx: Returns a degree sequence for a tree with a power law distribution.",
    "networkx: Returns the constraint on all nodes in the graph G ., The constraint is a measure of the extent to which a node v is\ninvested in those nodes that are themselves invested in the\nneighbors of v . Formally, the constraint on v , denoted c(v) ,\nis defined by, where \\(N(v)\\) is the subset of the neighbors of v that are either\npredecessors or successors of v and \\(\\ell(v, w)\\) is the local\nconstraint on v with respect to w  [1] . For the definition of local\nconstraint, see local_constraint() .",
    "networkx: Returns data in node-link format that is suitable for JSON serialization\nand use in JavaScript documents.",
    "networkx: Compute the degree centrality for nodes., The degree centrality for a node v is the fraction of nodes it\nis connected to.",
    "networkx: Compute shortest path lengths between all nodes in a weighted graph.",
    "networkx: Returns True if sequence is a valid degree sequence., A degree sequence is valid if some graph can realize it.",
    "networkx: Return sample sequence of length n from a power law distribution.",
    "networkx: Compute current-flow betweenness centrality for edges., Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths., Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] .",
    "networkx: Returns the Bull Graph, The Bull Graph has 5 nodes and 5 edges. It is a planar undirected\ngraph in the form of a triangle with two disjoint pendant edges [1] The name comes from the triangle and pendant edges representing\nrespectively the body and legs of a bull.",
    "networkx: Returns the LFR benchmark graph., This algorithm proceeds as follows:",
    "networkx: Returns subgraph centrality for each node in G., Subgraph centrality  of a node n is the sum of weighted closed\nwalks of all lengths starting and ending at node n . The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ( [1] ).",
    "networkx: Returns the mixing expansion between two node sets., The mixing expansion is the quotient of the cut size and twice the\nnumber of edges in the graph. [1]",
    "networkx: Returns the number of maximal cliques for each node., Returns a single or list depending on input nodes.\nOptional list of cliques can be input if already computed.",
    "networkx: Returns True if the graphs G1 and G2 are isomorphic and False otherwise.",
    "networkx: Returns induced subgraph of neighbors centered at node n within\na given radius.",
    "networkx: Find communities in G using greedy modularity maximization., This function uses Clauset-Newman-Moore greedy modularity maximization [2] to find the community partition with the largest modularity., Greedy modularity maximization begins with each node in its own community\nand repeatedly joins the pair of communities that lead to the largest\nmodularity until no further increase in modularity is possible (a maximum).\nTwo keyword arguments adjust the stopping condition. cutoff is a lower\nlimit on the number of communities so you can stop the process before\nreaching a maximum (used to save computation time). best_n is an upper\nlimit on the number of communities so you can make the process continue\nuntil at most n communities remain even if the maximum modularity occurs\nfor more. To obtain exactly n communities, set both cutoff and best_n to n., This function maximizes the generalized modularity, where resolution is the resolution parameter, often expressed as \\(\\gamma\\) .\nSee modularity() .",
    "networkx: Returns an iterator over all neighbors of node n., This function wraps the G.neighbors function.",
    "networkx: Returns k items without replacement from a weighted sample., The input is a dictionary of items with weights as values.",
    "networkx: Uses a greedy independent set removal strategy to determine the\ncolors., This function updates colors  in-place and return None ,\nunlike the other strategy functions in this module., This algorithm repeatedly finds and removes a maximal independent\nset, assigning each node in the set an unused color., G is a NetworkX graph., This strategy is related to strategy_smallest_last() : in that\nstrategy, an independent set of size one is chosen at each step\ninstead of a maximal independent set.",
    "networkx: Checks whether G is a chordal graph., A graph is chordal if every cycle of length at least 4 has a chord\n(an edge joining two nodes not adjacent in the cycle).",
    "networkx: Compute the approximate current-flow betweenness centrality for nodes., Approximates the current-flow betweenness centrality within absolute\nerror of epsilon with high probability [1] .",
    "networkx: Returns True if graph G is bipartite, False if not.",
    "networkx: Returns the maximum locally (k,l) -connected subgraph of G ., A graph is locally (k,l) -connected if for each edge (u,v) in the\ngraph there are at least l edge-disjoint paths of length at most k joining u to v .",
    "networkx: Returns the House graph with a cross inside the house square., The House X-graph is the House graph plus the two edges connecting diagonally\nopposite vertices of the square base. It is also one of the two graphs\nobtained by removing two edges from the pentatope graph [1] .",
    "networkx: Compute betweenness centrality for edges for a subset of nodes., where \\(S\\) is the set of sources, \\(T\\) is the set of targets, \\(\\sigma(s, t)\\) is the number of shortest \\((s, t)\\) -paths,\nand \\(\\sigma(s, t|e)\\) is the number of those paths\npassing through edge \\(e\\)  [2] .",
    "networkx: Returns a NetworkX MultiGraph or MultiDiGraph from the\ndot file with the passed path., If this file contains multiple graphs, only the first such graph is\nreturned. All graphs _except_ the first are silently ignored.",
    "networkx: Returns the average global efficiency of the graph., The efficiency of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The average\nglobal efficiency of a graph is the average efficiency of all pairs of\nnodes [1] .",
    "networkx: Find a maximum single-commodity flow using the Edmonds-Karp algorithm., This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks., This algorithm has a running time of \\(O(n m^2)\\) for \\(n\\) nodes and \\(m\\) edges.",
    "networkx: Returns a \\(G_{n,m}\\) random graph., In the \\(G_{n,m}\\) model, a graph is chosen uniformly at random from the set\nof all graphs with \\(n\\) nodes and \\(m\\) edges., This algorithm should be faster than dense_gnm_random_graph() for\nsparse graphs.",
    "networkx: Generate all bridges in a graph., A bridge in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.  Equivalently, a bridge is an\nedge that does not belong to any cycle. Bridges are also known as cut-edges,\nisthmuses, or cut arcs.",
    "networkx: Check if edges are equal., Equality here means equal as Python objects.\nEdge data must match if included.\nThe order of the edges is not relevant.",
    "networkx: Returns the closeness vitality for nodes in the graph., The closeness vitality of a node, defined in Section 3.6.2 of [1],\nis the change in the sum of distances between all node pairs when\nexcluding that node.",
    "networkx: Find all-pairs shortest path lengths using Floyd’s algorithm.",
    "networkx: Returns a bipartite graph from two given degree sequences using a\nHavel-Hakimi style construction., The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from set A are connected to nodes in the set B by connecting\nthe highest degree nodes in set A to the lowest degree nodes in\nset B until all stubs are connected.",
    "networkx: A read-only Mapping of Mappings with filtering criteria for nodes., It is a view into a dict-of-dict data structure, and it selects only\nnodes that meet the criteria defined by NODE_OK .",
    "networkx: Returns the list of all graphs with up to seven nodes named in the\nGraph Atlas., The graphs are listed in increasing order by, in that order, with three exceptions as described in the Notes section below. This causes the list to correspond with the index of\nthe graphs in the Graph Atlas [atlas] , with the first graph, G[0] , being the null graph.",
    "networkx: Sets node attributes from a given value or dictionary of values.",
    "networkx: Returns a minimum cost flow satisfying all demands in digraph G., G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.",
    "networkx: Computing a minimum-weight maximal matching of G., Use the maximum-weight algorithm with edge weights subtracted\nfrom the maximum weight of all edges., A matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges., This method replaces the edge weights with 1 plus the maximum edge weight\nminus the original edge weight., new_weight = (max_weight + 1) - edge_weight, then runs max_weight_matching() with the new weights.\nThe max weight matching with these new weights corresponds\nto the min weight matching using the original weights.\nAdding 1 to the max edge weight keeps all edge weights positive\nand as integers if they started as integers., You might worry that adding 1 to each weight would make the algorithm\nfavor matchings with more edges. But we use the parameter maxcardinality=True in max_weight_matching to ensure that the\nnumber of edges in the competing matchings are the same and thus\nthe optimum does not change due to changes in the number of edges., Read the documentation of max_weight_matching for more information.",
    "networkx: Returns the density of a graph., The density for undirected graphs is, and for directed graphs is, where n is the number of nodes and m is the number of edges in G ., Notes, The density is 0 for a graph without edges and 1 for a complete graph.\nThe density of multigraphs can be higher than 1., Self loops are counted in the total number of edges so graphs with self\nloops can have density higher than 1.",
    "networkx: Write NetworkX graph G to Graphviz dot format on path., Path can be a string or a file handle.",
    "networkx: Base class for undirected graphs., A Graph stores nodes and edges with optional data, or attributes., Graphs hold undirected edges.  Self loops are allowed but multiple\n(parallel) edges are not., Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes, except that None is not allowed as a node., Edges are represented as links between nodes with optional\nkey/value attributes.",
    "networkx: Base class for directed graphs., A DiGraph stores nodes and edges with optional data, or attributes., DiGraphs hold directed edges.  Self loops are allowed but multiple\n(parallel) edges are not., Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node., Edges are represented as links between nodes with optional\nkey/value attributes.",
    "networkx: An undirected graph class that can store multiedges., Multiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes., A MultiGraph holds undirected edges.  Self loops are allowed., Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node., Edges are represented as links between nodes with optional\nkey/value attributes, in a MultiGraph each edge has a key to\ndistinguish between multiple edges that have the same source and\ndestination nodes.",
    "networkx: A directed graph class that can store multiedges., Multiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes., A MultiDiGraph holds directed edges.  Self loops are allowed., Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node., Edges are represented as links between nodes with optional\nkey/value attributes."
]